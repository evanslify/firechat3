(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/base64-js/lib/b64.js","/../../node_modules/base64-js/lib")
},{"buffer":2,"rH1JPG":8}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/buffer/index.js","/../../node_modules/buffer")
},{"base64-js":1,"buffer":2,"ieee754":5,"rH1JPG":8}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 *  Firebase libraries for browser - npm package.
 *
 * Usage:
 *
 *   firebase = require('firebase');
 */
require('./firebase');
module.exports = firebase;

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/firebase/firebase-browser.js","/../../node_modules/firebase")
},{"./firebase":4,"buffer":2,"rH1JPG":8}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*! @license Firebase v3.0.3
    Build: 3.0.3-rc.1
    Terms: https://developers.google.com/terms */
(function() { var h="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global?global:this,l=function(){h.Symbol||(h.Symbol=aa);l=function(){}},ba=0,aa=function(a){return"jscomp_symbol_"+a+ba++},m=function(){l();h.Symbol.iterator||(h.Symbol.iterator=h.Symbol("iterator"));m=function(){}},ca=function(){var a=["next","error","complete"];m();if(a[h.Symbol.iterator])return a[h.Symbol.iterator]();var b=0;return{next:function(){return b==a.length?{done:!0}:{done:!1,value:a[b++]}}}},p=function(){return{done:!0,
value:void 0}},q=function(a,b){a instanceof String&&(a=String(a));var c=0;l();m();var d={},e=(d.next=function(){if(c<a.length){var d=c++;return{value:b(d,a[d]),done:!1}}e.next=p;return p()},d[Symbol.iterator]=function(){return e},d);return e},r=function(a,b){!Array.prototype[a]&&Object.defineProperties&&Object.defineProperty&&Object.defineProperty(Array.prototype,a,{configurable:!0,enumerable:!1,writable:!0,value:b})},t=function(a,b){if(null==a)throw new TypeError("The 'this' value for String.prototype."+
b+" must not be null or undefined");},u=function(a,b){if(a instanceof RegExp)throw new TypeError("First argument to String.prototype."+b+" must not be a regular expression");},da=function(a){t(this,"repeat");var b=String(this);if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var c="";a;)if(a&1&&(c+=b),a>>>=1)b+=b;return c},ea=function(a){t(this,"codePointAt");var b=String(this),c=b.length;a=Number(a)||0;if(0<=a&&a<c){a|=0;var d=b.charCodeAt(a);if(55296>d||56319<d||a+1===c)return d;
a=b.charCodeAt(a+1);return 56320>a||57343<a?d:1024*(d-55296)+a+9216}},fa=function(a,b){b=void 0===b?0:b;u(a,"includes");t(this,"includes");return-1!==String(this).indexOf(a,b)},ga=function(a,b){b=void 0===b?0:b;u(a,"startsWith");t(this,"startsWith");var c=String(this);a+="";var d=c.length,e=a.length;b=Math.max(0,Math.min(b|0,c.length));for(var f=0;f<e&&b<d;)if(c[b++]!=a[f++])return!1;return f>=e},ha=function(a,b){u(a,"endsWith");t(this,"endsWith");var c=String(this);a+="";void 0===b&&(b=c.length);
b=Math.max(0,Math.min(b|0,c.length));for(var d=a.length;0<d&&0<b;)if(c[--b]!=a[--d])return!1;return 0>=d};String.prototype.endsWith||(String.prototype.endsWith=ha);String.prototype.startsWith||(String.prototype.startsWith=ga);String.prototype.includes||(String.prototype.includes=fa);String.prototype.codePointAt||(String.prototype.codePointAt=ea);String.prototype.repeat||(String.prototype.repeat=da);r("values",function(){return q(this,function(a,b){return b})});r("keys",function(){return q(this,function(a){return a})});
r("entries",function(){return q(this,function(a,b){return[a,b]})});
var v=this,w=function(){},x=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b},y=function(a){return"function"==x(a)},ia=function(a,b,c){return a.call.apply(a.bind,arguments)},ja=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}},z=function(a,b,c){z=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?
ia:ja;return z.apply(null,arguments)},ka=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}},la=function(a,b){function c(){}c.prototype=b.prototype;a.ba=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.aa=function(a,c,f){for(var k=Array(arguments.length-2),g=2;g<arguments.length;g++)k[g-2]=arguments[g];return b.prototype[c].apply(a,k)}};function __extends(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)}
function __decorate(a,b,c,d){var e=arguments.length,f=3>e?b:null===d?d=Object.getOwnPropertyDescriptor(b,c):d,k;if("object"===typeof Reflect&&"function"===typeof Reflect.decorate)f=Reflect.decorate(a,b,c,d);else for(var g=a.length-1;0<=g;g--)if(k=a[g])f=(3>e?k(f):3<e?k(b,c,f):k(b,c))||f;return 3<e&&f&&Object.defineProperty(b,c,f),f}function __metadata(a,b){if("object"===typeof Reflect&&"function"===typeof Reflect.metadata)return Reflect.metadata(a,b)}
var __param=function(a,b){return function(c,d){b(c,d,a)}},__awaiter=function(a,b,c,d){return new (c||(c=Promise))(function(e,f){function k(a){try{n(d.next(a))}catch(b){f(b)}}function g(a){try{n(d.throw(a))}catch(b){f(b)}}function n(a){a.done?e(a.value):(new c(function(b){b(a.value)})).then(k,g)}n((d=d.apply(a,b)).next())})};var A=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,A);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))};la(A,Error);A.prototype.name="CustomError";var ma=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};var B=function(a,b){b.unshift(a);A.call(this,ma.apply(null,b));b.shift()};la(B,A);B.prototype.name="AssertionError";var na=function(a,b,c,d){var e="Assertion failed";if(c)var e=e+(": "+c),f=d;else a&&(e+=": "+a,f=b);throw new B(""+e,f||[]);},C=function(a,b,c){a||na("",null,b,Array.prototype.slice.call(arguments,2))},D=function(a,b,c){y(a)||na("Expected function but got %s: %s.",[x(a),a],b,Array.prototype.slice.call(arguments,2))};var E=function(a,b,c){this.S=c;this.L=a;this.U=b;this.s=0;this.o=null};E.prototype.get=function(){var a;0<this.s?(this.s--,a=this.o,this.o=a.next,a.next=null):a=this.L();return a};E.prototype.put=function(a){this.U(a);this.s<this.S&&(this.s++,a.next=this.o,this.o=a)};var F;a:{var oa=v.navigator;if(oa){var pa=oa.userAgent;if(pa){F=pa;break a}}F=""};var qa=function(a){v.setTimeout(function(){throw a;},0)},G,ra=function(){var a=v.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&-1==F.indexOf("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+
"//"+b.location.host,a=z(function(a){if(("*"==d||a.origin==d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&-1==F.indexOf("Trident")&&-1==F.indexOf("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.F;c.F=null;a()}};return function(a){d.next={F:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in
document.createElement("SCRIPT")?function(a){var b=document.createElement("SCRIPT");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){v.setTimeout(a,0)}};var H=function(){this.v=this.f=null},sa=new E(function(){return new I},function(a){a.reset()},100);H.prototype.add=function(a,b){var c=sa.get();c.set(a,b);this.v?this.v.next=c:(C(!this.f),this.f=c);this.v=c};H.prototype.remove=function(){var a=null;this.f&&(a=this.f,this.f=this.f.next,this.f||(this.v=null),a.next=null);return a};var I=function(){this.next=this.scope=this.B=null};I.prototype.set=function(a,b){this.B=a;this.scope=b;this.next=null};
I.prototype.reset=function(){this.next=this.scope=this.B=null};var L=function(a,b){J||ta();K||(J(),K=!0);ua.add(a,b)},J,ta=function(){if(v.Promise&&v.Promise.resolve){var a=v.Promise.resolve(void 0);J=function(){a.then(va)}}else J=function(){var a=va,c;!(c=!y(v.setImmediate))&&(c=v.Window&&v.Window.prototype)&&(c=-1==F.indexOf("Edge")&&v.Window.prototype.setImmediate==v.setImmediate);c?(G||(G=ra()),G(a)):v.setImmediate(a)}},K=!1,ua=new H,va=function(){for(var a;a=ua.remove();){try{a.B.call(a.scope)}catch(b){qa(b)}sa.put(a)}K=!1};var O=function(a,b){this.b=0;this.K=void 0;this.j=this.g=this.u=null;this.m=this.A=!1;if(a!=w)try{var c=this;a.call(b,function(a){M(c,2,a)},function(a){try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(b){}M(c,3,a)})}catch(d){M(this,3,d)}},wa=function(){this.next=this.context=this.h=this.c=this.child=null;this.w=!1};wa.prototype.reset=function(){this.context=this.h=this.c=this.child=null;this.w=!1};
var xa=new E(function(){return new wa},function(a){a.reset()},100),ya=function(a,b,c){var d=xa.get();d.c=a;d.h=b;d.context=c;return d},Aa=function(a,b,c){za(a,b,c,null)||L(ka(b,a))};O.prototype.then=function(a,b,c){null!=a&&D(a,"opt_onFulfilled should be a function.");null!=b&&D(b,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?");return Ba(this,y(a)?a:null,y(b)?b:null,c)};O.prototype.then=O.prototype.then;O.prototype.$goog_Thenable=!0;
O.prototype.X=function(a,b){return Ba(this,null,a,b)};var Da=function(a,b){a.g||2!=a.b&&3!=a.b||Ca(a);C(null!=b.c);a.j?a.j.next=b:a.g=b;a.j=b},Ba=function(a,b,c,d){var e=ya(null,null,null);e.child=new O(function(a,k){e.c=b?function(c){try{var e=b.call(d,c);a(e)}catch(N){k(N)}}:a;e.h=c?function(b){try{var e=c.call(d,b);a(e)}catch(N){k(N)}}:k});e.child.u=a;Da(a,e);return e.child};O.prototype.Y=function(a){C(1==this.b);this.b=0;M(this,2,a)};O.prototype.Z=function(a){C(1==this.b);this.b=0;M(this,3,a)};
var M=function(a,b,c){0==a.b&&(a==c&&(b=3,c=new TypeError("Promise cannot resolve to itself")),a.b=1,za(c,a.Y,a.Z,a)||(a.K=c,a.b=b,a.u=null,Ca(a),3!=b||Ea(a,c)))},za=function(a,b,c,d){if(a instanceof O)return null!=b&&D(b,"opt_onFulfilled should be a function."),null!=c&&D(c,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?"),Da(a,ya(b||w,c||null,d)),!0;var e;if(a)try{e=!!a.$goog_Thenable}catch(k){e=!1}else e=!1;if(e)return a.then(b,c,d),!0;
e=typeof a;if("object"==e&&null!=a||"function"==e)try{var f=a.then;if(y(f))return Fa(a,f,b,c,d),!0}catch(k){return c.call(d,k),!0}return!1},Fa=function(a,b,c,d,e){var f=!1,k=function(a){f||(f=!0,c.call(e,a))},g=function(a){f||(f=!0,d.call(e,a))};try{b.call(a,k,g)}catch(n){g(n)}},Ca=function(a){a.A||(a.A=!0,L(a.N,a))},Ga=function(a){var b=null;a.g&&(b=a.g,a.g=b.next,b.next=null);a.g||(a.j=null);null!=b&&C(null!=b.c);return b};
O.prototype.N=function(){for(var a;a=Ga(this);){var b=this.b,c=this.K;if(3==b&&a.h&&!a.w){var d;for(d=this;d&&d.m;d=d.u)d.m=!1}if(a.child)a.child.u=null,Ha(a,b,c);else try{a.w?a.c.call(a.context):Ha(a,b,c)}catch(e){Ia.call(null,e)}xa.put(a)}this.A=!1};var Ha=function(a,b,c){2==b?a.c.call(a.context,c):a.h&&a.h.call(a.context,c)},Ea=function(a,b){a.m=!0;L(function(){a.m&&Ia.call(null,b)})},Ia=qa;function P(a,b){if(!(b instanceof Object))return b;switch(b.constructor){case Date:return new Date(b.getTime());case Object:void 0===a&&(a={});break;case Array:a=[];break;default:return b}for(var c in b)b.hasOwnProperty(c)&&(a[c]=P(a[c],b[c]));return a};var Ja=Error.captureStackTrace,R=function(a,b){this.code=a;this.message=b;if(Ja)Ja(this,Q.prototype.create);else{var c=Error.apply(this,arguments);this.name="FirebaseError";Object.defineProperty(this,"stack",{get:function(){return c.stack}})}};R.prototype=Object.create(Error.prototype);R.prototype.constructor=R;R.prototype.name="FirebaseError";var Q=function(a,b,c){this.V=a;this.W=b;this.M=c;this.pattern=/\{\$([^}]+)}/g};
Q.prototype.create=function(a,b){void 0===b&&(b={});var c=this.M[a],c=void 0===c?"Error":c.replace(this.pattern,function(a,c){return void 0!==b[c]?b[c].toString():"<"+c+"?>"}),c=this.W+": "+c+" ("+this.V+"/"+a+").";a=new R(a,c);for(var d in b)b.hasOwnProperty(d)&&"_"!==d.slice(-1)&&(a[d]=b[d]);return a};O.all=function(a){return new O(function(b,c){var d=a.length,e=[];if(d)for(var f=function(a,c){d--;e[a]=c;0==d&&b(e)},k=function(a){c(a)},g=0,n;g<a.length;g++)n=a[g],Aa(n,ka(f,g),k);else b(e)})};O.resolve=function(a){if(a instanceof O)return a;var b=new O(w);M(b,2,a);return b};O.reject=function(a){return new O(function(b,c){c(a)})};O.prototype["catch"]=O.prototype.X;var S=O;"undefined"!==typeof Promise&&(S=Promise);var Ka=S;function La(a,b){a=new T(a,b);return a.subscribe.bind(a)}var T=function(a,b){var c=this;this.a=[];this.J=0;this.task=Ka.resolve();this.l=!1;this.D=b;this.task.then(function(){a(c)}).catch(function(a){c.error(a)})};T.prototype.next=function(a){U(this,function(b){b.next(a)})};T.prototype.error=function(a){U(this,function(b){b.error(a)});this.close(a)};T.prototype.complete=function(){U(this,function(a){a.complete()});this.close()};
T.prototype.subscribe=function(a,b,c){var d=this,e;if(void 0===a&&void 0===b&&void 0===c)throw Error("Missing Observer.");e=Ma(a)?a:{next:a,error:b,complete:c};void 0===e.next&&(e.next=V);void 0===e.error&&(e.error=V);void 0===e.complete&&(e.complete=V);a=this.$.bind(this,this.a.length);this.l&&this.task.then(function(){try{d.G?e.error(d.G):e.complete()}catch(a){}});this.a.push(e);return a};
T.prototype.$=function(a){void 0!==this.a&&void 0!==this.a[a]&&(this.a[a]=void 0,--this.J,0===this.J&&void 0!==this.D&&this.D(this))};var U=function(a,b){if(!a.l)for(var c=0;c<a.a.length;c++)Na(a,c,b)},Na=function(a,b,c){a.task.then(function(){if(void 0!==a.a&&void 0!==a.a[b])try{c(a.a[b])}catch(d){}})};T.prototype.close=function(a){var b=this;this.l||(this.l=!0,void 0!==a&&(this.G=a),this.task.then(function(){b.a=void 0;b.D=void 0}))};
function Ma(a){if("object"!==typeof a||null===a)return!1;for(var b=ca(),c=b.next();!c.done;c=b.next())if(c=c.value,c in a&&"function"===typeof a[c])return!0;return!1}function V(){};var W=S,X=function(a,b,c){var d=this;this.H=c;this.I=!1;this.i={};this.P={};this.C=b;this.T=P(void 0,a);Object.keys(c.INTERNAL.factories).forEach(function(a){d[a]=d.R.bind(d,a)})};X.prototype.delete=function(){var a=this;return(new W(function(b){Y(a);b()})).then(function(){a.H.INTERNAL.removeApp(a.C);return W.all(Object.keys(a.i).map(function(b){return a.i[b].INTERNAL.delete()}))}).then(function(){a.I=!0;a.i=null;a.P=null})};
X.prototype.R=function(a){Y(this);void 0===this.i[a]&&(this.i[a]=this.H.INTERNAL.factories[a](this,this.O.bind(this)));return this.i[a]};X.prototype.O=function(a){P(this,a)};var Y=function(a){a.I&&Z(Oa("deleted",{name:a.C}))};Object.defineProperties(X.prototype,{name:{configurable:!0,enumerable:!0,get:function(){Y(this);return this.C}},options:{configurable:!0,enumerable:!0,get:function(){Y(this);return this.T}}});X.prototype.name&&X.prototype.options||X.prototype.delete||console.log("dc");
function Pa(){function a(a){a=a||"[DEFAULT]";var c=b[a];void 0===c&&Z("noApp",{name:a});return c}var b={},c={},d=[],e={initializeApp:function(a,c){void 0===c?c="[DEFAULT]":"string"===typeof c&&""!==c||Z("bad-app-name",{name:c+""});void 0!==b[c]&&Z("dupApp",{name:c});var g=new X(a,c,e);b[c]=g;d.forEach(function(a){return a("create",g)});void 0!=g.INTERNAL&&void 0!=g.INTERNAL.getToken||P(g,{INTERNAL:{getToken:function(){return W.resolve(null)},addAuthTokenListener:function(){},removeAuthTokenListener:function(){}}});
return g},app:a,apps:null,Promise:W,SDK_VERSION:"0.0.0",INTERNAL:{registerService:function(b,d,g){c[b]&&Z("dupService",{name:b});c[b]=d;d=function(c){void 0===c&&(c=a());return c[b]()};void 0!==g&&P(d,g);return e[b]=d},createFirebaseNamespace:Pa,extendNamespace:function(a){P(e,a)},createSubscribe:La,ErrorFactory:Q,registerAppHook:function(a){d.push(a)},removeApp:function(a){d.forEach(function(c){return c("delete",b[a])});delete b[a]},factories:c,Promise:O,deepExtend:P}};Object.defineProperty(e,"apps",
{get:function(){return Object.keys(b).map(function(a){return b[a]})}});a.App=X;return e}function Z(a,b){throw Error(Oa(a,b));}
function Oa(a,b){b=b||{};b={noApp:"No Firebase App '"+b.name+"' has been created - call Firebase App.initializeApp().","bad-app-name":"Illegal App name: '"+b.name+"'.",dupApp:"Firebase App named '"+b.name+"' already exists.",deleted:"Firebase App named '"+b.name+"' already deleted.",dupService:"Firebase Service named '"+b.name+"' already registered."}[a];return void 0===b?"Application Error: ("+a+")":b};"undefined"!==typeof window&&(window.firebase=Pa()); })();
firebase.SDK_VERSION = "3.0.3";
(function(){var k,aa=aa||{},l=this,ba=function(){},ca=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&
!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==b&&"undefined"==typeof a.call)return"object";return b},da=function(a){return null===a},ea=function(a){return"array"==ca(a)},fa=function(a){var b=ca(a);return"array"==b||"object"==b&&"number"==typeof a.length},n=function(a){return"string"==typeof a},ga=function(a){return"number"==typeof a},p=function(a){return"function"==ca(a)},ha=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b},ia=function(a,
b,c){return a.call.apply(a.bind,arguments)},ja=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}},q=function(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ia:ja;return q.apply(null,arguments)},ka=function(a,b){var c=Array.prototype.slice.call(arguments,
1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}},la=Date.now||function(){return+new Date},r=function(a,b){function c(){}c.prototype=b.prototype;a.yc=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Ae=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)}};var t=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,t);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))};r(t,Error);t.prototype.name="CustomError";var ma=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")},na=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},oa=/&/g,pa=/</g,qa=/>/g,ra=/"/g,sa=/'/g,ta=/\x00/g,ua=/[\x00&<>"']/,u=function(a,b){return-1!=a.indexOf(b)},va=function(a,b){return a<b?-1:a>b?1:0};var wa=function(a,b){b.unshift(a);t.call(this,ma.apply(null,b));b.shift()};r(wa,t);wa.prototype.name="AssertionError";
var xa=function(a,b,c,d){var e="Assertion failed";if(c)var e=e+(": "+c),f=d;else a&&(e+=": "+a,f=b);throw new wa(""+e,f||[]);},v=function(a,b,c){a||xa("",null,b,Array.prototype.slice.call(arguments,2))},ya=function(a,b){throw new wa("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));},za=function(a,b,c){ga(a)||xa("Expected number but got %s: %s.",[ca(a),a],b,Array.prototype.slice.call(arguments,2));return a},Aa=function(a,b,c){n(a)||xa("Expected string but got %s: %s.",[ca(a),a],b,Array.prototype.slice.call(arguments,
2));return a},Ba=function(a,b,c){p(a)||xa("Expected function but got %s: %s.",[ca(a),a],b,Array.prototype.slice.call(arguments,2))};var Ca=Array.prototype.indexOf?function(a,b,c){v(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(n(a))return n(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},w=Array.prototype.forEach?function(a,b,c){v(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=n(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Da=function(a,b){for(var c=n(a)?
a.split(""):a,d=a.length-1;0<=d;--d)d in c&&b.call(void 0,c[d],d,a)},Ea=Array.prototype.map?function(a,b,c){v(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=n(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Fa=Array.prototype.some?function(a,b,c){v(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=n(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1},
Ha=function(a){var b;a:{b=Ga;for(var c=a.length,d=n(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:n(a)?a.charAt(b):a[b]},Ia=function(a,b){return 0<=Ca(a,b)},Ka=function(a,b){var c=Ca(a,b),d;(d=0<=c)&&Ja(a,c);return d},Ja=function(a,b){v(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length},La=function(a,b){var c=0;Da(a,function(d,e){b.call(void 0,d,e,a)&&Ja(a,e)&&c++})},Ma=function(a){return Array.prototype.concat.apply(Array.prototype,
arguments)},Na=function(a){return Array.prototype.concat.apply(Array.prototype,arguments)},Oa=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]},Pa=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(fa(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g]}else a.push(d)}};var Qa=function(a,b){for(var c in a)b.call(void 0,a[c],c,a)},Ra=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b},Sa=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},Ta=function(a){return null!==a&&"withCredentials"in a},Ua=function(a){for(var b in a)return!1;return!0},Va=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(c in b)if(!(c in a))return!1;return!0},Ya=function(a){var b={},c;for(c in a)b[c]=a[c];return b},Za="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
$a=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Za.length;f++)c=Za[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};var ab;a:{var bb=l.navigator;if(bb){var cb=bb.userAgent;if(cb){ab=cb;break a}}ab=""}var x=function(a){return u(ab,a)};var db=x("Opera"),y=x("Trident")||x("MSIE"),eb=x("Edge"),fb=eb||y,gb=x("Gecko")&&!(u(ab.toLowerCase(),"webkit")&&!x("Edge"))&&!(x("Trident")||x("MSIE"))&&!x("Edge"),hb=u(ab.toLowerCase(),"webkit")&&!x("Edge"),ib=function(){var a=l.document;return a?a.documentMode:void 0},jb;
a:{var kb="",lb=function(){var a=ab;if(gb)return/rv\:([^\);]+)(\)|;)/.exec(a);if(eb)return/Edge\/([\d\.]+)/.exec(a);if(y)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(hb)return/WebKit\/(\S+)/.exec(a);if(db)return/(?:Version)[ \/]?(\S+)/.exec(a)}();lb&&(kb=lb?lb[1]:"");if(y){var mb=ib();if(null!=mb&&mb>parseFloat(kb)){jb=String(mb);break a}}jb=kb}
var nb=jb,ob={},z=function(a){var b;if(!(b=ob[a])){b=0;for(var c=na(String(nb)).split("."),d=na(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"",m=RegExp("(\\d*)(\\D*)","g"),S=RegExp("(\\d*)(\\D*)","g");do{var Wa=m.exec(g)||["","",""],Xa=S.exec(h)||["","",""];if(0==Wa[0].length&&0==Xa[0].length)break;b=va(0==Wa[1].length?0:parseInt(Wa[1],10),0==Xa[1].length?0:parseInt(Xa[1],10))||va(0==Wa[2].length,0==Xa[2].length)||va(Wa[2],Xa[2])}while(0==b)}b=ob[a]=
0<=b}return b},pb=l.document,qb=pb&&y?ib()||("CSS1Compat"==pb.compatMode?parseInt(nb,10):5):void 0;var rb=null,sb=null,ub=function(a){var b="";tb(a,function(a){b+=String.fromCharCode(a)});return b},tb=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=sb[c];if(null!=e)return e;if(!/^[\s\xa0]*$/.test(c))throw Error("Unknown base64 encoding at char: "+c);}return b}vb();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h))}},vb=function(){if(!rb){rb={};sb={};for(var a=0;65>a;a++)rb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),
sb[rb[a]]=a,62<=a&&(sb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)]=a)}};var xb=function(){this.Pb="";this.wd=wb};xb.prototype.ic=!0;xb.prototype.gc=function(){return this.Pb};xb.prototype.toString=function(){return"Const{"+this.Pb+"}"};var yb=function(a){if(a instanceof xb&&a.constructor===xb&&a.wd===wb)return a.Pb;ya("expected object of type Const, got '"+a+"'");return"type_error:Const"},wb={};var A=function(){this.aa="";this.vd=zb};A.prototype.ic=!0;A.prototype.gc=function(){return this.aa};A.prototype.toString=function(){return"SafeUrl{"+this.aa+"}"};
var Ab=function(a){if(a instanceof A&&a.constructor===A&&a.vd===zb)return a.aa;ya("expected object of type SafeUrl, got '"+a+"' of type "+ca(a));return"type_error:SafeUrl"},Bb=/^(?:(?:https?|mailto|ftp):|[^&:/?#]*(?:[/?#]|$))/i,Db=function(a){if(a instanceof A)return a;a=a.ic?a.gc():String(a);Bb.test(a)||(a="about:invalid#zClosurez");return Cb(a)},zb={},Cb=function(a){var b=new A;b.aa=a;return b};Cb("about:blank");var Fb=function(){this.aa="";this.ud=Eb};Fb.prototype.ic=!0;Fb.prototype.gc=function(){return this.aa};Fb.prototype.toString=function(){return"SafeHtml{"+this.aa+"}"};var Gb=function(a){if(a instanceof Fb&&a.constructor===Fb&&a.ud===Eb)return a.aa;ya("expected object of type SafeHtml, got '"+a+"' of type "+ca(a));return"type_error:SafeHtml"},Eb={};Fb.prototype.Zd=function(a){this.aa=a;return this};var Hb=function(a,b){var c;c=b instanceof A?b:Db(b);a.href=Ab(c)};var Ib=function(a){Ib[" "](a);return a};Ib[" "]=ba;var Jb=!y||9<=Number(qb),Kb=y&&!z("9");!hb||z("528");gb&&z("1.9b")||y&&z("8")||db&&z("9.5")||hb&&z("528");gb&&!z("8")||y&&z("9");var Lb=function(){this.ra=this.ra;this.Gb=this.Gb};Lb.prototype.ra=!1;Lb.prototype.isDisposed=function(){return this.ra};Lb.prototype.Ga=function(){if(this.Gb)for(;this.Gb.length;)this.Gb.shift()()};var Mb=function(a,b){this.type=a;this.currentTarget=this.target=b;this.defaultPrevented=this.Na=!1;this.gd=!0};Mb.prototype.preventDefault=function(){this.defaultPrevented=!0;this.gd=!1};var Nb=function(a,b){Mb.call(this,a?a.type:"");this.relatedTarget=this.currentTarget=this.target=null;this.charCode=this.keyCode=this.button=this.screenY=this.screenX=this.clientY=this.clientX=this.offsetY=this.offsetX=0;this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.ub=this.state=null;a&&this.init(a,b)};r(Nb,Mb);
Nb.prototype.init=function(a,b){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.currentTarget=b;var e=a.relatedTarget;if(e){if(gb){var f;a:{try{Ib(e.nodeName);f=!0;break a}catch(g){}f=!1}f||(e=null)}}else"mouseover"==c?e=a.fromElement:"mouseout"==c&&(e=a.toElement);this.relatedTarget=e;null===d?(this.offsetX=hb||void 0!==a.offsetX?a.offsetX:a.layerX,this.offsetY=hb||void 0!==a.offsetY?a.offsetY:a.layerY,this.clientX=void 0!==a.clientX?a.clientX:
a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.keyCode=a.keyCode||0;this.charCode=a.charCode||("keypress"==c?a.keyCode:0);this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=a.metaKey;this.state=a.state;this.ub=a;a.defaultPrevented&&
this.preventDefault()};Nb.prototype.preventDefault=function(){Nb.yc.preventDefault.call(this);var a=this.ub;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Kb)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var Ob="closure_listenable_"+(1E6*Math.random()|0),Pb=0;var Qb=function(a,b,c,d,e){this.listener=a;this.Ib=null;this.src=b;this.type=c;this.rb=!!d;this.zb=e;this.key=++Pb;this.Pa=this.qb=!1},Rb=function(a){a.Pa=!0;a.listener=null;a.Ib=null;a.src=null;a.zb=null};var Sb=function(a){this.src=a;this.v={};this.pb=0};Sb.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.v[f];a||(a=this.v[f]=[],this.pb++);var g=Tb(a,b,d,e);-1<g?(b=a[g],c||(b.qb=!1)):(b=new Qb(b,this.src,f,!!d,e),b.qb=c,a.push(b));return b};Sb.prototype.remove=function(a,b,c,d){a=a.toString();if(!(a in this.v))return!1;var e=this.v[a];b=Tb(e,b,c,d);return-1<b?(Rb(e[b]),Ja(e,b),0==e.length&&(delete this.v[a],this.pb--),!0):!1};
var Ub=function(a,b){var c=b.type;c in a.v&&Ka(a.v[c],b)&&(Rb(b),0==a.v[c].length&&(delete a.v[c],a.pb--))};Sb.prototype.ec=function(a,b,c,d){a=this.v[a.toString()];var e=-1;a&&(e=Tb(a,b,c,d));return-1<e?a[e]:null};var Tb=function(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.Pa&&f.listener==b&&f.rb==!!c&&f.zb==d)return e}return-1};var Vb="closure_lm_"+(1E6*Math.random()|0),Wb={},Xb=0,Yb=function(a,b,c,d,e){if(ea(b))for(var f=0;f<b.length;f++)Yb(a,b[f],c,d,e);else c=Zb(c),a&&a[Ob]?$b(a,b,c,d,e):ac(a,b,c,!1,d,e)},ac=function(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=!!e,h=bc(a);h||(a[Vb]=h=new Sb(a));c=h.add(b,c,d,e,f);if(!c.Ib){d=cc();c.Ib=d;d.src=a;d.listener=c;if(a.addEventListener)a.addEventListener(b.toString(),d,g);else if(a.attachEvent)a.attachEvent(dc(b.toString()),d);else throw Error("addEventListener and attachEvent are unavailable.");
Xb++}},cc=function(){var a=ec,b=Jb?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b},fc=function(a,b,c,d,e){if(ea(b))for(var f=0;f<b.length;f++)fc(a,b[f],c,d,e);else c=Zb(c),a&&a[Ob]?gc(a,b,c,d,e):ac(a,b,c,!0,d,e)},hc=function(a,b,c,d,e){if(ea(b))for(var f=0;f<b.length;f++)hc(a,b[f],c,d,e);else c=Zb(c),a&&a[Ob]?a.O.remove(String(b),c,d,e):a&&(a=bc(a))&&(b=a.ec(b,c,!!d,e))&&ic(b)},ic=function(a){if(!ga(a)&&a&&!a.Pa){var b=a.src;if(b&&
b[Ob])Ub(b.O,a);else{var c=a.type,d=a.Ib;b.removeEventListener?b.removeEventListener(c,d,a.rb):b.detachEvent&&b.detachEvent(dc(c),d);Xb--;(c=bc(b))?(Ub(c,a),0==c.pb&&(c.src=null,b[Vb]=null)):Rb(a)}}},dc=function(a){return a in Wb?Wb[a]:Wb[a]="on"+a},kc=function(a,b,c,d){var e=!0;if(a=bc(a))if(b=a.v[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.rb==c&&!f.Pa&&(f=jc(f,d),e=e&&!1!==f)}return e},jc=function(a,b){var c=a.listener,d=a.zb||a.src;a.qb&&ic(a);return c.call(d,b)},ec=function(a,
b){if(a.Pa)return!0;if(!Jb){var c;if(!(c=b))a:{c=["window","event"];for(var d=l,e;e=c.shift();)if(null!=d[e])d=d[e];else{c=null;break a}c=d}e=c;c=new Nb(e,this);d=!0;if(!(0>e.keyCode||void 0!=e.returnValue)){a:{var f=!1;if(0==e.keyCode)try{e.keyCode=-1;break a}catch(m){f=!0}if(f||void 0==e.returnValue)e.returnValue=!0}e=[];for(f=c.currentTarget;f;f=f.parentNode)e.push(f);for(var f=a.type,g=e.length-1;!c.Na&&0<=g;g--){c.currentTarget=e[g];var h=kc(e[g],f,!0,c),d=d&&h}for(g=0;!c.Na&&g<e.length;g++)c.currentTarget=
e[g],h=kc(e[g],f,!1,c),d=d&&h}return d}return jc(a,new Nb(b,this))},bc=function(a){a=a[Vb];return a instanceof Sb?a:null},lc="__closure_events_fn_"+(1E9*Math.random()>>>0),Zb=function(a){v(a,"Listener can not be null.");if(p(a))return a;v(a.handleEvent,"An object listener must have handleEvent method.");a[lc]||(a[lc]=function(b){return a.handleEvent(b)});return a[lc]};var mc=/^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;var nc=function(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/(?:"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)[\s\u2028\u2029]*(?=:|,|]|}|$)/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);},qc=function(a){var b=[];oc(new pc,a,b);return b.join("")},pc=function(){this.Lb=void 0},oc=function(a,b,c){if(null==
b)c.push("null");else{if("object"==typeof b){if(ea(b)){var d=b;b=d.length;c.push("[");for(var e="",f=0;f<b;f++)c.push(e),e=d[f],oc(a,a.Lb?a.Lb.call(d,String(f),e):e,c),e=",";c.push("]");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push("{");f="";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(e=b[d],"function"!=typeof e&&(c.push(f),rc(d,c),c.push(":"),oc(a,a.Lb?a.Lb.call(b,d,e):e,c),f=","));c.push("}");return}}switch(typeof b){case "string":rc(b,
c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?String(b):"null");break;case "boolean":c.push(String(b));break;case "function":c.push("null");break;default:throw Error("Unknown type: "+typeof b);}}},sc={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},tc=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g,rc=function(a,b){b.push('"',a.replace(tc,function(a){var b=sc[a];b||(b="\\u"+(a.charCodeAt(0)|65536).toString(16).substr(1),
sc[a]=b);return b}),'"')};var uc=function(){};uc.prototype.Bc=null;var vc=function(a){return a.Bc||(a.Bc=a.Uc())};var wc,xc=function(){};r(xc,uc);xc.prototype.$b=function(){var a=yc(this);return a?new ActiveXObject(a):new XMLHttpRequest};xc.prototype.Uc=function(){var a={};yc(this)&&(a[0]=!0,a[1]=!0);return a};
var yc=function(a){if(!a.Qc&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.Qc=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.Qc};wc=new xc;var zc=function(){};r(zc,uc);zc.prototype.$b=function(){var a=new XMLHttpRequest;if("withCredentials"in a)return a;if("undefined"!=typeof XDomainRequest)return new Ac;throw Error("Unsupported browser");};zc.prototype.Uc=function(){return{}};
var Ac=function(){this.fa=new XDomainRequest;this.readyState=0;this.responseText=this.onreadystatechange=null;this.status=-1;this.statusText=this.responseXML=null;this.fa.onload=q(this.Nd,this);this.fa.onerror=q(this.Oc,this);this.fa.onprogress=q(this.Od,this);this.fa.ontimeout=q(this.Pd,this)};k=Ac.prototype;k.open=function(a,b,c){if(null!=c&&!c)throw Error("Only async requests are supported.");this.fa.open(a,b)};
k.send=function(a){if(a)if("string"==typeof a)this.fa.send(a);else throw Error("Only string data is supported");else this.fa.send()};k.abort=function(){this.fa.abort()};k.setRequestHeader=function(){};k.Nd=function(){this.status=200;this.responseText=this.fa.responseText;Bc(this,4)};k.Oc=function(){this.status=500;this.responseText=null;Bc(this,4)};k.Pd=function(){this.Oc()};k.Od=function(){this.status=200;Bc(this,1)};var Bc=function(a,b){a.readyState=b;if(a.onreadystatechange)a.onreadystatechange()};var B=function(a,b){this.h=[];this.g=b;for(var c=!0,d=a.length-1;0<=d;d--){var e=a[d]|0;c&&e==b||(this.h[d]=e,c=!1)}},Cc={},Dc=function(a){if(-128<=a&&128>a){var b=Cc[a];if(b)return b}b=new B([a|0],0>a?-1:0);-128<=a&&128>a&&(Cc[a]=b);return b},E=function(a){if(isNaN(a)||!isFinite(a))return C;if(0>a)return D(E(-a));for(var b=[],c=1,d=0;a>=c;d++)b[d]=a/c|0,c*=4294967296;return new B(b,0)},Ec=function(a,b){if(0==a.length)throw Error("number format error: empty string");var c=b||10;if(2>c||36<c)throw Error("radix out of range: "+
c);if("-"==a.charAt(0))return D(Ec(a.substring(1),c));if(0<=a.indexOf("-"))throw Error('number format error: interior "-" character');for(var d=E(Math.pow(c,8)),e=C,f=0;f<a.length;f+=8){var g=Math.min(8,a.length-f),h=parseInt(a.substring(f,f+g),c);8>g?(g=E(Math.pow(c,g)),e=e.multiply(g).add(E(h))):(e=e.multiply(d),e=e.add(E(h)))}return e},C=Dc(0),Fc=Dc(1),Gc=Dc(16777216),Hc=function(a){if(-1==a.g)return-Hc(D(a));for(var b=0,c=1,d=0;d<a.h.length;d++)b+=Ic(a,d)*c,c*=4294967296;return b};
B.prototype.toString=function(a){a=a||10;if(2>a||36<a)throw Error("radix out of range: "+a);if(F(this))return"0";if(-1==this.g)return"-"+D(this).toString(a);for(var b=E(Math.pow(a,6)),c=this,d="";;){var e=Jc(c,b),c=Kc(c,e.multiply(b)),f=((0<c.h.length?c.h[0]:c.g)>>>0).toString(a),c=e;if(F(c))return f+d;for(;6>f.length;)f="0"+f;d=""+f+d}};
var G=function(a,b){return 0>b?0:b<a.h.length?a.h[b]:a.g},Ic=function(a,b){var c=G(a,b);return 0<=c?c:4294967296+c},F=function(a){if(0!=a.g)return!1;for(var b=0;b<a.h.length;b++)if(0!=a.h[b])return!1;return!0};B.prototype.tb=function(a){if(this.g!=a.g)return!1;for(var b=Math.max(this.h.length,a.h.length),c=0;c<b;c++)if(G(this,c)!=G(a,c))return!1;return!0};B.prototype.compare=function(a){a=Kc(this,a);return-1==a.g?-1:F(a)?0:1};
var D=function(a){for(var b=a.h.length,c=[],d=0;d<b;d++)c[d]=~a.h[d];return(new B(c,~a.g)).add(Fc)};B.prototype.add=function(a){for(var b=Math.max(this.h.length,a.h.length),c=[],d=0,e=0;e<=b;e++){var f=d+(G(this,e)&65535)+(G(a,e)&65535),g=(f>>>16)+(G(this,e)>>>16)+(G(a,e)>>>16),d=g>>>16,f=f&65535,g=g&65535;c[e]=g<<16|f}return new B(c,c[c.length-1]&-2147483648?-1:0)};var Kc=function(a,b){return a.add(D(b))};
B.prototype.multiply=function(a){if(F(this)||F(a))return C;if(-1==this.g)return-1==a.g?D(this).multiply(D(a)):D(D(this).multiply(a));if(-1==a.g)return D(this.multiply(D(a)));if(0>this.compare(Gc)&&0>a.compare(Gc))return E(Hc(this)*Hc(a));for(var b=this.h.length+a.h.length,c=[],d=0;d<2*b;d++)c[d]=0;for(d=0;d<this.h.length;d++)for(var e=0;e<a.h.length;e++){var f=G(this,d)>>>16,g=G(this,d)&65535,h=G(a,e)>>>16,m=G(a,e)&65535;c[2*d+2*e]+=g*m;Lc(c,2*d+2*e);c[2*d+2*e+1]+=f*m;Lc(c,2*d+2*e+1);c[2*d+2*e+1]+=
g*h;Lc(c,2*d+2*e+1);c[2*d+2*e+2]+=f*h;Lc(c,2*d+2*e+2)}for(d=0;d<b;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=b;d<2*b;d++)c[d]=0;return new B(c,0)};
var Lc=function(a,b){for(;(a[b]&65535)!=a[b];)a[b+1]+=a[b]>>>16,a[b]&=65535},Jc=function(a,b){if(F(b))throw Error("division by zero");if(F(a))return C;if(-1==a.g)return-1==b.g?Jc(D(a),D(b)):D(Jc(D(a),b));if(-1==b.g)return D(Jc(a,D(b)));if(30<a.h.length){if(-1==a.g||-1==b.g)throw Error("slowDivide_ only works with positive integers.");for(var c=Fc,d=b;0>=d.compare(a);)c=c.shiftLeft(1),d=d.shiftLeft(1);for(var e=Mc(c,1),f=Mc(d,1),g,d=Mc(d,2),c=Mc(c,2);!F(d);)g=f.add(d),0>=g.compare(a)&&(e=e.add(c),
f=g),d=Mc(d,1),c=Mc(c,1);return e}c=C;for(d=a;0<=d.compare(b);){e=Math.max(1,Math.floor(Hc(d)/Hc(b)));f=Math.ceil(Math.log(e)/Math.LN2);f=48>=f?1:Math.pow(2,f-48);g=E(e);for(var h=g.multiply(b);-1==h.g||0<h.compare(d);)e-=f,g=E(e),h=g.multiply(b);F(g)&&(g=Fc);c=c.add(g);d=Kc(d,h)}return c},Nc=function(a,b){for(var c=Math.max(a.h.length,b.h.length),d=[],e=0;e<c;e++)d[e]=G(a,e)|G(b,e);return new B(d,a.g|b.g)};
B.prototype.shiftLeft=function(a){var b=a>>5;a%=32;for(var c=this.h.length+b+(0<a?1:0),d=[],e=0;e<c;e++)d[e]=0<a?G(this,e-b)<<a|G(this,e-b-1)>>>32-a:G(this,e-b);return new B(d,this.g)};var Mc=function(a,b){for(var c=b>>5,d=b%32,e=a.h.length-c,f=[],g=0;g<e;g++)f[g]=0<d?G(a,g+c)>>>d|G(a,g+c+1)<<32-d:G(a,g+c);return new B(f,a.g)};var Oc=function(a,b){this.cb=a;this.ea=b};Oc.prototype.tb=function(a){return this.ea==a.ea&&this.cb.tb(Ya(a.cb))};
var Rc=function(a){try{var b;if(b=0==a.lastIndexOf("[",0)){var c=a.length-1;b=0<=c&&a.indexOf("]",c)==c}return b?new Pc(a.substring(1,a.length-1)):new Qc(a)}catch(d){return null}},Qc=function(a){var b=C;if(a instanceof B){if(0!=a.g||0>a.compare(C)||0<a.compare(Sc))throw Error("The address does not look like an IPv4.");b=Ya(a)}else{if(!Tc.test(a))throw Error(a+" does not look like an IPv4 address.");var c=a.split(".");if(4!=c.length)throw Error(a+" does not look like an IPv4 address.");for(var d=0;d<
c.length;d++){var e;e=c[d];var f=Number(e);e=0==f&&/^[\s\xa0]*$/.test(e)?NaN:f;if(isNaN(e)||0>e||255<e||1!=c[d].length&&0==c[d].lastIndexOf("0",0))throw Error("In "+a+", octet "+d+" is not valid");e=E(e);b=Nc(b.shiftLeft(8),e)}}Oc.call(this,b,4)};r(Qc,Oc);var Tc=/^[0-9.]*$/,Sc=Kc(Fc.shiftLeft(32),Fc);Qc.prototype.toString=function(){if(this.va)return this.va;for(var a=Ic(this.cb,0),b=[],c=3;0<=c;c--)b[c]=String(a&255),a>>>=8;return this.va=b.join(".")};
var Pc=function(a){var b=C;if(a instanceof B){if(0!=a.g||0>a.compare(C)||0<a.compare(Uc))throw Error("The address does not look like a valid IPv6.");b=Ya(a)}else{if(!Vc.test(a))throw Error(a+" is not a valid IPv6 address.");var c=a.split(":");if(-1!=c[c.length-1].indexOf(".")){a=Ic(Ya((new Qc(c[c.length-1])).cb),0);var d=[];d.push((a>>>16&65535).toString(16));d.push((a&65535).toString(16));Ja(c,c.length-1);Pa(c,d);a=c.join(":")}d=a.split("::");if(2<d.length||1==d.length&&8!=c.length)throw Error(a+
" is not a valid IPv6 address.");if(1<d.length){c=d[0].split(":");d=d[1].split(":");1==c.length&&""==c[0]&&(c=[]);1==d.length&&""==d[0]&&(d=[]);var e=8-(c.length+d.length);if(1>e)c=[];else{for(var f=[],g=0;g<e;g++)f[g]="0";c=Na(c,f,d)}}if(8!=c.length)throw Error(a+" is not a valid IPv6 address");for(d=0;d<c.length;d++){e=Ec(c[d],16);if(0>e.compare(C)||0<e.compare(Wc))throw Error(c[d]+" in "+a+" is not a valid hextet.");b=Nc(b.shiftLeft(16),e)}}Oc.call(this,b,6)};r(Pc,Oc);
var Vc=/^([a-fA-F0-9]*:){2}[a-fA-F0-9:.]*$/,Wc=Dc(65535),Uc=Kc(Fc.shiftLeft(128),Fc);Pc.prototype.toString=function(){if(this.va)return this.va;for(var a=[],b=3;0<=b;b--){var c=Ic(this.cb,b),d=c&65535;a.push((c>>>16).toString(16));a.push(d.toString(16))}for(var c=b=-1,e=d=0,f=0;f<a.length;f++)"0"==a[f]?(e++,-1==c&&(c=f),e>d&&(d=e,b=c)):(c=-1,e=0);0<d&&(b+d==a.length&&a.push(""),a.splice(b,d,""),0==b&&(a=[""].concat(a)));return this.va=a.join(":")};!gb&&!y||y&&9<=Number(qb)||gb&&z("1.9.1");y&&z("9");var Yc=function(a,b){Qa(b,function(b,d){"style"==d?a.style.cssText=b:"class"==d?a.className=b:"for"==d?a.htmlFor=b:Xc.hasOwnProperty(d)?a.setAttribute(Xc[d],b):0==d.lastIndexOf("aria-",0)||0==d.lastIndexOf("data-",0)?a.setAttribute(d,b):a[d]=b})},Xc={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",nonce:"nonce",role:"role",rowspan:"rowSpan",type:"type",usemap:"useMap",valign:"vAlign",width:"width"};var Zc=function(a,b,c){this.ae=c;this.Cd=a;this.le=b;this.Fb=0;this.Ab=null};Zc.prototype.get=function(){var a;0<this.Fb?(this.Fb--,a=this.Ab,this.Ab=a.next,a.next=null):a=this.Cd();return a};Zc.prototype.put=function(a){this.le(a);this.Fb<this.ae&&(this.Fb++,a.next=this.Ab,this.Ab=a)};var $c=function(a){l.setTimeout(function(){throw a;},0)},ad,bd=function(){var a=l.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!x("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host,
a=q(function(a){if(("*"==d||a.origin==d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!x("Trident")&&!x("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.Fc;c.Fc=null;a()}};return function(a){d.next={Fc:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?
function(a){var b=document.createElement("SCRIPT");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){l.setTimeout(a,0)}};var cd=function(){this.Tb=this.Da=null},ed=new Zc(function(){return new dd},function(a){a.reset()},100);cd.prototype.add=function(a,b){var c=ed.get();c.set(a,b);this.Tb?this.Tb.next=c:(v(!this.Da),this.Da=c);this.Tb=c};cd.prototype.remove=function(){var a=null;this.Da&&(a=this.Da,this.Da=this.Da.next,this.Da||(this.Tb=null),a.next=null);return a};var dd=function(){this.next=this.scope=this.dc=null};dd.prototype.set=function(a,b){this.dc=a;this.scope=b;this.next=null};
dd.prototype.reset=function(){this.next=this.scope=this.dc=null};var jd=function(a,b){fd||gd();hd||(fd(),hd=!0);id.add(a,b)},fd,gd=function(){if(l.Promise&&l.Promise.resolve){var a=l.Promise.resolve(void 0);fd=function(){a.then(kd)}}else fd=function(){var a=kd;!p(l.setImmediate)||l.Window&&l.Window.prototype&&!x("Edge")&&l.Window.prototype.setImmediate==l.setImmediate?(ad||(ad=bd()),ad(a)):l.setImmediate(a)}},hd=!1,id=new cd,kd=function(){for(var a;a=id.remove();){try{a.dc.call(a.scope)}catch(b){$c(b)}ed.put(a)}hd=!1};var ld=function(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0},md=function(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};var H=function(a,b){this.A=0;this.ca=void 0;this.Fa=this.X=this.l=null;this.yb=this.cc=!1;if(a!=ba)try{var c=this;a.call(b,function(a){nd(c,2,a)},function(a){if(!(a instanceof od))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(b){}nd(c,3,a)})}catch(d){nd(this,3,d)}},pd=function(){this.next=this.context=this.La=this.wa=this.child=null;this.Wa=!1};pd.prototype.reset=function(){this.context=this.La=this.wa=this.child=null;this.Wa=!1};
var qd=new Zc(function(){return new pd},function(a){a.reset()},100),rd=function(a,b,c){var d=qd.get();d.wa=a;d.La=b;d.context=c;return d},I=function(a){if(a instanceof H)return a;var b=new H(ba);nd(b,2,a);return b},sd=function(a){return new H(function(b,c){c(a)})},ud=function(a,b,c){td(a,b,c,null)||jd(ka(b,a))},vd=function(a){return new H(function(b){var c=a.length,d=[];if(c)for(var e=function(a,e,f){c--;d[a]=e?{Ld:!0,value:f}:{Ld:!1,reason:f};0==c&&b(d)},f=0,g;f<a.length;f++)g=a[f],ud(g,ka(e,f,!0),
ka(e,f,!1));else b(d)})};H.prototype.then=function(a,b,c){null!=a&&Ba(a,"opt_onFulfilled should be a function.");null!=b&&Ba(b,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?");return wd(this,p(a)?a:null,p(b)?b:null,c)};ld(H);var yd=function(a,b){var c=rd(b,b,void 0);c.Wa=!0;xd(a,c);return a};H.prototype.I=function(a,b){return wd(this,null,a,b)};H.prototype.cancel=function(a){0==this.A&&jd(function(){var b=new od(a);zd(this,b)},this)};
var zd=function(a,b){if(0==a.A)if(a.l){var c=a.l;if(c.X){for(var d=0,e=null,f=null,g=c.X;g&&(g.Wa||(d++,g.child==a&&(e=g),!(e&&1<d)));g=g.next)e||(f=g);e&&(0==c.A&&1==d?zd(c,b):(f?(d=f,v(c.X),v(null!=d),d.next==c.Fa&&(c.Fa=d),d.next=d.next.next):Ad(c),Bd(c,e,3,b)))}a.l=null}else nd(a,3,b)},xd=function(a,b){a.X||2!=a.A&&3!=a.A||Cd(a);v(null!=b.wa);a.Fa?a.Fa.next=b:a.X=b;a.Fa=b},wd=function(a,b,c,d){var e=rd(null,null,null);e.child=new H(function(a,g){e.wa=b?function(c){try{var e=b.call(d,c);a(e)}catch(S){g(S)}}:
a;e.La=c?function(b){try{var e=c.call(d,b);void 0===e&&b instanceof od?g(b):a(e)}catch(S){g(S)}}:g});e.child.l=a;xd(a,e);return e.child};H.prototype.ve=function(a){v(1==this.A);this.A=0;nd(this,2,a)};H.prototype.we=function(a){v(1==this.A);this.A=0;nd(this,3,a)};
var nd=function(a,b,c){0==a.A&&(a==c&&(b=3,c=new TypeError("Promise cannot resolve to itself")),a.A=1,td(c,a.ve,a.we,a)||(a.ca=c,a.A=b,a.l=null,Cd(a),3!=b||c instanceof od||Dd(a,c)))},td=function(a,b,c,d){if(a instanceof H)return null!=b&&Ba(b,"opt_onFulfilled should be a function."),null!=c&&Ba(c,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?"),xd(a,rd(b||ba,c||null,d)),!0;if(md(a))return a.then(b,c,d),!0;if(ha(a))try{var e=a.then;if(p(e))return Ed(a,
e,b,c,d),!0}catch(f){return c.call(d,f),!0}return!1},Ed=function(a,b,c,d,e){var f=!1,g=function(a){f||(f=!0,c.call(e,a))},h=function(a){f||(f=!0,d.call(e,a))};try{b.call(a,g,h)}catch(m){h(m)}},Cd=function(a){a.cc||(a.cc=!0,jd(a.Gd,a))},Ad=function(a){var b=null;a.X&&(b=a.X,a.X=b.next,b.next=null);a.X||(a.Fa=null);null!=b&&v(null!=b.wa);return b};H.prototype.Gd=function(){for(var a;a=Ad(this);)Bd(this,a,this.A,this.ca);this.cc=!1};
var Bd=function(a,b,c,d){if(3==c&&b.La&&!b.Wa)for(;a&&a.yb;a=a.l)a.yb=!1;if(b.child)b.child.l=null,Fd(b,c,d);else try{b.Wa?b.wa.call(b.context):Fd(b,c,d)}catch(e){Gd.call(null,e)}qd.put(b)},Fd=function(a,b,c){2==b?a.wa.call(a.context,c):a.La&&a.La.call(a.context,c)},Dd=function(a,b){a.yb=!0;jd(function(){a.yb&&Gd.call(null,b)})},Gd=$c,od=function(a){t.call(this,a)};r(od,t);od.prototype.name="cancel";/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
var Hd=function(a,b){this.Mb=[];this.Zc=a;this.Hc=b||null;this.$a=this.Ia=!1;this.ca=void 0;this.wc=this.Ac=this.Xb=!1;this.Rb=0;this.l=null;this.Yb=0};Hd.prototype.cancel=function(a){if(this.Ia)this.ca instanceof Hd&&this.ca.cancel();else{if(this.l){var b=this.l;delete this.l;a?b.cancel(a):(b.Yb--,0>=b.Yb&&b.cancel())}this.Zc?this.Zc.call(this.Hc,this):this.wc=!0;this.Ia||Id(this,new Jd)}};Hd.prototype.Gc=function(a,b){this.Xb=!1;Kd(this,a,b)};
var Kd=function(a,b,c){a.Ia=!0;a.ca=c;a.$a=!b;Ld(a)},Nd=function(a){if(a.Ia){if(!a.wc)throw new Md;a.wc=!1}};Hd.prototype.callback=function(a){Nd(this);Od(a);Kd(this,!0,a)};var Id=function(a,b){Nd(a);Od(b);Kd(a,!1,b)},Od=function(a){v(!(a instanceof Hd),"An execution sequence may not be initiated with a blocking Deferred.")},Qd=function(a,b){Pd(a,null,b,void 0)},Pd=function(a,b,c,d){v(!a.Ac,"Blocking Deferreds can not be re-used");a.Mb.push([b,c,d]);a.Ia&&Ld(a)};
Hd.prototype.then=function(a,b,c){var d,e,f=new H(function(a,b){d=a;e=b});Pd(this,d,function(a){a instanceof Jd?f.cancel():e(a)});return f.then(a,b,c)};ld(Hd);
var Rd=function(a){return Fa(a.Mb,function(a){return p(a[1])})},Ld=function(a){if(a.Rb&&a.Ia&&Rd(a)){var b=a.Rb,c=Sd[b];c&&(l.clearTimeout(c.ab),delete Sd[b]);a.Rb=0}a.l&&(a.l.Yb--,delete a.l);for(var b=a.ca,d=c=!1;a.Mb.length&&!a.Xb;){var e=a.Mb.shift(),f=e[0],g=e[1],e=e[2];if(f=a.$a?g:f)try{var h=f.call(e||a.Hc,b);void 0!==h&&(a.$a=a.$a&&(h==b||h instanceof Error),a.ca=b=h);if(md(b)||"function"===typeof l.Promise&&b instanceof l.Promise)d=!0,a.Xb=!0}catch(m){b=m,a.$a=!0,Rd(a)||(c=!0)}}a.ca=b;d&&
(h=q(a.Gc,a,!0),d=q(a.Gc,a,!1),b instanceof Hd?(Pd(b,h,d),b.Ac=!0):b.then(h,d));c&&(b=new Td(b),Sd[b.ab]=b,a.Rb=b.ab)},Md=function(){t.call(this)};r(Md,t);Md.prototype.message="Deferred has already fired";Md.prototype.name="AlreadyCalledError";var Jd=function(){t.call(this)};r(Jd,t);Jd.prototype.message="Deferred was canceled";Jd.prototype.name="CanceledError";var Td=function(a){this.ab=l.setTimeout(q(this.ue,this),0);this.D=a};
Td.prototype.ue=function(){v(Sd[this.ab],"Cannot throw an error that is not scheduled.");delete Sd[this.ab];throw this.D;};var Sd={};var Yd=function(a){var b={},c=b.document||document,d=document.createElement("SCRIPT"),e={hd:d,ob:void 0},f=new Hd(Ud,e),g=null,h=null!=b.timeout?b.timeout:5E3;0<h&&(g=window.setTimeout(function(){Vd(d,!0);Id(f,new Wd(1,"Timeout reached for loading script "+a))},h),e.ob=g);d.onload=d.onreadystatechange=function(){d.readyState&&"loaded"!=d.readyState&&"complete"!=d.readyState||(Vd(d,b.Be||!1,g),f.callback(null))};d.onerror=function(){Vd(d,!0,g);Id(f,new Wd(0,"Error while loading script "+a))};e=b.attributes||
{};$a(e,{type:"text/javascript",charset:"UTF-8",src:a});Yc(d,e);Xd(c).appendChild(d);return f},Xd=function(a){var b=a.getElementsByTagName("HEAD");return b&&0!=b.length?b[0]:a.documentElement},Ud=function(){if(this&&this.hd){var a=this.hd;a&&"SCRIPT"==a.tagName&&Vd(a,!0,this.ob)}},Vd=function(a,b,c){null!=c&&l.clearTimeout(c);a.onload=ba;a.onerror=ba;a.onreadystatechange=ba;b&&window.setTimeout(function(){a&&a.parentNode&&a.parentNode.removeChild(a)},0)},Wd=function(a,b){var c="Jsloader error (code #"+
a+")";b&&(c+=": "+b);t.call(this,c);this.code=a};r(Wd,t);var J=function(){Lb.call(this);this.O=new Sb(this);this.yd=this;this.lc=null};r(J,Lb);J.prototype[Ob]=!0;J.prototype.addEventListener=function(a,b,c,d){Yb(this,a,b,c,d)};J.prototype.removeEventListener=function(a,b,c,d){hc(this,a,b,c,d)};
J.prototype.dispatchEvent=function(a){Zd(this);var b,c=this.lc;if(c){b=[];for(var d=1;c;c=c.lc)b.push(c),v(1E3>++d,"infinite loop")}c=this.yd;d=a.type||a;if(n(a))a=new Mb(a,c);else if(a instanceof Mb)a.target=a.target||c;else{var e=a;a=new Mb(d,c);$a(a,e)}var e=!0,f;if(b)for(var g=b.length-1;!a.Na&&0<=g;g--)f=a.currentTarget=b[g],e=$d(f,d,!0,a)&&e;a.Na||(f=a.currentTarget=c,e=$d(f,d,!0,a)&&e,a.Na||(e=$d(f,d,!1,a)&&e));if(b)for(g=0;!a.Na&&g<b.length;g++)f=a.currentTarget=b[g],e=$d(f,d,!1,a)&&e;return e};
J.prototype.Ga=function(){J.yc.Ga.call(this);if(this.O){var a=this.O,b=0,c;for(c in a.v){for(var d=a.v[c],e=0;e<d.length;e++)++b,Rb(d[e]);delete a.v[c];a.pb--}}this.lc=null};
var $b=function(a,b,c,d,e){Zd(a);a.O.add(String(b),c,!1,d,e)},gc=function(a,b,c,d,e){a.O.add(String(b),c,!0,d,e)},$d=function(a,b,c,d){b=a.O.v[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.Pa&&g.rb==c){var h=g.listener,m=g.zb||g.src;g.qb&&Ub(a.O,g);e=!1!==h.call(m,d)&&e}}return e&&0!=d.gd};J.prototype.ec=function(a,b,c,d){return this.O.ec(String(a),b,c,d)};var Zd=function(a){v(a.O,"Event target is not initialized. Did you call the superclass (goog.events.EventTarget) constructor?")};var ae="StopIteration"in l?l.StopIteration:{message:"StopIteration",stack:""},be=function(){};be.prototype.next=function(){throw ae;};be.prototype.Va=function(){return this};
var ce=function(a){if(a instanceof be)return a;if("function"==typeof a.Va)return a.Va(!1);if(fa(a)){var b=0,c=new be;c.next=function(){for(;;){if(b>=a.length)throw ae;if(b in a)return a[b++];b++}};return c}throw Error("Not implemented");},de=function(a,b){if(fa(a))try{w(a,b,void 0)}catch(c){if(c!==ae)throw c;}else{a=ce(a);try{for(;;)b.call(void 0,a.next(),void 0,a)}catch(c){if(c!==ae)throw c;}}};var ee=function(a,b){this.P={};this.m=[];this.ea=this.i=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else a&&this.addAll(a)};k=ee.prototype;k.wb=function(){return this.i};k.J=function(){fe(this);for(var a=[],b=0;b<this.m.length;b++)a.push(this.P[this.m[b]]);return a};k.Y=function(){fe(this);return this.m.concat()};k.Ya=function(a){return ge(this.P,a)};
k.tb=function(a,b){if(this===a)return!0;if(this.i!=a.wb())return!1;var c=b||he;fe(this);for(var d,e=0;d=this.m[e];e++)if(!c(this.get(d),a.get(d)))return!1;return!0};var he=function(a,b){return a===b};ee.prototype.remove=function(a){return ge(this.P,a)?(delete this.P[a],this.i--,this.ea++,this.m.length>2*this.i&&fe(this),!0):!1};
var fe=function(a){if(a.i!=a.m.length){for(var b=0,c=0;b<a.m.length;){var d=a.m[b];ge(a.P,d)&&(a.m[c++]=d);b++}a.m.length=c}if(a.i!=a.m.length){for(var e={},c=b=0;b<a.m.length;)d=a.m[b],ge(e,d)||(a.m[c++]=d,e[d]=1),b++;a.m.length=c}};k=ee.prototype;k.get=function(a,b){return ge(this.P,a)?this.P[a]:b};k.set=function(a,b){ge(this.P,a)||(this.i++,this.m.push(a),this.ea++);this.P[a]=b};
k.addAll=function(a){var b;a instanceof ee?(b=a.Y(),a=a.J()):(b=Sa(a),a=Ra(a));for(var c=0;c<b.length;c++)this.set(b[c],a[c])};k.forEach=function(a,b){for(var c=this.Y(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};k.clone=function(){return new ee(this)};k.Va=function(a){fe(this);var b=0,c=this.ea,d=this,e=new be;e.next=function(){if(c!=d.ea)throw Error("The map has changed since the iterator was created");if(b>=d.m.length)throw ae;var e=d.m[b++];return a?e:d.P[e]};return e};
var ge=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var ie=function(a){if(a.J&&"function"==typeof a.J)return a.J();if(n(a))return a.split("");if(fa(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Ra(a)},je=function(a){if(a.Y&&"function"==typeof a.Y)return a.Y();if(!a.J||"function"!=typeof a.J){if(fa(a)||n(a)){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}return Sa(a)}},ke=function(a,b){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,void 0);else if(fa(a)||n(a))w(a,b,void 0);else for(var c=je(a),d=ie(a),e=d.length,
f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)};var le=function(a,b,c,d,e){this.reset(a,b,c,d,e)};le.prototype.Jc=null;var me=0;le.prototype.reset=function(a,b,c,d,e){"number"==typeof e||me++;d||la();this.gb=a;this.de=b;delete this.Jc};le.prototype.kd=function(a){this.gb=a};var ne=function(a){this.ee=a;this.Pc=this.Zb=this.gb=this.l=null},oe=function(a,b){this.name=a;this.value=b};oe.prototype.toString=function(){return this.name};var pe=new oe("SEVERE",1E3),qe=new oe("CONFIG",700),re=new oe("FINE",500);ne.prototype.getParent=function(){return this.l};ne.prototype.kd=function(a){this.gb=a};var se=function(a){if(a.gb)return a.gb;if(a.l)return se(a.l);ya("Root logger has no level set.");return null};
ne.prototype.log=function(a,b,c){if(a.value>=se(this).value)for(p(b)&&(b=b()),a=new le(a,String(b),this.ee),c&&(a.Jc=c),c="log:"+a.de,l.console&&(l.console.timeStamp?l.console.timeStamp(c):l.console.markTimeline&&l.console.markTimeline(c)),l.msWriteProfilerMark&&l.msWriteProfilerMark(c),c=this;c;){b=c;var d=a;if(b.Pc)for(var e=0,f;f=b.Pc[e];e++)f(d);c=c.getParent()}};
var te={},ue=null,ve=function(a){ue||(ue=new ne(""),te[""]=ue,ue.kd(qe));var b;if(!(b=te[a])){b=new ne(a);var c=a.lastIndexOf("."),d=a.substr(c+1),c=ve(a.substr(0,c));c.Zb||(c.Zb={});c.Zb[d]=b;b.l=c;te[a]=b}return b};var K=function(a,b){a&&a.log(re,b,void 0)};var we=function(a,b,c){if(p(a))c&&(a=q(a,c));else if(a&&"function"==typeof a.handleEvent)a=q(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:l.setTimeout(a,b||0)},xe=function(a){var b=null;return(new H(function(c,d){b=we(function(){c(void 0)},a);-1==b&&d(Error("Failed to schedule timer."))})).I(function(a){l.clearTimeout(b);throw a;})};var ye=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/,ze=function(a,b){if(a)for(var c=a.split("&"),d=0;d<c.length;d++){var e=c[d].indexOf("="),f,g=null;0<=e?(f=c[d].substring(0,e),g=c[d].substring(e+1)):f=c[d];b(f,g?decodeURIComponent(g.replace(/\+/g," ")):"")}};var L=function(a){J.call(this);this.headers=new ee;this.Vb=a||null;this.ga=!1;this.Ub=this.a=null;this.fb=this.Wc=this.Cb="";this.ua=this.jc=this.Bb=this.bc=!1;this.Sa=0;this.Qb=null;this.fd="";this.Sb=this.ke=this.ye=!1};r(L,J);var Ae=L.prototype,Be=ve("goog.net.XhrIo");Ae.L=Be;var Ce=/^https?$/i,De=["POST","PUT"];
L.prototype.send=function(a,b,c,d){if(this.a)throw Error("[goog.net.XhrIo] Object is active with another request="+this.Cb+"; newUri="+a);b=b?b.toUpperCase():"GET";this.Cb=a;this.fb="";this.Wc=b;this.bc=!1;this.ga=!0;this.a=this.Vb?this.Vb.$b():wc.$b();this.Ub=this.Vb?vc(this.Vb):vc(wc);this.a.onreadystatechange=q(this.ad,this);this.ke&&"onprogress"in this.a&&(this.a.onprogress=q(function(a){this.$c(a,!0)},this),this.a.upload&&(this.a.upload.onprogress=q(this.$c,this)));try{K(this.L,Ee(this,"Opening Xhr")),
this.jc=!0,this.a.open(b,String(a),!0),this.jc=!1}catch(f){K(this.L,Ee(this,"Error opening Xhr: "+f.message));this.D(5,f);return}a=c||"";var e=this.headers.clone();d&&ke(d,function(a,b){e.set(b,a)});d=Ha(e.Y());c=l.FormData&&a instanceof l.FormData;!Ia(De,b)||d||c||e.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.fd&&(this.a.responseType=this.fd);Ta(this.a)&&(this.a.withCredentials=this.ye);try{Fe(this),0<this.Sa&&
(this.Sb=Ge(this.a),K(this.L,Ee(this,"Will abort after "+this.Sa+"ms if incomplete, xhr2 "+this.Sb)),this.Sb?(this.a.timeout=this.Sa,this.a.ontimeout=q(this.ob,this)):this.Qb=we(this.ob,this.Sa,this)),K(this.L,Ee(this,"Sending request")),this.Bb=!0,this.a.send(a),this.Bb=!1}catch(f){K(this.L,Ee(this,"Send error: "+f.message)),this.D(5,f)}};var Ge=function(a){return y&&z(9)&&ga(a.timeout)&&void 0!==a.ontimeout},Ga=function(a){return"content-type"==a.toLowerCase()};
L.prototype.ob=function(){"undefined"!=typeof aa&&this.a&&(this.fb="Timed out after "+this.Sa+"ms, aborting",K(this.L,Ee(this,this.fb)),this.dispatchEvent("timeout"),this.abort(8))};L.prototype.D=function(a,b){this.ga=!1;this.a&&(this.ua=!0,this.a.abort(),this.ua=!1);this.fb=b;He(this);Ie(this)};var He=function(a){a.bc||(a.bc=!0,a.dispatchEvent("complete"),a.dispatchEvent("error"))};
L.prototype.abort=function(){this.a&&this.ga&&(K(this.L,Ee(this,"Aborting")),this.ga=!1,this.ua=!0,this.a.abort(),this.ua=!1,this.dispatchEvent("complete"),this.dispatchEvent("abort"),Ie(this))};L.prototype.Ga=function(){this.a&&(this.ga&&(this.ga=!1,this.ua=!0,this.a.abort(),this.ua=!1),Ie(this,!0));L.yc.Ga.call(this)};L.prototype.ad=function(){this.isDisposed()||(this.jc||this.Bb||this.ua?Je(this):this.ie())};L.prototype.ie=function(){Je(this)};
var Je=function(a){if(a.ga&&"undefined"!=typeof aa)if(a.Ub[1]&&4==Ke(a)&&2==Le(a))K(a.L,Ee(a,"Local request error detected and ignored"));else if(a.Bb&&4==Ke(a))we(a.ad,0,a);else if(a.dispatchEvent("readystatechange"),4==Ke(a)){K(a.L,Ee(a,"Request complete"));a.ga=!1;try{var b=Le(a),c;a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.Cb).match(ye)[1]||null;if(!f&&l.self&&l.self.location)var g=l.self.location.protocol,
f=g.substr(0,g.length-1);e=!Ce.test(f?f.toLowerCase():"")}d=e}if(d)a.dispatchEvent("complete"),a.dispatchEvent("success");else{var h;try{h=2<Ke(a)?a.a.statusText:""}catch(m){K(a.L,"Can not get status: "+m.message),h=""}a.fb=h+" ["+Le(a)+"]";He(a)}}finally{Ie(a)}}};L.prototype.$c=function(a,b){v("progress"===a.type,"goog.net.EventType.PROGRESS is of the same type as raw XHR progress.");this.dispatchEvent(Me(a,"progress"));this.dispatchEvent(Me(a,b?"downloadprogress":"uploadprogress"))};
var Me=function(a,b){return{type:b,lengthComputable:a.lengthComputable,loaded:a.loaded,total:a.total}},Ie=function(a,b){if(a.a){Fe(a);var c=a.a,d=a.Ub[0]?ba:null;a.a=null;a.Ub=null;b||a.dispatchEvent("ready");try{c.onreadystatechange=d}catch(e){(c=a.L)&&c.log(pe,"Problem encountered resetting onreadystatechange: "+e.message,void 0)}}},Fe=function(a){a.a&&a.Sb&&(a.a.ontimeout=null);ga(a.Qb)&&(l.clearTimeout(a.Qb),a.Qb=null)},Ke=function(a){return a.a?a.a.readyState:0},Le=function(a){try{return 2<Ke(a)?
a.a.status:-1}catch(b){return-1}},Ee=function(a,b){return b+" ["+a.Wc+" "+a.Cb+" "+Le(a)+"]"};var Ne=function(a,b){this.ia=this.Ca=this.na="";this.Ma=null;this.ta=this.ka="";this.F=this.$d=!1;var c;if(a instanceof Ne)this.F=void 0!==b?b:a.F,Oe(this,a.na),c=a.Ca,M(this),this.Ca=c,Pe(this,a.ia),Qe(this,a.Ma),Re(this,a.ka),Se(this,a.S.clone()),c=a.ta,M(this),this.ta=c;else if(a&&(c=String(a).match(ye))){this.F=!!b;Oe(this,c[1]||"",!0);var d=c[2]||"";M(this);this.Ca=Te(d);Pe(this,c[3]||"",!0);Qe(this,c[4]);Re(this,c[5]||"",!0);Se(this,c[6]||"",!0);c=c[7]||"";M(this);this.ta=Te(c)}else this.F=
!!b,this.S=new N(null,0,this.F)};Ne.prototype.toString=function(){var a=[],b=this.na;b&&a.push(Ue(b,Ve,!0),":");var c=this.ia;if(c||"file"==b)a.push("//"),(b=this.Ca)&&a.push(Ue(b,Ve,!0),"@"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),c=this.Ma,null!=c&&a.push(":",String(c));if(c=this.ka)this.ia&&"/"!=c.charAt(0)&&a.push("/"),a.push(Ue(c,"/"==c.charAt(0)?We:Xe,!0));(c=this.S.toString())&&a.push("?",c);(c=this.ta)&&a.push("#",Ue(c,Ye));return a.join("")};
Ne.prototype.resolve=function(a){var b=this.clone(),c=!!a.na;c?Oe(b,a.na):c=!!a.Ca;if(c){var d=a.Ca;M(b);b.Ca=d}else c=!!a.ia;c?Pe(b,a.ia):c=null!=a.Ma;d=a.ka;if(c)Qe(b,a.Ma);else if(c=!!a.ka){if("/"!=d.charAt(0))if(this.ia&&!this.ka)d="/"+d;else{var e=b.ka.lastIndexOf("/");-1!=e&&(d=b.ka.substr(0,e+1)+d)}e=d;if(".."==e||"."==e)d="";else if(u(e,"./")||u(e,"/.")){for(var d=0==e.lastIndexOf("/",0),e=e.split("/"),f=[],g=0;g<e.length;){var h=e[g++];"."==h?d&&g==e.length&&f.push(""):".."==h?((1<f.length||
1==f.length&&""!=f[0])&&f.pop(),d&&g==e.length&&f.push("")):(f.push(h),d=!0)}d=f.join("/")}else d=e}c?Re(b,d):c=""!==a.S.toString();c?Se(b,Te(a.S.toString())):c=!!a.ta;c&&(a=a.ta,M(b),b.ta=a);return b};Ne.prototype.clone=function(){return new Ne(this)};
var Oe=function(a,b,c){M(a);a.na=c?Te(b,!0):b;a.na&&(a.na=a.na.replace(/:$/,""))},Pe=function(a,b,c){M(a);a.ia=c?Te(b,!0):b},Qe=function(a,b){M(a);if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.Ma=b}else a.Ma=null},Re=function(a,b,c){M(a);a.ka=c?Te(b,!0):b},Se=function(a,b,c){M(a);b instanceof N?(a.S=b,a.S.vc(a.F)):(c||(b=Ue(b,Ze)),a.S=new N(b,0,a.F))},O=function(a,b,c){M(a);a.S.set(b,c)},M=function(a){if(a.$d)throw Error("Tried to modify a read-only Uri");};
Ne.prototype.vc=function(a){this.F=a;this.S&&this.S.vc(a);return this};
var $e=function(a,b){var c=new Ne(null,void 0);Oe(c,"https");a&&Pe(c,a);b&&Re(c,b);return c},Te=function(a,b){return a?b?decodeURI(a.replace(/%25/g,"%2525")):decodeURIComponent(a):""},Ue=function(a,b,c){return n(a)?(a=encodeURI(a).replace(b,af),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null},af=function(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)},Ve=/[#\/\?@]/g,Xe=/[\#\?:]/g,We=/[\#\?]/g,Ze=/[\#\?@]/g,Ye=/#/g,N=function(a,b,c){this.i=this.j=null;this.C=a||null;
this.F=!!c},bf=function(a){a.j||(a.j=new ee,a.i=0,a.C&&ze(a.C,function(b,c){a.add(decodeURIComponent(b.replace(/\+/g," ")),c)}))},df=function(a){var b=je(a);if("undefined"==typeof b)throw Error("Keys are undefined");var c=new N(null,0,void 0);a=ie(a);for(var d=0;d<b.length;d++){var e=b[d],f=a[d];ea(f)?cf(c,e,f):c.add(e,f)}return c};k=N.prototype;k.wb=function(){bf(this);return this.i};
k.add=function(a,b){bf(this);this.C=null;a=this.s(a);var c=this.j.get(a);c||this.j.set(a,c=[]);c.push(b);this.i=za(this.i)+1;return this};k.remove=function(a){bf(this);a=this.s(a);return this.j.Ya(a)?(this.C=null,this.i=za(this.i)-this.j.get(a).length,this.j.remove(a)):!1};k.Ya=function(a){bf(this);a=this.s(a);return this.j.Ya(a)};k.Y=function(){bf(this);for(var a=this.j.J(),b=this.j.Y(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};
k.J=function(a){bf(this);var b=[];if(n(a))this.Ya(a)&&(b=Ma(b,this.j.get(this.s(a))));else{a=this.j.J();for(var c=0;c<a.length;c++)b=Ma(b,a[c])}return b};k.set=function(a,b){bf(this);this.C=null;a=this.s(a);this.Ya(a)&&(this.i=za(this.i)-this.j.get(a).length);this.j.set(a,[b]);this.i=za(this.i)+1;return this};k.get=function(a,b){var c=a?this.J(a):[];return 0<c.length?String(c[0]):b};var cf=function(a,b,c){a.remove(b);0<c.length&&(a.C=null,a.j.set(a.s(b),Oa(c)),a.i=za(a.i)+c.length)};
N.prototype.toString=function(){if(this.C)return this.C;if(!this.j)return"";for(var a=[],b=this.j.Y(),c=0;c<b.length;c++)for(var d=b[c],e=encodeURIComponent(String(d)),d=this.J(d),f=0;f<d.length;f++){var g=e;""!==d[f]&&(g+="="+encodeURIComponent(String(d[f])));a.push(g)}return this.C=a.join("&")};N.prototype.clone=function(){var a=new N;a.C=this.C;this.j&&(a.j=this.j.clone(),a.i=this.i);return a};N.prototype.s=function(a){a=String(a);this.F&&(a=a.toLowerCase());return a};
N.prototype.vc=function(a){a&&!this.F&&(bf(this),this.C=null,this.j.forEach(function(a,c){var d=c.toLowerCase();c!=d&&(this.remove(c),cf(this,d,a))},this));this.F=a};var ef=function(a,b){var c=[],d;for(d in a)d in b?typeof a[d]!=typeof b[d]?c.push(d):ea(a[d])?Va(a[d],b[d])||c.push(d):"object"==typeof a[d]&&null!=a[d]&&null!=b[d]?0<ef(a[d],b[d]).length&&c.push(d):a[d]!==b[d]&&c.push(d):c.push(d);for(d in b)d in a||c.push(d);return c},ff=function(a,b){var c=null,d=Math.floor(1E9*Math.random()).toString(),e=a||500,f=b||600,g=(window.screen.availHeight-f)/2,h=(window.screen.availWidth-e)/2,e={width:e,height:f,top:0<g?g:0,left:0<h?h:0,location:!0,resizable:!0,statusbar:!0,
toolbar:!1};d&&(e.target=d);navigator.userAgent&&-1!=navigator.userAgent.indexOf("Firefox/")&&(c=c||"http://localhost");var m,f=c||"about:blank";(d=e)||(d={});c=window;e=f instanceof A?f:Db("undefined"!=typeof f.href?f.href:String(f));f=d.target||f.target;g=[];for(m in d)switch(m){case "width":case "height":case "top":case "left":g.push(m+"="+d[m]);break;case "target":case "noreferrer":break;default:g.push(m+"="+(d[m]?1:0))}m=g.join(",");(x("iPhone")&&!x("iPod")&&!x("iPad")||x("iPad")||x("iPod"))&&
c.navigator&&c.navigator.standalone&&f&&"_self"!=f?(m=c.document.createElement("A"),e=e instanceof A?e:Db(e),m.href=Ab(e),m.setAttribute("target",f),d.noreferrer&&m.setAttribute("rel","noreferrer"),d=document.createEvent("MouseEvent"),d.initMouseEvent("click",!0,!0,c,1),m.dispatchEvent(d),m={}):d.noreferrer?(m=c.open("",f,m),d=Ab(e),m&&(fb&&u(d,";")&&(d="'"+d.replace(/'/g,"%27")+"'"),m.opener=null,c=new xb,c.Pb="b/12014412, meta tag with sanitized URL",ua.test(d)&&(-1!=d.indexOf("&")&&(d=d.replace(oa,
"&amp;")),-1!=d.indexOf("<")&&(d=d.replace(pa,"&lt;")),-1!=d.indexOf(">")&&(d=d.replace(qa,"&gt;")),-1!=d.indexOf('"')&&(d=d.replace(ra,"&quot;")),-1!=d.indexOf("'")&&(d=d.replace(sa,"&#39;")),-1!=d.indexOf("\x00")&&(d=d.replace(ta,"&#0;"))),d='<META HTTP-EQUIV="refresh" content="0; url='+d+'">',Aa(yb(c),"must provide justification"),v(!/^[\s\xa0]*$/.test(yb(c)),"must provide non-empty justification"),m.document.write(Gb((new Fb).Zd(d))),m.document.close())):m=c.open(Ab(e),f,m);if(m)try{m.focus()}catch(S){}return m},
gf=function(a){return new H(function(b){var c=function(){xe(2E3).then(function(){if(!a||a.closed)b();else return c()})};return c()})},hf=function(){var a=null;return(new H(function(b){"complete"==l.document.readyState?b():(a=function(){b()},fc(window,"load",a))})).I(function(b){hc(window,"load",a);throw b;})},jf=function(){var a=navigator.userAgent,b=a.toLowerCase();if(u(b,"opera/")||u(b,"opr/")||u(b,"opios/"))return"Opera";if(u(b,"msie")||u(b,"trident/"))return"IE";if(u(b,"edge/"))return"Edge";if(u(b,
"firefox/"))return"Firefox";if(u(b,"silk/"))return"Silk";if(u(b,"safari/")&&!u(b,"chrome/"))return"Safari";if(!u(b,"chrome/")&&!u(b,"crios/")||u(b,"edge/")){if((a=a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/))&&2==a.length)return a[1]}else return"Chrome";return"Other"},kf=function(a){return jf()+"/JsCore/"+a},lf=function(a){a=a.split(".");for(var b=l,c=0;c<a.length&&"object"==typeof b&&null!=b;c++)b=b[a[c]];c!=a.length&&(b=void 0);return b};var mf;try{var nf={};Object.defineProperty(nf,"abcd",{configurable:!0,enumerable:!0,value:1});Object.defineProperty(nf,"abcd",{configurable:!0,enumerable:!0,value:2});mf=2==nf.abcd}catch(a){mf=!1}
var P=function(a,b,c){mf?Object.defineProperty(a,b,{configurable:!0,enumerable:!0,value:c}):a[b]=c},of=function(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&P(a,c,b[c])},pf=function(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b},qf=function(a,b){if(!b||!b.length)return!0;if(!a)return!1;for(var c=0;c<b.length;c++){var d=a[b[c]];if(void 0===d||null===d||""===d)return!1}return!0};var rf={rd:{kb:985,jb:735,providerId:"facebook.com"},sd:{kb:1040,jb:620,providerId:"github.com"},td:{kb:485,jb:640,providerId:"google.com"},xd:{kb:485,jb:705,providerId:"twitter.com"}},sf=function(a){for(var b in rf)if(rf[b].providerId==a)return rf[b];return null};var Q=function(a,b){this.code="auth/"+a;this.message=b||tf[a]||""};r(Q,Error);Q.prototype.N=function(){return{name:this.code,code:this.code,message:this.message}};
var tf={"argument-error":"","app-not-authorized":"This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.","cors-unsupported":"This browser is not supported.","credential-already-in-use":"This credential is already associated with a different user account.","custom-token-mismatch":"The custom token corresponds to a different audience.","requires-recent-login":"This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
"email-already-in-use":"The email address is already in use by another account.","expired-action-code":"The action code has expired. ","cancelled-popup-request":"This operation has been cancelled due to another conflicting popup being opened.","internal-error":"An internal error has occurred.","invalid-user-token":"The user's credential is no longer valid. The user must sign in again.","invalid-auth-event":"An internal error has occurred.","invalid-custom-token":"The custom token format is incorrect. Please check the documentation.",
"invalid-email":"The email address is badly formatted.","invalid-api-key":"Your API key is invalid, please check you have copied it correctly.","invalid-credential":"The supplied auth credential is malformed or has expired.","invalid-oauth-provider":"EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.","unauthorized-domain":"This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
"invalid-action-code":"The action code is invalid. This can happen if the code is malformed, expired, or has already been used.","wrong-password":"The password is invalid or the user does not have a password.","missing-iframe-start":"An internal error has occurred.","auth-domain-config-required":"Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.","app-deleted":"This instance of FirebaseApp has been deleted.","account-exists-with-different-credential":"An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
"network-request-failed":"A network error (such as timeout, interrupted connection or unreachable host) has occurred.","no-auth-event":"An internal error has occurred.","no-such-provider":"User was not linked to an account with the given provider.","operation-not-allowed":"This operation is not allowed. You must enable this service in the console.","popup-blocked":"Unable to establish a connection with the popup. It may have been blocked by the browser.","popup-closed-by-user":"The popup has been closed by the user before finalizing the operation.",
"provider-already-linked":"User can only be linked to one identity for the given provider.",timeout:"The operation has timed out.","user-token-expired":"The user's credential is no longer valid. The user must sign in again.","too-many-requests":"We have blocked all requests from this device due to unusual activity. Try again later.","user-not-found":"There is no user record corresponding to this identifier. The user may have been deleted.","user-disabled":"The user account has been disabled by an administrator.",
"user-mismatch":"The supplied credentials do not correspond to the previously signed in user.","user-signed-out":"","weak-password":"The password must be 6 characters long or more.","web-storage-unsupported":"This browser is not supported."};var uf=function(a,b,c,d,e){this.pa=a;this.sa=b||null;this.Ua=c||null;this.uc=d||null;this.D=e||null;if(this.Ua||this.D){if(this.Ua&&this.D)throw new Q("invalid-auth-event");if(this.Ua&&!this.uc)throw new Q("invalid-auth-event");}else throw new Q("invalid-auth-event");};uf.prototype.fc=function(){return this.uc};uf.prototype.getError=function(){return this.D};uf.prototype.N=function(){return{type:this.pa,eventId:this.sa,urlResponse:this.Ua,sessionId:this.uc,error:this.D&&this.D.N()}};var vf=function(a){this.be=a.sub;la();this.sb=a.email||null};var wf=function(a,b,c,d){var e={};ha(c)?e=c:b&&n(c)&&n(d)?e={oauthToken:c,oauthTokenSecret:d}:!b&&n(c)&&(e={accessToken:c});if(b||!e.idToken&&!e.accessToken)if(b&&e.oauthToken&&e.oauthTokenSecret)P(this,"accessToken",e.oauthToken),P(this,"secret",e.oauthTokenSecret);else{if(b)throw new Q("argument-error","credential failed: expected 2 arguments (the OAuth access token and secret).");throw new Q("argument-error","credential failed: expected 1 argument (the OAuth access token).");}else e.idToken&&P(this,
"idToken",e.idToken),e.accessToken&&P(this,"accessToken",e.accessToken);P(this,"provider",a)};wf.prototype.xb=function(a){return xf(a,yf(this))};wf.prototype.Xc=function(a,b){var c=yf(this);c.idToken=b;return R(a,zf,c)};var yf=function(a){var b={};a.idToken&&(b.id_token=a.idToken);a.accessToken&&(b.access_token=a.accessToken);a.secret&&(b.oauth_token_secret=a.secret);b.providerId=a.provider;return{postBody:df(b).toString(),requestUri:window.location.href}};
wf.prototype.N=function(){var a={provider:this.provider};this.idToken&&(a.oauthIdToken=this.idToken);this.accessToken&&(a.oauthAccessToken=this.accessToken);this.secret&&(a.oauthTokenSecret=this.secret);return a};
var Af=function(a,b){var c=!!b,d=function(){of(this,{providerId:a,isOAuthProvider:!0});this.tc=[]};c||(d.prototype.addScope=function(a){Ia(this.tc,a)||this.tc.push(a)});d.prototype.Mc=function(){return Oa(this.tc)};d.credential=function(b,d){return new wf(a,c,b,d)};of(d,{PROVIDER_ID:a});return d},Bf=Af("facebook.com");Bf.prototype.addScope=Bf.prototype.addScope||void 0;var Cf=Af("github.com");Cf.prototype.addScope=Cf.prototype.addScope||void 0;var Df=Af("google.com");
Df.prototype.addScope=Df.prototype.addScope||void 0;Df.credential=function(a,b){if(!a&&!b)throw new Q("argument-error","credential failed: must provide the ID token and/or the access token.");return new wf("google.com",!1,ha(a)?a:{idToken:a||null,accessToken:b||null})};var Ef=Af("twitter.com",!0),Ff=function(a,b){this.sb=a;this.mc=b;P(this,"provider","password")};Ff.prototype.xb=function(a){return R(a,Gf,{email:this.sb,password:this.mc})};
Ff.prototype.Xc=function(a,b){return R(a,Hf,{idToken:b,email:this.sb,password:this.mc})};Ff.prototype.N=function(){return{email:this.sb,password:this.mc}};var If=function(){of(this,{providerId:"password",isOAuthProvider:!1})};of(If,{PROVIDER_ID:"password"});
var Jf={ze:If,rd:Bf,td:Df,sd:Cf,xd:Ef},Kf=function(a){var b=a&&a.providerId;if(!b)return null;var c=a&&a.oauthAccessToken,d=a&&a.oauthTokenSecret;a=a&&a.oauthIdToken;for(var e in Jf)if(Jf[e].PROVIDER_ID==b)try{return Jf[e].credential({accessToken:c,idToken:a,oauthToken:c,oauthTokenSecret:d})}catch(f){break}return null};var Lf=function(a,b,c){Q.call(this,"account-exists-with-different-credential",c);P(this,"email",a);P(this,"credential",b)};r(Lf,Q);Lf.prototype.N=function(){var a={code:this.code,message:this.message,email:this.email},b=this.credential&&this.credential.N();b&&($a(a,b),a.providerId=b.provider,delete a.provider);return a};var T=function(a,b,c){this.u=a;a=b||{};this.ne=a.secureTokenEndpoint||"https://securetoken.googleapis.com/v1/token";this.pe=a.secureTokenTimeout||1E4;this.oe=Ya(a.secureTokenHeaders||Mf);this.Jd=a.firebaseEndpoint||"https://www.googleapis.com/identitytoolkit/v3/relyingparty/";this.Kd=a.firebaseTimeout||1E4;this.Lc=Ya(a.firebaseHeaders||Nf);c&&(this.Lc["X-Client-Version"]=c);this.Bd=new zc},Of,Mf={"Content-Type":"application/x-www-form-urlencoded"},Nf={"Content-Type":"application/json"},Qf=function(a,
b,c,d,e,f,g){!y||!qb||9<qb?a=q(a.re,a):(Of||(Of=new H(function(a,b){Pf(a,b)})),a=q(a.qe,a));a(b,c,d,e,f,g)};
T.prototype.re=function(a,b,c,d,e,f){var g=new L(this.Bd),h;f&&(g.Sa=Math.max(0,f),h=setTimeout(function(){g.dispatchEvent("timeout")},f));$b(g,"complete",function(){h&&clearTimeout(h);var a=null;try{var c;c=this.a?nc(this.a.responseText):void 0;a=c||null}catch(d){a=null}b&&b(a)});gc(g,"ready",function(){h&&clearTimeout(h);this.ra||(this.ra=!0,this.Ga())});gc(g,"timeout",function(){h&&clearTimeout(h);this.ra||(this.ra=!0,this.Ga());b&&b(null)});g.send(a,c,d,e)};
var Rf="__fcb"+Math.floor(1E6*Math.random()).toString(),Pf=function(a,b){((window.gapi||{}).client||{}).request?a():(l[Rf]=function(){((window.gapi||{}).client||{}).request?a():b(Error("CORS_UNSUPPORTED"))},Qd(Yd("//apis.google.com/js/client.js?onload="+Rf),function(){b(Error("CORS_UNSUPPORTED"))}))};
T.prototype.qe=function(a,b,c,d,e){var f=this;Of.then(function(){window.gapi.client.setApiKey(f.u);var g=window.gapi.auth.getToken();window.gapi.auth.setToken(null);window.gapi.client.request({path:a,method:c,body:d,headers:e,authType:"none",callback:function(a){window.gapi.auth.setToken(g);b&&b(a)}})}).I(function(a){b&&b({error:{message:a&&a.message||"CORS_UNSUPPORTED"}})})};
var Tf=function(a,b){return new H(function(c,d){"refresh_token"==b.grant_type&&b.refresh_token||"authorization_code"==b.grant_type&&b.code?Qf(a,a.ne+"?key="+encodeURIComponent(a.u),function(a){a?a.error?d(Sf(a)):a.access_token&&a.refresh_token?c(a):d(new Q("internal-error")):d(new Q("network-request-failed"))},"POST",df(b).toString(),a.oe,a.pe):d(new Q("internal-error"))})},Uf=function(a){var b={},c;for(c in a)null!==a[c]&&void 0!==a[c]&&(b[c]=a[c]);return qc(b)},Vf=function(a,b,c,d,e){var f=a.Jd+
b+"?key="+encodeURIComponent(a.u);e&&(f+="&cb="+la().toString());return new H(function(b,e){Qf(a,f,function(a){a?a.error?e(Sf(a)):b(a):e(new Q("network-request-failed"))},c,Uf(d),a.Lc,a.Kd)})},Wf=function(a){if(!mc.test(a.email))throw new Q("invalid-email");},Xf=function(a){"email"in a&&Wf(a)},Zf=function(a,b){return R(a,Yf,{identifier:b,continueUri:window.location.href}).then(function(a){return a.allProviders||[]})},ag=function(a){return R(a,$f,{}).then(function(a){return a.authorizedDomains||[]})},
bg=function(a){if(!a.idToken)throw new Q("internal-error");};T.prototype.signInAnonymously=function(){return R(this,cg,{})};T.prototype.updateEmail=function(a,b){return R(this,dg,{idToken:a,email:b})};T.prototype.updatePassword=function(a,b){return R(this,Hf,{idToken:a,password:b})};var eg={displayName:"DISPLAY_NAME",photoUrl:"PHOTO_URL"};
T.prototype.updateProfile=function(a,b){var c={idToken:a},d=[];Qa(eg,function(a,f){var g=b[f];null===g?d.push(a):f in b&&(c[f]=g)});d.length&&(c.deleteAttribute=d);return R(this,dg,c)};T.prototype.sendPasswordResetEmail=function(a){return R(this,fg,{requestType:"PASSWORD_RESET",email:a})};T.prototype.sendEmailVerification=function(a){return R(this,gg,{requestType:"VERIFY_EMAIL",idToken:a})};
var ig=function(a,b,c){return R(a,hg,{idToken:b,deleteProvider:c})},jg=function(a){if(!a.requestUri||!a.sessionId&&!a.postBody)throw new Q("internal-error");},kg=function(a){if(a.needConfirmation)throw(a&&a.email?new Lf(a.email,Kf(a),a.message):null)||new Q("account-exists-with-different-credential");if(!a.idToken)throw new Q("internal-error");},xf=function(a,b){return R(a,lg,b)},mg=function(a){if(!a.oobCode)throw new Q("invalid-action-code");};
T.prototype.confirmPasswordReset=function(a,b){return R(this,ng,{oobCode:a,newPassword:b})};T.prototype.checkActionCode=function(a){return R(this,og,{oobCode:a})};T.prototype.applyActionCode=function(a){return R(this,pg,{oobCode:a})};
var pg={endpoint:"setAccountInfo",w:mg,Ra:"email"},og={endpoint:"resetPassword",w:mg,la:function(a){if(!mc.test(a.email))throw new Q("internal-error");}},qg={endpoint:"signupNewUser",w:function(a){Wf(a);if(!a.password)throw new Q("weak-password");},la:bg,ma:!0},Yf={endpoint:"createAuthUri"},rg={endpoint:"deleteAccount",Qa:["idToken"]},hg={endpoint:"setAccountInfo",Qa:["idToken","deleteProvider"],w:function(a){if(!ea(a.deleteProvider))throw new Q("internal-error");}},sg={endpoint:"getAccountInfo"},
gg={endpoint:"getOobConfirmationCode",Qa:["idToken","requestType"],w:function(a){if("VERIFY_EMAIL"!=a.requestType)throw new Q("internal-error");},Ra:"email"},fg={endpoint:"getOobConfirmationCode",Qa:["requestType"],w:function(a){if("PASSWORD_RESET"!=a.requestType)throw new Q("internal-error");Wf(a)},Ra:"email"},$f={Ad:!0,endpoint:"getProjectConfig",Sd:"GET"},ng={endpoint:"resetPassword",w:mg,Ra:"email"},dg={endpoint:"setAccountInfo",Qa:["idToken"],w:Xf,ma:!0},Hf={endpoint:"setAccountInfo",Qa:["idToken"],
w:function(a){Xf(a);if(!a.password)throw new Q("weak-password");},la:bg,ma:!0},cg={endpoint:"signupNewUser",la:bg,ma:!0},lg={endpoint:"verifyAssertion",w:jg,la:kg,ma:!0},zf={endpoint:"verifyAssertion",w:function(a){jg(a);if(!a.idToken)throw new Q("internal-error");},la:kg,ma:!0},tg={endpoint:"verifyCustomToken",w:function(a){if(!a.token)throw new Q("invalid-custom-token");},la:bg,ma:!0},Gf={endpoint:"verifyPassword",w:function(a){Wf(a);if(!a.password)throw new Q("wrong-password");},la:bg,ma:!0},R=
function(a,b,c){if(!qf(c,b.Qa))return sd(new Q("internal-error"));var d=b.Sd||"POST",e;return I(c).then(b.w).then(function(){b.ma&&(c.returnSecureToken=!0);return Vf(a,b.endpoint,d,c,b.Ad||!1)}).then(function(a){return e=a}).then(b.la).then(function(){if(!b.Ra)return e;if(!(b.Ra in e))throw new Q("internal-error");return e[b.Ra]})},Sf=function(a){var b;b=(a.error&&a.error.errors&&a.error.errors[0]||{}).reason||"";var c={keyInvalid:"invalid-api-key",ipRefererBlocked:"app-not-authorized"};if(b=c[b]?
new Q(c[b]):null)return b;a=a.error&&a.error.message||"";b={INVALID_CUSTOM_TOKEN:"invalid-custom-token",CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_EMAIL:"invalid-email",INVALID_PASSWORD:"wrong-password",USER_DISABLED:"user-disabled",MISSING_PASSWORD:"internal-error",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",
FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",EMAIL_NOT_FOUND:"user-not-found",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",CORS_UNSUPPORTED:"cors-unsupported"};if(b[a])return new Q(b[a]);b={TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",WEAK_PASSWORD:"weak-password",
OPERATION_NOT_ALLOWED:"operation-not-allowed"};for(var d in b)if(0===a.indexOf(d))return new Q(b[d]);return new Q("internal-error")};var ug=function(a){this.G=a};ug.prototype.value=function(){return this.G};ug.prototype.ld=function(a){this.G.style=a;return this};var vg=function(a){this.G=a||{}};vg.prototype.value=function(){return this.G};vg.prototype.ld=function(a){this.G.style=a;return this};var xg=function(a){this.xe=a;this.hc=null;this.he=wg(this)},yg,zg=function(a){var b=new vg;b.G.where=document.body;b.G.url=a.xe;b.G.messageHandlersFilter=lf("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER");b.G.attributes=b.G.attributes||{};(new ug(b.G.attributes)).ld({position:"absolute",top:"-100px",width:"1px",height:"1px"});b.G.dontclear=!0;return b},wg=function(a){return Ag().then(function(){return new H(function(b){lf("gapi.iframes.getContext")().open(zg(a).value(),function(c){a.hc=c;a.hc.restyle({setHideOnLeave:!1});
b()})})})},Bg=function(a,b){a.he.then(function(){a.hc.register("authEvent",b,lf("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})},Cg="__iframefcb"+Math.floor(1E6*Math.random()).toString(),Ag=function(){return yg?yg:yg=new H(function(a,b){var c=function(){lf("gapi.load")("gapi.iframes",function(){a()})};lf("gapi.iframes.Iframe")?a():lf("gapi.load")?c():(l[Cg]=function(){lf("gapi.load")?c():b()},Qd(Yd("//apis.google.com/js/api.js?onload="+Cg),function(){b()}))})};var Eg=function(a,b,c,d){this.ha=a;this.u=b;this.W=c;d=this.qa=d||null;a=$e(a,"/__/auth/iframe");O(a,"apiKey",b);O(a,"appName",c);d&&O(a,"v",d);this.Ud=a.toString();this.Vd=new xg(this.Ud);this.Wb=[];Dg(this)},Fg=function(a,b,c,d,e,f,g,h,m){a=$e(a,"/__/auth/handler");O(a,"apiKey",b);O(a,"appName",c);O(a,"authType",d);O(a,"providerId",e);f&&f.length&&O(a,"scopes",f.join(","));g&&O(a,"redirectUrl",g);h&&O(a,"eventId",h);m&&O(a,"v",m);return a.toString()},Dg=function(a){Bg(a.Vd,function(b){var c={};
if(b&&b.authEvent){var d=!1;b=b.authEvent||{};if(b.type){if(c=b.error)var e=(c=b.error)&&(c.name||c.code),c=e?new Q(e.substring(5),c.message):null;b=new uf(b.type,b.eventId,b.urlResponse,b.sessionId,c)}else b=null;for(c=0;c<a.Wb.length;c++)d=a.Wb[c](b)||d;c={};c.status=d?"ACK":"ERROR";return I(c)}c.status="ERROR";return I(c)})};Eg.prototype.zc=function(a){this.Wb.push(a)};var Gg=function(a){this.Eb=a};Gg.prototype.set=function(a,b){void 0!==b?this.Eb.set(a,qc(b)):this.Eb.remove(a)};Gg.prototype.get=function(a){var b;try{b=this.Eb.get(a)}catch(c){return}if(null!==b)try{return nc(b)}catch(c){throw"Storage: Invalid value was encountered";}};Gg.prototype.remove=function(a){this.Eb.remove(a)};var Hg=function(){};var Ig=function(){};r(Ig,Hg);Ig.prototype.wb=function(){var a=0;de(this.Va(!0),function(b){Aa(b);a++});return a};var Jg=function(a){this.H=a};r(Jg,Ig);var Kg=function(a){if(!a.H)return!1;try{return a.H.setItem("__sak","1"),a.H.removeItem("__sak"),!0}catch(b){return!1}};k=Jg.prototype;k.set=function(a,b){try{this.H.setItem(a,b)}catch(c){if(0==this.H.length)throw"Storage mechanism: Storage disabled";throw"Storage mechanism: Quota exceeded";}};k.get=function(a){a=this.H.getItem(a);if(!n(a)&&null!==a)throw"Storage mechanism: Invalid value was encountered";return a};k.remove=function(a){this.H.removeItem(a)};
k.wb=function(){return this.H.length};k.Va=function(a){var b=0,c=this.H,d=new be;d.next=function(){if(b>=c.length)throw ae;var d=Aa(c.key(b++));if(a)return d;d=c.getItem(d);if(!n(d))throw"Storage mechanism: Invalid value was encountered";return d};return d};k.key=function(a){return this.H.key(a)};var Lg=function(){var a=null;try{a=window.localStorage||null}catch(b){}this.H=a};r(Lg,Jg);var Mg=function(){var a=null;try{a=window.sessionStorage||null}catch(b){}this.H=a};r(Mg,Jg);var Ng="First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" "),U=function(a,b){return{name:a||"",U:"a valid string",optional:!!b,V:n}},Og=function(a){return{name:a||"",U:"a valid object",optional:!1,V:ha}},Pg=function(a,b){return{name:a||"",U:"a function",optional:!!b,V:p}},Qg=function(){return{name:"",U:"null",optional:!1,V:da}},Rg=function(){return{name:"credential",U:"a valid credential",optional:!1,V:function(a){return!(!a||!a.xb)}}},Sg=function(){return{name:"authProvider",U:"a valid Auth provider",
optional:!1,V:function(a){return!!(a&&a.providerId&&a.hasOwnProperty&&a.hasOwnProperty("isOAuthProvider"))}}},Tg=function(a,b,c,d){return{name:c||"",U:a.U+" or "+b.U,optional:!!d,V:function(c){return a.V(c)||b.V(c)}}};var Vg=function(a,b){for(var c in b){var d=b[c].name;a[d]=Ug(d,a[c],b[c].b)}},V=function(a,b,c,d){a[b]=Ug(b,c,d)},Ug=function(a,b,c){if(!c)return b;var d=Wg(a);a=function(){var a=Array.prototype.slice.call(arguments),e;a:{e=Array.prototype.slice.call(a);var h;h=0;for(var m=!1,S=0;S<c.length;S++)if(c[S].optional)m=!0;else{if(m)throw new Q("internal-error","Argument validator encountered a required argument after an optional argument.");h++}m=c.length;if(e.length<h||m<e.length)e="Expected "+(h==m?1==
h?"1 argument":h+" arguments":h+"-"+m+" arguments")+" but got "+e.length+".";else{for(h=0;h<e.length;h++)if(m=c[h].optional&&void 0===e[h],!c[h].V(e[h])&&!m){e=c[h];if(0>h||h>=Ng.length)throw new Q("internal-error","Argument validator received an unsupported number of arguments.");e=Ng[h]+" argument "+(e.name?'"'+e.name+'" ':"")+"must be "+e.U+".";break a}e=null}}if(e)throw new Q("argument-error",d+" failed: "+e);return b.apply(this,a)};for(var e in b)a[e]=b[e];for(e in b.prototype)a.prototype[e]=
b.prototype[e];return a},Wg=function(a){a=a.split(".");return a[a.length-1]};var $g=function(a,b,c){var d=(this.qa=firebase.SDK_VERSION||null)?kf(this.qa):null;this.c=new T(b,null,d);this.bd=Xg(this.c);this.ha=a;this.u=b;this.W=c;this.nb=[];this.Tc=!1;this.zd=q(this.Md,this);this.lb=new Yg;this.dd=new Zg;this.Ta={};this.Ta.unknown=this.lb;this.Ta.signInViaRedirect=this.lb;this.Ta.linkViaRedirect=this.lb;this.Ta.signInViaPopup=this.dd;this.Ta.linkViaPopup=this.dd},Xg=function(a){var b=window.location.href;return ag(a).then(function(a){a:{for(var d=(b instanceof Ne?b.clone():
new Ne(b,void 0)).ia,e=0;e<a.length;e++){var f;var g=a[e];f=d;var h=Rc(g);h?f=(f=Rc(f))?h.tb(f):!1:(h=g.split(".").join("\\."),f=(new RegExp("^(.+."+h+"|"+h+")$","i")).test(f));if(f){a=!0;break a}}a=!1}if(!a)throw new Q("unauthorized-domain");})},ah=function(a){a.Tc=!0;hf().then(function(){a.Td=new Eg(a.ha,a.u,a.W,a.qa);a.Td.zc(a.zd)})};$g.prototype.subscribe=function(a){Ia(this.nb,a)||this.nb.push(a);this.Tc||ah(this)};$g.prototype.unsubscribe=function(a){La(this.nb,function(b){return b==a})};
$g.prototype.Md=function(a){if(!a)throw new Q("invalid-auth-event");for(var b=!1,c=0;c<this.nb.length;c++){var d=this.nb[c];if(d.Ec(a.pa,a.sa)){(b=this.Ta[a.pa])&&b.ed(a,d);b=!0;break}}a=this.lb;a.qc||(a.qc=!0,bh(a,!1,null,null));return b};$g.prototype.getRedirectResult=function(){return this.lb.getRedirectResult()};
var dh=function(a,b,c,d,e){return b?a.bd.then(function(){ch(d);var f=Fg(a.ha,a.u,a.W,c,d.providerId,d.Mc(),null,e,a.qa);Hb((b||window).location,f);return b}):sd(new Q("popup-blocked"))},eh=function(a,b,c,d){return a.bd.then(function(){ch(c);var e=Fg(a.ha,a.u,a.W,b,c.providerId,c.Mc(),window.location.href,d,a.qa);Hb(window.location,e)})},fh=function(a,b,c,d){var e=new Q("popup-closed-by-user");return gf(c).then(function(){return xe(3E4).then(function(){a.Ba(b,null,e,d)})})},ch=function(a){if(!a.isOAuthProvider)throw new Q("invalid-oauth-provider");
},gh={},hh=function(a,b,c){var d=b+":"+c;gh[d]||(gh[d]=new $g(a,b,c));return gh[d]},Yg=function(){this.rc=this.Kb=this.Oa=this.T=null;this.qc=!1};Yg.prototype.ed=function(a,b){if(!a)return sd(new Q("invalid-auth-event"));this.qc=!0;var c=a.pa,d=a.sa;"unknown"==c?(this.T||bh(this,!1,null,null),c=I()):c=a.D?this.oc(a,b):b.Za(c,d)?this.pc(a,b):sd(new Q("invalid-auth-event"));return c};Yg.prototype.oc=function(a){this.T||bh(this,!0,null,a.getError());return I()};
Yg.prototype.pc=function(a,b){var c=this,d=a.pa,e=b.Za(d,a.sa),f=a.Ua,g=a.fc(),h="signInViaRedirect"==d||"linkViaRedirect"==d;return e(f,g).then(function(a){c.T||bh(c,h,a,null)}).I(function(a){c.T||bh(c,h,null,a)})};var bh=function(a,b,c,d){b?d?(a.T=function(){return sd(d)},a.Kb&&a.Kb(d)):(a.T=function(){return I(c)},a.Oa&&a.Oa(c)):(a.T=function(){return I({user:null})},a.Oa&&a.Oa({user:null}));a.Oa=null;a.Kb=null};
Yg.prototype.getRedirectResult=function(){var a=this;this.Cc||(this.Cc=new H(function(b,c){a.T?a.T().then(b,c):(a.Oa=b,a.Kb=c,ih(a))}));return this.Cc};var ih=function(a){var b=new Q("timeout");a.rc&&a.rc.cancel();a.rc=xe(3E4).then(function(){a.T||bh(a,!0,null,b)})},Zg=function(){};Zg.prototype.ed=function(a,b){if(!a)return sd(new Q("invalid-auth-event"));var c=a.pa,d=a.sa;return a.D?this.oc(a,b):b.Za(c,d)?this.pc(a,b):sd(new Q("invalid-auth-event"))};
Zg.prototype.oc=function(a,b){b.Ba(a.pa,null,a.getError(),a.sa);return I()};Zg.prototype.pc=function(a,b){var c=a.sa,d=a.pa,e=b.Za(d,c),f=a.Ua,g=a.fc();return e(f,g).then(function(a){b.Ba(d,a,null,c)}).I(function(a){b.Ba(d,null,a,c)})};var jh=function(a){this.c=a;this.Ea=this.ba=null;this.Ha=0};jh.prototype.N=function(){return{apiKey:this.c.u,refreshToken:this.ba,accessToken:this.Ea,expirationTime:this.Ha}};var lh=function(a,b){var c=b.idToken,d=b.refreshToken,e=kh(b.expiresIn);a.Ea=c;a.Ha=e;a.ba=d},kh=function(a){return la()+1E3*parseInt(a,10)},mh=function(a,b){return Tf(a.c,b).then(function(b){a.Ea=b.access_token;a.Ha=kh(b.expires_in);a.ba=b.refresh_token;return{accessToken:a.Ea,expirationTime:a.Ha,refreshToken:a.ba}})};
jh.prototype.getToken=function(a){return a||!this.Ea||la()>this.Ha-3E4?this.ba?mh(this,{grant_type:"refresh_token",refresh_token:this.ba}):I(null):I({accessToken:this.Ea,expirationTime:this.Ha,refreshToken:this.ba})};var nh=function(a,b,c,d,e){of(this,{uid:a,displayName:d||null,photoURL:e||null,email:c||null,providerId:b})},oh=function(a,b){Mb.call(this,a);for(var c in b)this[c]=b[c]};r(oh,Mb);
var W=function(a,b,c){this.M=[];this.u=a.apiKey;this.W=a.appName;this.ha=a.authDomain||null;a=firebase.SDK_VERSION?kf(firebase.SDK_VERSION):null;this.c=new T(this.u,null,a);this.oa=new jh(this.c);ph(this,b.idToken);lh(this.oa,b);P(this,"refreshToken",this.oa.ba);qh(this,c||{});J.call(this);this.Hb=!1;this.ha&&(this.o=hh(this.ha,this.u,this.W));this.Nb=[]};r(W,J);
var ph=function(a,b){a.Vc=b;P(a,"_lat",b)},rh=function(a,b){La(a.Nb,function(a){return a==b})},sh=function(a){for(var b=[],c=0;c<a.Nb.length;c++)b.push(a.Nb[c](a));return vd(b).then(function(){return a})},th=function(a){a.o&&!a.Hb&&(a.Hb=!0,a.o.subscribe(a))},qh=function(a,b){of(a,{uid:b.uid,displayName:b.displayName||null,photoURL:b.photoURL||null,email:b.email||null,emailVerified:b.emailVerified||!1,isAnonymous:b.isAnonymous||!1,providerData:[]})};P(W.prototype,"providerId","firebase");
var uh=function(){},vh=function(a){return I().then(function(){if(a.Ed)throw new Q("app-deleted");})},wh=function(a){return Ea(a.providerData,function(a){return a.providerId})},yh=function(a,b){b&&(xh(a,b.providerId),a.providerData.push(b))},xh=function(a,b){La(a.providerData,function(a){return a.providerId==b})},zh=function(a,b,c){("uid"!=b||c)&&a.hasOwnProperty(b)&&P(a,b,c)};
W.prototype.copy=function(a){var b=this;b!=a&&(of(this,{uid:a.uid,displayName:a.displayName,photoURL:a.photoURL,email:a.email,emailVerified:a.emailVerified,isAnonymous:a.isAnonymous,providerData:[]}),w(a.providerData,function(a){yh(b,a)}),this.oa=a.oa,P(this,"refreshToken",this.oa.ba))};W.prototype.reload=function(){var a=this;return vh(this).then(function(){return Ah(a).then(function(){return sh(a)}).then(uh)})};
var Ah=function(a){return a.getToken().then(function(b){var c=a.isAnonymous;return Bh(a,b).then(function(){c||zh(a,"isAnonymous",!1);return b}).I(function(b){"auth/user-token-expired"==b.code&&(a.dispatchEvent(new oh("userDeleted")),Ch(a));throw b;})})};W.prototype.getToken=function(a){var b=this;return vh(this).then(function(){return b.oa.getToken(a)}).then(function(a){if(!a)throw new Q("internal-error");a.accessToken!=b.Vc&&(ph(b,a.accessToken),b.ja());zh(b,"refreshToken",a.refreshToken);return a.accessToken})};
var Dh=function(a,b){b.idToken&&a.Vc!=b.idToken&&(lh(a.oa,b),a.ja(),ph(a,b.idToken))};W.prototype.ja=function(){this.dispatchEvent(new oh("tokenChanged"))};var Bh=function(a,b){return R(a.c,sg,{idToken:b}).then(q(a.je,a))};
W.prototype.je=function(a){a=a.users;if(!a||!a.length)throw new Q("internal-error");a=a[0];qh(this,{uid:a.localId,displayName:a.displayName,photoURL:a.photoUrl,email:a.email,emailVerified:!!a.emailVerified});for(var b=Eh(a),c=0;c<b.length;c++)yh(this,b[c]);zh(this,"isAnonymous",!(this.email&&a.passwordHash)&&!(this.providerData&&this.providerData.length))};
var Eh=function(a){return(a=a.providerUserInfo)&&a.length?Ea(a,function(a){return new nh(a.rawId,a.providerId,a.email,a.displayName,a.photoUrl)}):[]};W.prototype.reauthenticate=function(a){var b=this;return this.f(a.xb(this.c).then(function(a){var d;a:{var e=a.idToken.split(".");if(3==e.length){for(var e=e[1],f=(4-e.length%4)%4,g=0;g<f;g++)e+=".";try{var h=nc(ub(e));if(h.sub&&h.iss&&h.aud&&h.exp){d=new vf(h);break a}}catch(m){}}d=null}if(!d||b.uid!=d.be)throw new Q("user-mismatch");Dh(b,a);return b.reload()}))};
var Fh=function(a,b){return Ah(a).then(function(){if(Ia(wh(a),b))return sh(a).then(function(){throw new Q("provider-already-linked");})})};k=W.prototype;k.link=function(a){var b=this;return this.f(Fh(this,a.provider).then(function(){return b.getToken()}).then(function(c){return a.Xc(b.c,c)}).then(q(this.Kc,this)))};k.Kc=function(a){Dh(this,a);var b=this;return this.reload().then(function(){return b})};
k.updateEmail=function(a){var b=this;return this.f(this.getToken().then(function(c){return b.c.updateEmail(c,a)}).then(function(a){Dh(b,a);return b.reload()}))};k.updatePassword=function(a){var b=this;return this.f(this.getToken().then(function(c){return b.c.updatePassword(c,a)}).then(function(a){Dh(b,a);return b.reload()}))};
k.updateProfile=function(a){if(void 0===a.displayName&&void 0===a.photoURL)return vh(this);var b=this;return this.f(this.getToken().then(function(c){return b.c.updateProfile(c,{displayName:a.displayName,photoUrl:a.photoURL})}).then(function(a){Dh(b,a);zh(b,"displayName",a.displayName||null);zh(b,"photoURL",a.photoUrl||null);return sh(b)}).then(uh))};
k.unlink=function(a){var b=this;return this.f(Ah(this).then(function(c){return Ia(wh(b),a)?ig(b.c,c,[a]).then(function(a){var c={};w(a.providerUserInfo||[],function(a){c[a.providerId]=!0});w(wh(b),function(a){c[a]||xh(b,a)});return sh(b)}):sh(b).then(function(){throw new Q("no-such-provider");})}))};k["delete"]=function(){var a=this;return this.f(this.getToken().then(function(b){return R(a.c,rg,{idToken:b})}).then(function(){a.dispatchEvent(new oh("userDeleted"))})).then(function(){Ch(a)})};
k.Ec=function(a,b){return"linkViaPopup"==a&&(this.$||null)==b&&this.R||"linkViaRedirect"==a&&(this.Jb||null)==b?!0:!1};k.Ba=function(a,b,c,d){"linkViaPopup"==a&&d==(this.$||null)&&(c&&this.xa?this.xa(c):b&&!c&&this.R&&this.R(b),this.ya&&(this.ya.cancel(),this.ya=null),delete this.R,delete this.xa)};k.Za=function(a,b){return"linkViaPopup"==a&&b==(this.$||null)||"linkViaRedirect"==a&&(this.Jb||null)==b?q(this.Hd,this):null};k.vb=function(){return this.uid+":::"+Math.floor(1E9*Math.random()).toString()};
k.linkWithPopup=function(a){var b=this,c=sf(a.providerId),d=ff(c&&c.kb,c&&c.jb),e=this.vb(),c=Fh(this,a.providerId).then(function(){return sh(b)}).then(function(){b.Ja();return b.getToken()}).then(function(){return dh(b.o,d,"linkViaPopup",a,e)}).then(function(a){return new H(function(c,d){b.Ba("linkViaPopup",null,new Q("cancelled-popup-request"),b.$||null);b.R=c;b.xa=d;b.$=e;b.ya=fh(b,"linkViaPopup",a,e)})}).then(function(a){d&&(d||window).close();return a}).I(function(a){d&&(d||window).close();throw a;
});return this.f(c)};k.linkWithRedirect=function(a){var b=this,c=null,d=this.vb(),e=Fh(this,a.providerId).then(function(){b.Ja();return b.getToken()}).then(function(){b.Jb=d;return sh(b)}).then(function(a){b.za&&(a=b.u+":"+b.W,a=Gh(b.za,Hh,b.N(),a));return a}).then(function(){return eh(b.o,"linkViaRedirect",a,d)}).I(function(a){c=a;if(b.za)return Ih(b.za,Hh,b.u+":"+b.W);throw c;}).then(function(){if(c)throw c;});return this.f(e)};
k.Ja=function(){if(this.o&&this.Hb)return this.o;if(this.o&&!this.Hb)throw new Q("internal-error");throw new Q("auth-domain-config-required");};k.Hd=function(a,b){var c=this,d=null,e=this.getToken().then(function(d){return R(c.c,zf,{requestUri:a,sessionId:b,idToken:d})}).then(function(a){d=Kf(a);return c.Kc(a)}).then(function(a){return{user:a,credential:d}});return this.f(e)};
k.sendEmailVerification=function(){var a=this;return this.f(this.getToken().then(function(b){return a.c.sendEmailVerification(b)}).then(function(b){if(a.email!=b)return a.reload()}).then(function(){}))};var Ch=function(a){for(var b=0;b<a.M.length;b++)a.M[b].cancel("app-deleted");a.M=[];a.Ed=!0;P(a,"refreshToken",null);a.o&&a.o.unsubscribe(a)};W.prototype.f=function(a){var b=this;this.M.push(a);yd(a,function(){Ka(b.M,a)});return a};
W.prototype.N=function(){var a={uid:this.uid,displayName:this.displayName,photoURL:this.photoURL,email:this.email,emailVerified:this.emailVerified,isAnonymous:this.isAnonymous,providerData:[],apiKey:this.u,appName:this.W,authDomain:this.ha,stsTokenManager:this.oa.N(),redirectEventId:this.Jb||null};w(this.providerData,function(b){a.providerData.push(pf(b))});return a};
var Jh=function(a){if(!a.apiKey)return null;var b={apiKey:a.apiKey,authDomain:a.authDomain,appName:a.appName},c={};if(a.stsTokenManager&&a.stsTokenManager.accessToken&&a.stsTokenManager.refreshToken&&a.stsTokenManager.expirationTime)c.idToken=a.stsTokenManager.accessToken,c.refreshToken=a.stsTokenManager.refreshToken,c.expiresIn=(a.stsTokenManager.expirationTime-la())/1E3;else return null;var d=new W(b,c,a);a.providerData&&w(a.providerData,function(a){if(a){var b={};of(b,a);yh(d,b)}});a.redirectEventId&&
(d.Jb=a.redirectEventId);return d},Kh=function(a,b,c){var d=new W(a,b);c&&(d.za=c);return d.reload().then(function(){return d})};var Lh,Mh=function(a,b,c,d,e,f){this.Dd=a;this.kc=b;this.ac=c;this.qd=d;this.ea=e;this.Db={};this.mb=[];this.ib=0;this.Wd=f||l.indexedDB},Nh=function(a){return new H(function(b,c){var d=a.Wd.open(a.Dd,a.ea);d.onerror=function(a){c(Error(a.target.errorCode))};d.onupgradeneeded=function(b){b=b.target.result;try{b.createObjectStore(a.kc,{keyPath:a.ac})}catch(d){c(d)}};d.onsuccess=function(a){b(a.target.result)}})},Oh=function(a){a.Sc||(a.Sc=Nh(a));return a.Sc},Ph=function(a,b){return b.objectStore(a.kc)},
Qh=function(a,b,c){return b.transaction([a.kc],c?"readwrite":"readonly")},Rh=function(a){return new H(function(b,c){a.onsuccess=function(a){a&&a.target?b(a.target.result):b()};a.onerror=function(a){c(Error(a.target.errorCode))}})};
Mh.prototype.set=function(a,b){var c=!1,d,e=this;return yd(Oh(this).then(function(b){d=b;b=Ph(e,Qh(e,d,!0));return Rh(b.get(a))}).then(function(f){var g=Ph(e,Qh(e,d,!0));if(f)return f.value=b,Rh(g.put(f));e.ib++;c=!0;f={};f[e.ac]=a;f[e.qd]=b;return Rh(g.add(f))}).then(function(){e.Db[a]=b}),function(){c&&e.ib--})};Mh.prototype.get=function(a){var b=this;return Oh(this).then(function(c){return Rh(Ph(b,Qh(b,c,!1)).get(a))})};
Mh.prototype.remove=function(a){var b=!1,c=this;return yd(Oh(this).then(function(d){b=!0;c.ib++;return Rh(Ph(c,Qh(c,d,!0))["delete"](a))}).then(function(){delete c.Db[a]}),function(){b&&c.ib--})};
Mh.prototype.te=function(){var a=this;return Oh(this).then(function(b){var c=Ph(a,Qh(a,b,!1));return c.getAll?Rh(c.getAll()):new H(function(a,b){var f=[],g=c.openCursor();g.onsuccess=function(b){(b=b.target.result)?(f.push(b.value),b["continue"]()):a(f)};g.onerror=function(a){b(Error(a.target.errorCode))}})}).then(function(b){var c={},d=[];if(0==a.ib){for(d=0;d<b.length;d++)c[b[d][a.ac]]=b[d][a.qd];d=ef(a.Db,c);a.Db=c}return d})};
var Sh=function(a,b){La(a.mb,function(a){return a==b});0==a.mb.length&&a.Ob()};Mh.prototype.xc=function(){var a=this;this.Ob();var b=function(){a.nc=xe(1E3).then(q(a.te,a)).then(function(b){0<b.length&&w(a.mb,function(a){a(b)})}).then(b).I(function(a){"STOP_EVENT"!=a.message&&b()});return a.nc};b()};Mh.prototype.Ob=function(){this.nc&&this.nc.cancel("STOP_EVENT")};var Hh={name:"redirectUser",Z:!1},Th={name:"sessionId",Z:!1},Uh={name:"authEvent",Z:!0},Vh={name:"authUser",Z:!0},Wh=function(a,b,c,d,e){this.fe=a;this.jd=b;this.hb=d;this.me=e;if(!Kg(new Lg)||!Kg(new Mg))throw new Q("web-storage-unsupported");this.K={};this.bb=c;this.Yc=q(this.ce,this);this.Rc=q(this.Xd,this)},Xh,Yh=function(){if(!Xh){Lh||(Lh=new Mh("firebaseLocalStorageDb","firebaseLocalStorage","fbase_key","value",1));var a=navigator.userAgent.toLowerCase();Xh=new Wh("firebase",":",Lh,y&&!!qb&&
11==qb||/Edge\/\d+/.test(ab),-1!=a.indexOf("safari")&&-1==a.indexOf("chrome")&&window!=window.top?!0:!1)}return Xh},Zh=function(a,b){var c;b?(a.cd||(c=new Lg,c=Kg(c)?c:null,a.cd=new Gg(c)),c=a.cd):(a.md||(c=new Mg,c=Kg(c)?c:null,a.md=new Gg(c)),c=a.md);return c};Wh.prototype.s=function(a,b){return this.fe+this.jd+a.name+(b?this.jd+b:"")};
var $h=function(a,b,c){return a.hb&&b.Z?a.bb.get(a.s(b,c)).then(function(a){return a&&a.value}):I(Zh(a,b.Z).get(a.s(b,c)))},Ih=function(a,b,c){if(a.hb&&b.Z)return a.bb.remove(a.s(b,c));Zh(a,b.Z).remove(a.s(b,c));return I()},Gh=function(a,b,c,d){if(a.hb&&b.Z)return a.bb.set(a.s(b,d),c);Zh(a,b.Z).set(a.s(b,d),c);return I()};Wh.prototype.fc=function(a){return $h(this,Th,a)};Wh.prototype.zc=function(a,b){ai(this,this.s(Uh,a),b)};
var bi=function(a,b,c){return $h(a,Vh,b).then(function(a){a&&c&&(a.authDomain=c);return Jh(a||{})})},ci=function(a,b,c){return $h(a,Hh,b).then(function(a){a&&c&&(a.authDomain=c);return Jh(a||{})})},ai=function(a,b,c){Ua(a.K)&&a.xc();a.K[b]||(a.K[b]=[]);a.K[b].push(c)},di=function(a,b,c){a.K[b]&&(La(a.K[b],function(a){return a==c}),0==a.K[b].length&&delete a.K[b]);Ua(a.K)&&a.Ob()};k=Wh.prototype;
k.xc=function(){if(this.hb){var a=this.bb,b=this.Rc;0==a.mb.length&&a.xc();a.mb.push(b)}else Yb(window,"storage",this.Yc)};k.Ob=function(){this.hb?Sh(this.bb,this.Rc):hc(window,"storage",this.Yc)};k.ce=function(a){var b=a.ub.key;if(this.me){var c=window.localStorage.getItem(b);a=a.ub.newValue;a!=c&&(a?window.localStorage.setItem(b,a):a||window.localStorage.removeItem(b))}this.Dc(b)};k.Xd=function(a){w(a,q(this.Dc,this))};k.Dc=function(a){this.K[a]&&w(this.K[a],function(a){a()})};var Y=function(a){this.Ic=!1;P(this,"app",a);if(X(this).options&&X(this).options.apiKey)a=firebase.SDK_VERSION?kf(firebase.SDK_VERSION):null,this.c=new T(X(this).options&&X(this).options.apiKey,null,a);else throw new Q("invalid-api-key");this.M=[];this.Xa=[];this.ge=firebase.INTERNAL.createSubscribe(q(this.Yd,this));ei(this,null);this.Aa=this.da=null;try{this.da=Yh(),this.Aa=Yh(),this.B=fi(this)}catch(b){this.B=sd(b)}this.eb=!1;this.Nc=q(this.se,this);this.od=q(this.Ka,this);this.pd=q(this.Rd,this);
this.nd=q(this.Qd,this);gi(this);this.INTERNAL={};this.INTERNAL["delete"]=q(this["delete"],this)};Y.prototype.Ja=function(){return this.Fd||sd(new Q("auth-domain-config-required"))};var gi=function(a){var b=X(a).options.authDomain,c=X(a).options.apiKey;b&&(a.Fd=a.B.then(function(){a.o=hh(b,c,X(a).name);a.o.subscribe(a);Z(a)&&th(Z(a));a.sc&&(th(a.sc),a.sc=null);return a.o}))};k=Y.prototype;
k.Ec=function(a,b){switch(a){case "unknown":case "signInViaRedirect":return!0;case "signInViaPopup":return this.$==b&&!!this.R;default:return!1}};k.Ba=function(a,b,c,d){"signInViaPopup"==a&&this.$==d&&(c&&this.xa?this.xa(c):b&&!c&&this.R&&this.R(b),this.ya&&(this.ya.cancel(),this.ya=null),delete this.R,delete this.xa)};k.Za=function(a,b){return"signInViaRedirect"==a||"signInViaPopup"==a&&this.$==b&&this.R?q(this.Id,this):null};
k.Id=function(a,b){var c=this,d=null,e=xf(c.c,{requestUri:a,sessionId:b}).then(function(a){d=Kf(a);return a}),f=c.B.then(function(){return e}).then(function(a){return hi(c,a)}).then(function(){return{user:Z(c),credential:d}});return this.f(f)};k.vb=function(){return Math.floor(1E9*Math.random()).toString()};
k.signInWithPopup=function(a){var b=this,c=sf(a.providerId),d=ff(c&&c.kb,c&&c.jb),e=this.vb(),c=this.Ja().then(function(b){return dh(b,d,"signInViaPopup",a,e)}).then(function(a){return new H(function(c,d){b.Ba("signInViaPopup",null,new Q("cancelled-popup-request"),b.$);b.R=c;b.xa=d;b.$=e;b.ya=fh(b,"signInViaPopup",a,e)})}).then(function(a){d&&(d||window).close();return a}).I(function(a){d&&(d||window).close();throw a;});return this.f(c)};
k.signInWithRedirect=function(a){var b=this,c=this.Ja().then(function(){return eh(b.o,"signInViaRedirect",a)});return this.f(c)};k.getRedirectResult=function(){var a=this,b=this.Ja().then(function(){return a.o.getRedirectResult()});return this.f(b)};
var hi=function(a,b){var c={};c.apiKey=X(a).options.apiKey;c.authDomain=X(a).options.authDomain;c.appName=X(a).name;return a.B.then(function(){return Kh(c,b,a.Aa)}).then(function(b){if(Z(a)&&b.uid==Z(a).uid)return Z(a).copy(b),a.Ka(b);ei(a,b);th(b);return a.Ka(b)}).then(function(){a.ja()})},ei=function(a,b){Z(a)&&(rh(Z(a),a.od),hc(Z(a),"tokenChanged",a.pd),hc(Z(a),"userDeleted",a.nd));b&&(b.Nb.push(a.od),Yb(b,"tokenChanged",a.pd),Yb(b,"userDeleted",a.nd));P(a,"currentUser",b)};
Y.prototype.signOut=function(){var a=this,b=this.B.then(function(){if(!Z(a))return I();ei(a,null);return Ih(a.da,Vh,ii(a)).then(function(){a.ja()})});return this.f(b)};
var ji=function(a){var b=ii(a),c=ci(a.Aa,b,X(a).options.authDomain).then(function(c){if(a.sc=c)c.za=a.Aa;return Ih(a.Aa,Hh,b)});return a.f(c)},fi=function(a){var b=ii(a),c=X(a).options.authDomain,d=yd(ji(a).then(function(){return bi(a.da,b,c)}).then(function(c){return c?(c.za=a.Aa,c.reload().then(function(){return c}).I(function(d){return"auth/network-request-failed"==d.code?c:Ih(a.da,Vh,b)})):null}).then(function(b){ei(a,b||null);a.eb=!0;a.ja()}),function(){if(!a.Ic){a.eb=!0;var c=a.da;ai(c,c.s(Vh,
b),a.Nc)}});return a.f(d)};Y.prototype.se=function(){var a=this;return bi(this.da,ii(this),X(this).options.authDomain).then(function(b){var c;if(c=Z(a)&&b){c=Z(a).uid;var d=b.uid;c=void 0===c||null===c||""===c||void 0===d||null===d||""===d?!1:c==d}if(c)return Z(a).copy(b),Z(a).getToken();ei(a,b);b&&(th(b),b.za=a.Aa);a.o.subscribe(a);a.ja()})};Y.prototype.Ka=function(a){var b=ii(this);return Gh(this.da,Vh,a.N(),b)};Y.prototype.Rd=function(){this.eb=!0;this.ja();this.Ka(Z(this))};Y.prototype.Qd=function(){this.signOut()};
var ki=function(a,b){return a.f(b.then(function(b){return hi(a,b)}).then(function(){return Z(a)}))};k=Y.prototype;k.Yd=function(a){var b=this;this.addAuthTokenListener(function(){a.next(Z(b))})};k.onAuthStateChanged=function(a,b,c){var d=this;this.eb&&firebase.Promise.resolve().then(function(){p(a)?a(Z(d)):p(a.next)&&a.next(Z(d))});return this.ge(a,b,c)};k.getToken=function(a){var b=this,c=this.B.then(function(){return Z(b)?Z(b).getToken(a).then(function(a){return{accessToken:a}}):null});return this.f(c)};
k.signInWithCustomToken=function(a){var b=this;return this.B.then(function(){return ki(b,R(b.c,tg,{token:a}))}).then(function(a){zh(a,"isAnonymous",!1);return b.Ka(a)}).then(function(){return Z(b)})};k.signInWithEmailAndPassword=function(a,b){var c=this;return this.B.then(function(){return ki(c,R(c.c,Gf,{email:a,password:b}))})};k.createUserWithEmailAndPassword=function(a,b){var c=this;return this.B.then(function(){return ki(c,R(c.c,qg,{email:a,password:b}))})};
k.signInWithCredential=function(a){var b=this;return this.B.then(function(){return ki(b,a.xb(b.c))})};k.signInAnonymously=function(){var a=Z(this),b=this;return a&&a.isAnonymous?I(a):this.B.then(function(){return ki(b,b.c.signInAnonymously())}).then(function(a){zh(a,"isAnonymous",!0);return b.Ka(a)}).then(function(){return Z(b)})};var ii=function(a){return X(a).options.apiKey+":"+X(a).name},X=function(a){return a.app},Z=function(a){return a.currentUser};k=Y.prototype;
k.ja=function(){for(var a=0;a<this.Xa.length;a++)if(this.Xa[a])this.Xa[a](Z(this)&&Z(this)._lat||null)};k.addAuthTokenListener=function(a){this.Xa.push(a);var b=this;this.eb&&this.B.then(function(){a(Z(b)&&Z(b)._lat||null)})};k.removeAuthTokenListener=function(a){La(this.Xa,function(b){return b==a})};k["delete"]=function(){this.Ic=!0;for(var a=0;a<this.M.length;a++)this.M[a].cancel("app-deleted");this.M=[];this.da&&(a=this.da,di(a,a.s(Vh,ii(this)),this.Nc));this.o&&this.o.unsubscribe(this)};
k.f=function(a){var b=this;this.M.push(a);yd(a,function(){Ka(b.M,a)});return a};k.fetchProvidersForEmail=function(a){return this.f(Zf(this.c,a))};k.verifyPasswordResetCode=function(a){return this.checkActionCode(a).then(function(a){return a.data.email})};k.confirmPasswordReset=function(a,b){return this.f(this.c.confirmPasswordReset(a,b).then(function(){}))};k.checkActionCode=function(a){return this.f(this.c.checkActionCode(a).then(function(a){return{data:{email:a.email}}}))};k.applyActionCode=function(a){return this.f(this.c.applyActionCode(a).then(function(){}))};
k.sendPasswordResetEmail=function(a){return this.f(this.c.sendPasswordResetEmail(a).then(function(){}))};Vg(Y.prototype,{applyActionCode:{name:"applyActionCode",b:[U("code")]},checkActionCode:{name:"checkActionCode",b:[U("code")]},confirmPasswordReset:{name:"confirmPasswordReset",b:[U("code"),U("newPassword")]},createUserWithEmailAndPassword:{name:"createUserWithEmailAndPassword",b:[U("email"),U("password")]},fetchProvidersForEmail:{name:"fetchProvidersForEmail",b:[U("email")]},getRedirectResult:{name:"getRedirectResult",b:[]},onAuthStateChanged:{name:"onAuthStateChanged",b:[Tg(Og(),Pg(),"nextOrObserver"),
Pg("opt_error",!0),Pg("opt_completed",!0)]},sendPasswordResetEmail:{name:"sendPasswordResetEmail",b:[U("email")]},signInAnonymously:{name:"signInAnonymously",b:[]},signInWithCredential:{name:"signInWithCredential",b:[Rg()]},signInWithCustomToken:{name:"signInWithCustomToken",b:[U("token")]},signInWithEmailAndPassword:{name:"signInWithEmailAndPassword",b:[U("email"),U("password")]},signInWithPopup:{name:"signInWithPopup",b:[Sg()]},signInWithRedirect:{name:"signInWithRedirect",b:[Sg()]},signOut:{name:"signOut",
b:[]},verifyPasswordResetCode:{name:"verifyPasswordResetCode",b:[U("code")]}});
Vg(W.prototype,{"delete":{name:"delete",b:[]},getToken:{name:"getToken",b:[{name:"opt_forceRefresh",U:"a boolean",optional:!0,V:function(a){return"boolean"==typeof a}}]},link:{name:"link",b:[Rg()]},linkWithPopup:{name:"linkWithPopup",b:[Sg()]},linkWithRedirect:{name:"linkWithRedirect",b:[Sg()]},reauthenticate:{name:"reauthenticate",b:[Rg()]},reload:{name:"reload",b:[]},sendEmailVerification:{name:"sendEmailVerification",b:[]},unlink:{name:"unlink",b:[U("provider")]},updateEmail:{name:"updateEmail",
b:[U("email")]},updatePassword:{name:"updatePassword",b:[U("password")]},updateProfile:{name:"updateProfile",b:[Og("profile")]}});Vg(H.prototype,{I:{name:"catch"},then:{name:"then"}});V(If,"credential",function(a,b){return new Ff(a,b)},[U("email"),U("password")]);Vg(Bf.prototype,{addScope:{name:"addScope",b:[U("scope")]}});V(Bf,"credential",Bf.credential,[Tg(U(),Og(),"token")]);Vg(Cf.prototype,{addScope:{name:"addScope",b:[U("scope")]}});V(Cf,"credential",Cf.credential,[Tg(U(),Og(),"token")]);
Vg(Df.prototype,{addScope:{name:"addScope",b:[U("scope")]}});V(Df,"credential",Df.credential,[Tg(U(),Tg(Og(),Qg()),"idToken"),Tg(U(),Qg(),"accessToken",!0)]);V(Ef,"credential",Ef.credential,[Tg(U(),Og(),"token"),U("secret",!0)]);
(function(){if("undefined"!==typeof firebase&&firebase.INTERNAL&&firebase.INTERNAL.registerService){var a={Auth:Y,Error:Q};V(a,"EmailAuthProvider",If,[]);V(a,"FacebookAuthProvider",Bf,[]);V(a,"GithubAuthProvider",Cf,[]);V(a,"GoogleAuthProvider",Df,[]);V(a,"TwitterAuthProvider",Ef,[]);firebase.INTERNAL.registerService("auth",function(a,c){var d=new Y(a);c({INTERNAL:{getToken:q(d.getToken,d),addAuthTokenListener:q(d.addAuthTokenListener,d),removeAuthTokenListener:q(d.removeAuthTokenListener,d)}});return d},
a);firebase.INTERNAL.registerAppHook(function(a,c){"create"===a&&c.auth()});firebase.INTERNAL.extendNamespace({User:W})}else throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");})();})();
(function() {var g,n=this;function p(a){return void 0!==a}function aa(){}function ba(a){a.Wb=function(){return a.$e?a.$e:a.$e=new a}}
function ca(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function da(a){return"array"==ca(a)}function ea(a){var b=ca(a);return"array"==b||"object"==b&&"number"==typeof a.length}function q(a){return"string"==typeof a}function fa(a){return"number"==typeof a}function ga(a){return"function"==ca(a)}function ha(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ia(a,b,c){return a.call.apply(a.bind,arguments)}
function ja(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function r(a,b,c){r=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ia:ja;return r.apply(null,arguments)}
function ka(a,b){function c(){}c.prototype=b.prototype;a.Eg=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Bg=function(a,c,f){for(var h=Array(arguments.length-2),k=2;k<arguments.length;k++)h[k-2]=arguments[k];return b.prototype[c].apply(a,h)}};function la(){this.Ya=-1};function ma(){this.Ya=-1;this.Ya=64;this.N=[];this.Wd=[];this.Hf=[];this.zd=[];this.zd[0]=128;for(var a=1;a<this.Ya;++a)this.zd[a]=0;this.Pd=this.ac=0;this.reset()}ka(ma,la);ma.prototype.reset=function(){this.N[0]=1732584193;this.N[1]=4023233417;this.N[2]=2562383102;this.N[3]=271733878;this.N[4]=3285377520;this.Pd=this.ac=0};
function na(a,b,c){c||(c=0);var d=a.Hf;if(q(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.N[0];c=a.N[1];for(var h=a.N[2],k=a.N[3],m=a.N[4],l,e=0;80>e;e++)40>e?20>e?(f=k^c&(h^k),l=1518500249):(f=c^h^k,l=1859775393):60>e?(f=c&h|k&(c|h),l=2400959708):(f=c^h^k,l=3395469782),f=(b<<
5|b>>>27)+f+m+l+d[e]&4294967295,m=k,k=h,h=(c<<30|c>>>2)&4294967295,c=b,b=f;a.N[0]=a.N[0]+b&4294967295;a.N[1]=a.N[1]+c&4294967295;a.N[2]=a.N[2]+h&4294967295;a.N[3]=a.N[3]+k&4294967295;a.N[4]=a.N[4]+m&4294967295}
ma.prototype.update=function(a,b){if(null!=a){p(b)||(b=a.length);for(var c=b-this.Ya,d=0,e=this.Wd,f=this.ac;d<b;){if(0==f)for(;d<=c;)na(this,a,d),d+=this.Ya;if(q(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Ya){na(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Ya){na(this,e);f=0;break}}this.ac=f;this.Pd+=b}};function t(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function oa(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function pa(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function qa(a){var b=0,c;for(c in a)b++;return b}function ra(a){for(var b in a)return b}function sa(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function ta(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function ua(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function va(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function wa(a,b){var c=va(a,b,void 0);return c&&a[c]}function xa(a){for(var b in a)return!1;return!0}function ya(a){var b={},c;for(c in a)b[c]=a[c];return b};function za(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function Aa(){this.Fd=void 0}
function Ba(a,b,c){switch(typeof b){case "string":Ca(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(da(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],Ba(a,a.Fd?a.Fd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),Ca(f,c),
c.push(":"),Ba(a,a.Fd?a.Fd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var Da={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Ea=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Ca(a,b){b.push('"',a.replace(Ea,function(a){if(a in Da)return Da[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return Da[a]=e+b.toString(16)}),'"')};var v;a:{var Fa=n.navigator;if(Fa){var Ga=Fa.userAgent;if(Ga){v=Ga;break a}}v=""};function Ha(a){if(Error.captureStackTrace)Error.captureStackTrace(this,Ha);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}ka(Ha,Error);Ha.prototype.name="CustomError";var w=Array.prototype,Ia=w.indexOf?function(a,b,c){return w.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(q(a))return q(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ja=w.forEach?function(a,b,c){w.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Ka=w.filter?function(a,b,c){return w.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,h=q(a)?
a.split(""):a,k=0;k<d;k++)if(k in h){var m=h[k];b.call(c,m,k,a)&&(e[f++]=m)}return e},La=w.map?function(a,b,c){return w.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=q(a)?a.split(""):a,h=0;h<d;h++)h in f&&(e[h]=b.call(c,f[h],h,a));return e},Ma=w.reduce?function(a,b,c,d){for(var e=[],f=1,h=arguments.length;f<h;f++)e.push(arguments[f]);d&&(e[0]=r(b,d));return w.reduce.apply(a,e)}:function(a,b,c,d){var e=c;Ja(a,function(c,h){e=b.call(d,e,c,h,a)});return e},Na=w.every?function(a,b,
c){return w.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Oa(a,b){var c=Pa(a,b,void 0);return 0>c?null:q(a)?a.charAt(c):a[c]}function Pa(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Qa(a,b){var c=Ia(a,b);0<=c&&w.splice.call(a,c,1)}function Ra(a,b,c){return 2>=arguments.length?w.slice.call(a,b):w.slice.call(a,b,c)}
function Sa(a,b){a.sort(b||Ta)}function Ta(a,b){return a>b?1:a<b?-1:0};var Ua=-1!=v.indexOf("Opera")||-1!=v.indexOf("OPR"),Va=-1!=v.indexOf("Trident")||-1!=v.indexOf("MSIE"),Wa=-1!=v.indexOf("Gecko")&&-1==v.toLowerCase().indexOf("webkit")&&!(-1!=v.indexOf("Trident")||-1!=v.indexOf("MSIE")),Xa=-1!=v.toLowerCase().indexOf("webkit");
(function(){var a="",b;if(Ua&&n.opera)return a=n.opera.version,ga(a)?a():a;Wa?b=/rv\:([^\);]+)(\)|;)/:Va?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:Xa&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(v))?a[1]:"");return Va&&(b=(b=n.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var Ya=null,Za=null,$a=null;function ab(a,b){if(!ea(a))throw Error("encodeByteArray takes an array as a parameter");bb();for(var c=b?Za:Ya,d=[],e=0;e<a.length;e+=3){var f=a[e],h=e+1<a.length,k=h?a[e+1]:0,m=e+2<a.length,l=m?a[e+2]:0,u=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|l>>6,l=l&63;m||(l=64,h||(k=64));d.push(c[u],c[f],c[k],c[l])}return d.join("")}
function bb(){if(!Ya){Ya={};Za={};$a={};for(var a=0;65>a;a++)Ya[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),Za[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),$a[Za[a]]=a,62<=a&&($a["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)]=a)}};function cb(a){n.setTimeout(function(){throw a;},0)}var db;
function eb(){var a=n.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&-1==v.indexOf("Presto")&&(a=function(){var a=document.createElement("iframe");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host,a=r(function(a){if(("*"==d||a.origin==
d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&-1==v.indexOf("Trident")&&-1==v.indexOf("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(p(c.next)){c=c.next;var a=c.Ke;c.Ke=null;a()}};return function(a){d.next={Ke:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("script")?function(a){var b=
document.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){n.setTimeout(a,0)}};function fb(a,b){gb||hb();ib||(gb(),ib=!0);jb.push(new kb(a,b))}var gb;function hb(){if(n.Promise&&n.Promise.resolve){var a=n.Promise.resolve();gb=function(){a.then(lb)}}else gb=function(){var a=lb;!ga(n.setImmediate)||n.Window&&n.Window.prototype&&n.Window.prototype.setImmediate==n.setImmediate?(db||(db=eb()),db(a)):n.setImmediate(a)}}var ib=!1,jb=[];[].push(function(){ib=!1;jb=[]});
function lb(){for(;jb.length;){var a=jb;jb=[];for(var b=0;b<a.length;b++){var c=a[b];try{c.Uf.call(c.scope)}catch(d){cb(d)}}}ib=!1}function kb(a,b){this.Uf=a;this.scope=b};function mb(a,b){this.L=nb;this.sf=void 0;this.Ca=this.Ha=null;this.jd=this.be=!1;if(a==ob)pb(this,qb,b);else try{var c=this;a.call(b,function(a){pb(c,qb,a)},function(a){if(!(a instanceof rb))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(b){}pb(c,sb,a)})}catch(d){pb(this,sb,d)}}var nb=0,qb=2,sb=3;function ob(){}mb.prototype.then=function(a,b,c){return tb(this,ga(a)?a:null,ga(b)?b:null,c)};mb.prototype.then=mb.prototype.then;mb.prototype.$goog_Thenable=!0;g=mb.prototype;
g.xg=function(a,b){return tb(this,null,a,b)};g.cancel=function(a){this.L==nb&&fb(function(){var b=new rb(a);ub(this,b)},this)};function ub(a,b){if(a.L==nb)if(a.Ha){var c=a.Ha;if(c.Ca){for(var d=0,e=-1,f=0,h;h=c.Ca[f];f++)if(h=h.m)if(d++,h==a&&(e=f),0<=e&&1<d)break;0<=e&&(c.L==nb&&1==d?ub(c,b):(d=c.Ca.splice(e,1)[0],vb(c,d,sb,b)))}a.Ha=null}else pb(a,sb,b)}function wb(a,b){a.Ca&&a.Ca.length||a.L!=qb&&a.L!=sb||xb(a);a.Ca||(a.Ca=[]);a.Ca.push(b)}
function tb(a,b,c,d){var e={m:null,ff:null,hf:null};e.m=new mb(function(a,h){e.ff=b?function(c){try{var e=b.call(d,c);a(e)}catch(l){h(l)}}:a;e.hf=c?function(b){try{var e=c.call(d,b);!p(e)&&b instanceof rb?h(b):a(e)}catch(l){h(l)}}:h});e.m.Ha=a;wb(a,e);return e.m}g.Af=function(a){this.L=nb;pb(this,qb,a)};g.Bf=function(a){this.L=nb;pb(this,sb,a)};
function pb(a,b,c){if(a.L==nb){if(a==c)b=sb,c=new TypeError("Promise cannot resolve to itself");else{var d;if(c)try{d=!!c.$goog_Thenable}catch(e){d=!1}else d=!1;if(d){a.L=1;c.then(a.Af,a.Bf,a);return}if(ha(c))try{var f=c.then;if(ga(f)){yb(a,c,f);return}}catch(h){b=sb,c=h}}a.sf=c;a.L=b;a.Ha=null;xb(a);b!=sb||c instanceof rb||zb(a,c)}}function yb(a,b,c){function d(b){f||(f=!0,a.Bf(b))}function e(b){f||(f=!0,a.Af(b))}a.L=1;var f=!1;try{c.call(b,e,d)}catch(h){d(h)}}
function xb(a){a.be||(a.be=!0,fb(a.Sf,a))}g.Sf=function(){for(;this.Ca&&this.Ca.length;){var a=this.Ca;this.Ca=null;for(var b=0;b<a.length;b++)vb(this,a[b],this.L,this.sf)}this.be=!1};function vb(a,b,c,d){if(c==qb)b.ff(d);else{if(b.m)for(;a&&a.jd;a=a.Ha)a.jd=!1;b.hf(d)}}function zb(a,b){a.jd=!0;fb(function(){a.jd&&Ab.call(null,b)})}var Ab=cb;function rb(a){Ha.call(this,a)}ka(rb,Ha);rb.prototype.name="cancel";function Bb(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function x(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function Cb(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])};function y(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function Db(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function A(a,b,c,d){if((!d||p(c))&&!ga(c))throw Error(Db(a,b,d)+"must be a valid function.");}function Eb(a,b,c){if(p(c)&&(!ha(c)||null===c))throw Error(Db(a,b,!0)+"must be a valid context object.");};function Fb(a){var b=[];Cb(a,function(a,d){da(d)?Ja(d,function(d){b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))}):b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))});return b.length?"&"+b.join("&"):""};var Gb=n.Promise||mb;mb.prototype["catch"]=mb.prototype.xg;function Hb(){var a=this;this.reject=this.resolve=null;this.ra=new Gb(function(b,c){a.resolve=b;a.reject=c})}function Ib(a,b){return function(c,d){c?a.reject(c):a.resolve(d);ga(b)&&(Jb(a.ra),1===b.length?b(c):b(c,d))}}function Jb(a){a.then(void 0,aa)};function Kb(a,b){if(!a)throw Lb(b);}function Lb(a){return Error("Firebase Database ("+firebase.SDK_VERSION+") INTERNAL ASSERT FAILED: "+a)};function Mb(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,Kb(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b}function Nb(a){for(var b=0,c=0;c<a.length;c++){var d=a.charCodeAt(c);128>d?b++:2048>d?b+=2:55296<=d&&56319>=d?(b+=4,c++):b+=3}return b};function Ob(a){return"undefined"!==typeof JSON&&p(JSON.parse)?JSON.parse(a):za(a)}function B(a){if("undefined"!==typeof JSON&&p(JSON.stringify))a=JSON.stringify(a);else{var b=[];Ba(new Aa,a,b);a=b.join("")}return a};function Pb(a,b){this.committed=a;this.snapshot=b};function Qb(a){this.se=a;this.Bd=[];this.Rb=0;this.Yd=-1;this.Gb=null}function Rb(a,b,c){a.Yd=b;a.Gb=c;a.Yd<a.Rb&&(a.Gb(),a.Gb=null)}function Sb(a,b,c){for(a.Bd[b]=c;a.Bd[a.Rb];){var d=a.Bd[a.Rb];delete a.Bd[a.Rb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Tb(function(){f.se(d[e])})}if(a.Rb===a.Yd){a.Gb&&(clearTimeout(a.Gb),a.Gb(),a.Gb=null);break}a.Rb++}};function Ub(){this.qc={}}Ub.prototype.set=function(a,b){null==b?delete this.qc[a]:this.qc[a]=b};Ub.prototype.get=function(a){return Bb(this.qc,a)?this.qc[a]:null};Ub.prototype.remove=function(a){delete this.qc[a]};Ub.prototype.af=!0;function Vb(a){this.vc=a;this.Cd="firebase:"}g=Vb.prototype;g.set=function(a,b){null==b?this.vc.removeItem(this.Cd+a):this.vc.setItem(this.Cd+a,B(b))};g.get=function(a){a=this.vc.getItem(this.Cd+a);return null==a?null:Ob(a)};g.remove=function(a){this.vc.removeItem(this.Cd+a)};g.af=!1;g.toString=function(){return this.vc.toString()};function Wb(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new Vb(b)}}catch(c){}return new Ub}var Xb=Wb("localStorage"),Yb=Wb("sessionStorage");function Zb(a,b,c){this.type=$b;this.source=a;this.path=b;this.Ja=c}Zb.prototype.Nc=function(a){return this.path.e()?new Zb(this.source,C,this.Ja.R(a)):new Zb(this.source,D(this.path),this.Ja)};Zb.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ja.toString()+")"};function ac(a,b){this.type=bc;this.source=a;this.path=b}ac.prototype.Nc=function(){return this.path.e()?new ac(this.source,C):new ac(this.source,D(this.path))};ac.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function cc(a){this.Ge=a}cc.prototype.getToken=function(a){return this.Ge.INTERNAL.getToken(a).then(null,function(a){return a&&"auth/token-not-initialized"===a.code?(E("Got auth/token-not-initialized error.  Treating as null token."),null):Promise.reject(a)})};function dc(a,b){a.Ge.INTERNAL.addAuthTokenListener(b)};function ec(){this.Jd=F}ec.prototype.j=function(a){return this.Jd.Q(a)};ec.prototype.toString=function(){return this.Jd.toString()};function fc(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.Sc=b;this.oe=c;this.zg=d;this.lf=e||"";this.bb=Xb.get("host:"+a)||this.host}function gc(a,b){b!==a.bb&&(a.bb=b,"s-"===a.bb.substr(0,2)&&Xb.set("host:"+a.host,a.bb))}
function hc(a,b,c){H("string"===typeof b,"typeof type must == string");H("object"===typeof c,"typeof params must == object");if("websocket"===b)b=(a.Sc?"wss://":"ws://")+a.bb+"/.ws?";else if("long_polling"===b)b=(a.Sc?"https://":"http://")+a.bb+"/.lp?";else throw Error("Unknown connection type: "+b);a.host!==a.bb&&(c.ns=a.oe);var d=[];t(c,function(a,b){d.push(b+"="+a)});return b+d.join("&")}
fc.prototype.toString=function(){var a=(this.Sc?"https://":"http://")+this.host;this.lf&&(a+="<"+this.lf+">");return a};function ic(a,b){this.xf={};this.Vc=new jc(a);this.va=b;var c=1E4+2E4*Math.random();setTimeout(r(this.pf,this),Math.floor(c))}ic.prototype.pf=function(){var a=this.Vc.get(),b={},c=!1,d;for(d in a)0<a[d]&&Bb(this.xf,d)&&(b[d]=a[d],c=!0);c&&this.va.xe(b);setTimeout(r(this.pf,this),Math.floor(6E5*Math.random()))};function kc(){this.uc={}}function lc(a,b,c){p(c)||(c=1);Bb(a.uc,b)||(a.uc[b]=0);a.uc[b]+=c}kc.prototype.get=function(){return ya(this.uc)};function jc(a){this.Lf=a;this.rd=null}jc.prototype.get=function(){var a=this.Lf.get(),b=ya(a);if(this.rd)for(var c in this.rd)b[c]-=this.rd[c];this.rd=a;return b};var mc={},nc={};function oc(a){a=a.toString();mc[a]||(mc[a]=new kc);return mc[a]}function pc(a,b){var c=a.toString();nc[c]||(nc[c]=b());return nc[c]};function qc(){this.wb=[]}function rc(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Zb();null===c||f.ca(c.Zb())||(a.wb.push(c),c=null);null===c&&(c=new sc(f));c.add(e)}c&&a.wb.push(c)}function tc(a,b,c){rc(a,c);uc(a,function(a){return a.ca(b)})}function vc(a,b,c){rc(a,c);uc(a,function(a){return a.contains(b)||b.contains(a)})}
function uc(a,b){for(var c=!0,d=0;d<a.wb.length;d++){var e=a.wb[d];if(e)if(e=e.Zb(),b(e)){for(var e=a.wb[d],f=0;f<e.hd.length;f++){var h=e.hd[f];if(null!==h){e.hd[f]=null;var k=h.Ub();wc&&E("event: "+h.toString());Tb(k)}}a.wb[d]=null}else c=!1}c&&(a.wb=[])}function sc(a){this.qa=a;this.hd=[]}sc.prototype.add=function(a){this.hd.push(a)};sc.prototype.Zb=function(){return this.qa};function xc(a,b,c,d){this.ae=b;this.Md=c;this.Dd=d;this.gd=a}xc.prototype.Zb=function(){var a=this.Md.xb();return"value"===this.gd?a.path:a.getParent().path};xc.prototype.ge=function(){return this.gd};xc.prototype.Ub=function(){return this.ae.Ub(this)};xc.prototype.toString=function(){return this.Zb().toString()+":"+this.gd+":"+B(this.Md.Se())};function yc(a,b,c){this.ae=a;this.error=b;this.path=c}yc.prototype.Zb=function(){return this.path};yc.prototype.ge=function(){return"cancel"};
yc.prototype.Ub=function(){return this.ae.Ub(this)};yc.prototype.toString=function(){return this.path.toString()+":cancel"};function zc(){}zc.prototype.Ve=function(){return null};zc.prototype.fe=function(){return null};var Ac=new zc;function Bc(a,b,c){this.Ef=a;this.Na=b;this.yd=c}Bc.prototype.Ve=function(a){var b=this.Na.O;if(Cc(b,a))return b.j().R(a);b=null!=this.yd?new Dc(this.yd,!0,!1):this.Na.u();return this.Ef.rc(a,b)};Bc.prototype.fe=function(a,b,c){var d=null!=this.yd?this.yd:Ec(this.Na);a=this.Ef.Xd(d,b,1,c,a);return 0===a.length?null:a[0]};function I(a,b,c,d){this.type=a;this.Ma=b;this.Za=c;this.pe=d;this.Dd=void 0}function Fc(a){return new I(Gc,a)}var Gc="value";function Dc(a,b,c){this.A=a;this.ea=b;this.Tb=c}function Hc(a){return a.ea}function Ic(a){return a.Tb}function Jc(a,b){return b.e()?a.ea&&!a.Tb:Cc(a,J(b))}function Cc(a,b){return a.ea&&!a.Tb||a.A.Fa(b)}Dc.prototype.j=function(){return this.A};function Kc(a,b){return Lc(a.name,b.name)}function Mc(a,b){return Lc(a,b)};function K(a,b){this.name=a;this.S=b}function Nc(a,b){return new K(a,b)};function Oc(a,b){return a&&"object"===typeof a?(H(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Pc(a,b){var c=new Qc;Rc(a,new L(""),function(a,e){Sc(c,a,Tc(e,b))});return c}function Tc(a,b){var c=a.C().H(),c=Oc(c,b),d;if(a.J()){var e=Oc(a.Ea(),b);return e!==a.Ea()||c!==a.C().H()?new Uc(e,M(c)):a}d=a;c!==a.C().H()&&(d=d.ga(new Uc(c)));a.P(N,function(a,c){var e=Tc(c,b);e!==c&&(d=d.U(a,e))});return d};var Vc=function(){var a=1;return function(){return a++}}(),H=Kb,Wc=Lb;
function Xc(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{bb();for(var c=$a,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],h=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var m=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==h||null==k||null==m)throw Error();d.push(f<<2|h>>4);64!=k&&(d.push(h<<4&240|k>>2),64!=m&&d.push(k<<6&192|m))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Ra(d,c,
c+8192));b=a}}return b}catch(l){E("base64Decode failed: ",l)}return null}function Yc(a){var b=Mb(a);a=new ma;a.update(b);var b=[],c=8*a.Pd;56>a.ac?a.update(a.zd,56-a.ac):a.update(a.zd,a.Ya-(a.ac-56));for(var d=a.Ya-1;56<=d;d--)a.Wd[d]=c&255,c/=256;na(a,a.Wd);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.N[d]>>e&255,++c;return ab(b)}
function Zc(a){for(var b="",c=0;c<arguments.length;c++)b=ea(arguments[c])?b+Zc.apply(null,arguments[c]):"object"===typeof arguments[c]?b+B(arguments[c]):b+arguments[c],b+=" ";return b}var wc=null,$c=!0;
function ad(a,b){Kb(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?wc=r(console.log,console):"object"===typeof console.log&&(wc=function(a){console.log(a)})),b&&Yb.set("logging_enabled",!0)):ga(a)?wc=a:(wc=null,Yb.remove("logging_enabled"))}function E(a){!0===$c&&($c=!1,null===wc&&!0===Yb.get("logging_enabled")&&ad(!0));if(wc){var b=Zc.apply(null,arguments);wc(b)}}
function bd(a){return function(){E(a,arguments)}}function cd(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+Zc.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function dd(a){var b=Zc.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function O(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+Zc.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function ed(a){var b,c,d,e,f,h=a;f=c=a=b="";d=!0;e="https";if(q(h)){var k=h.indexOf("//");0<=k&&(e=h.substring(0,k-1),h=h.substring(k+2));k=h.indexOf("/");-1===k&&(k=h.length);b=h.substring(0,k);f="";h=h.substring(k).split("/");for(k=0;k<h.length;k++)if(0<h[k].length){var m=h[k];try{m=decodeURIComponent(m.replace(/\+/g," "))}catch(l){}f+="/"+m}h=b.split(".");3===h.length?(a=h[1],c=h[0].toLowerCase()):2===h.length&&(a=h[0]);k=b.indexOf(":");0<=k&&(d="https"===e||"wss"===e)}"firebase"===a&&dd(b+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
c&&"undefined"!=c||dd("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&O("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");return{kc:new fc(b,d,c,"ws"===e||"wss"===e),path:new L(f)}}function fd(a){return fa(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function gd(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function Lc(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=hd(a),d=hd(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function id(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+B(b));}
function jd(a){if("object"!==typeof a||null===a)return B(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=B(b[d]),c+=":",c+=jd(a[b[d]]);return c+"}"}function kd(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function ld(a,b){if(da(a))for(var c=0;c<a.length;++c)b(c,a[c]);else t(a,b)}
function md(a){H(!fd(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;--a)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;--a)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var nd=/^-?\d{1,10}$/;function hd(a){return nd.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Tb(a){try{a()}catch(b){setTimeout(function(){O("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function od(a,b,c){Object.defineProperty(a,b,{get:c})};function pd(a){var b={};try{var c=a.split(".");Ob(Xc(c[0])||"");b=Ob(Xc(c[1])||"");delete b.d}catch(d){}a=b;return"object"===typeof a&&!0===x(a,"admin")};var qd=null;"undefined"!==typeof MozWebSocket?qd=MozWebSocket:"undefined"!==typeof WebSocket&&(qd=WebSocket);function rd(a,b,c,d){this.Zd=a;this.f=bd(this.Zd);this.frames=this.Ac=null;this.qb=this.rb=this.Ee=0;this.Xa=oc(b);a={v:"5"};"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");c&&(a.s=c);d&&(a.ls=d);this.Le=hc(b,"websocket",a)}var td;
rd.prototype.open=function(a,b){this.kb=b;this.fg=a;this.f("Websocket connecting to "+this.Le);this.xc=!1;Xb.set("previous_websocket_failure",!0);try{this.La=new qd(this.Le)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.fb();return}var e=this;this.La.onopen=function(){e.f("Websocket connected.");e.xc=!0};this.La.onclose=function(){e.f("Websocket connection was disconnected.");e.La=null;e.fb()};this.La.onmessage=function(a){if(null!==e.La)if(a=a.data,e.qb+=
a.length,lc(e.Xa,"bytes_received",a.length),ud(e),null!==e.frames)vd(e,a);else{a:{H(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.Ee=b;e.frames=[];a=null;break a}}e.Ee=1;e.frames=[]}null!==a&&vd(e,a)}};this.La.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.fb()}};rd.prototype.start=function(){};
rd.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==qd&&!td};rd.responsesRequiredToBeHealthy=2;rd.healthyTimeout=3E4;g=rd.prototype;g.sd=function(){Xb.remove("previous_websocket_failure")};function vd(a,b){a.frames.push(b);if(a.frames.length==a.Ee){var c=a.frames.join("");a.frames=null;c=Ob(c);a.fg(c)}}
g.send=function(a){ud(this);a=B(a);this.rb+=a.length;lc(this.Xa,"bytes_sent",a.length);a=kd(a,16384);1<a.length&&wd(this,String(a.length));for(var b=0;b<a.length;b++)wd(this,a[b])};g.Tc=function(){this.Bb=!0;this.Ac&&(clearInterval(this.Ac),this.Ac=null);this.La&&(this.La.close(),this.La=null)};g.fb=function(){this.Bb||(this.f("WebSocket is closing itself"),this.Tc(),this.kb&&(this.kb(this.xc),this.kb=null))};g.close=function(){this.Bb||(this.f("WebSocket is being closed"),this.Tc())};
function ud(a){clearInterval(a.Ac);a.Ac=setInterval(function(){a.La&&wd(a,"0");ud(a)},Math.floor(45E3))}function wd(a,b){try{a.La.send(b)}catch(c){a.f("Exception thrown from WebSocket.send():",c.message||c.data,"Closing connection."),setTimeout(r(a.fb,a),0)}};function xd(a,b,c){this.f=bd("p:rest:");this.M=a;this.Hb=b;this.Vd=c;this.$={}}function yd(a,b){if(p(b))return"tag$"+b;H(zd(a.n),"should have a tag if it's not a default query.");return a.path.toString()}g=xd.prototype;
g.bf=function(a,b,c,d){var e=a.path.toString();this.f("Listen called for "+e+" "+a.ya());var f=yd(a,c),h={};this.$[f]=h;a=Ad(a.n);var k=this;Bd(this,e+".json",a,function(a,b){var u=b;404===a&&(a=u=null);null===a&&k.Hb(e,u,!1,c);x(k.$,f)===h&&d(a?401==a?"permission_denied":"rest_error:"+a:"ok",null)})};g.Cf=function(a,b){var c=yd(a,b);delete this.$[c]};g.of=function(){};g.qe=function(){};g.ef=function(){};g.xd=function(){};g.put=function(){};g.cf=function(){};g.xe=function(){};
function Bd(a,b,c,d){c=c||{};c.format="export";a.Vd.getToken(!1).then(function(e){(e=e&&e.accessToken)&&(c.auth=e);var f=(a.M.Sc?"https://":"http://")+a.M.host+b+"?"+Fb(c);a.f("Sending REST request for "+f);var h=new XMLHttpRequest;h.onreadystatechange=function(){if(d&&4===h.readyState){a.f("REST Response for "+f+" received. status:",h.status,"response:",h.responseText);var b=null;if(200<=h.status&&300>h.status){try{b=Ob(h.responseText)}catch(c){O("Failed to parse JSON response for "+f+": "+h.responseText)}d(null,
b)}else 401!==h.status&&404!==h.status&&O("Got unsuccessful REST response for "+f+" Status: "+h.status),d(h.status);d=null}};h.open("GET",f,!0);h.send()})};function Cd(a,b,c){this.type=Dd;this.source=a;this.path=b;this.children=c}Cd.prototype.Nc=function(a){if(this.path.e())return a=this.children.subtree(new L(a)),a.e()?null:a.value?new Zb(this.source,C,a.value):new Cd(this.source,C,a);H(J(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new Cd(this.source,D(this.path),this.children)};Cd.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};function Ed(){this.hb={}}
function Fd(a,b){var c=b.type,d=b.Za;H("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");H(".priority"!==d,"Only non-priority child changes can be tracked.");var e=x(a.hb,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.hb[d]=new I("child_changed",b.Ma,d,e.Ma);else if("child_removed"==c&&"child_added"==f)delete a.hb[d];else if("child_removed"==c&&"child_changed"==f)a.hb[d]=new I("child_removed",e.pe,d);else if("child_changed"==c&&
"child_added"==f)a.hb[d]=new I("child_added",b.Ma,d);else if("child_changed"==c&&"child_changed"==f)a.hb[d]=new I("child_changed",b.Ma,d,e.pe);else throw Wc("Illegal combination of changes: "+b+" occurred after "+e);}else a.hb[d]=b};function Gd(a){this.W=a;this.g=a.n.g}function Hd(a,b,c,d){var e=[],f=[];Ja(b,function(b){"child_changed"===b.type&&a.g.nd(b.pe,b.Ma)&&f.push(new I("child_moved",b.Ma,b.Za))});Id(a,e,"child_removed",b,d,c);Id(a,e,"child_added",b,d,c);Id(a,e,"child_moved",f,d,c);Id(a,e,"child_changed",b,d,c);Id(a,e,Gc,b,d,c);return e}function Id(a,b,c,d,e,f){d=Ka(d,function(a){return a.type===c});Sa(d,r(a.Mf,a));Ja(d,function(c){var d=Jd(a,c,f);Ja(e,function(e){e.rf(c.type)&&b.push(e.createEvent(d,a.W))})})}
function Jd(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Dd=c.Xe(b.Za,b.Ma,a.g));return b}Gd.prototype.Mf=function(a,b){if(null==a.Za||null==b.Za)throw Wc("Should only compare child_ events.");return this.g.compare(new K(a.Za,a.Ma),new K(b.Za,b.Ma))};function Kd(a,b){this.Sd=a;this.Kf=b}function Ld(a){this.V=a}
Ld.prototype.gb=function(a,b,c,d){var e=new Ed,f;if(b.type===$b)b.source.ee?c=Md(this,a,b.path,b.Ja,c,d,e):(H(b.source.Ue,"Unknown source."),f=b.source.De||Ic(a.u())&&!b.path.e(),c=Nd(this,a,b.path,b.Ja,c,d,f,e));else if(b.type===Dd)b.source.ee?c=Od(this,a,b.path,b.children,c,d,e):(H(b.source.Ue,"Unknown source."),f=b.source.De||Ic(a.u()),c=Pd(this,a,b.path,b.children,c,d,f,e));else if(b.type===Qd)if(b.Id)if(b=b.path,null!=c.mc(b))c=a;else{f=new Bc(c,a,d);d=a.O.j();if(b.e()||".priority"===J(b))Hc(a.u())?
b=c.Ba(Ec(a)):(b=a.u().j(),H(b instanceof P,"serverChildren would be complete if leaf node"),b=c.sc(b)),b=this.V.za(d,b,e);else{var h=J(b),k=c.rc(h,a.u());null==k&&Cc(a.u(),h)&&(k=d.R(h));b=null!=k?this.V.F(d,h,k,D(b),f,e):a.O.j().Fa(h)?this.V.F(d,h,F,D(b),f,e):d;b.e()&&Hc(a.u())&&(d=c.Ba(Ec(a)),d.J()&&(b=this.V.za(b,d,e)))}d=Hc(a.u())||null!=c.mc(C);c=Rd(a,b,d,this.V.Qa())}else c=Sd(this,a,b.path,b.Pb,c,d,e);else if(b.type===bc)d=b.path,b=a.u(),f=b.j(),h=b.ea||d.e(),c=Td(this,new Ud(a.O,new Dc(f,
h,b.Tb)),d,c,Ac,e);else throw Wc("Unknown operation type: "+b.type);e=sa(e.hb);d=c;b=d.O;b.ea&&(f=b.j().J()||b.j().e(),h=Vd(a),(0<e.length||!a.O.ea||f&&!b.j().ca(h)||!b.j().C().ca(h.C()))&&e.push(Fc(Vd(d))));return new Kd(c,e)};
function Td(a,b,c,d,e,f){var h=b.O;if(null!=d.mc(c))return b;var k;if(c.e())H(Hc(b.u()),"If change path is empty, we must have complete server data"),Ic(b.u())?(e=Ec(b),d=d.sc(e instanceof P?e:F)):d=d.Ba(Ec(b)),f=a.V.za(b.O.j(),d,f);else{var m=J(c);if(".priority"==m)H(1==Wd(c),"Can't have a priority with additional path components"),f=h.j(),k=b.u().j(),d=d.$c(c,f,k),f=null!=d?a.V.ga(f,d):h.j();else{var l=D(c);Cc(h,m)?(k=b.u().j(),d=d.$c(c,h.j(),k),d=null!=d?h.j().R(m).F(l,d):h.j().R(m)):d=d.rc(m,
b.u());f=null!=d?a.V.F(h.j(),m,d,l,e,f):h.j()}}return Rd(b,f,h.ea||c.e(),a.V.Qa())}function Nd(a,b,c,d,e,f,h,k){var m=b.u();h=h?a.V:a.V.Vb();if(c.e())d=h.za(m.j(),d,null);else if(h.Qa()&&!m.Tb)d=m.j().F(c,d),d=h.za(m.j(),d,null);else{var l=J(c);if(!Jc(m,c)&&1<Wd(c))return b;var u=D(c);d=m.j().R(l).F(u,d);d=".priority"==l?h.ga(m.j(),d):h.F(m.j(),l,d,u,Ac,null)}m=m.ea||c.e();b=new Ud(b.O,new Dc(d,m,h.Qa()));return Td(a,b,c,e,new Bc(e,b,f),k)}
function Md(a,b,c,d,e,f,h){var k=b.O;e=new Bc(e,b,f);if(c.e())h=a.V.za(b.O.j(),d,h),a=Rd(b,h,!0,a.V.Qa());else if(f=J(c),".priority"===f)h=a.V.ga(b.O.j(),d),a=Rd(b,h,k.ea,k.Tb);else{c=D(c);var m=k.j().R(f);if(!c.e()){var l=e.Ve(f);d=null!=l?".priority"===Xd(c)&&l.Q(c.parent()).e()?l:l.F(c,d):F}m.ca(d)?a=b:(h=a.V.F(k.j(),f,d,c,e,h),a=Rd(b,h,k.ea,a.V.Qa()))}return a}
function Od(a,b,c,d,e,f,h){var k=b;Yd(d,function(d,l){var u=c.m(d);Cc(b.O,J(u))&&(k=Md(a,k,u,l,e,f,h))});Yd(d,function(d,l){var u=c.m(d);Cc(b.O,J(u))||(k=Md(a,k,u,l,e,f,h))});return k}function Zd(a,b){Yd(b,function(b,d){a=a.F(b,d)});return a}
function Pd(a,b,c,d,e,f,h,k){if(b.u().j().e()&&!Hc(b.u()))return b;var m=b;c=c.e()?d:$d(Q,c,d);var l=b.u().j();c.children.ia(function(c,d){if(l.Fa(c)){var G=b.u().j().R(c),G=Zd(G,d);m=Nd(a,m,new L(c),G,e,f,h,k)}});c.children.ia(function(c,d){var G=!Cc(b.u(),c)&&null==d.value;l.Fa(c)||G||(G=b.u().j().R(c),G=Zd(G,d),m=Nd(a,m,new L(c),G,e,f,h,k))});return m}
function Sd(a,b,c,d,e,f,h){if(null!=e.mc(c))return b;var k=Ic(b.u()),m=b.u();if(null!=d.value){if(c.e()&&m.ea||Jc(m,c))return Nd(a,b,c,m.j().Q(c),e,f,k,h);if(c.e()){var l=Q;m.j().P(ae,function(a,b){l=l.set(new L(a),b)});return Pd(a,b,c,l,e,f,k,h)}return b}l=Q;Yd(d,function(a){var b=c.m(a);Jc(m,b)&&(l=l.set(a,m.j().Q(b)))});return Pd(a,b,c,l,e,f,k,h)};function be(a){this.g=a}g=be.prototype;g.F=function(a,b,c,d,e,f){H(a.zc(this.g),"A node must be indexed if only a child is updated");e=a.R(b);if(e.Q(d).ca(c.Q(d))&&e.e()==c.e())return a;null!=f&&(c.e()?a.Fa(b)?Fd(f,new I("child_removed",e,b)):H(a.J(),"A child remove without an old child only makes sense on a leaf node"):e.e()?Fd(f,new I("child_added",c,b)):Fd(f,new I("child_changed",c,b,e)));return a.J()&&c.e()?a:a.U(b,c).ob(this.g)};
g.za=function(a,b,c){null!=c&&(a.J()||a.P(N,function(a,e){b.Fa(a)||Fd(c,new I("child_removed",e,a))}),b.J()||b.P(N,function(b,e){if(a.Fa(b)){var f=a.R(b);f.ca(e)||Fd(c,new I("child_changed",e,b,f))}else Fd(c,new I("child_added",e,b))}));return b.ob(this.g)};g.ga=function(a,b){return a.e()?F:a.ga(b)};g.Qa=function(){return!1};g.Vb=function(){return this};function ce(a){this.he=new be(a.g);this.g=a.g;var b;a.ka?(b=de(a),b=a.g.Fc(ee(a),b)):b=a.g.Ic();this.Uc=b;a.na?(b=fe(a),a=a.g.Fc(ge(a),b)):a=a.g.Gc();this.wc=a}g=ce.prototype;g.matches=function(a){return 0>=this.g.compare(this.Uc,a)&&0>=this.g.compare(a,this.wc)};g.F=function(a,b,c,d,e,f){this.matches(new K(b,c))||(c=F);return this.he.F(a,b,c,d,e,f)};
g.za=function(a,b,c){b.J()&&(b=F);var d=b.ob(this.g),d=d.ga(F),e=this;b.P(N,function(a,b){e.matches(new K(a,b))||(d=d.U(a,F))});return this.he.za(a,d,c)};g.ga=function(a){return a};g.Qa=function(){return!0};g.Vb=function(){return this.he};function he(a){this.sa=new ce(a);this.g=a.g;H(a.xa,"Only valid if limit has been set");this.oa=a.oa;this.Jb=!ie(a)}g=he.prototype;g.F=function(a,b,c,d,e,f){this.sa.matches(new K(b,c))||(c=F);return a.R(b).ca(c)?a:a.Fb()<this.oa?this.sa.Vb().F(a,b,c,d,e,f):je(this,a,b,c,e,f)};
g.za=function(a,b,c){var d;if(b.J()||b.e())d=F.ob(this.g);else if(2*this.oa<b.Fb()&&b.zc(this.g)){d=F.ob(this.g);b=this.Jb?b.$b(this.sa.wc,this.g):b.Yb(this.sa.Uc,this.g);for(var e=0;0<b.Sa.length&&e<this.oa;){var f=R(b),h;if(h=this.Jb?0>=this.g.compare(this.sa.Uc,f):0>=this.g.compare(f,this.sa.wc))d=d.U(f.name,f.S),e++;else break}}else{d=b.ob(this.g);d=d.ga(F);var k,m,l;if(this.Jb){b=d.Ye(this.g);k=this.sa.wc;m=this.sa.Uc;var u=ke(this.g);l=function(a,b){return u(b,a)}}else b=d.Xb(this.g),k=this.sa.Uc,
m=this.sa.wc,l=ke(this.g);for(var e=0,z=!1;0<b.Sa.length;)f=R(b),!z&&0>=l(k,f)&&(z=!0),(h=z&&e<this.oa&&0>=l(f,m))?e++:d=d.U(f.name,F)}return this.sa.Vb().za(a,d,c)};g.ga=function(a){return a};g.Qa=function(){return!0};g.Vb=function(){return this.sa.Vb()};
function je(a,b,c,d,e,f){var h;if(a.Jb){var k=ke(a.g);h=function(a,b){return k(b,a)}}else h=ke(a.g);H(b.Fb()==a.oa,"");var m=new K(c,d),l=a.Jb?le(b,a.g):me(b,a.g),u=a.sa.matches(m);if(b.Fa(c)){for(var z=b.R(c),l=e.fe(a.g,l,a.Jb);null!=l&&(l.name==c||b.Fa(l.name));)l=e.fe(a.g,l,a.Jb);e=null==l?1:h(l,m);if(u&&!d.e()&&0<=e)return null!=f&&Fd(f,new I("child_changed",d,c,z)),b.U(c,d);null!=f&&Fd(f,new I("child_removed",z,c));b=b.U(c,F);return null!=l&&a.sa.matches(l)?(null!=f&&Fd(f,new I("child_added",
l.S,l.name)),b.U(l.name,l.S)):b}return d.e()?b:u&&0<=h(l,m)?(null!=f&&(Fd(f,new I("child_removed",l.S,l.name)),Fd(f,new I("child_added",d,c))),b.U(c,d).U(l.name,F)):b};function Uc(a,b){this.B=a;H(p(this.B)&&null!==this.B,"LeafNode shouldn't be created with null/undefined value.");this.aa=b||F;ne(this.aa);this.Eb=null}var oe=["object","boolean","number","string"];g=Uc.prototype;g.J=function(){return!0};g.C=function(){return this.aa};g.ga=function(a){return new Uc(this.B,a)};g.R=function(a){return".priority"===a?this.aa:F};g.Q=function(a){return a.e()?this:".priority"===J(a)?this.aa:F};g.Fa=function(){return!1};g.Xe=function(){return null};
g.U=function(a,b){return".priority"===a?this.ga(b):b.e()&&".priority"!==a?this:F.U(a,b).ga(this.aa)};g.F=function(a,b){var c=J(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;H(".priority"!==c||1===Wd(a),".priority must be the last token in a path");return this.U(c,F.F(D(a),b))};g.e=function(){return!1};g.Fb=function(){return 0};g.P=function(){return!1};g.H=function(a){return a&&!this.C().e()?{".value":this.Ea(),".priority":this.C().H()}:this.Ea()};
g.hash=function(){if(null===this.Eb){var a="";this.aa.e()||(a+="priority:"+pe(this.aa.H())+":");var b=typeof this.B,a=a+(b+":"),a="number"===b?a+md(this.B):a+this.B;this.Eb=Yc(a)}return this.Eb};g.Ea=function(){return this.B};g.tc=function(a){if(a===F)return 1;if(a instanceof P)return-1;H(a.J(),"Unknown node type");var b=typeof a.B,c=typeof this.B,d=Ia(oe,b),e=Ia(oe,c);H(0<=d,"Unknown leaf type: "+b);H(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.B<a.B?-1:this.B===a.B?0:1:e-d};
g.ob=function(){return this};g.zc=function(){return!0};g.ca=function(a){return a===this?!0:a.J()?this.B===a.B&&this.aa.ca(a.aa):!1};g.toString=function(){return B(this.H(!0))};function qe(){}var re={};function ke(a){return r(a.compare,a)}qe.prototype.nd=function(a,b){return 0!==this.compare(new K("[MIN_NAME]",a),new K("[MIN_NAME]",b))};qe.prototype.Ic=function(){return se};function te(a){H(!a.e()&&".priority"!==J(a),"Can't create PathIndex with empty path or .priority key");this.cc=a}ka(te,qe);g=te.prototype;g.yc=function(a){return!a.Q(this.cc).e()};g.compare=function(a,b){var c=a.S.Q(this.cc),d=b.S.Q(this.cc),c=c.tc(d);return 0===c?Lc(a.name,b.name):c};
g.Fc=function(a,b){var c=M(a),c=F.F(this.cc,c);return new K(b,c)};g.Gc=function(){var a=F.F(this.cc,ue);return new K("[MAX_NAME]",a)};g.toString=function(){return this.cc.slice().join("/")};function ve(){}ka(ve,qe);g=ve.prototype;g.compare=function(a,b){var c=a.S.C(),d=b.S.C(),c=c.tc(d);return 0===c?Lc(a.name,b.name):c};g.yc=function(a){return!a.C().e()};g.nd=function(a,b){return!a.C().ca(b.C())};g.Ic=function(){return se};g.Gc=function(){return new K("[MAX_NAME]",new Uc("[PRIORITY-POST]",ue))};
g.Fc=function(a,b){var c=M(a);return new K(b,new Uc("[PRIORITY-POST]",c))};g.toString=function(){return".priority"};var N=new ve;function we(){}ka(we,qe);g=we.prototype;g.compare=function(a,b){return Lc(a.name,b.name)};g.yc=function(){throw Wc("KeyIndex.isDefinedOn not expected to be called.");};g.nd=function(){return!1};g.Ic=function(){return se};g.Gc=function(){return new K("[MAX_NAME]",F)};g.Fc=function(a){H(q(a),"KeyIndex indexValue must always be a string.");return new K(a,F)};g.toString=function(){return".key"};
var ae=new we;function xe(){}ka(xe,qe);g=xe.prototype;g.compare=function(a,b){var c=a.S.tc(b.S);return 0===c?Lc(a.name,b.name):c};g.yc=function(){return!0};g.nd=function(a,b){return!a.ca(b)};g.Ic=function(){return se};g.Gc=function(){return ye};g.Fc=function(a,b){var c=M(a);return new K(b,c)};g.toString=function(){return".value"};var ze=new xe;function Ae(){this.Sb=this.na=this.Lb=this.ka=this.xa=!1;this.oa=0;this.oc="";this.ec=null;this.Ab="";this.bc=null;this.yb="";this.g=N}var Be=new Ae;function ie(a){return""===a.oc?a.ka:"l"===a.oc}function ee(a){H(a.ka,"Only valid if start has been set");return a.ec}function de(a){H(a.ka,"Only valid if start has been set");return a.Lb?a.Ab:"[MIN_NAME]"}function ge(a){H(a.na,"Only valid if end has been set");return a.bc}
function fe(a){H(a.na,"Only valid if end has been set");return a.Sb?a.yb:"[MAX_NAME]"}function Ce(a){var b=new Ae;b.xa=a.xa;b.oa=a.oa;b.ka=a.ka;b.ec=a.ec;b.Lb=a.Lb;b.Ab=a.Ab;b.na=a.na;b.bc=a.bc;b.Sb=a.Sb;b.yb=a.yb;b.g=a.g;return b}g=Ae.prototype;g.me=function(a){var b=Ce(this);b.xa=!0;b.oa=a;b.oc="l";return b};g.ne=function(a){var b=Ce(this);b.xa=!0;b.oa=a;b.oc="r";return b};g.Nd=function(a,b){var c=Ce(this);c.ka=!0;p(a)||(a=null);c.ec=a;null!=b?(c.Lb=!0,c.Ab=b):(c.Lb=!1,c.Ab="");return c};
g.fd=function(a,b){var c=Ce(this);c.na=!0;p(a)||(a=null);c.bc=a;p(b)?(c.Sb=!0,c.yb=b):(c.Dg=!1,c.yb="");return c};function De(a,b){var c=Ce(a);c.g=b;return c}function Ee(a){var b={};a.ka&&(b.sp=a.ec,a.Lb&&(b.sn=a.Ab));a.na&&(b.ep=a.bc,a.Sb&&(b.en=a.yb));if(a.xa){b.l=a.oa;var c=a.oc;""===c&&(c=ie(a)?"l":"r");b.vf=c}a.g!==N&&(b.i=a.g.toString());return b}function S(a){return!(a.ka||a.na||a.xa)}function zd(a){return S(a)&&a.g==N}
function Ad(a){var b={};if(zd(a))return b;var c;a.g===N?c="$priority":a.g===ze?c="$value":a.g===ae?c="$key":(H(a.g instanceof te,"Unrecognized index type!"),c=a.g.toString());b.orderBy=B(c);a.ka&&(b.startAt=B(a.ec),a.Lb&&(b.startAt+=","+B(a.Ab)));a.na&&(b.endAt=B(a.bc),a.Sb&&(b.endAt+=","+B(a.yb)));a.xa&&(ie(a)?b.limitToFirst=a.oa:b.limitToLast=a.oa);return b}g.toString=function(){return B(Ee(this))};function Fe(a,b){this.od=a;this.dc=b}Fe.prototype.get=function(a){var b=x(this.od,a);if(!b)throw Error("No index defined for "+a);return b===re?null:b};function Ge(a,b,c){var d=oa(a.od,function(d,f){var h=x(a.dc,f);H(h,"Missing index implementation for "+f);if(d===re){if(h.yc(b.S)){for(var k=[],m=c.Xb(Nc),l=R(m);l;)l.name!=b.name&&k.push(l),l=R(m);k.push(b);return He(k,ke(h))}return re}h=c.get(b.name);k=d;h&&(k=k.remove(new K(b.name,h)));return k.Ra(b,b.S)});return new Fe(d,a.dc)}
function Ie(a,b,c){var d=oa(a.od,function(a){if(a===re)return a;var d=c.get(b.name);return d?a.remove(new K(b.name,d)):a});return new Fe(d,a.dc)}var Je=new Fe({".priority":re},{".priority":N});function Ke(){this.set={}}g=Ke.prototype;g.add=function(a,b){this.set[a]=null!==b?b:!0};g.contains=function(a){return Bb(this.set,a)};g.get=function(a){return this.contains(a)?this.set[a]:void 0};g.remove=function(a){delete this.set[a]};g.clear=function(){this.set={}};g.e=function(){return xa(this.set)};g.count=function(){return qa(this.set)};function Le(a,b){t(a.set,function(a,d){b(d,a)})}g.keys=function(){var a=[];t(this.set,function(b,c){a.push(c)});return a};function Me(a,b,c,d){this.Zd=a;this.f=bd(a);this.kc=b;this.qb=this.rb=0;this.Xa=oc(b);this.zf=c;this.xc=!1;this.Db=d;this.Yc=function(a){return hc(b,"long_polling",a)}}var Ne,Oe;
Me.prototype.open=function(a,b){this.Oe=0;this.ja=b;this.df=new Qb(a);this.Bb=!1;var c=this;this.tb=setTimeout(function(){c.f("Timed out trying to connect.");c.fb();c.tb=null},Math.floor(3E4));gd(function(){if(!c.Bb){c.Wa=new Pe(function(a,b,d,k,m){Qe(c,arguments);if(c.Wa)if(c.tb&&(clearTimeout(c.tb),c.tb=null),c.xc=!0,"start"==a)c.id=b,c.kf=d;else if("close"===a)b?(c.Wa.Kd=!1,Rb(c.df,b,function(){c.fb()})):c.fb();else throw Error("Unrecognized command received: "+a);},function(a,b){Qe(c,arguments);
Sb(c.df,a,b)},function(){c.fb()},c.Yc);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Wa.Qd&&(a.cb=c.Wa.Qd);a.v="5";c.zf&&(a.s=c.zf);c.Db&&(a.ls=c.Db);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.Yc(a);c.f("Connecting via long-poll to "+a);Re(c.Wa,a,function(){})}})};
Me.prototype.start=function(){var a=this.Wa,b=this.kf;a.dg=this.id;a.eg=b;for(a.Ud=!0;Se(a););a=this.id;b=this.kf;this.gc=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.gc.src=this.Yc(c);this.gc.style.display="none";document.body.appendChild(this.gc)};
Me.isAvailable=function(){return Ne||!Oe&&"undefined"!==typeof document&&null!=document.createElement&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Ag)&&!0};g=Me.prototype;g.sd=function(){};g.Tc=function(){this.Bb=!0;this.Wa&&(this.Wa.close(),this.Wa=null);this.gc&&(document.body.removeChild(this.gc),this.gc=null);this.tb&&(clearTimeout(this.tb),this.tb=null)};
g.fb=function(){this.Bb||(this.f("Longpoll is closing itself"),this.Tc(),this.ja&&(this.ja(this.xc),this.ja=null))};g.close=function(){this.Bb||(this.f("Longpoll is being closed."),this.Tc())};g.send=function(a){a=B(a);this.rb+=a.length;lc(this.Xa,"bytes_sent",a.length);a=Mb(a);a=ab(a,!0);a=kd(a,1840);for(var b=0;b<a.length;b++){var c=this.Wa;c.Qc.push({sg:this.Oe,yg:a.length,Qe:a[b]});c.Ud&&Se(c);this.Oe++}};function Qe(a,b){var c=B(b).length;a.qb+=c;lc(a.Xa,"bytes_received",c)}
function Pe(a,b,c,d){this.Yc=d;this.kb=c;this.ue=new Ke;this.Qc=[];this.$d=Math.floor(1E8*Math.random());this.Kd=!0;this.Qd=Vc();window["pLPCommand"+this.Qd]=a;window["pRTLPCB"+this.Qd]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||E("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.ib=a.contentDocument:a.contentWindow?a.ib=a.contentWindow.document:a.document&&(a.ib=a.document);this.Ga=a;a="";this.Ga.src&&"javascript:"===this.Ga.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ga.ib.open(),this.Ga.ib.write(a),this.Ga.ib.close()}catch(f){E("frame writing exception"),f.stack&&E(f.stack),E(f)}}
Pe.prototype.close=function(){this.Ud=!1;if(this.Ga){this.Ga.ib.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ga&&(document.body.removeChild(a.Ga),a.Ga=null)},Math.floor(0))}var b=this.kb;b&&(this.kb=null,b())};
function Se(a){if(a.Ud&&a.Kd&&a.ue.count()<(0<a.Qc.length?2:1)){a.$d++;var b={};b.id=a.dg;b.pw=a.eg;b.ser=a.$d;for(var b=a.Yc(b),c="",d=0;0<a.Qc.length;)if(1870>=a.Qc[0].Qe.length+30+c.length){var e=a.Qc.shift(),c=c+"&seg"+d+"="+e.sg+"&ts"+d+"="+e.yg+"&d"+d+"="+e.Qe;d++}else break;Te(a,b+c,a.$d);return!0}return!1}function Te(a,b,c){function d(){a.ue.remove(c);Se(a)}a.ue.add(c,1);var e=setTimeout(d,Math.floor(25E3));Re(a,b,function(){clearTimeout(e);d()})}
function Re(a,b,c){setTimeout(function(){try{if(a.Kd){var d=a.Ga.ib.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){E("Long-poll script failed to load: "+b);a.Kd=!1;a.close()};a.Ga.ib.body.appendChild(d)}}catch(e){}},Math.floor(1))};function Ue(a){Ve(this,a)}var We=[Me,rd];function Ve(a,b){var c=rd&&rd.isAvailable(),d=c&&!(Xb.af||!0===Xb.get("previous_websocket_failure"));b.zg&&(c||O("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.Wc=[rd];else{var e=a.Wc=[];ld(We,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function Xe(a){if(0<a.Wc.length)return a.Wc[0];throw Error("No transports available");};function Ye(a,b,c,d,e,f,h){this.id=a;this.f=bd("c:"+this.id+":");this.se=c;this.Mc=d;this.ja=e;this.re=f;this.M=b;this.Ad=[];this.Me=0;this.yf=new Ue(b);this.L=0;this.Db=h;this.f("Connection created");Ze(this)}
function Ze(a){var b=Xe(a.yf);a.I=new b("c:"+a.id+":"+a.Me++,a.M,void 0,a.Db);a.we=b.responsesRequiredToBeHealthy||0;var c=$e(a,a.I),d=af(a,a.I);a.Xc=a.I;a.Rc=a.I;a.D=null;a.Cb=!1;setTimeout(function(){a.I&&a.I.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.md=setTimeout(function(){a.md=null;a.Cb||(a.I&&102400<a.I.qb?(a.f("Connection exceeded healthy timeout but has received "+a.I.qb+" bytes.  Marking connection healthy."),a.Cb=!0,a.I.sd()):a.I&&10240<a.I.rb?a.f("Connection exceeded healthy timeout but has sent "+
a.I.rb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function af(a,b){return function(c){b===a.I?(a.I=null,c||0!==a.L?1===a.L&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.M.bb.substr(0,2)&&(Xb.remove("host:"+a.M.host),a.M.bb=a.M.host)),a.close()):b===a.D?(a.f("Secondary connection lost."),c=a.D,a.D=null,a.Xc!==c&&a.Rc!==c||a.close()):a.f("closing an old connection")}}
function $e(a,b){return function(c){if(2!=a.L)if(b===a.Rc){var d=id("t",c);c=id("d",c);if("c"==d){if(d=id("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.wf=c.s;gc(a.M,f);0==a.L&&(a.I.start(),bf(a,a.I,d),"5"!==e&&O("Protocol version mismatch detected"),c=a.yf,(c=1<c.Wc.length?c.Wc[1]:null)&&cf(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.Rc=a.D;for(c=0;c<a.Ad.length;++c)a.wd(a.Ad[c]);a.Ad=[];df(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.re&&(a.re(c),a.re=null),a.ja=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),gc(a.M,c),1===a.L?a.close():(ef(a),Ze(a))):"e"===d?cd("Server Error: "+c):"o"===d?(a.f("got pong on primary."),ff(a),gf(a)):cd("Unknown control packet command: "+d)}else"d"==d&&a.wd(c)}else if(b===a.D)if(d=id("t",c),c=id("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?hf(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.D.close(),a.Xc!==a.D&&a.Rc!==a.D||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.uf--,hf(a)));else if("d"==d)a.Ad.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}Ye.prototype.ua=function(a){jf(this,{t:"d",d:a})};function df(a){a.Xc===a.D&&a.Rc===a.D&&(a.f("cleaning up and promoting a connection: "+a.D.Zd),a.I=a.D,a.D=null)}
function hf(a){0>=a.uf?(a.f("Secondary connection is healthy."),a.Cb=!0,a.D.sd(),a.D.start(),a.f("sending client ack on secondary"),a.D.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.I.send({t:"c",d:{t:"n",d:{}}}),a.Xc=a.D,df(a)):(a.f("sending ping on secondary."),a.D.send({t:"c",d:{t:"p",d:{}}}))}Ye.prototype.wd=function(a){ff(this);this.se(a)};function ff(a){a.Cb||(a.we--,0>=a.we&&(a.f("Primary connection is healthy."),a.Cb=!0,a.I.sd()))}
function cf(a,b){a.D=new b("c:"+a.id+":"+a.Me++,a.M,a.wf);a.uf=b.responsesRequiredToBeHealthy||0;a.D.open($e(a,a.D),af(a,a.D));setTimeout(function(){a.D&&(a.f("Timed out trying to upgrade."),a.D.close())},Math.floor(6E4))}function bf(a,b,c){a.f("Realtime connection established.");a.I=b;a.L=1;a.Mc&&(a.Mc(c,a.wf),a.Mc=null);0===a.we?(a.f("Primary connection is healthy."),a.Cb=!0):setTimeout(function(){gf(a)},Math.floor(5E3))}
function gf(a){a.Cb||1!==a.L||(a.f("sending ping on primary."),jf(a,{t:"c",d:{t:"p",d:{}}}))}function jf(a,b){if(1!==a.L)throw"Connection is not connected";a.Xc.send(b)}Ye.prototype.close=function(){2!==this.L&&(this.f("Closing realtime connection."),this.L=2,ef(this),this.ja&&(this.ja(),this.ja=null))};function ef(a){a.f("Shutting down all connections");a.I&&(a.I.close(),a.I=null);a.D&&(a.D.close(),a.D=null);a.md&&(clearTimeout(a.md),a.md=null)};function L(a,b){if(1==arguments.length){this.o=a.split("/");for(var c=0,d=0;d<this.o.length;d++)0<this.o[d].length&&(this.o[c]=this.o[d],c++);this.o.length=c;this.Z=0}else this.o=a,this.Z=b}function T(a,b){var c=J(a);if(null===c)return b;if(c===J(b))return T(D(a),D(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
function kf(a,b){for(var c=a.slice(),d=b.slice(),e=0;e<c.length&&e<d.length;e++){var f=Lc(c[e],d[e]);if(0!==f)return f}return c.length===d.length?0:c.length<d.length?-1:1}function J(a){return a.Z>=a.o.length?null:a.o[a.Z]}function Wd(a){return a.o.length-a.Z}function D(a){var b=a.Z;b<a.o.length&&b++;return new L(a.o,b)}function Xd(a){return a.Z<a.o.length?a.o[a.o.length-1]:null}g=L.prototype;
g.toString=function(){for(var a="",b=this.Z;b<this.o.length;b++)""!==this.o[b]&&(a+="/"+this.o[b]);return a||"/"};g.slice=function(a){return this.o.slice(this.Z+(a||0))};g.parent=function(){if(this.Z>=this.o.length)return null;for(var a=[],b=this.Z;b<this.o.length-1;b++)a.push(this.o[b]);return new L(a,0)};
g.m=function(a){for(var b=[],c=this.Z;c<this.o.length;c++)b.push(this.o[c]);if(a instanceof L)for(c=a.Z;c<a.o.length;c++)b.push(a.o[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new L(b,0)};g.e=function(){return this.Z>=this.o.length};g.ca=function(a){if(Wd(this)!==Wd(a))return!1;for(var b=this.Z,c=a.Z;b<=this.o.length;b++,c++)if(this.o[b]!==a.o[c])return!1;return!0};
g.contains=function(a){var b=this.Z,c=a.Z;if(Wd(this)>Wd(a))return!1;for(;b<this.o.length;){if(this.o[b]!==a.o[c])return!1;++b;++c}return!0};var C=new L("");function lf(a,b){this.Ta=a.slice();this.Ka=Math.max(1,this.Ta.length);this.Re=b;for(var c=0;c<this.Ta.length;c++)this.Ka+=Nb(this.Ta[c]);mf(this)}lf.prototype.push=function(a){0<this.Ta.length&&(this.Ka+=1);this.Ta.push(a);this.Ka+=Nb(a);mf(this)};lf.prototype.pop=function(){var a=this.Ta.pop();this.Ka-=Nb(a);0<this.Ta.length&&--this.Ka};
function mf(a){if(768<a.Ka)throw Error(a.Re+"has a key path longer than 768 bytes ("+a.Ka+").");if(32<a.Ta.length)throw Error(a.Re+"path specified exceeds the maximum depth that can be written (32) or object contains a cycle "+nf(a));}function nf(a){return 0==a.Ta.length?"":"in property '"+a.Ta.join(".")+"'"};function of(a){a instanceof pf||dd("Don't call new Database() directly - please use firebase.database().");this.ta=a;this.ba=new U(a,C);this.INTERNAL=new qf(this)}var rf={TIMESTAMP:{".sv":"timestamp"}};g=of.prototype;g.app=null;g.nf=function(a){sf(this,"ref");y("database.ref",0,1,arguments.length);return p(a)?this.ba.m(a):this.ba};
g.pg=function(a){sf(this,"database.refFromURL");y("database.refFromURL",1,1,arguments.length);var b=ed(a);tf("database.refFromURL",b);var c=b.kc;c.host!==this.ta.M.host&&dd("database.refFromURL: Host name does not match the current database: (found "+c.host+" but expected "+this.ta.M.host+")");return this.nf(b.path.toString())};function sf(a,b){null===a.ta&&dd("Cannot call "+b+" on a deleted database.")}g.Yf=function(){y("database.goOffline",0,0,arguments.length);sf(this,"goOffline");this.ta.eb()};
g.Zf=function(){y("database.goOnline",0,0,arguments.length);sf(this,"goOnline");this.ta.lc()};Object.defineProperty(of.prototype,"app",{get:function(){return this.ta.app}});function qf(a){this.$a=a}qf.prototype.delete=function(){sf(this.$a,"delete");var a=uf.Wb(),b=this.$a.ta;x(a.nb,b.app.name)!==b&&dd("Database "+b.app.name+" has already been deleted.");b.eb();delete a.nb[b.app.name];this.$a.ta=null;this.$a.ba=null;this.$a=this.$a.INTERNAL=null;return Promise.resolve()};of.prototype.ref=of.prototype.nf;
of.prototype.refFromURL=of.prototype.pg;of.prototype.goOnline=of.prototype.Zf;of.prototype.goOffline=of.prototype.Yf;qf.prototype["delete"]=qf.prototype.delete;function Qc(){this.k=this.B=null}Qc.prototype.find=function(a){if(null!=this.B)return this.B.Q(a);if(a.e()||null==this.k)return null;var b=J(a);a=D(a);return this.k.contains(b)?this.k.get(b).find(a):null};function Sc(a,b,c){if(b.e())a.B=c,a.k=null;else if(null!==a.B)a.B=a.B.F(b,c);else{null==a.k&&(a.k=new Ke);var d=J(b);a.k.contains(d)||a.k.add(d,new Qc);a=a.k.get(d);b=D(b);Sc(a,b,c)}}
function vf(a,b){if(b.e())return a.B=null,a.k=null,!0;if(null!==a.B){if(a.B.J())return!1;var c=a.B;a.B=null;c.P(N,function(b,c){Sc(a,new L(b),c)});return vf(a,b)}return null!==a.k?(c=J(b),b=D(b),a.k.contains(c)&&vf(a.k.get(c),b)&&a.k.remove(c),a.k.e()?(a.k=null,!0):!1):!0}function Rc(a,b,c){null!==a.B?c(b,a.B):a.P(function(a,e){var f=new L(b.toString()+"/"+a);Rc(e,f,c)})}Qc.prototype.P=function(a){null!==this.k&&Le(this.k,function(b,c){a(b,c)})};var wf=/[\[\].#$\/\u0000-\u001F\u007F]/,xf=/[\[\].#$\u0000-\u001F\u007F]/;function yf(a){return q(a)&&0!==a.length&&!wf.test(a)}function zf(a){return null===a||q(a)||fa(a)&&!fd(a)||ha(a)&&Bb(a,".sv")}function Af(a,b,c,d){d&&!p(b)||Bf(Db(a,1,d),b,c)}
function Bf(a,b,c){c instanceof L&&(c=new lf(c,a));if(!p(b))throw Error(a+"contains undefined "+nf(c));if(ga(b))throw Error(a+"contains a function "+nf(c)+" with contents: "+b.toString());if(fd(b))throw Error(a+"contains "+b.toString()+" "+nf(c));if(q(b)&&b.length>10485760/3&&10485760<Nb(b))throw Error(a+"contains a string greater than 10485760 utf8 bytes "+nf(c)+" ('"+b.substring(0,50)+"...')");if(ha(b)){var d=!1,e=!1;Cb(b,function(b,h){if(".value"===b)d=!0;else if(".priority"!==b&&".sv"!==b&&(e=
!0,!yf(b)))throw Error(a+" contains an invalid key ("+b+") "+nf(c)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');c.push(b);Bf(a,h,c);c.pop()});if(d&&e)throw Error(a+' contains ".value" child '+nf(c)+" in addition to actual children.");}}
function Cf(a,b){var c,d;for(c=0;c<b.length;c++){d=b[c];for(var e=d.slice(),f=0;f<e.length;f++)if((".priority"!==e[f]||f!==e.length-1)&&!yf(e[f]))throw Error(a+"contains an invalid key ("+e[f]+") in path "+d.toString()+'. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');}b.sort(kf);e=null;for(c=0;c<b.length;c++){d=b[c];if(null!==e&&e.contains(d))throw Error(a+"contains a path "+e.toString()+" that is ancestor of another path "+d.toString());e=d}}
function Df(a,b,c){var d=Db(a,1,!1);if(!ha(b)||da(b))throw Error(d+" must be an object containing the children to replace.");var e=[];Cb(b,function(a,b){var k=new L(a);Bf(d,b,c.m(k));if(".priority"===Xd(k)&&!zf(b))throw Error(d+"contains an invalid value for '"+k.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");e.push(k)});Cf(d,e)}
function Ef(a,b,c){if(fd(c))throw Error(Db(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!zf(c))throw Error(Db(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function Ff(a,b,c){if(!c||p(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(Db(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function Gf(a,b){if(p(b)&&!yf(b))throw Error(Db(a,2,!0)+'was an invalid key: "'+b+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function Hf(a,b){if(!q(b)||0===b.length||xf.test(b))throw Error(Db(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function If(a,b){if(".info"===J(b))throw Error(a+" failed: Can't modify data under /.info/");}
function tf(a,b){var c=b.path.toString(),d;!(d=!q(b.kc.host)||0===b.kc.host.length||!yf(b.kc.oe))&&(d=0!==c.length)&&(c&&(c=c.replace(/^\/*\.info(\/|$)/,"/")),d=!(q(c)&&0!==c.length&&!xf.test(c)));if(d)throw Error(Db(a,1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');};function V(a,b){this.ta=a;this.qa=b}V.prototype.cancel=function(a){y("Firebase.onDisconnect().cancel",0,1,arguments.length);A("Firebase.onDisconnect().cancel",1,a,!0);var b=new Hb;this.ta.xd(this.qa,Ib(b,a));return b.ra};V.prototype.cancel=V.prototype.cancel;V.prototype.remove=function(a){y("Firebase.onDisconnect().remove",0,1,arguments.length);If("Firebase.onDisconnect().remove",this.qa);A("Firebase.onDisconnect().remove",1,a,!0);var b=new Hb;Jf(this.ta,this.qa,null,Ib(b,a));return b.ra};
V.prototype.remove=V.prototype.remove;V.prototype.set=function(a,b){y("Firebase.onDisconnect().set",1,2,arguments.length);If("Firebase.onDisconnect().set",this.qa);Af("Firebase.onDisconnect().set",a,this.qa,!1);A("Firebase.onDisconnect().set",2,b,!0);var c=new Hb;Jf(this.ta,this.qa,a,Ib(c,b));return c.ra};V.prototype.set=V.prototype.set;
V.prototype.Kb=function(a,b,c){y("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);If("Firebase.onDisconnect().setWithPriority",this.qa);Af("Firebase.onDisconnect().setWithPriority",a,this.qa,!1);Ef("Firebase.onDisconnect().setWithPriority",2,b);A("Firebase.onDisconnect().setWithPriority",3,c,!0);var d=new Hb;Kf(this.ta,this.qa,a,b,Ib(d,c));return d.ra};V.prototype.setWithPriority=V.prototype.Kb;
V.prototype.update=function(a,b){y("Firebase.onDisconnect().update",1,2,arguments.length);If("Firebase.onDisconnect().update",this.qa);if(da(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Df("Firebase.onDisconnect().update",a,this.qa);A("Firebase.onDisconnect().update",2,b,!0);
c=new Hb;Lf(this.ta,this.qa,a,Ib(c,b));return c.ra};V.prototype.update=V.prototype.update;function Mf(a){H(da(a)&&0<a.length,"Requires a non-empty array");this.If=a;this.Ec={}}Mf.prototype.Fe=function(a,b){var c;c=this.Ec[a]||[];var d=c.length;if(0<d){for(var e=Array(d),f=0;f<d;f++)e[f]=c[f];c=e}else c=[];for(d=0;d<c.length;d++)c[d].Je.apply(c[d].Pa,Array.prototype.slice.call(arguments,1))};Mf.prototype.hc=function(a,b,c){Nf(this,a);this.Ec[a]=this.Ec[a]||[];this.Ec[a].push({Je:b,Pa:c});(a=this.We(a))&&b.apply(c,a)};
Mf.prototype.Jc=function(a,b,c){Nf(this,a);a=this.Ec[a]||[];for(var d=0;d<a.length;d++)if(a[d].Je===b&&(!c||c===a[d].Pa)){a.splice(d,1);break}};function Nf(a,b){H(Oa(a.If,function(a){return a===b}),"Unknown event: "+b)};function Of(){Mf.call(this,["online"]);this.ic=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.ic||(a.ic=!0,a.Fe("online",!0))},!1);window.addEventListener("offline",function(){a.ic&&(a.ic=!1,a.Fe("online",!1))},!1)}}ka(Of,Mf);Of.prototype.We=function(a){H("online"===a,"Unknown event type: "+a);return[this.ic]};ba(Of);function Pf(){Mf.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.Nb=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.Nb&&(c.Nb=b,c.Fe("visible",b))},!1)}}ka(Pf,Mf);Pf.prototype.We=function(a){H("visible"===a,"Unknown event type: "+a);return[this.Nb]};ba(Pf);var Qf=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);H(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);H(20===c.length,"nextPushId: Length should be 20.");
return c}}();function Rf(a,b){this.Oa=a;this.ba=b?b:Sf}g=Rf.prototype;g.Ra=function(a,b){return new Rf(this.Oa,this.ba.Ra(a,b,this.Oa).Y(null,null,!1,null,null))};g.remove=function(a){return new Rf(this.Oa,this.ba.remove(a,this.Oa).Y(null,null,!1,null,null))};g.get=function(a){for(var b,c=this.ba;!c.e();){b=this.Oa(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function Tf(a,b){for(var c,d=a.ba,e=null;!d.e();){c=a.Oa(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}g.e=function(){return this.ba.e()};g.count=function(){return this.ba.count()};g.Hc=function(){return this.ba.Hc()};g.fc=function(){return this.ba.fc()};g.ia=function(a){return this.ba.ia(a)};
g.Xb=function(a){return new Uf(this.ba,null,this.Oa,!1,a)};g.Yb=function(a,b){return new Uf(this.ba,a,this.Oa,!1,b)};g.$b=function(a,b){return new Uf(this.ba,a,this.Oa,!0,b)};g.Ye=function(a){return new Uf(this.ba,null,this.Oa,!0,a)};function Uf(a,b,c,d,e){this.Hd=e||null;this.ke=d;this.Sa=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.ke?a.left:a.right;else if(0===e){this.Sa.push(a);break}else this.Sa.push(a),a=this.ke?a.right:a.left}
function R(a){if(0===a.Sa.length)return null;var b=a.Sa.pop(),c;c=a.Hd?a.Hd(b.key,b.value):{key:b.key,value:b.value};if(a.ke)for(b=b.left;!b.e();)a.Sa.push(b),b=b.right;else for(b=b.right;!b.e();)a.Sa.push(b),b=b.left;return c}function Vf(a){if(0===a.Sa.length)return null;var b;b=a.Sa;b=b[b.length-1];return a.Hd?a.Hd(b.key,b.value):{key:b.key,value:b.value}}function Wf(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:Sf;this.right=null!=e?e:Sf}g=Wf.prototype;
g.Y=function(a,b,c,d,e){return new Wf(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};g.count=function(){return this.left.count()+1+this.right.count()};g.e=function(){return!1};g.ia=function(a){return this.left.ia(a)||a(this.key,this.value)||this.right.ia(a)};function Xf(a){return a.left.e()?a:Xf(a.left)}g.Hc=function(){return Xf(this).key};g.fc=function(){return this.right.e()?this.key:this.right.fc()};
g.Ra=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.Y(null,null,null,e.left.Ra(a,b,c),null):0===d?e.Y(null,b,null,null,null):e.Y(null,null,null,null,e.right.Ra(a,b,c));return Yf(e)};function Zf(a){if(a.left.e())return Sf;a.left.fa()||a.left.left.fa()||(a=$f(a));a=a.Y(null,null,null,Zf(a.left),null);return Yf(a)}
g.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.fa()||c.left.left.fa()||(c=$f(c)),c=c.Y(null,null,null,c.left.remove(a,b),null);else{c.left.fa()&&(c=ag(c));c.right.e()||c.right.fa()||c.right.left.fa()||(c=bg(c),c.left.left.fa()&&(c=ag(c),c=bg(c)));if(0===b(a,c.key)){if(c.right.e())return Sf;d=Xf(c.right);c=c.Y(d.key,d.value,null,null,Zf(c.right))}c=c.Y(null,null,null,null,c.right.remove(a,b))}return Yf(c)};g.fa=function(){return this.color};
function Yf(a){a.right.fa()&&!a.left.fa()&&(a=cg(a));a.left.fa()&&a.left.left.fa()&&(a=ag(a));a.left.fa()&&a.right.fa()&&(a=bg(a));return a}function $f(a){a=bg(a);a.right.left.fa()&&(a=a.Y(null,null,null,null,ag(a.right)),a=cg(a),a=bg(a));return a}function cg(a){return a.right.Y(null,null,a.color,a.Y(null,null,!0,null,a.right.left),null)}function ag(a){return a.left.Y(null,null,a.color,null,a.Y(null,null,!0,a.left.right,null))}
function bg(a){return a.Y(null,null,!a.color,a.left.Y(null,null,!a.left.color,null,null),a.right.Y(null,null,!a.right.color,null,null))}function dg(){}g=dg.prototype;g.Y=function(){return this};g.Ra=function(a,b){return new Wf(a,b,null)};g.remove=function(){return this};g.count=function(){return 0};g.e=function(){return!0};g.ia=function(){return!1};g.Hc=function(){return null};g.fc=function(){return null};g.fa=function(){return!1};var Sf=new dg;function P(a,b,c){this.k=a;(this.aa=b)&&ne(this.aa);a.e()&&H(!this.aa||this.aa.e(),"An empty node cannot have a priority");this.zb=c;this.Eb=null}g=P.prototype;g.J=function(){return!1};g.C=function(){return this.aa||F};g.ga=function(a){return this.k.e()?this:new P(this.k,a,this.zb)};g.R=function(a){if(".priority"===a)return this.C();a=this.k.get(a);return null===a?F:a};g.Q=function(a){var b=J(a);return null===b?this:this.R(b).Q(D(a))};g.Fa=function(a){return null!==this.k.get(a)};
g.U=function(a,b){H(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.ga(b);var c=new K(a,b),d,e;b.e()?(d=this.k.remove(a),c=Ie(this.zb,c,this.k)):(d=this.k.Ra(a,b),c=Ge(this.zb,c,this.k));e=d.e()?F:this.aa;return new P(d,e,c)};g.F=function(a,b){var c=J(a);if(null===c)return b;H(".priority"!==J(a)||1===Wd(a),".priority must be the last token in a path");var d=this.R(c).F(D(a),b);return this.U(c,d)};g.e=function(){return this.k.e()};g.Fb=function(){return this.k.count()};
var eg=/^(0|[1-9]\d*)$/;g=P.prototype;g.H=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.P(N,function(f,h){b[f]=h.H(a);c++;e&&eg.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],h;for(h in b)f[h]=b[h];return f}a&&!this.C().e()&&(b[".priority"]=this.C().H());return b};g.hash=function(){if(null===this.Eb){var a="";this.C().e()||(a+="priority:"+pe(this.C().H())+":");this.P(N,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.Eb=""===a?"":Yc(a)}return this.Eb};
g.Xe=function(a,b,c){return(c=fg(this,c))?(a=Tf(c,new K(a,b)))?a.name:null:Tf(this.k,a)};function le(a,b){var c;c=(c=fg(a,b))?(c=c.Hc())&&c.name:a.k.Hc();return c?new K(c,a.k.get(c)):null}function me(a,b){var c;c=(c=fg(a,b))?(c=c.fc())&&c.name:a.k.fc();return c?new K(c,a.k.get(c)):null}g.P=function(a,b){var c=fg(this,a);return c?c.ia(function(a){return b(a.name,a.S)}):this.k.ia(b)};g.Xb=function(a){return this.Yb(a.Ic(),a)};
g.Yb=function(a,b){var c=fg(this,b);if(c)return c.Yb(a,function(a){return a});for(var c=this.k.Yb(a.name,Nc),d=Vf(c);null!=d&&0>b.compare(d,a);)R(c),d=Vf(c);return c};g.Ye=function(a){return this.$b(a.Gc(),a)};g.$b=function(a,b){var c=fg(this,b);if(c)return c.$b(a,function(a){return a});for(var c=this.k.$b(a.name,Nc),d=Vf(c);null!=d&&0<b.compare(d,a);)R(c),d=Vf(c);return c};g.tc=function(a){return this.e()?a.e()?0:-1:a.J()||a.e()?1:a===ue?-1:0};
g.ob=function(a){if(a===ae||ua(this.zb.dc,a.toString()))return this;var b=this.zb,c=this.k;H(a!==ae,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Xb(Nc),f=R(c);f;)e=e||a.yc(f.S),d.push(f),f=R(c);d=e?He(d,ke(a)):re;e=a.toString();c=ya(b.dc);c[e]=a;a=ya(b.od);a[e]=d;return new P(this.k,this.aa,new Fe(a,c))};g.zc=function(a){return a===ae||ua(this.zb.dc,a.toString())};
g.ca=function(a){if(a===this)return!0;if(a.J())return!1;if(this.C().ca(a.C())&&this.k.count()===a.k.count()){var b=this.Xb(N);a=a.Xb(N);for(var c=R(b),d=R(a);c&&d;){if(c.name!==d.name||!c.S.ca(d.S))return!1;c=R(b);d=R(a)}return null===c&&null===d}return!1};function fg(a,b){return b===ae?null:a.zb.get(b.toString())}g.toString=function(){return B(this.H(!0))};function M(a,b){if(null===a)return F;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);H(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new Uc(a,M(c));if(a instanceof Array){var d=F,e=a;t(e,function(a,b){if(Bb(e,b)&&"."!==b.substring(0,1)){var c=M(a);if(c.J()||!c.e())d=
d.U(b,c)}});return d.ga(M(c))}var f=[],h=!1,k=a;Cb(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=M(k[a]);b.e()||(h=h||!b.C().e(),f.push(new K(a,b)))}});if(0==f.length)return F;var m=He(f,Kc,function(a){return a.name},Mc);if(h){var l=He(f,ke(N));return new P(m,M(c),new Fe({".priority":l},{".priority":N}))}return new P(m,M(c),Je)}var gg=Math.log(2);
function hg(a){this.count=parseInt(Math.log(a+1)/gg,10);this.Pe=this.count-1;this.Jf=a+1&parseInt(Array(this.count+1).join("1"),2)}function ig(a){var b=!(a.Jf&1<<a.Pe);a.Pe--;return b}
function He(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var l=a[b],u=c?c(l):l;return new Wf(u,l.S,!1,null,null)}var l=parseInt(f/2,10)+b,f=e(b,l),z=e(l+1,d),l=a[l],u=c?c(l):l;return new Wf(u,l.S,!1,f,z)}a.sort(b);var f=function(b){function d(b,h){var k=u-b,z=u;u-=b;var z=e(k+1,z),k=a[k],G=c?c(k):k,z=new Wf(G,k.S,h,null,z);f?f.left=z:l=z;f=z}for(var f=null,l=null,u=a.length,z=0;z<b.count;++z){var G=ig(b),sd=Math.pow(2,b.count-(z+1));G?d(sd,!1):(d(sd,!1),d(sd,!0))}return l}(new hg(a.length));
return null!==f?new Rf(d||b,f):new Rf(d||b)}function pe(a){return"number"===typeof a?"number:"+md(a):"string:"+a}function ne(a){if(a.J()){var b=a.H();H("string"===typeof b||"number"===typeof b||"object"===typeof b&&Bb(b,".sv"),"Priority must be a string or number.")}else H(a===ue||a.e(),"priority of unexpected type.");H(a===ue||a.C().e(),"Priority nodes can't have a priority of their own.")}var F=new P(new Rf(Mc),null,Je);function jg(){P.call(this,new Rf(Mc),F,Je)}ka(jg,P);g=jg.prototype;
g.tc=function(a){return a===this?0:1};g.ca=function(a){return a===this};g.C=function(){return this};g.R=function(){return F};g.e=function(){return!1};var ue=new jg,se=new K("[MIN_NAME]",F),ye=new K("[MAX_NAME]",ue);function W(a,b,c){this.A=a;this.W=b;this.g=c}W.prototype.H=function(){y("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.H()};W.prototype.val=W.prototype.H;W.prototype.Se=function(){y("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.H(!0)};W.prototype.exportVal=W.prototype.Se;W.prototype.Tf=function(){y("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};W.prototype.exists=W.prototype.Tf;
W.prototype.m=function(a){y("Firebase.DataSnapshot.child",0,1,arguments.length);fa(a)&&(a=String(a));Hf("Firebase.DataSnapshot.child",a);var b=new L(a),c=this.W.m(b);return new W(this.A.Q(b),c,N)};W.prototype.child=W.prototype.m;W.prototype.Fa=function(a){y("Firebase.DataSnapshot.hasChild",1,1,arguments.length);Hf("Firebase.DataSnapshot.hasChild",a);var b=new L(a);return!this.A.Q(b).e()};W.prototype.hasChild=W.prototype.Fa;
W.prototype.C=function(){y("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.C().H()};W.prototype.getPriority=W.prototype.C;W.prototype.forEach=function(a){y("Firebase.DataSnapshot.forEach",1,1,arguments.length);A("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.J())return!1;var b=this;return!!this.A.P(this.g,function(c,d){return a(new W(d,b.W.m(c),N))})};W.prototype.forEach=W.prototype.forEach;
W.prototype.kd=function(){y("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.J()?!1:!this.A.e()};W.prototype.hasChildren=W.prototype.kd;W.prototype.getKey=function(){y("Firebase.DataSnapshot.key",0,0,arguments.length);return this.W.getKey()};od(W.prototype,"key",W.prototype.getKey);W.prototype.Fb=function(){y("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.Fb()};W.prototype.numChildren=W.prototype.Fb;
W.prototype.xb=function(){y("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.W};od(W.prototype,"ref",W.prototype.xb);function Ud(a,b){this.O=a;this.Ld=b}function Rd(a,b,c,d){return new Ud(new Dc(b,c,d),a.Ld)}function Vd(a){return a.O.ea?a.O.j():null}Ud.prototype.u=function(){return this.Ld};function Ec(a){return a.Ld.ea?a.Ld.j():null};function kg(a,b){this.W=a;var c=a.n,d=new be(c.g),c=S(c)?new be(c.g):c.xa?new he(c):new ce(c);this.mf=new Ld(c);var e=b.u(),f=b.O,h=d.za(F,e.j(),null),k=c.za(F,f.j(),null);this.Na=new Ud(new Dc(k,f.ea,c.Qa()),new Dc(h,e.ea,d.Qa()));this.ab=[];this.Qf=new Gd(a)}function lg(a){return a.W}g=kg.prototype;g.u=function(){return this.Na.u().j()};g.jb=function(a){var b=Ec(this.Na);return b&&(S(this.W.n)||!a.e()&&!b.R(J(a)).e())?b.Q(a):null};g.e=function(){return 0===this.ab.length};g.Ob=function(a){this.ab.push(a)};
g.mb=function(a,b){var c=[];if(b){H(null==a,"A cancel should cancel all event registrations.");var d=this.W.path;Ja(this.ab,function(a){(a=a.Ne(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.ab.length;++f){var h=this.ab[f];if(!h.matches(a))e.push(h);else if(a.Ze()){e=e.concat(this.ab.slice(f+1));break}}this.ab=e}else this.ab=[];return c};
g.gb=function(a,b,c){a.type===Dd&&null!==a.source.Ib&&(H(Ec(this.Na),"We should always have a full cache before handling merges"),H(Vd(this.Na),"Missing event cache, even though we have a server cache"));var d=this.Na;a=this.mf.gb(d,a,b,c);b=this.mf;c=a.Sd;H(c.O.j().zc(b.V.g),"Event snap not indexed");H(c.u().j().zc(b.V.g),"Server snap not indexed");H(Hc(a.Sd.u())||!Hc(d.u()),"Once a server snap is complete, it should never go back");this.Na=a.Sd;return mg(this,a.Kf,a.Sd.O.j(),null)};
function ng(a,b){var c=a.Na.O,d=[];c.j().J()||c.j().P(N,function(a,b){d.push(new I("child_added",b,a))});c.ea&&d.push(Fc(c.j()));return mg(a,d,c.j(),b)}function mg(a,b,c,d){return Hd(a.Qf,b,c,d?[d]:a.ab)};function og(a,b,c){this.Qb=a;this.sb=b;this.ub=c||null}g=og.prototype;g.rf=function(a){return"value"===a};g.createEvent=function(a,b){var c=b.n.g;return new xc("value",this,new W(a.Ma,b.xb(),c))};g.Ub=function(a){var b=this.ub;if("cancel"===a.ge()){H(this.sb,"Raising a cancel event on a listener with no cancel callback");var c=this.sb;return function(){c.call(b,a.error)}}var d=this.Qb;return function(){d.call(b,a.Md)}};g.Ne=function(a,b){return this.sb?new yc(this,a,b):null};
g.matches=function(a){return a instanceof og?a.Qb&&this.Qb?a.Qb===this.Qb&&a.ub===this.ub:!0:!1};g.Ze=function(){return null!==this.Qb};function pg(a,b,c){this.ha=a;this.sb=b;this.ub=c}g=pg.prototype;g.rf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ha};g.Ne=function(a,b){return this.sb?new yc(this,a,b):null};
g.createEvent=function(a,b){H(null!=a.Za,"Child events should have a childName.");var c=b.xb().m(a.Za);return new xc(a.type,this,new W(a.Ma,c,b.n.g),a.Dd)};g.Ub=function(a){var b=this.ub;if("cancel"===a.ge()){H(this.sb,"Raising a cancel event on a listener with no cancel callback");var c=this.sb;return function(){c.call(b,a.error)}}var d=this.ha[a.gd];return function(){d.call(b,a.Md,a.Dd)}};
g.matches=function(a){if(a instanceof pg){if(!this.ha||!a.ha)return!0;if(this.ub===a.ub){var b=qa(a.ha);if(b===qa(this.ha)){if(1===b){var b=ra(a.ha),c=ra(this.ha);return c===b&&(!a.ha[b]||!this.ha[c]||a.ha[b]===this.ha[c])}return pa(this.ha,function(b,c){return a.ha[c]===b})}}}return!1};g.Ze=function(){return null!==this.ha};function X(a,b,c,d){this.w=a;this.path=b;this.n=c;this.Oc=d}
function qg(a){var b=null,c=null;a.ka&&(b=ee(a));a.na&&(c=ge(a));if(a.g===ae){if(a.ka){if("[MIN_NAME]"!=de(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.na){if("[MAX_NAME]"!=fe(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===N){if(null!=b&&!zf(b)||null!=c&&!zf(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(H(a.g instanceof te||a.g===ze,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function rg(a){if(a.ka&&a.na&&a.xa&&(!a.xa||""===a.oc))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function sg(a,b){if(!0===a.Oc)throw Error(b+": You can't combine multiple orderBy calls.");}g=X.prototype;g.xb=function(){y("Query.ref",0,0,arguments.length);return new U(this.w,this.path)};
g.hc=function(a,b,c,d){y("Query.on",2,4,arguments.length);Ff("Query.on",a,!1);A("Query.on",2,b,!1);var e=tg("Query.on",c,d);if("value"===a)ug(this.w,this,new og(b,e.cancel||null,e.Pa||null));else{var f={};f[a]=b;ug(this.w,this,new pg(f,e.cancel,e.Pa))}return b};
g.Jc=function(a,b,c){y("Query.off",0,3,arguments.length);Ff("Query.off",a,!0);A("Query.off",2,b,!0);Eb("Query.off",3,c);var d=null,e=null;"value"===a?d=new og(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new pg(e,null,c||null));e=this.w;d=".info"===J(this.path)?e.pd.mb(this,d):e.K.mb(this,d);tc(e.da,this.path,d)};
g.ig=function(a,b){function c(k){f&&(f=!1,e.Jc(a,c),b&&b.call(d.Pa,k),h.resolve(k))}y("Query.once",1,4,arguments.length);Ff("Query.once",a,!1);A("Query.once",2,b,!0);var d=tg("Query.once",arguments[2],arguments[3]),e=this,f=!0,h=new Hb;Jb(h.ra);this.hc(a,c,function(b){e.Jc(a,c);d.cancel&&d.cancel.call(d.Pa,b);h.reject(b)});return h.ra};
g.me=function(a){y("Query.limitToFirst",1,1,arguments.length);if(!fa(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.xa)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new X(this.w,this.path,this.n.me(a),this.Oc)};
g.ne=function(a){y("Query.limitToLast",1,1,arguments.length);if(!fa(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.xa)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new X(this.w,this.path,this.n.ne(a),this.Oc)};
g.jg=function(a){y("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');Hf("Query.orderByChild",a);sg(this,"Query.orderByChild");var b=new L(a);if(b.e())throw Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
b=new te(b);b=De(this.n,b);qg(b);return new X(this.w,this.path,b,!0)};g.kg=function(){y("Query.orderByKey",0,0,arguments.length);sg(this,"Query.orderByKey");var a=De(this.n,ae);qg(a);return new X(this.w,this.path,a,!0)};g.lg=function(){y("Query.orderByPriority",0,0,arguments.length);sg(this,"Query.orderByPriority");var a=De(this.n,N);qg(a);return new X(this.w,this.path,a,!0)};
g.mg=function(){y("Query.orderByValue",0,0,arguments.length);sg(this,"Query.orderByValue");var a=De(this.n,ze);qg(a);return new X(this.w,this.path,a,!0)};g.Nd=function(a,b){y("Query.startAt",0,2,arguments.length);Af("Query.startAt",a,this.path,!0);Gf("Query.startAt",b);var c=this.n.Nd(a,b);rg(c);qg(c);if(this.n.ka)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");p(a)||(b=a=null);return new X(this.w,this.path,c,this.Oc)};
g.fd=function(a,b){y("Query.endAt",0,2,arguments.length);Af("Query.endAt",a,this.path,!0);Gf("Query.endAt",b);var c=this.n.fd(a,b);rg(c);qg(c);if(this.n.na)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new X(this.w,this.path,c,this.Oc)};
g.Pf=function(a,b){y("Query.equalTo",1,2,arguments.length);Af("Query.equalTo",a,this.path,!1);Gf("Query.equalTo",b);if(this.n.ka)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.na)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.Nd(a,b).fd(a,b)};
g.toString=function(){y("Query.toString",0,0,arguments.length);for(var a=this.path,b="",c=a.Z;c<a.o.length;c++)""!==a.o[c]&&(b+="/"+encodeURIComponent(String(a.o[c])));return this.w.toString()+(b||"/")};g.ya=function(){var a=jd(Ee(this.n));return"{}"===a?"default":a};
function tg(a,b,c){var d={cancel:null,Pa:null};if(b&&c)d.cancel=b,A(a,3,d.cancel,!0),d.Pa=c,Eb(a,4,d.Pa);else if(b)if("object"===typeof b&&null!==b)d.Pa=b;else if("function"===typeof b)d.cancel=b;else throw Error(Db(a,3,!0)+" must either be a cancel callback or a context object.");return d}X.prototype.on=X.prototype.hc;X.prototype.off=X.prototype.Jc;X.prototype.once=X.prototype.ig;X.prototype.limitToFirst=X.prototype.me;X.prototype.limitToLast=X.prototype.ne;X.prototype.orderByChild=X.prototype.jg;
X.prototype.orderByKey=X.prototype.kg;X.prototype.orderByPriority=X.prototype.lg;X.prototype.orderByValue=X.prototype.mg;X.prototype.startAt=X.prototype.Nd;X.prototype.endAt=X.prototype.fd;X.prototype.equalTo=X.prototype.Pf;X.prototype.toString=X.prototype.toString;od(X.prototype,"ref",X.prototype.xb);function vg(a,b){this.value=a;this.children=b||wg}var wg=new Rf(function(a,b){return a===b?0:a<b?-1:1});function xg(a){var b=Q;t(a,function(a,d){b=b.set(new L(d),a)});return b}g=vg.prototype;g.e=function(){return null===this.value&&this.children.e()};function yg(a,b,c){if(null!=a.value&&c(a.value))return{path:C,value:a.value};if(b.e())return null;var d=J(b);a=a.children.get(d);return null!==a?(b=yg(a,D(b),c),null!=b?{path:(new L(d)).m(b.path),value:b.value}:null):null}
function zg(a,b){return yg(a,b,function(){return!0})}g.subtree=function(a){if(a.e())return this;var b=this.children.get(J(a));return null!==b?b.subtree(D(a)):Q};g.set=function(a,b){if(a.e())return new vg(b,this.children);var c=J(a),d=(this.children.get(c)||Q).set(D(a),b),c=this.children.Ra(c,d);return new vg(this.value,c)};
g.remove=function(a){if(a.e())return this.children.e()?Q:new vg(null,this.children);var b=J(a),c=this.children.get(b);return c?(a=c.remove(D(a)),b=a.e()?this.children.remove(b):this.children.Ra(b,a),null===this.value&&b.e()?Q:new vg(this.value,b)):this};g.get=function(a){if(a.e())return this.value;var b=this.children.get(J(a));return b?b.get(D(a)):null};
function $d(a,b,c){if(b.e())return c;var d=J(b);b=$d(a.children.get(d)||Q,D(b),c);d=b.e()?a.children.remove(d):a.children.Ra(d,b);return new vg(a.value,d)}function Ag(a,b){return Bg(a,C,b)}function Bg(a,b,c){var d={};a.children.ia(function(a,f){d[a]=Bg(f,b.m(a),c)});return c(b,a.value,d)}function Cg(a,b,c){return Dg(a,b,C,c)}function Dg(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=J(b);return(a=a.children.get(e))?Dg(a,D(b),c.m(e),d):null}
function Eg(a,b,c){Fg(a,b,C,c)}function Fg(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=J(b);return(a=a.children.get(e))?Fg(a,D(b),c.m(e),d):Q}function Yd(a,b){Gg(a,C,b)}function Gg(a,b,c){a.children.ia(function(a,e){Gg(e,b.m(a),c)});a.value&&c(b,a.value)}function Hg(a,b){a.children.ia(function(a,d){d.value&&b(a,d.value)})}var Q=new vg(null);vg.prototype.toString=function(){var a={};Yd(this,function(b,c){a[b.toString()]=c.toString()});return B(a)};function Ig(a,b,c){this.type=Qd;this.source=Jg;this.path=a;this.Pb=b;this.Id=c}Ig.prototype.Nc=function(a){if(this.path.e()){if(null!=this.Pb.value)return H(this.Pb.children.e(),"affectedTree should not have overlapping affected paths."),this;a=this.Pb.subtree(new L(a));return new Ig(C,a,this.Id)}H(J(this.path)===a,"operationForChild called for unrelated child.");return new Ig(D(this.path),this.Pb,this.Id)};
Ig.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Id+" affectedTree="+this.Pb+")"};var $b=0,Dd=1,Qd=2,bc=3;function Kg(a,b,c,d){this.ee=a;this.Ue=b;this.Ib=c;this.De=d;H(!d||b,"Tagged queries must be from server.")}var Jg=new Kg(!0,!1,null,!1),Lg=new Kg(!1,!0,null,!1);Kg.prototype.toString=function(){return this.ee?"user":this.De?"server(queryID="+this.Ib+")":"server"};function Mg(a){this.X=a}var Ng=new Mg(new vg(null));function Og(a,b,c){if(b.e())return new Mg(new vg(c));var d=zg(a.X,b);if(null!=d){var e=d.path,d=d.value;b=T(e,b);d=d.F(b,c);return new Mg(a.X.set(e,d))}a=$d(a.X,b,new vg(c));return new Mg(a)}function Pg(a,b,c){var d=a;Cb(c,function(a,c){d=Og(d,b.m(a),c)});return d}Mg.prototype.Ed=function(a){if(a.e())return Ng;a=$d(this.X,a,Q);return new Mg(a)};function Qg(a,b){var c=zg(a.X,b);return null!=c?a.X.get(c.path).Q(T(c.path,b)):null}
function Rg(a){var b=[],c=a.X.value;null!=c?c.J()||c.P(N,function(a,c){b.push(new K(a,c))}):a.X.children.ia(function(a,c){null!=c.value&&b.push(new K(a,c.value))});return b}function Sg(a,b){if(b.e())return a;var c=Qg(a,b);return null!=c?new Mg(new vg(c)):new Mg(a.X.subtree(b))}Mg.prototype.e=function(){return this.X.e()};Mg.prototype.apply=function(a){return Tg(C,this.X,a)};
function Tg(a,b,c){if(null!=b.value)return c.F(a,b.value);var d=null;b.children.ia(function(b,f){".priority"===b?(H(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Tg(a.m(b),f,c)});c.Q(a).e()||null===d||(c=c.F(a.m(".priority"),d));return c};function Ug(){this.Aa={}}g=Ug.prototype;g.e=function(){return xa(this.Aa)};g.gb=function(a,b,c){var d=a.source.Ib;if(null!==d)return d=x(this.Aa,d),H(null!=d,"SyncTree gave us an op for an invalid query."),d.gb(a,b,c);var e=[];t(this.Aa,function(d){e=e.concat(d.gb(a,b,c))});return e};g.Ob=function(a,b,c,d,e){var f=a.ya(),h=x(this.Aa,f);if(!h){var h=c.Ba(e?d:null),k=!1;h?k=!0:(h=d instanceof P?c.sc(d):F,k=!1);h=new kg(a,new Ud(new Dc(h,k,!1),new Dc(d,e,!1)));this.Aa[f]=h}h.Ob(b);return ng(h,b)};
g.mb=function(a,b,c){var d=a.ya(),e=[],f=[],h=null!=Vg(this);if("default"===d){var k=this;t(this.Aa,function(a,d){f=f.concat(a.mb(b,c));a.e()&&(delete k.Aa[d],S(a.W.n)||e.push(a.W))})}else{var m=x(this.Aa,d);m&&(f=f.concat(m.mb(b,c)),m.e()&&(delete this.Aa[d],S(m.W.n)||e.push(m.W)))}h&&null==Vg(this)&&e.push(new U(a.w,a.path));return{qg:e,Rf:f}};function Wg(a){return Ka(sa(a.Aa),function(a){return!S(a.W.n)})}g.jb=function(a){var b=null;t(this.Aa,function(c){b=b||c.jb(a)});return b};
function Xg(a,b){if(S(b.n))return Vg(a);var c=b.ya();return x(a.Aa,c)}function Vg(a){return wa(a.Aa,function(a){return S(a.W.n)})||null};function Yg(){this.T=Ng;this.la=[];this.Cc=-1}function Zg(a,b){for(var c=0;c<a.la.length;c++){var d=a.la[c];if(d.Zc===b)return d}return null}g=Yg.prototype;
g.Ed=function(a){var b=Pa(this.la,function(b){return b.Zc===a});H(0<=b,"removeWrite called with nonexistent writeId.");var c=this.la[b];this.la.splice(b,1);for(var d=c.visible,e=!1,f=this.la.length-1;d&&0<=f;){var h=this.la[f];h.visible&&(f>=b&&$g(h,c.path)?d=!1:c.path.contains(h.path)&&(e=!0));f--}if(d){if(e)this.T=ah(this.la,bh,C),this.Cc=0<this.la.length?this.la[this.la.length-1].Zc:-1;else if(c.Ja)this.T=this.T.Ed(c.path);else{var k=this;t(c.children,function(a,b){k.T=k.T.Ed(c.path.m(b))})}return!0}return!1};
g.Ba=function(a,b,c,d){if(c||d){var e=Sg(this.T,a);return!d&&e.e()?b:d||null!=b||null!=Qg(e,C)?(e=ah(this.la,function(b){return(b.visible||d)&&(!c||!(0<=Ia(c,b.Zc)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||F,e.apply(b)):null}e=Qg(this.T,a);if(null!=e)return e;e=Sg(this.T,a);return e.e()?b:null!=b||null!=Qg(e,C)?(b=b||F,e.apply(b)):null};
g.sc=function(a,b){var c=F,d=Qg(this.T,a);if(d)d.J()||d.P(N,function(a,b){c=c.U(a,b)});else if(b){var e=Sg(this.T,a);b.P(N,function(a,b){var d=Sg(e,new L(a)).apply(b);c=c.U(a,d)});Ja(Rg(e),function(a){c=c.U(a.name,a.S)})}else e=Sg(this.T,a),Ja(Rg(e),function(a){c=c.U(a.name,a.S)});return c};g.$c=function(a,b,c,d){H(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.m(b);if(null!=Qg(this.T,a))return null;a=Sg(this.T,a);return a.e()?d.Q(b):a.apply(d.Q(b))};
g.rc=function(a,b,c){a=a.m(b);var d=Qg(this.T,a);return null!=d?d:Cc(c,b)?Sg(this.T,a).apply(c.j().R(b)):null};g.mc=function(a){return Qg(this.T,a)};g.Xd=function(a,b,c,d,e,f){var h;a=Sg(this.T,a);h=Qg(a,C);if(null==h)if(null!=b)h=a.apply(b);else return[];h=h.ob(f);if(h.e()||h.J())return[];b=[];a=ke(f);e=e?h.$b(c,f):h.Yb(c,f);for(f=R(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=R(e);return b};
function $g(a,b){return a.Ja?a.path.contains(b):!!va(a.children,function(c,d){return a.path.m(d).contains(b)})}function bh(a){return a.visible}
function ah(a,b,c){for(var d=Ng,e=0;e<a.length;++e){var f=a[e];if(b(f)){var h=f.path;if(f.Ja)c.contains(h)?(h=T(c,h),d=Og(d,h,f.Ja)):h.contains(c)&&(h=T(h,c),d=Og(d,C,f.Ja.Q(h)));else if(f.children)if(c.contains(h))h=T(c,h),d=Pg(d,h,f.children);else{if(h.contains(c))if(h=T(h,c),h.e())d=Pg(d,C,f.children);else if(f=x(f.children,J(h)))f=f.Q(D(h)),d=Og(d,C,f)}else throw Wc("WriteRecord should have .snap or .children");}}return d}function ch(a,b){this.Mb=a;this.X=b}g=ch.prototype;
g.Ba=function(a,b,c){return this.X.Ba(this.Mb,a,b,c)};g.sc=function(a){return this.X.sc(this.Mb,a)};g.$c=function(a,b,c){return this.X.$c(this.Mb,a,b,c)};g.mc=function(a){return this.X.mc(this.Mb.m(a))};g.Xd=function(a,b,c,d,e){return this.X.Xd(this.Mb,a,b,c,d,e)};g.rc=function(a,b){return this.X.rc(this.Mb,a,b)};g.m=function(a){return new ch(this.Mb.m(a),this.X)};function dh(){this.children={};this.ad=0;this.value=null}function eh(a,b,c){this.ud=a?a:"";this.Ha=b?b:null;this.A=c?c:new dh}function fh(a,b){for(var c=b instanceof L?b:new L(b),d=a,e;null!==(e=J(c));)d=new eh(e,d,x(d.A.children,e)||new dh),c=D(c);return d}g=eh.prototype;g.Ea=function(){return this.A.value};function gh(a,b){H("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;hh(a)}g.clear=function(){this.A.value=null;this.A.children={};this.A.ad=0;hh(this)};
g.kd=function(){return 0<this.A.ad};g.e=function(){return null===this.Ea()&&!this.kd()};g.P=function(a){var b=this;t(this.A.children,function(c,d){a(new eh(d,b,c))})};function ih(a,b,c,d){c&&!d&&b(a);a.P(function(a){ih(a,b,!0,d)});c&&d&&b(a)}function jh(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}g.path=function(){return new L(null===this.Ha?this.ud:this.Ha.path()+"/"+this.ud)};g.name=function(){return this.ud};g.parent=function(){return this.Ha};
function hh(a){if(null!==a.Ha){var b=a.Ha,c=a.ud,d=a.e(),e=Bb(b.A.children,c);d&&e?(delete b.A.children[c],b.A.ad--,hh(b)):d||e||(b.A.children[c]=a.A,b.A.ad++,hh(b))}};function kh(a,b,c,d,e,f){this.id=lh++;this.f=bd("p:"+this.id+":");this.qd={};this.$={};this.pa=[];this.Pc=0;this.Lc=[];this.ma=!1;this.Va=1E3;this.td=3E5;this.Hb=b;this.Kc=c;this.te=d;this.M=a;this.pb=this.Ia=this.Db=this.ye=null;this.Vd=e;this.de=!1;if(f)throw Error("Auth override specified in options, but not supported on non Node.js platforms");this.Ie=f||null;this.vb=null;this.Nb=!1;this.Gd={};this.rg=0;this.Te=!0;this.Bc=this.le=null;mh(this,0);Pf.Wb().hc("visible",this.hg,this);-1===a.host.indexOf("fblocal")&&
Of.Wb().hc("online",this.gg,this)}var lh=0,nh=0;g=kh.prototype;g.ua=function(a,b,c){var d=++this.rg;a={r:d,a:a,b:b};this.f(B(a));H(this.ma,"sendRequest call when we're not connected not allowed.");this.Ia.ua(a);c&&(this.Gd[d]=c)};
g.bf=function(a,b,c,d){var e=a.ya(),f=a.path.toString();this.f("Listen called for "+f+" "+e);this.$[f]=this.$[f]||{};H(zd(a.n)||!S(a.n),"listen() called for non-default but complete query");H(!this.$[f][e],"listen() called twice for same path/queryId.");a={G:d,ld:b,ng:a,tag:c};this.$[f][e]=a;this.ma&&oh(this,a)};
function oh(a,b){var c=b.ng,d=c.path.toString(),e=c.ya();a.f("Listen on "+d+" for "+e);var f={p:d};b.tag&&(f.q=Ee(c.n),f.t=b.tag);f.h=b.ld();a.ua("q",f,function(f){var k=f.d,m=f.s;if(k&&"object"===typeof k&&Bb(k,"w")){var l=x(k,"w");da(l)&&0<=Ia(l,"no_index")&&O("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}(a.$[d]&&a.$[d][e])===b&&(a.f("listen response",f),"ok"!==m&&ph(a,d,e),b.G&&b.G(m,
k))})}g.of=function(a){this.pb=a;this.f("Auth token refreshed");this.pb?qh(this):this.ma&&this.ua("unauth",{},function(){});if(a&&40===a.length||pd(a))this.f("Admin auth credential detected.  Reducing max reconnect time."),this.td=3E4};function qh(a){if(a.ma&&a.pb){var b=a.pb,c={cred:b};a.Ie&&(c.authvar=a.Ie);a.ua("auth",c,function(c){var e=c.s;c=c.d||"error";"ok"!==e&&a.pb===b&&rh(a,e,c)})}}
g.Cf=function(a,b){var c=a.path.toString(),d=a.ya();this.f("Unlisten called for "+c+" "+d);H(zd(a.n)||!S(a.n),"unlisten() called for non-default but complete query");if(ph(this,c,d)&&this.ma){var e=Ee(a.n);this.f("Unlisten on "+c+" for "+d);c={p:c};b&&(c.q=e,c.t=b);this.ua("n",c)}};g.qe=function(a,b,c){this.ma?sh(this,"o",a,b,c):this.Lc.push({ve:a,action:"o",data:b,G:c})};g.ef=function(a,b,c){this.ma?sh(this,"om",a,b,c):this.Lc.push({ve:a,action:"om",data:b,G:c})};
g.xd=function(a,b){this.ma?sh(this,"oc",a,null,b):this.Lc.push({ve:a,action:"oc",data:null,G:b})};function sh(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.ua(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}g.put=function(a,b,c,d){th(this,"p",a,b,c,d)};g.cf=function(a,b,c,d){th(this,"m",a,b,c,d)};function th(a,b,c,d,e,f){d={p:c,d:d};p(f)&&(d.h=f);a.pa.push({action:b,qf:d,G:e});a.Pc++;b=a.pa.length-1;a.ma?uh(a,b):a.f("Buffering put: "+c)}
function uh(a,b){var c=a.pa[b].action,d=a.pa[b].qf,e=a.pa[b].G;a.pa[b].og=a.ma;a.ua(c,d,function(d){a.f(c+" response",d);delete a.pa[b];a.Pc--;0===a.Pc&&(a.pa=[]);e&&e(d.s,d.d)})}g.xe=function(a){this.ma&&(a={c:a},this.f("reportStats",a),this.ua("s",a,function(a){"ok"!==a.s&&this.f("reportStats","Error sending stats: "+a.d)}))};
g.wd=function(a){if("r"in a){this.f("from server: "+B(a));var b=a.r,c=this.Gd[b];c&&(delete this.Gd[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,a=a.b,this.f("handleServerMessage",b,a),"d"===b?this.Hb(a.p,a.d,!1,a.t):"m"===b?this.Hb(a.p,a.d,!0,a.t):"c"===b?vh(this,a.p,a.q):"ac"===b?rh(this,a.s,a.d):"sd"===b?this.ye?this.ye(a):"msg"in a&&"undefined"!==typeof console&&console.log("FIREBASE: "+a.msg.replace("\n","\nFIREBASE: ")):cd("Unrecognized action received from server: "+
B(b)+"\nAre you using the latest client?"))}};
g.Mc=function(a,b){this.f("connection ready");this.ma=!0;this.Bc=(new Date).getTime();this.te({serverTimeOffset:a-(new Date).getTime()});this.Db=b;if(this.Te){var c={};c["sdk.js."+firebase.SDK_VERSION.replace(/\./g,"-")]=1;"undefined"!==typeof window&&(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test("undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:"")?c["framework.cordova"]=1:"object"===typeof navigator&&
"ReactNative"===navigator.product&&(c["framework.reactnative"]=1);this.xe(c)}wh(this);this.Te=!1;this.Kc(!0)};function mh(a,b){H(!a.Ia,"Scheduling a connect when we're already connected/ing?");a.vb&&clearTimeout(a.vb);a.vb=setTimeout(function(){a.vb=null;xh(a)},Math.floor(b))}g.hg=function(a){a&&!this.Nb&&this.Va===this.td&&(this.f("Window became visible.  Reducing delay."),this.Va=1E3,this.Ia||mh(this,0));this.Nb=a};
g.gg=function(a){a?(this.f("Browser went online."),this.Va=1E3,this.Ia||mh(this,0)):(this.f("Browser went offline.  Killing connection."),this.Ia&&this.Ia.close())};
g.gf=function(){this.f("data client disconnected");this.ma=!1;this.Ia=null;for(var a=0;a<this.pa.length;a++){var b=this.pa[a];b&&"h"in b.qf&&b.og&&(b.G&&b.G("disconnect"),delete this.pa[a],this.Pc--)}0===this.Pc&&(this.pa=[]);this.Gd={};yh(this)&&(this.Nb?this.Bc&&(3E4<(new Date).getTime()-this.Bc&&(this.Va=1E3),this.Bc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Va=this.td,this.le=(new Date).getTime()),a=Math.max(0,this.Va-((new Date).getTime()-this.le)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),mh(this,a),this.Va=Math.min(this.td,1.3*this.Va));this.Kc(!1)};
function xh(a){if(yh(a)){a.f("Making a connection attempt");a.le=(new Date).getTime();a.Bc=null;var b=r(a.wd,a),c=r(a.Mc,a),d=r(a.gf,a),e=a.id+":"+nh++,f=a.Db,h=!1,k=null,m=function(){k?k.close():(h=!0,d())};a.Ia={close:m,ua:function(a){H(k,"sendRequest call when we're not connected not allowed.");k.ua(a)}};var l=a.de;a.de=!1;a.Vd.getToken(l).then(function(l){h?E("getToken() completed but was canceled"):(E("getToken() completed. Creating connection."),a.pb=l&&l.accessToken,k=new Ye(e,a.M,b,c,d,function(b){O(b+
" ("+a.M.toString()+")");a.eb("server_kill")},f))}).then(null,function(b){a.f("Failed to get token: "+b);h||m()})}}g.eb=function(a){E("Interrupting connection for reason: "+a);this.qd[a]=!0;this.Ia?this.Ia.close():(this.vb&&(clearTimeout(this.vb),this.vb=null),this.ma&&this.gf())};g.lc=function(a){E("Resuming connection for reason: "+a);delete this.qd[a];xa(this.qd)&&(this.Va=1E3,this.Ia||mh(this,0))};
function vh(a,b,c){c=c?La(c,function(a){return jd(a)}).join("$"):"default";(a=ph(a,b,c))&&a.G&&a.G("permission_denied")}function ph(a,b,c){b=(new L(b)).toString();var d;p(a.$[b])?(d=a.$[b][c],delete a.$[b][c],0===qa(a.$[b])&&delete a.$[b]):d=void 0;return d}
function rh(a,b,c){E("Auth token revoked: "+b+"/"+c);a.pb=null;a.de=!0;a.Ia.close();"invalid_token"===b&&(a.Va=3E4,O("Provided authentication credentials are invalid. This usually indicates your FirebaseApp instance was not initialized correctly. Make sure your apiKey and databaseURL match the values provided for your app at https://console.firebase.google.com/, or if you're using a service account, make sure it's authorized to access the specified databaseURL and is from the correct project."))}
function wh(a){qh(a);t(a.$,function(b){t(b,function(b){oh(a,b)})});for(var b=0;b<a.pa.length;b++)a.pa[b]&&uh(a,b);for(;a.Lc.length;)b=a.Lc.shift(),sh(a,b.action,b.ve,b.data,b.G)}function yh(a){var b;b=Of.Wb().ic;return xa(a.qd)&&b};var Y={Vf:function(){Ne=td=!0}};Y.forceLongPolling=Y.Vf;Y.Wf=function(){Oe=!0};Y.forceWebSockets=Y.Wf;Y.bg=function(){return rd.isAvailable()};Y.isWebSocketsAvailable=Y.bg;Y.ug=function(a,b){a.w.Ua.ye=b};Y.setSecurityDebugCallback=Y.ug;Y.Ae=function(a,b){a.w.Ae(b)};Y.stats=Y.Ae;Y.Be=function(a,b){a.w.Be(b)};Y.statsIncrementCounter=Y.Be;Y.ed=function(a){return a.w.ed};Y.dataUpdateCount=Y.ed;Y.ag=function(a,b){a.w.je=b};Y.interceptServerData=Y.ag;function zh(a){this.wa=Q;this.lb=new Yg;this.Ce={};this.jc={};this.Dc=a}function Ah(a,b,c,d,e){var f=a.lb,h=e;H(d>f.Cc,"Stacking an older write on top of newer ones");p(h)||(h=!0);f.la.push({path:b,Ja:c,Zc:d,visible:h});h&&(f.T=Og(f.T,b,c));f.Cc=d;return e?Bh(a,new Zb(Jg,b,c)):[]}function Ch(a,b,c,d){var e=a.lb;H(d>e.Cc,"Stacking an older merge on top of newer ones");e.la.push({path:b,children:c,Zc:d,visible:!0});e.T=Pg(e.T,b,c);e.Cc=d;c=xg(c);return Bh(a,new Cd(Jg,b,c))}
function Dh(a,b,c){c=c||!1;var d=Zg(a.lb,b);if(a.lb.Ed(b)){var e=Q;null!=d.Ja?e=e.set(C,!0):Cb(d.children,function(a,b){e=e.set(new L(a),b)});return Bh(a,new Ig(d.path,e,c))}return[]}function Eh(a,b,c){c=xg(c);return Bh(a,new Cd(Lg,b,c))}function Fh(a,b,c,d){d=Gh(a,d);if(null!=d){var e=Hh(d);d=e.path;e=e.Ib;b=T(d,b);c=new Zb(new Kg(!1,!0,e,!0),b,c);return Ih(a,d,c)}return[]}
function Jh(a,b,c,d){if(d=Gh(a,d)){var e=Hh(d);d=e.path;e=e.Ib;b=T(d,b);c=xg(c);c=new Cd(new Kg(!1,!0,e,!0),b,c);return Ih(a,d,c)}return[]}
zh.prototype.Ob=function(a,b){var c=a.path,d=null,e=!1;Eg(this.wa,c,function(a,b){var f=T(a,c);d=d||b.jb(f);e=e||null!=Vg(b)});var f=this.wa.get(c);f?(e=e||null!=Vg(f),d=d||f.jb(C)):(f=new Ug,this.wa=this.wa.set(c,f));var h;null!=d?h=!0:(h=!1,d=F,Hg(this.wa.subtree(c),function(a,b){var c=b.jb(C);c&&(d=d.U(a,c))}));var k=null!=Xg(f,a);if(!k&&!S(a.n)){var m=Kh(a);H(!(m in this.jc),"View does not exist, but we have a tag");var l=Lh++;this.jc[m]=l;this.Ce["_"+l]=m}h=f.Ob(a,b,new ch(c,this.lb),d,h);k||
e||(f=Xg(f,a),h=h.concat(Mh(this,a,f)));return h};
zh.prototype.mb=function(a,b,c){var d=a.path,e=this.wa.get(d),f=[];if(e&&("default"===a.ya()||null!=Xg(e,a))){f=e.mb(a,b,c);e.e()&&(this.wa=this.wa.remove(d));e=f.qg;f=f.Rf;b=-1!==Pa(e,function(a){return S(a.n)});var h=Cg(this.wa,d,function(a,b){return null!=Vg(b)});if(b&&!h&&(d=this.wa.subtree(d),!d.e()))for(var d=Nh(d),k=0;k<d.length;++k){var m=d[k],l=m.W,m=Oh(this,m);this.Dc.ze(Ph(l),Qh(this,l),m.ld,m.G)}if(!h&&0<e.length&&!c)if(b)this.Dc.Od(Ph(a),null);else{var u=this;Ja(e,function(a){a.ya();
var b=u.jc[Kh(a)];u.Dc.Od(Ph(a),b)})}Rh(this,e)}return f};zh.prototype.Ba=function(a,b){var c=this.lb,d=Cg(this.wa,a,function(b,c){var d=T(b,a);if(d=c.jb(d))return d});return c.Ba(a,d,b,!0)};function Nh(a){return Ag(a,function(a,c,d){if(c&&null!=Vg(c))return[Vg(c)];var e=[];c&&(e=Wg(c));t(d,function(a){e=e.concat(a)});return e})}function Rh(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!S(d.n)){var d=Kh(d),e=a.jc[d];delete a.jc[d];delete a.Ce["_"+e]}}}
function Ph(a){return S(a.n)&&!zd(a.n)?a.xb():a}function Mh(a,b,c){var d=b.path,e=Qh(a,b);c=Oh(a,c);b=a.Dc.ze(Ph(b),e,c.ld,c.G);d=a.wa.subtree(d);if(e)H(null==Vg(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=Ag(d,function(a,b,c){if(!a.e()&&b&&null!=Vg(b))return[lg(Vg(b))];var d=[];b&&(d=d.concat(La(Wg(b),function(a){return a.W})));t(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Dc.Od(Ph(c),Qh(a,c));return b}
function Oh(a,b){var c=b.W,d=Qh(a,c);return{ld:function(){return(b.u()||F).hash()},G:function(b){if("ok"===b){if(d){var f=c.path;if(b=Gh(a,d)){var h=Hh(b);b=h.path;h=h.Ib;f=T(b,f);f=new ac(new Kg(!1,!0,h,!0),f);b=Ih(a,b,f)}else b=[]}else b=Bh(a,new ac(Lg,c.path));return b}f="Unknown Error";"too_big"===b?f="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?f="Client doesn't have permission to access the desired data.":"unavailable"==b&&
(f="The service is unavailable");f=Error(b+" at "+c.path.toString()+": "+f);f.code=b.toUpperCase();return a.mb(c,null,f)}}}function Kh(a){return a.path.toString()+"$"+a.ya()}function Hh(a){var b=a.indexOf("$");H(-1!==b&&b<a.length-1,"Bad queryKey.");return{Ib:a.substr(b+1),path:new L(a.substr(0,b))}}function Gh(a,b){var c=a.Ce,d="_"+b;return d in c?c[d]:void 0}function Qh(a,b){var c=Kh(b);return x(a.jc,c)}var Lh=1;
function Ih(a,b,c){var d=a.wa.get(b);H(d,"Missing sync point for query tag that we're tracking");return d.gb(c,new ch(b,a.lb),null)}function Bh(a,b){return Sh(a,b,a.wa,null,new ch(C,a.lb))}function Sh(a,b,c,d,e){if(b.path.e())return Th(a,b,c,d,e);var f=c.get(C);null==d&&null!=f&&(d=f.jb(C));var h=[],k=J(b.path),m=b.Nc(k);if((c=c.children.get(k))&&m)var l=d?d.R(k):null,k=e.m(k),h=h.concat(Sh(a,m,c,l,k));f&&(h=h.concat(f.gb(b,e,d)));return h}
function Th(a,b,c,d,e){var f=c.get(C);null==d&&null!=f&&(d=f.jb(C));var h=[];c.children.ia(function(c,f){var l=d?d.R(c):null,u=e.m(c),z=b.Nc(c);z&&(h=h.concat(Th(a,z,f,l,u)))});f&&(h=h.concat(f.gb(b,e,d)));return h};function pf(a,b,c){this.app=c;var d=new cc(c);this.M=a;this.Xa=oc(a);this.Vc=null;this.da=new qc;this.vd=1;this.Ua=null;if(b||0<=("object"===typeof window&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i))this.va=new xd(this.M,r(this.Hb,this),d),setTimeout(r(this.Kc,this,!0),0);else{b=c.options.databaseAuthVariableOverride||null;if(null!==b){if("object"!==ca(b))throw Error("Only objects are supported for option databaseAuthVariableOverride");
try{B(b)}catch(e){throw Error("Invalid authOverride provided: "+e);}}this.va=this.Ua=new kh(this.M,r(this.Hb,this),r(this.Kc,this),r(this.te,this),d,b)}var f=this;dc(d,function(a){f.va.of(a)});this.wg=pc(a,r(function(){return new ic(this.Xa,this.va)},this));this.nc=new eh;this.ie=new ec;this.pd=new zh({ze:function(a,b,c,d){b=[];c=f.ie.j(a.path);c.e()||(b=Bh(f.pd,new Zb(Lg,a.path,c)),setTimeout(function(){d("ok")},0));return b},Od:aa});Uh(this,"connected",!1);this.ja=new Qc;this.$a=new of(this);this.ed=
0;this.je=null;this.K=new zh({ze:function(a,b,c,d){f.va.bf(a,c,b,function(b,c){var e=d(b,c);vc(f.da,a.path,e)});return[]},Od:function(a,b){f.va.Cf(a,b)}})}g=pf.prototype;g.toString=function(){return(this.M.Sc?"https://":"http://")+this.M.host};g.name=function(){return this.M.oe};function Vh(a){a=a.ie.j(new L(".info/serverTimeOffset")).H()||0;return(new Date).getTime()+a}function Wh(a){a=a={timestamp:Vh(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}
g.Hb=function(a,b,c,d){this.ed++;var e=new L(a);b=this.je?this.je(a,b):b;a=[];d?c?(b=oa(b,function(a){return M(a)}),a=Jh(this.K,e,b,d)):(b=M(b),a=Fh(this.K,e,b,d)):c?(d=oa(b,function(a){return M(a)}),a=Eh(this.K,e,d)):(d=M(b),a=Bh(this.K,new Zb(Lg,e,d)));d=e;0<a.length&&(d=Xh(this,e));vc(this.da,d,a)};g.Kc=function(a){Uh(this,"connected",a);!1===a&&Yh(this)};g.te=function(a){var b=this;ld(a,function(a,d){Uh(b,d,a)})};
function Uh(a,b,c){b=new L("/.info/"+b);c=M(c);var d=a.ie;d.Jd=d.Jd.F(b,c);c=Bh(a.pd,new Zb(Lg,b,c));vc(a.da,b,c)}g.Kb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,Cg:c});var e=Wh(this);b=M(b,c);var e=Tc(b,e),f=this.vd++,e=Ah(this.K,a,e,f,!0);rc(this.da,e);var h=this;this.va.put(a.toString(),b.H(!0),function(b,c){var e="ok"===b;e||O("set at "+a+" failed: "+b);e=Dh(h.K,f,!e);vc(h.da,a,e);Zh(d,b,c)});e=$h(this,a);Xh(this,e);vc(this.da,e,[])};
g.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Wh(this),f={};t(b,function(a,b){d=!1;var c=M(a);f[b]=Tc(c,e)});if(d)E("update() called with empty data.  Don't do anything."),Zh(c,"ok");else{var h=this.vd++,k=Ch(this.K,a,f,h);rc(this.da,k);var m=this;this.va.cf(a.toString(),b,function(b,d){var e="ok"===b;e||O("update at "+a+" failed: "+b);var e=Dh(m.K,h,!e),f=a;0<e.length&&(f=Xh(m,a));vc(m.da,f,e);Zh(c,b,d)});b=$h(this,a);Xh(this,b);vc(this.da,a,[])}};
function Yh(a){a.f("onDisconnectEvents");var b=Wh(a),c=[];Rc(Pc(a.ja,b),C,function(b,e){c=c.concat(Bh(a.K,new Zb(Lg,b,e)));var f=$h(a,b);Xh(a,f)});a.ja=new Qc;vc(a.da,C,c)}g.xd=function(a,b){var c=this;this.va.xd(a.toString(),function(d,e){"ok"===d&&vf(c.ja,a);Zh(b,d,e)})};function Jf(a,b,c,d){var e=M(c);a.va.qe(b.toString(),e.H(!0),function(c,h){"ok"===c&&Sc(a.ja,b,e);Zh(d,c,h)})}function Kf(a,b,c,d,e){var f=M(c,d);a.va.qe(b.toString(),f.H(!0),function(c,d){"ok"===c&&Sc(a.ja,b,f);Zh(e,c,d)})}
function Lf(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(E("onDisconnect().update() called with empty data.  Don't do anything."),Zh(d,"ok")):a.va.ef(b.toString(),c,function(e,f){if("ok"===e)for(var m in c){var l=M(c[m]);Sc(a.ja,b.m(m),l)}Zh(d,e,f)})}function ug(a,b,c){c=".info"===J(b.path)?a.pd.Ob(b,c):a.K.Ob(b,c);tc(a.da,b.path,c)}g.eb=function(){this.Ua&&this.Ua.eb("repo_interrupt")};g.lc=function(){this.Ua&&this.Ua.lc("repo_interrupt")};
g.Ae=function(a){if("undefined"!==typeof console){a?(this.Vc||(this.Vc=new jc(this.Xa)),a=this.Vc.get()):a=this.Xa.get();var b=Ma(ta(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};g.Be=function(a){lc(this.Xa,a);this.wg.xf[a]=!0};g.f=function(a){var b="";this.Ua&&(b=this.Ua.id+":");E(b,arguments)};
function Zh(a,b,c){a&&Tb(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function ai(a,b,c,d,e){function f(){}a.f("transaction on "+b);var h=new U(a,b);h.hc("value",f);c={path:b,update:c,G:d,status:null,jf:Vc(),He:e,tf:0,Rd:function(){h.Jc("value",f)},Td:null,Da:null,bd:null,cd:null,dd:null};d=a.K.Ba(b,void 0)||F;c.bd=d;d=c.update(d.H());if(p(d)){Bf("transaction failed: Data returned ",d,c.path);c.status=1;e=fh(a.nc,b);var k=e.Ea()||[];k.push(c);gh(e,k);"object"===typeof d&&null!==d&&Bb(d,".priority")?(k=x(d,".priority"),H(zf(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.K.Ba(b)||F).C().H();e=Wh(a);d=M(d,k);e=Tc(d,e);c.cd=d;c.dd=e;c.Da=a.vd++;c=Ah(a.K,b,e,c.Da,c.He);vc(a.da,b,c);bi(a)}else c.Rd(),c.cd=null,c.dd=null,c.G&&(a=new W(c.bd,new U(a,c.path),N),c.G(null,!1,a))}function bi(a,b){var c=b||a.nc;b||ci(a,c);if(null!==c.Ea()){var d=di(a,c);H(0<d.length,"Sending zero length transaction queue");Na(d,function(a){return 1===a.status})&&ei(a,c.path(),d)}else c.kd()&&c.P(function(b){bi(a,b)})}
function ei(a,b,c){for(var d=La(c,function(a){return a.Da}),e=a.K.Ba(b,d)||F,d=e,e=e.hash(),f=0;f<c.length;f++){var h=c[f];H(1===h.status,"tryToSendTransactionQueue_: items in queue should all be run.");h.status=2;h.tf++;var k=T(b,h.path),d=d.F(k,h.cd)}d=d.H(!0);a.va.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(Dh(a.K,c[f].Da));if(c[f].G){var h=c[f].dd,k=new U(a,c[f].path);d.push(r(c[f].G,
null,null,!0,new W(h,k,N)))}c[f].Rd()}ci(a,fh(a.nc,b));bi(a);vc(a.da,b,e);for(f=0;f<d.length;f++)Tb(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(O("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].Td=d;Xh(a,b)}},e)}function Xh(a,b){var c=fi(a,b),d=c.path(),c=di(a,c);gi(a,c,d);return d}
function gi(a,b,c){if(0!==b.length){for(var d=[],e=[],f=La(b,function(a){return a.Da}),h=0;h<b.length;h++){var k=b[h],m=T(c,k.path),l=!1,u;H(null!==m,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)l=!0,u=k.Td,e=e.concat(Dh(a.K,k.Da,!0));else if(1===k.status)if(25<=k.tf)l=!0,u="maxretry",e=e.concat(Dh(a.K,k.Da,!0));else{var z=a.K.Ba(k.path,f)||F;k.bd=z;var G=b[h].update(z.H());p(G)?(Bf("transaction failed: Data returned ",G,k.path),m=M(G),"object"===typeof G&&null!=
G&&Bb(G,".priority")||(m=m.ga(z.C())),z=k.Da,G=Wh(a),G=Tc(m,G),k.cd=m,k.dd=G,k.Da=a.vd++,Qa(f,z),e=e.concat(Ah(a.K,k.path,G,k.Da,k.He)),e=e.concat(Dh(a.K,z,!0))):(l=!0,u="nodata",e=e.concat(Dh(a.K,k.Da,!0)))}vc(a.da,c,e);e=[];l&&(b[h].status=3,setTimeout(b[h].Rd,Math.floor(0)),b[h].G&&("nodata"===u?(k=new U(a,b[h].path),d.push(r(b[h].G,null,null,!1,new W(b[h].bd,k,N)))):d.push(r(b[h].G,null,Error(u),!1,null))))}ci(a,a.nc);for(h=0;h<d.length;h++)Tb(d[h]);bi(a)}}
function fi(a,b){for(var c,d=a.nc;null!==(c=J(b))&&null===d.Ea();)d=fh(d,c),b=D(b);return d}function di(a,b){var c=[];hi(a,b,c);c.sort(function(a,b){return a.jf-b.jf});return c}function hi(a,b,c){var d=b.Ea();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.P(function(b){hi(a,b,c)})}function ci(a,b){var c=b.Ea();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;gh(b,0<c.length?c:null)}b.P(function(b){ci(a,b)})}
function $h(a,b){var c=fi(a,b).path(),d=fh(a.nc,b);jh(d,function(b){ii(a,b)});ii(a,d);ih(d,function(b){ii(a,b)});return c}
function ii(a,b){var c=b.Ea();if(null!==c){for(var d=[],e=[],f=-1,h=0;h<c.length;h++)4!==c[h].status&&(2===c[h].status?(H(f===h-1,"All SENT items should be at beginning of queue."),f=h,c[h].status=4,c[h].Td="set"):(H(1===c[h].status,"Unexpected transaction status in abort"),c[h].Rd(),e=e.concat(Dh(a.K,c[h].Da,!0)),c[h].G&&d.push(r(c[h].G,null,Error("set"),!1,null))));-1===f?gh(b,null):c.length=f+1;vc(a.da,b.path(),e);for(h=0;h<d.length;h++)Tb(d[h])}};function uf(){this.nb={};this.Df=!1}uf.prototype.eb=function(){for(var a in this.nb)this.nb[a].eb()};uf.prototype.lc=function(){for(var a in this.nb)this.nb[a].lc()};uf.prototype.ce=function(a){this.Df=a};ba(uf);uf.prototype.interrupt=uf.prototype.eb;uf.prototype.resume=uf.prototype.lc;var Z={};Z.pc=kh;Z.DataConnection=Z.pc;kh.prototype.vg=function(a,b){this.ua("q",{p:a},b)};Z.pc.prototype.simpleListen=Z.pc.prototype.vg;kh.prototype.Of=function(a,b){this.ua("echo",{d:a},b)};Z.pc.prototype.echo=Z.pc.prototype.Of;kh.prototype.interrupt=kh.prototype.eb;Z.Gf=Ye;Z.RealTimeConnection=Z.Gf;Ye.prototype.sendRequest=Ye.prototype.ua;Ye.prototype.close=Ye.prototype.close;
Z.$f=function(a){var b=kh.prototype.put;kh.prototype.put=function(c,d,e,f){p(f)&&(f=a());b.call(this,c,d,e,f)};return function(){kh.prototype.put=b}};Z.hijackHash=Z.$f;Z.Ff=fc;Z.ConnectionTarget=Z.Ff;Z.ya=function(a){return a.ya()};Z.queryIdentifier=Z.ya;Z.cg=function(a){return a.w.Ua.$};Z.listens=Z.cg;Z.ce=function(a){uf.Wb().ce(a)};Z.forceRestClient=Z.ce;Z.Context=uf;function U(a,b){if(!(a instanceof pf))throw Error("new Firebase() no longer supported - use app.database().");X.call(this,a,b,Be,!1);this.then=void 0;this["catch"]=void 0}ka(U,X);g=U.prototype;g.getKey=function(){y("Firebase.key",0,0,arguments.length);return this.path.e()?null:Xd(this.path)};
g.m=function(a){y("Firebase.child",1,1,arguments.length);if(fa(a))a=String(a);else if(!(a instanceof L))if(null===J(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));Hf("Firebase.child",b)}else Hf("Firebase.child",a);return new U(this.w,this.path.m(a))};g.getParent=function(){y("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new U(this.w,a)};
g.Xf=function(){y("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.getParent();)a=a.getParent();return a};g.Nf=function(){return this.w.$a};g.set=function(a,b){y("Firebase.set",1,2,arguments.length);If("Firebase.set",this.path);Af("Firebase.set",a,this.path,!1);A("Firebase.set",2,b,!0);var c=new Hb;this.w.Kb(this.path,a,null,Ib(c,b));return c.ra};
g.update=function(a,b){y("Firebase.update",1,2,arguments.length);If("Firebase.update",this.path);if(da(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;O("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Df("Firebase.update",a,this.path);A("Firebase.update",2,b,!0);c=new Hb;this.w.update(this.path,a,Ib(c,b));return c.ra};
g.Kb=function(a,b,c){y("Firebase.setWithPriority",2,3,arguments.length);If("Firebase.setWithPriority",this.path);Af("Firebase.setWithPriority",a,this.path,!1);Ef("Firebase.setWithPriority",2,b);A("Firebase.setWithPriority",3,c,!0);if(".length"===this.getKey()||".keys"===this.getKey())throw"Firebase.setWithPriority failed: "+this.getKey()+" is a read-only object.";var d=new Hb;this.w.Kb(this.path,a,b,Ib(d,c));return d.ra};
g.remove=function(a){y("Firebase.remove",0,1,arguments.length);If("Firebase.remove",this.path);A("Firebase.remove",1,a,!0);return this.set(null,a)};
g.transaction=function(a,b,c){y("Firebase.transaction",1,3,arguments.length);If("Firebase.transaction",this.path);A("Firebase.transaction",1,a,!1);A("Firebase.transaction",2,b,!0);if(p(c)&&"boolean"!=typeof c)throw Error(Db("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.getKey()||".keys"===this.getKey())throw"Firebase.transaction failed: "+this.getKey()+" is a read-only object.";"undefined"===typeof c&&(c=!0);var d=new Hb;ga(b)&&Jb(d.ra);ai(this.w,this.path,a,function(a,c,
h){a?d.reject(a):d.resolve(new Pb(c,h));ga(b)&&b(a,c,h)},c);return d.ra};g.tg=function(a,b){y("Firebase.setPriority",1,2,arguments.length);If("Firebase.setPriority",this.path);Ef("Firebase.setPriority",1,a);A("Firebase.setPriority",2,b,!0);var c=new Hb;this.w.Kb(this.path.m(".priority"),a,null,Ib(c,b));return c.ra};
g.push=function(a,b){y("Firebase.push",0,2,arguments.length);If("Firebase.push",this.path);Af("Firebase.push",a,this.path,!0);A("Firebase.push",2,b,!0);var c=Vh(this.w),d=Qf(c),c=this.m(d);if(null!=a){var e=this,f=c.set(a,b).then(function(){return e.m(d)});c.then=r(f.then,f);c["catch"]=r(f.then,f,void 0);ga(b)&&Jb(f)}return c};g.kb=function(){If("Firebase.onDisconnect",this.path);return new V(this.w,this.path)};U.prototype.child=U.prototype.m;U.prototype.set=U.prototype.set;U.prototype.update=U.prototype.update;
U.prototype.setWithPriority=U.prototype.Kb;U.prototype.remove=U.prototype.remove;U.prototype.transaction=U.prototype.transaction;U.prototype.setPriority=U.prototype.tg;U.prototype.push=U.prototype.push;U.prototype.onDisconnect=U.prototype.kb;od(U.prototype,"database",U.prototype.Nf);od(U.prototype,"key",U.prototype.getKey);od(U.prototype,"parent",U.prototype.getParent);od(U.prototype,"root",U.prototype.Xf);if("undefined"===typeof firebase)throw Error("Cannot install Firebase Database - be sure to load firebase-app.js first.");
try{firebase.INTERNAL.registerService("database",function(a){var b=uf.Wb(),c=a.options.databaseURL;p(c)||dd("Can't determine Firebase Database URL.  Be sure to include databaseURL option when calling firebase.intializeApp().");var d=ed(c),c=d.kc;tf("Invalid Firebase Database URL",d);d.path.e()||dd("Database URL must point to the root of a Firebase Database (not including a child path).");(d=x(b.nb,a.name))&&dd("FIREBASE INTERNAL ERROR: Database initialized multiple times.");d=new pf(c,b.Df,a);b.nb[a.name]=
d;return d.$a},{Reference:U,Query:X,Database:of,enableLogging:ad,INTERNAL:Y,TEST_ACCESS:Z,ServerValue:rf})}catch(ji){dd("Failed to register the Firebase Database Service ("+ji+")")};})();

(function() {var k,aa=aa||{},m=this,n=function(a){return void 0!==a},ba=function(){},p=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=
typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==b&&"undefined"==typeof a.call)return"object";return b},ca=function(a){var b=p(a);return"array"==b||"object"==b&&"number"==typeof a.length},q=function(a){return"string"==typeof a},r=function(a){return"function"==p(a)},da=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b},ea="closure_uid_"+(1E9*Math.random()>>>0),fa=0,ga=function(a,b,c){return a.call.apply(a.bind,
arguments)},ha=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}},t=function(a,b,c){t=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ga:ha;return t.apply(null,arguments)},ia=Date.now||function(){return+new Date},u=function(a,b){function c(){}
c.prototype=b.prototype;a.G=b.prototype;a.prototype=new c;a.Ma=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)}};var ja=function(a,b,c){function d(){O||(O=!0,b.apply(null,arguments))}function e(b){l=setTimeout(function(){l=null;a(f,2===v)},b)}function f(a,b){if(!O)if(a)d.apply(null,arguments);else if(2===v||B)d.apply(null,arguments);else{64>h&&(h*=2);var c;1===v?(v=2,c=0):c=1E3*(h+Math.random());e(c)}}function g(a){Sb||(Sb=!0,O||(null!==l?(a||(v=2),clearTimeout(l),e(0)):a||(v=1)))}var h=1,l=null,B=!1,v=0,O=!1,Sb=!1;e(0);setTimeout(function(){B=!0;g(!0)},c);return g};var ka="https://firebasestorage.googleapis.com";var w=function(a,b){this.code="storage/"+a;this.message="Firebase Storage: "+b;this.serverResponse=null;this.name="FirebaseError"};u(w,Error);
var la=function(){return new w("unknown","An unknown error occurred, please check the error payload for server response.")},ma=function(){return new w("unauthenticated","User is not authenticated, please authenticate using Firebase Authentication and try again.")},na=function(a){return new w("unauthorized","User does not have permission to access '"+a+"'.")},oa=function(){return new w("canceled","User canceled the upload/download.")},pa=function(a,b,c){return new w("invalid-argument","Invalid argument in `"+
b+"` at index "+a+": "+c)},qa=function(){return new w("app-deleted","The Firebase app was deleted.")};var ra=function(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])},sa=function(a){var b={};ra(a,function(a,d){b[a]=d});return b};var x=function(a,b,c,d){this.l=a;this.f={};this.i=b;this.b={};this.c="";this.N=c;this.g=this.a=null;this.h=[200];this.j=d};var ta={STATE_CHANGED:"state_changed"},ua={RUNNING:"running",PAUSED:"paused",SUCCESS:"success",CANCELED:"canceled",ERROR:"error"},va=function(a){switch(a){case "running":case "pausing":case "canceling":return"running";case "paused":return"paused";case "success":return"success";case "canceled":return"canceled";case "error":return"error";default:return"error"}};var y=function(a){return n(a)&&null!==a},wa=function(a){return"string"===typeof a||a instanceof String};var xa=function(a,b,c){this.f=c;this.c=a;this.g=b;this.b=0;this.a=null};xa.prototype.get=function(){var a;0<this.b?(this.b--,a=this.a,this.a=a.next,a.next=null):a=this.c();return a};var ya=function(a,b){a.g(b);a.b<a.f&&(a.b++,b.next=a.a,a.a=b)};var za=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,za);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))};u(za,Error);za.prototype.name="CustomError";var Aa=function(a,b,c,d,e){this.reset(a,b,c,d,e)};Aa.prototype.a=null;var Ba=0;Aa.prototype.reset=function(a,b,c,d,e){"number"==typeof e||Ba++;d||ia();this.b=b;delete this.a};var Ca=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b},Da=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},Ea=function(a){return null!==a&&"withCredentials"in a},Fa="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),Ga=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Fa.length;f++)c=Fa[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};var Ha=function(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0},Ia=function(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};var Ja=function(a){Ja[" "](a);return a};Ja[" "]=ba;var Ka=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")},La=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ma=function(a,b){return a<b?-1:a>b?1:0};var Na=function(a,b){this.a=a;this.b=b};Na.prototype.clone=function(){return new Na(this.a,this.b)};var z=function(a,b){this.bucket=a;this.path=b},Oa=function(a){var b=encodeURIComponent;return"/b/"+b(a.bucket)+"/o/"+b(a.path)},Pa=function(a){for(var b=null,c=[{ja:/^gs:\/\/([A-Za-z0-9.\-]+)(\/(.*))?$/i,aa:{bucket:1,path:3},ia:function(a){"/"===a.path.charAt(a.path.length-1)&&(a.path=a.path.slice(0,-1))}},{ja:/^https?:\/\/firebasestorage\.googleapis\.com\/v[A-Za-z0-9_]+\/b\/([A-Za-z0-9.\-]+)\/o(\/([^?#]*).*)?$/i,aa:{bucket:1,path:3},ia:function(a){a.path=decodeURIComponent(a.path)}}],d=0;d<c.length;d++){var e=
c[d],f=e.ja.exec(a);if(f){b=f[e.aa.bucket];(f=f[e.aa.path])||(f="");b=new z(b,f);e.ia(b);break}}if(null==b)throw new w("invalid-url","Invalid URL '"+a+"'.");return b};var Qa=function(a,b,c){r(a)||y(b)||y(c)?(this.next=a,this.error=b||null,this.a=c||null):(this.next=a.next||null,this.error=a.error||null,this.a=a.complete||null)};var Ra=function(a){var b=encodeURIComponent,c="?";ra(a,function(a,e){a=b(a)+"="+b(e);c=c+a+"&"});return c=c.slice(0,-1)};var A=function(a,b,c,d,e,f){this.b=a;this.h=b;this.f=c;this.a=d;this.g=e;this.c=f};k=A.prototype;k.qa=function(){return this.b};k.La=function(){return this.h};k.Ia=function(){return this.f};k.Da=function(){return this.a};k.sa=function(){if(y(this.a)){var a=this.a.downloadURLs;return y(a)&&y(a[0])?a[0]:null}return null};k.Ka=function(){return this.g};k.Ga=function(){return this.c};var Sa=function(a,b){b.unshift(a);za.call(this,Ka.apply(null,b));b.shift()};u(Sa,za);Sa.prototype.name="AssertionError";
var Ta=function(a,b,c,d){var e="Assertion failed";if(c)var e=e+(": "+c),f=d;else a&&(e+=": "+a,f=b);throw new Sa(""+e,f||[]);},C=function(a,b,c){a||Ta("",null,b,Array.prototype.slice.call(arguments,2))},Ua=function(a,b){throw new Sa("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));},Wa=function(a,b,c){r(a)||Ta("Expected function but got %s: %s.",[p(a),a],b,Array.prototype.slice.call(arguments,2))};var D=function(){this.g=this.g;this.s=this.s};D.prototype.g=!1;D.prototype.fa=function(){this.g||(this.g=!0,this.A())};D.prototype.A=function(){if(this.s)for(;this.s.length;)this.s.shift()()};var Xa="closure_listenable_"+(1E6*Math.random()|0),Ya=0;var Za;a:{var $a=m.navigator;if($a){var ab=$a.userAgent;if(ab){Za=ab;break a}}Za=""}var E=function(a){return-1!=Za.indexOf(a)};var bb=function(){};bb.prototype.a=null;var db=function(a){var b;(b=a.a)||(b={},cb(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var eb=Array.prototype.indexOf?function(a,b,c){C(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(q(a))return q(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},fb=Array.prototype.forEach?function(a,b,c){C(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},gb=Array.prototype.filter?function(a,
b,c){C(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=q(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var l=g[h];b.call(c,l,h,a)&&(e[f++]=l)}return e},hb=Array.prototype.map?function(a,b,c){C(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=q(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},ib=Array.prototype.some?function(a,b,c){C(null!=a.length);return Array.prototype.some.call(a,
b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1},kb=function(a){var b;a:{b=jb;for(var c=a.length,d=q(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:q(a)?a.charAt(b):a[b]},lb=function(a){if("array"!=p(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0},mb=function(a,b){b=eb(a,b);var c;if(c=0<=b)C(null!=a.length),Array.prototype.splice.call(a,b,1);return c},nb=function(a){var b=
a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var pb=new xa(function(){return new ob},function(a){a.reset()},100),rb=function(){var a=qb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b},ob=function(){this.next=this.b=this.a=null};ob.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};ob.prototype.reset=function(){this.next=this.b=this.a=null};var sb=function(a,b){this.type=a;this.a=this.target=b;this.ka=!0};sb.prototype.b=function(){this.ka=!1};var tb=function(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.U=!!d;this.N=e;++Ya;this.O=this.T=!1},ub=function(a){a.O=!0;a.listener=null;a.a=null;a.src=null;a.N=null};var vb=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;var wb=function(a,b){b=gb(b.split("/"),function(a){return 0<a.length}).join("/");return 0===a.length?b:a+"/"+b},xb=function(a){var b=a.lastIndexOf("/",a.length-2);return-1===b?a:a.slice(b+1)};var yb=function(a){this.src=a;this.a={};this.b=0},Ab=function(a,b,c,d,e,f){var g=b.toString();b=a.a[g];b||(b=a.a[g]=[],a.b++);var h=zb(b,c,e,f);-1<h?(a=b[h],d||(a.T=!1)):(a=new tb(c,a.src,g,!!e,f),a.T=d,b.push(a));return a},Bb=function(a,b){var c=b.type;c in a.a&&mb(a.a[c],b)&&(ub(b),0==a.a[c].length&&(delete a.a[c],a.b--))},zb=function(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.O&&f.listener==b&&f.U==!!c&&f.N==d)return e}return-1};var Cb,Db=function(){};u(Db,bb);var Eb=function(a){return(a=cb(a))?new ActiveXObject(a):new XMLHttpRequest},cb=function(a){if(!a.b&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.b};Cb=new Db;var Fb=function(a){this.a=[];if(a)a:{var b;if(a instanceof Fb){if(b=a.D(),a=a.w(),0>=this.o()){for(var c=this.a,d=0;d<b.length;d++)c.push(new Na(b[d],a[d]));break a}}else b=Da(a),a=Ca(a);for(d=0;d<b.length;d++)Gb(this,b[d],a[d])}},Gb=function(a,b,c){var d=a.a;d.push(new Na(b,c));b=d.length-1;a=a.a;for(c=a[b];0<b;)if(d=b-1>>1,a[d].a>c.a)a[b]=a[d],b=d;else break;a[b]=c};k=Fb.prototype;k.w=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].b);return b};
k.D=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].a);return b};k.clone=function(){return new Fb(this)};k.o=function(){return this.a.length};k.F=function(){return 0==this.a.length};k.clear=function(){lb(this.a)};var Hb=function(){this.b=[];this.a=[]},Ib=function(a){0==a.b.length&&(a.b=a.a,a.b.reverse(),a.a=[]);return a.b.pop()};Hb.prototype.o=function(){return this.b.length+this.a.length};Hb.prototype.F=function(){return 0==this.b.length&&0==this.a.length};Hb.prototype.clear=function(){this.b=[];this.a=[]};Hb.prototype.w=function(){for(var a=[],b=this.b.length-1;0<=b;--b)a.push(this.b[b]);for(var c=this.a.length,b=0;b<c;++b)a.push(this.a[b]);return a};var Jb=function(a){if(a.w&&"function"==typeof a.w)return a.w();if(q(a))return a.split("");if(ca(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Ca(a)},Kb=function(a,b){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,void 0);else if(ca(a)||q(a))fb(a,b,void 0);else{var c;if(a.D&&"function"==typeof a.D)c=a.D();else if(a.w&&"function"==typeof a.w)c=void 0;else if(ca(a)||q(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=Da(a);for(var d=Jb(a),e=d.length,f=0;f<e;f++)b.call(void 0,
d[f],c&&c[f],a)}};var Lb=function(a){m.setTimeout(function(){throw a;},0)},Mb,Nb=function(){var a=m.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!E("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host,
a=t(function(a){if(("*"==d||a.origin==d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!E("Trident")&&!E("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(n(c.next)){c=c.next;var a=c.ea;c.ea=null;a()}};return function(a){d.next={ea:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?
function(a){var b=document.createElement("SCRIPT");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){m.setTimeout(a,0)}};var Ob="StopIteration"in m?m.StopIteration:{message:"StopIteration",stack:""},Pb=function(){};Pb.prototype.next=function(){throw Ob;};Pb.prototype.X=function(){return this};var Qb=function(){Fb.call(this)};u(Qb,Fb);var Rb=E("Opera"),F=E("Trident")||E("MSIE"),Tb=E("Edge"),Ub=E("Gecko")&&!(-1!=Za.toLowerCase().indexOf("webkit")&&!E("Edge"))&&!(E("Trident")||E("MSIE"))&&!E("Edge"),Vb=-1!=Za.toLowerCase().indexOf("webkit")&&!E("Edge"),Wb=function(){var a=m.document;return a?a.documentMode:void 0},Xb;
a:{var Yb="",Zb=function(){var a=Za;if(Ub)return/rv\:([^\);]+)(\)|;)/.exec(a);if(Tb)return/Edge\/([\d\.]+)/.exec(a);if(F)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(Vb)return/WebKit\/(\S+)/.exec(a);if(Rb)return/(?:Version)[ \/]?(\S+)/.exec(a)}();Zb&&(Yb=Zb?Zb[1]:"");if(F){var $b=Wb();if(null!=$b&&$b>parseFloat(Yb)){Xb=String($b);break a}}Xb=Yb}
var ac=Xb,bc={},G=function(a){var b;if(!(b=bc[a])){b=0;for(var c=La(String(ac)).split("."),d=La(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"",l=/(\d*)(\D*)/g,B=/(\d*)(\D*)/g;do{var v=l.exec(g)||["","",""],O=B.exec(h)||["","",""];if(0==v[0].length&&0==O[0].length)break;b=Ma(0==v[1].length?0:parseInt(v[1],10),0==O[1].length?0:parseInt(O[1],10))||Ma(0==v[2].length,0==O[2].length)||Ma(v[2],O[2])}while(0==b)}b=bc[a]=0<=b}return b},cc=m.document,dc=cc&&
F?Wb()||("CSS1Compat"==cc.compatMode?parseInt(ac,10):5):void 0;var hc=function(a,b){ec||fc();gc||(ec(),gc=!0);var c=qb,d=pb.get();d.set(a,b);c.b?c.b.next=d:(C(!c.a),c.a=d);c.b=d},ec,fc=function(){if(m.Promise&&m.Promise.resolve){var a=m.Promise.resolve(void 0);ec=function(){a.then(ic)}}else ec=function(){var a=ic;!r(m.setImmediate)||m.Window&&m.Window.prototype&&!E("Edge")&&m.Window.prototype.setImmediate==m.setImmediate?(Mb||(Mb=Nb()),Mb(a)):m.setImmediate(a)}},gc=!1,qb=new function(){this.b=this.a=null},ic=function(){for(var a;a=rb();){try{a.a.call(a.b)}catch(b){Lb(b)}ya(pb,
a)}gc=!1};var jc;(jc=!F)||(jc=9<=Number(dc));var kc=jc,lc=F&&!G("9");!Vb||G("528");Ub&&G("1.9b")||F&&G("8")||Rb&&G("9.5")||Vb&&G("528");Ub&&!G("8")||F&&G("9");var mc=function(a,b){this.b={};this.a=[];this.f=this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){a instanceof mc?(c=a.D(),d=a.w()):(c=Da(a),d=Ca(a));for(var e=0;e<c.length;e++)this.set(c[e],d[e])}};k=mc.prototype;k.o=function(){return this.c};k.w=function(){nc(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};k.D=function(){nc(this);return this.a.concat()};
k.F=function(){return 0==this.c};k.clear=function(){this.b={};this.f=this.c=this.a.length=0};
var oc=function(a,b){return Object.prototype.hasOwnProperty.call(a.b,b)?(delete a.b[b],a.c--,a.f++,a.a.length>2*a.c&&nc(a),!0):!1},nc=function(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];Object.prototype.hasOwnProperty.call(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){for(var e={},c=b=0;b<a.a.length;)d=a.a[b],Object.prototype.hasOwnProperty.call(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}};k=mc.prototype;
k.get=function(a,b){return Object.prototype.hasOwnProperty.call(this.b,a)?this.b[a]:b};k.set=function(a,b){Object.prototype.hasOwnProperty.call(this.b,a)||(this.c++,this.a.push(a),this.f++);this.b[a]=b};k.forEach=function(a,b){for(var c=this.D(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};k.clone=function(){return new mc(this)};
k.X=function(a){nc(this);var b=0,c=this.f,d=this,e=new Pb;e.next=function(){if(c!=d.f)throw Error("The map has changed since the iterator was created");if(b>=d.a.length)throw Ob;var e=d.a[b++];return a?e:d.b[e]};return e};var pc=function(a,b){sb.call(this,a?a.type:"");this.c=this.a=this.target=null;if(a){this.type=a.type;this.target=a.target||a.srcElement;this.a=b;if((b=a.relatedTarget)&&Ub)try{Ja(b.nodeName)}catch(c){}this.c=a;a.defaultPrevented&&this.b()}};u(pc,sb);pc.prototype.b=function(){pc.G.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,lc)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var H=function(a,b){this.a=0;this.i=void 0;this.c=this.b=this.f=null;this.g=this.h=!1;if(a!=ba)try{var c=this;a.call(b,function(a){qc(c,2,a)},function(a){try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(b){}qc(c,3,a)})}catch(d){qc(this,3,d)}},rc=function(){this.next=this.f=this.c=this.a=this.b=null;this.g=!1};rc.prototype.reset=function(){this.f=this.c=this.a=this.b=null;this.g=!1};
var sc=new xa(function(){return new rc},function(a){a.reset()},100),tc=function(a,b,c){var d=sc.get();d.a=a;d.c=b;d.f=c;return d},uc=function(a){if(a instanceof H)return a;var b=new H(ba);qc(b,2,a);return b},vc=function(a){return new H(function(b,c){c(a)})};
H.prototype.then=function(a,b,c){null!=a&&Wa(a,"opt_onFulfilled should be a function.");null!=b&&Wa(b,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?");return wc(this,r(a)?a:null,r(b)?b:null,c)};Ha(H);H.prototype.l=function(a,b){return wc(this,null,a,b)};
var yc=function(a,b){a.b||2!=a.a&&3!=a.a||xc(a);C(null!=b.a);a.c?a.c.next=b:a.b=b;a.c=b},wc=function(a,b,c,d){var e=tc(null,null,null);e.b=new H(function(a,g){e.a=b?function(c){try{var e=b.call(d,c);a(e)}catch(B){g(B)}}:a;e.c=c?function(b){try{var e=c.call(d,b);a(e)}catch(B){g(B)}}:g});e.b.f=a;yc(a,e);return e.b};H.prototype.s=function(a){C(1==this.a);this.a=0;qc(this,2,a)};H.prototype.m=function(a){C(1==this.a);this.a=0;qc(this,3,a)};
var qc=function(a,b,c){if(0==a.a){a==c&&(b=3,c=new TypeError("Promise cannot resolve to itself"));a.a=1;var d;a:{var e=c,f=a.s,g=a.m;if(e instanceof H)null!=f&&Wa(f,"opt_onFulfilled should be a function."),null!=g&&Wa(g,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?"),yc(e,tc(f||ba,g||null,a)),d=!0;else if(Ia(e))e.then(f,g,a),d=!0;else{if(da(e))try{var h=e.then;if(r(h)){zc(e,h,f,g,a);d=!0;break a}}catch(l){g.call(a,l);d=!0;break a}d=!1}}d||
(a.i=c,a.a=b,a.f=null,xc(a),3!=b||Ac(a,c))}},zc=function(a,b,c,d,e){var f=!1,g=function(a){f||(f=!0,c.call(e,a))},h=function(a){f||(f=!0,d.call(e,a))};try{b.call(a,g,h)}catch(l){h(l)}},xc=function(a){a.h||(a.h=!0,hc(a.j,a))},Bc=function(a){var b=null;a.b&&(b=a.b,a.b=b.next,b.next=null);a.b||(a.c=null);null!=b&&C(null!=b.a);return b};
H.prototype.j=function(){for(var a;a=Bc(this);){var b=this.a,c=this.i;if(3==b&&a.c&&!a.g){var d;for(d=this;d&&d.g;d=d.f)d.g=!1}if(a.b)a.b.f=null,Cc(a,b,c);else try{a.g?a.a.call(a.f):Cc(a,b,c)}catch(e){Dc.call(null,e)}ya(sc,a)}this.h=!1};var Cc=function(a,b,c){2==b?a.a.call(a.f,c):a.c&&a.c.call(a.f,c)},Ac=function(a,b){a.g=!0;hc(function(){a.g&&Dc.call(null,b)})},Dc=Lb;var Fc=function(a){this.a=new mc;if(a){a=Jb(a);for(var b=a.length,c=0;c<b;c++){var d=a[c];this.a.set(Ec(d),d)}}},Ec=function(a){var b=typeof a;return"object"==b&&a||"function"==b?"o"+(a[ea]||(a[ea]=++fa)):b.substr(0,1)+a};k=Fc.prototype;k.o=function(){return this.a.o()};k.clear=function(){this.a.clear()};k.F=function(){return this.a.F()};k.w=function(){return this.a.w()};k.clone=function(){return new Fc(this)};k.X=function(){return this.a.X(!1)};var Gc=function(a){return function(){var b=[];Array.prototype.push.apply(b,arguments);uc(!0).then(function(){a.apply(null,b)})}};var Hc="closure_lm_"+(1E6*Math.random()|0),Ic={},Jc=0,Kc=function(a,b,c,d,e){if("array"==p(b)){for(var f=0;f<b.length;f++)Kc(a,b[f],c,d,e);return null}c=Lc(c);a&&a[Xa]?(Mc(a),a=Ab(a.b,String(b),c,!1,d,e)):a=Nc(a,b,c,!1,d,e);return a},Nc=function(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=!!e,h=Oc(a);h||(a[Hc]=h=new yb(a));c=Ab(h,b,c,d,e,f);if(c.a)return c;d=Pc();c.a=d;d.src=a;d.listener=c;if(a.addEventListener)a.addEventListener(b.toString(),d,g);else if(a.attachEvent)a.attachEvent(Qc(b.toString()),
d);else throw Error("addEventListener and attachEvent are unavailable.");Jc++;return c},Pc=function(){var a=Rc,b=kc?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b},Sc=function(a,b,c,d,e){if("array"==p(b))for(var f=0;f<b.length;f++)Sc(a,b[f],c,d,e);else c=Lc(c),a&&a[Xa]?Ab(a.b,String(b),c,!0,d,e):Nc(a,b,c,!0,d,e)},Tc=function(a,b,c,d,e){if("array"==p(b))for(var f=0;f<b.length;f++)Tc(a,b[f],c,d,e);else(c=Lc(c),a&&a[Xa])?(a=a.b,b=String(b).toString(),
b in a.a&&(f=a.a[b],c=zb(f,c,d,e),-1<c&&(ub(f[c]),C(null!=f.length),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=Oc(a))&&(b=a.a[b.toString()],a=-1,b&&(a=zb(b,c,!!d,e)),(c=-1<a?b[a]:null)&&Uc(c))},Uc=function(a){if("number"!=typeof a&&a&&!a.O){var b=a.src;if(b&&b[Xa])Bb(b.b,a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.U):b.detachEvent&&b.detachEvent(Qc(c),d);Jc--;(c=Oc(b))?(Bb(c,a),0==c.b&&(c.src=null,b[Hc]=null)):ub(a)}}},Qc=function(a){return a in
Ic?Ic[a]:Ic[a]="on"+a},Wc=function(a,b,c,d){var e=!0;if(a=Oc(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.U==c&&!f.O&&(f=Vc(f,d),e=e&&!1!==f)}return e},Vc=function(a,b){var c=a.listener,d=a.N||a.src;a.T&&Uc(a);return c.call(d,b)},Rc=function(a,b){if(a.O)return!0;if(!kc){if(!b)a:{b=["window","event"];for(var c=m,d;d=b.shift();)if(null!=c[d])c=c[d];else{b=null;break a}b=c}d=b;b=new pc(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=
-1;break a}catch(g){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.a;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.a=d[e];var f=Wc(d[e],a,!0,b),c=c&&f}for(e=0;e<d.length;e++)b.a=d[e],f=Wc(d[e],a,!1,b),c=c&&f}return c}return Vc(a,new pc(b,this))},Oc=function(a){a=a[Hc];return a instanceof yb?a:null},Xc="__closure_events_fn_"+(1E9*Math.random()>>>0),Lc=function(a){C(a,"Listener can not be null.");if(r(a))return a;C(a.handleEvent,"An object listener must have handleEvent method.");
a[Xc]||(a[Xc]=function(b){return a.handleEvent(b)});return a[Xc]};var I=function(a,b){D.call(this);this.l=a||0;this.c=b||10;if(this.l>this.c)throw Error("[goog.structs.Pool] Min can not be greater than max");this.a=new Hb;this.b=new Fc;this.i=null;this.S()};u(I,D);I.prototype.W=function(){var a=ia();if(!(null!=this.i&&0>a-this.i)){for(var b;0<this.a.o()&&(b=Ib(this.a),!this.j(b));)this.S();!b&&this.o()<this.c&&(b=this.h());b&&(this.i=a,this.b.a.set(Ec(b),b));return b}};var Zc=function(a){var b=Yc;oc(b.b.a,Ec(a))&&b.Y(a)};
I.prototype.Y=function(a){oc(this.b.a,Ec(a));this.j(a)&&this.o()<this.c?this.a.a.push(a):$c(a)};I.prototype.S=function(){for(var a=this.a;this.o()<this.l;){var b=this.h();a.a.push(b)}for(;this.o()>this.c&&0<this.a.o();)$c(Ib(a))};I.prototype.h=function(){return{}};var $c=function(a){if("function"==typeof a.fa)a.fa();else for(var b in a)a[b]=null};I.prototype.j=function(a){return"function"==typeof a.ra?a.ra():!0};I.prototype.o=function(){return this.a.o()+this.b.o()};
I.prototype.F=function(){return this.a.F()&&this.b.F()};I.prototype.A=function(){I.G.A.call(this);if(0<this.b.o())throw Error("[goog.structs.Pool] Objects not released");delete this.b;for(var a=this.a;!a.F();)$c(Ib(a));delete this.a};/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
var ad=function(a,b){this.c=[];this.m=b||null;this.a=this.h=!1;this.b=void 0;this.j=this.g=!1;this.f=0;this.i=null;this.s=0};ad.prototype.l=function(a,b){this.g=!1;this.h=!0;this.b=b;this.a=!a;bd(this)};var cd=function(a,b,c){C(!a.j,"Blocking Deferreds can not be re-used");a.c.push([b,c,void 0]);a.h&&bd(a)};ad.prototype.then=function(a,b,c){var d,e,f=new H(function(a,b){d=a;e=b});cd(this,d,function(a){e(a)});return f.then(a,b,c)};Ha(ad);
var dd=function(a){return ib(a.c,function(a){return r(a[1])})},bd=function(a){if(a.f&&a.h&&dd(a)){var b=a.f,c=ed[b];c&&(m.clearTimeout(c.a),delete ed[b]);a.f=0}a.i&&(a.i.s--,delete a.i);for(var b=a.b,d=c=!1;a.c.length&&!a.g;){var e=a.c.shift(),f=e[0],g=e[1],e=e[2];if(f=a.a?g:f)try{var h=f.call(e||a.m,b);n(h)&&(a.a=a.a&&(h==b||h instanceof Error),a.b=b=h);if(Ia(b)||"function"===typeof m.Promise&&b instanceof m.Promise)d=!0,a.g=!0}catch(l){b=l,a.a=!0,dd(a)||(c=!0)}}a.b=b;d&&(h=t(a.l,a,!0),d=t(a.l,a,
!1),b instanceof ad?(cd(b,h,d),b.j=!0):b.then(h,d));c&&(b=new fd(b),ed[b.a]=b,a.f=b.a)},fd=function(a){this.a=m.setTimeout(t(this.c,this),0);this.b=a};fd.prototype.c=function(){C(ed[this.a],"Cannot throw an error that is not scheduled.");delete ed[this.a];throw this.b;};var ed={};var gd=function(a){this.f=a;this.b=this.c=this.a=null},hd=function(a,b){this.name=a;this.value=b};hd.prototype.toString=function(){return this.name};var id=new hd("SEVERE",1E3),jd=new hd("CONFIG",700),kd=new hd("FINE",500),ld=function(a){if(a.c)return a.c;if(a.a)return ld(a.a);Ua("Root logger has no level set.");return null};
gd.prototype.log=function(a,b,c){if(a.value>=ld(this).value)for(r(b)&&(b=b()),a=new Aa(a,String(b),this.f),c&&(a.a=c),c="log:"+a.b,m.console&&(m.console.timeStamp?m.console.timeStamp(c):m.console.markTimeline&&m.console.markTimeline(c)),m.msWriteProfilerMark&&m.msWriteProfilerMark(c),c=this;c;)c=c.a};
var md={},nd=null,od=function(a){nd||(nd=new gd(""),md[""]=nd,nd.c=jd);var b;if(!(b=md[a])){b=new gd(a);var c=a.lastIndexOf("."),d=a.substr(c+1),c=od(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;md[a]=b}return b};var J=function(){D.call(this);this.b=new yb(this);this.ma=this;this.I=null};u(J,D);J.prototype[Xa]=!0;J.prototype.removeEventListener=function(a,b,c,d){Tc(this,a,b,c,d)};
var K=function(a,b){Mc(a);var c,d=a.I;if(d){c=[];for(var e=1;d;d=d.I)c.push(d),C(1E3>++e,"infinite loop")}a=a.ma;d=b.type||b;q(b)?b=new sb(b,a):b instanceof sb?b.target=b.target||a:(e=b,b=new sb(d,a),Ga(b,e));var e=!0,f;if(c)for(var g=c.length-1;0<=g;g--)f=b.a=c[g],e=pd(f,d,!0,b)&&e;f=b.a=a;e=pd(f,d,!0,b)&&e;e=pd(f,d,!1,b)&&e;if(c)for(g=0;g<c.length;g++)f=b.a=c[g],e=pd(f,d,!1,b)&&e};
J.prototype.A=function(){J.G.A.call(this);if(this.b){var a=this.b,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,ub(d[e]);delete a.a[c];a.b--}}this.I=null};var pd=function(a,b,c,d){b=a.b.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.O&&g.U==c){var h=g.listener,l=g.N||g.src;g.T&&Bb(a.b,g);e=!1!==h.call(l,d)&&e}}return e&&0!=d.ka},Mc=function(a){C(a.b,"Event target is not initialized. Did you call the superclass (goog.events.EventTarget) constructor?")};var L=function(a,b){this.f=new Qb;I.call(this,a,b)};u(L,I);k=L.prototype;k.W=function(a,b){if(!a)return L.G.W.call(this);Gb(this.f,n(b)?b:100,a);this.$()};k.$=function(){for(var a=this.f;0<a.o();){var b=this.W();if(b){var c;var d=a,e=d.a,f=e.length;c=e[0];if(0>=f)c=void 0;else{if(1==f)lb(e);else{e[0]=e.pop();for(var e=0,d=d.a,f=d.length,g=d[e];e<f>>1;){var h=2*e+1,l=2*e+2,h=l<f&&d[l].a<d[h].a?l:h;if(d[h].a>g.a)break;d[e]=d[h];e=h}d[e]=g}c=c.b}c.apply(this,[b])}else break}};
k.Y=function(a){L.G.Y.call(this,a);this.$()};k.S=function(){L.G.S.call(this);this.$()};k.A=function(){L.G.A.call(this);m.clearTimeout(void 0);this.f.clear();this.f=null};var M=function(a,b){a&&a.log(kd,b,void 0)};var qd=function(a,b,c){if(r(a))c&&(a=t(a,c));else if(a&&"function"==typeof a.handleEvent)a=t(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:m.setTimeout(a,b||0)};var N=function(a){J.call(this);this.L=new mc;this.C=a||null;this.c=!1;this.B=this.a=null;this.P=this.l="";this.J=0;this.h="";this.f=this.H=this.j=this.K=!1;this.i=0;this.m=null;this.da="";this.v=this.ba=this.Z=!1};u(N,J);var rd=N.prototype,sd=od("goog.net.XhrIo");rd.u=sd;var td=/^https?$/i,ud=["POST","PUT"];
N.prototype.send=function(a,b,c,d){if(this.a)throw Error("[goog.net.XhrIo] Object is active with another request="+this.l+"; newUri="+a);b=b?b.toUpperCase():"GET";this.l=a;this.h="";this.J=0;this.P=b;this.K=!1;this.c=!0;this.a=this.C?Eb(this.C):Eb(Cb);this.B=this.C?db(this.C):db(Cb);this.a.onreadystatechange=t(this.ca,this);this.ba&&"onprogress"in this.a&&(this.a.onprogress=t(function(a){this.R(a,!0)},this),this.a.upload&&(this.a.upload.onprogress=t(this.R,this)));try{M(this.u,P(this,"Opening Xhr")),
this.H=!0,this.a.open(b,String(a),!0),this.H=!1}catch(f){M(this.u,P(this,"Error opening Xhr: "+f.message));vd(this,f);return}a=c||"";var e=this.L.clone();d&&Kb(d,function(a,b){e.set(b,a)});d=kb(e.D());c=m.FormData&&a instanceof m.FormData;!(0<=eb(ud,b))||d||c||e.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.da&&(this.a.responseType=this.da);Ea(this.a)&&(this.a.withCredentials=this.Z);try{wd(this),0<this.i&&(this.v=
xd(this.a),M(this.u,P(this,"Will abort after "+this.i+"ms if incomplete, xhr2 "+this.v)),this.v?(this.a.timeout=this.i,this.a.ontimeout=t(this.M,this)):this.m=qd(this.M,this.i,this)),M(this.u,P(this,"Sending request")),this.j=!0,this.a.send(a),this.j=!1}catch(f){M(this.u,P(this,"Send error: "+f.message)),vd(this,f)}};var xd=function(a){return F&&G(9)&&"number"==typeof a.timeout&&n(a.ontimeout)},jb=function(a){return"content-type"==a.toLowerCase()};
N.prototype.M=function(){"undefined"!=typeof aa&&this.a&&(this.h="Timed out after "+this.i+"ms, aborting",this.J=8,M(this.u,P(this,this.h)),K(this,"timeout"),yd(this,8))};var vd=function(a,b){a.c=!1;a.a&&(a.f=!0,a.a.abort(),a.f=!1);a.h=b;a.J=5;zd(a);Ad(a)},zd=function(a){a.K||(a.K=!0,K(a,"complete"),K(a,"error"))},yd=function(a,b){a.a&&a.c&&(M(a.u,P(a,"Aborting")),a.c=!1,a.f=!0,a.a.abort(),a.f=!1,a.J=b||7,K(a,"complete"),K(a,"abort"),Ad(a))};
N.prototype.A=function(){this.a&&(this.c&&(this.c=!1,this.f=!0,this.a.abort(),this.f=!1),Ad(this,!0));N.G.A.call(this)};N.prototype.ca=function(){this.g||(this.H||this.j||this.f?Bd(this):this.na())};N.prototype.na=function(){Bd(this)};
var Bd=function(a){if(a.c&&"undefined"!=typeof aa)if(a.B[1]&&4==Dd(a)&&2==Q(a))M(a.u,P(a,"Local request error detected and ignored"));else if(a.j&&4==Dd(a))qd(a.ca,0,a);else if(K(a,"readystatechange"),4==Dd(a)){M(a.u,P(a,"Request complete"));a.c=!1;try{if(Ed(a))K(a,"complete"),K(a,"success");else{a.J=6;var b;try{b=2<Dd(a)?a.a.statusText:""}catch(c){M(a.u,"Can not get status: "+c.message),b=""}a.h=b+" ["+Q(a)+"]";zd(a)}}finally{Ad(a)}}};
N.prototype.R=function(a,b){C("progress"===a.type,"goog.net.EventType.PROGRESS is of the same type as raw XHR progress.");K(this,Fd(a,"progress"));K(this,Fd(a,b?"downloadprogress":"uploadprogress"))};
var Fd=function(a,b){return{type:b,lengthComputable:a.lengthComputable,loaded:a.loaded,total:a.total}},Ad=function(a,b){if(a.a){wd(a);var c=a.a,d=a.B[0]?ba:null;a.a=null;a.B=null;b||K(a,"ready");try{c.onreadystatechange=d}catch(e){(a=a.u)&&a.log(id,"Problem encountered resetting onreadystatechange: "+e.message,void 0)}}},wd=function(a){a.a&&a.v&&(a.a.ontimeout=null);"number"==typeof a.m&&(m.clearTimeout(a.m),a.m=null)},Ed=function(a){var b=Q(a),c;a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:c=
!0;break a;default:c=!1}if(!c){if(b=0===b)a=String(a.l).match(vb)[1]||null,!a&&m.self&&m.self.location&&(a=m.self.location.protocol,a=a.substr(0,a.length-1)),b=!td.test(a?a.toLowerCase():"");c=b}return c},Dd=function(a){return a.a?a.a.readyState:0},Q=function(a){try{return 2<Dd(a)?a.a.status:-1}catch(b){return-1}},Gd=function(a){try{return a.a?a.a.responseText:""}catch(b){return M(a.u,"Can not get responseText: "+b.message),""}},Hd=function(a,b){return a.a&&4==Dd(a)?a.a.getResponseHeader(b):void 0},
P=function(a,b){return b+" ["+a.P+" "+a.l+" "+Q(a)+"]"};var Id=function(a,b,c,d){this.m=a;this.v=!!d;L.call(this,b,c)};u(Id,L);Id.prototype.h=function(){var a=new N,b=this.m;b&&b.forEach(function(b,d){a.L.set(d,b)});this.v&&(a.Z=!0);return a};Id.prototype.j=function(a){return!a.g&&!a.a};var Yc=new Id;var Kd=function(a,b,c,d,e,f,g,h,l,B){this.L=a;this.H=b;this.B=c;this.m=d;this.I=e.slice();this.s=this.l=this.f=this.c=null;this.h=this.i=!1;this.v=f;this.j=g;this.g=l;this.M=B;this.K=h;var v=this;this.C=new H(function(a,b){v.l=a;v.s=b;Jd(v)})},Ld=function(a,b,c){this.b=a;this.c=b;this.a=!!c},Jd=function(a){function b(a,b){b?a(!1,new Ld(!1,null,!0)):Yc.W(function(b){b.Z=d.M;d.c=b;var c=null;null!==d.g&&(b.ba=!0,c=Kc(b,"uploadprogress",function(a){d.g(a.loaded,a.lengthComputable?a.total:-1)}),b.ba=
null!==d.g);b.send(d.L,d.H,d.m,d.B);Sc(b,"complete",function(b){null!==c&&Uc(c);d.c=null;b=b.target;var f=6===b.J&&100<=Q(b),f=Ed(b)||f,g=Q(b);!f||500<=g&&600>g||429===g?(f=7===b.J,Zc(b),a(!1,new Ld(!1,null,f))):(f=0<=eb(d.I,g),a(!0,new Ld(f,b)))})})}function c(a,b){var c=d.l;a=d.s;var h=b.c;if(b.b)try{var l=d.v(h,Gd(h));n(l)?c(l):c()}catch(B){a(B)}else null!==h?(b=la(),l=Gd(h),b.serverResponse=l,d.j?a(d.j(h,b)):a(b)):(b=b.a?d.h?qa():oa():new w("retry-limit-exceeded","Max retry time for operation exceeded, please try again."),
a(b));Zc(h)}var d=a;a.i?c(0,new Ld(!1,null,!0)):a.f=ja(b,c,a.K)};Kd.prototype.a=function(){return this.C};Kd.prototype.b=function(a){this.i=!0;this.h=a||!1;null!==this.f&&(0,this.f)(!1);null!==this.c&&yd(this.c)};var Md=function(a,b,c){var d=Ra(a.f),d=a.l+d,e=a.b?sa(a.b):{};null!==b&&0<b.length&&(e.Authorization="Firebase "+b);e["X-Firebase-Storage-Version"]="webjs/1.0.0";return new Kd(d,a.i,e,a.c,a.h,a.N,a.a,a.j,a.g,c)};var Nd=function(a){var b=m.BlobBuilder||m.WebKitBlobBuilder;if(n(b)){for(var b=new b,c=0;c<arguments.length;c++)b.append(arguments[c]);return b.getBlob()}b=nb(arguments);c=m.BlobBuilder||m.WebKitBlobBuilder;if(n(c)){for(var c=new c,d=0;d<b.length;d++)c.append(b[d],void 0);b=c.getBlob(void 0)}else if(n(m.Blob))b=new Blob(b,{});else throw Error("This browser doesn't seem to support creating Blobs");return b},Od=function(a,b,c){n(c)||(c=a.size);return a.webkitSlice?a.webkitSlice(b,c):a.mozSlice?a.mozSlice(b,
c):a.slice?Ub&&!G("13.0")||Vb&&!G("537.1")?(0>b&&(b+=a.size),0>b&&(b=0),0>c&&(c+=a.size),c<b&&(c=b),a.slice(b,c-b)):a.slice(b,c):null};var Pd=function(a){this.c=vc(a)};Pd.prototype.a=function(){return this.c};Pd.prototype.b=function(){};var Qd=function(){this.a={};this.b=Number.MIN_SAFE_INTEGER},Rd=function(a,b){function c(){delete e.a[d]}var d=a.b;a.b++;a.a[d]=b;var e=a;b.a().then(c,c)};Qd.prototype.clear=function(){ra(this.a,function(a,b){b&&b.b(!0)});this.a={}};var Sd=function(a,b,c,d){this.a=a;this.f=null;null!==this.a&&(a=this.a.options,y(a)?this.f=a.storageBucket||null:this.f=null);this.l=b;this.j=c;this.i=d;this.c=12E4;this.b=6E4;this.h=new Qd;this.g=!1},Td=function(a){return null!==a.a&&y(a.a.INTERNAL)&&y(a.a.INTERNAL.getToken)?a.a.INTERNAL.getToken().then(function(a){return y(a)?a.accessToken:null},function(){return null}):uc(null)};Sd.prototype.bucket=function(){if(this.g)throw qa();return this.f};
var R=function(a,b,c){if(a.g)return new Pd(qa());b=a.j(b,c,null===a.a);Rd(a.h,b);return b};var Ud=function(a,b){return b},S=function(a,b,c,d){this.c=a;this.b=b||a;this.f=!!c;this.a=d||Ud},Vd=null,Wd=function(){if(Vd)return Vd;var a=[];a.push(new S("bucket"));a.push(new S("generation"));a.push(new S("metageneration"));a.push(new S("name","fullPath",!0));var b=new S("name");b.a=function(a,b){return!wa(b)||2>b.length?b:xb(b)};a.push(b);b=new S("size");b.a=function(a,b){return y(b)?+b:b};a.push(b);a.push(new S("timeCreated"));a.push(new S("updated"));a.push(new S("md5Hash",null,!0));a.push(new S("cacheControl",
null,!0));a.push(new S("contentDisposition",null,!0));a.push(new S("contentEncoding",null,!0));a.push(new S("contentLanguage",null,!0));a.push(new S("contentType",null,!0));a.push(new S("metadata","customMetadata",!0));a.push(new S("downloadTokens","downloadURLs",!1,function(a,b){if(!(wa(b)&&0<b.length))return[];var e=encodeURIComponent;return hb(b.split(","),function(b){var d=a.fullPath,d="https://firebasestorage.googleapis.com/v0"+("/b/"+e(a.bucket)+"/o/"+e(d));b=Ra({alt:"media",token:b});return d+
b})}));return Vd=a},Xd=function(a,b){Object.defineProperty(a,"ref",{get:function(){return b.l(b,new z(a.bucket,a.fullPath))}})},Yd=function(a,b){for(var c={},d=b.length,e=0;e<d;e++){var f=b[e];f.f&&(c[f.c]=a[f.b])}return JSON.stringify(c)},Zd=function(a){if(!a||"object"!==typeof a)throw"Expected Metadata object.";for(var b in a){var c=a[b];if("customMetadata"===b&&"object"!==typeof c)throw"Expected object for 'customMetadata' mapping.";}};var T=function(a,b,c){for(var d=b.length,e=b.length,f=0;f<b.length;f++)if(b[f].b){d=f;break}if(!(d<=c.length&&c.length<=e))throw d===e?(b=d,d=1===d?"argument":"arguments"):(b="between "+d+" and "+e,d="arguments"),new w("invalid-argument-count","Invalid argument count in `"+a+"`: Expected "+b+" "+d+", received "+c.length+".");for(f=0;f<c.length;f++)try{b[f].a(c[f])}catch(g){if(g instanceof Error)throw pa(f,a,g.message);throw pa(f,a,g);}},U=function(a,b){var c=this;this.a=function(b){c.b&&!n(b)||a(b)};
this.b=!!b},$d=function(a,b){return function(c){a(c);b(c)}},ae=function(a,b){function c(a){if(!("string"===typeof a||a instanceof String))throw"Expected string.";}var d;a?d=$d(c,a):d=c;return new U(d,b)},be=function(){return new U(function(a){if(!(a instanceof Blob))throw"Expected Blob or File.";})},ce=function(){return new U(function(a){if(!(("number"===typeof a||a instanceof Number)&&0<=a))throw"Expected a number 0 or greater.";})},de=function(a,b){return new U(function(b){if(!(null===b||y(b)&&
b instanceof Object))throw"Expected an Object.";y(a)&&a(b)},b)},ee=function(){return new U(function(a){if(null!==a&&!r(a))throw"Expected a Function.";},!0)};var fe=function(a){if(!a)throw la();},ge=function(a,b){return function(c,d){a:{var e;try{e=JSON.parse(d)}catch(h){c=null;break a}c=da(e)?e:null}if(null===c)c=null;else{d={type:"file"};e=b.length;for(var f=0;f<e;f++){var g=b[f];d[g.b]=g.a(d,c[g.c])}Xd(d,a);c=d}fe(null!==c);return c}},he=function(a){return function(b,c){b=404===Q(b)?new w("object-not-found","Object '"+a.path+"' does not exist."):401===Q(b)?ma():403===Q(b)?na(a.path):c;b.serverResponse=c.serverResponse;return b}},ie=function(a){return function(b,
c){b=401===Q(b)?ma():403===Q(b)?na(a.path):c;b.serverResponse=c.serverResponse;return b}},je=function(a,b,c){var d=Oa(b);a=new x(ka+"/v0"+d,"GET",ge(a,c),a.c);a.a=he(b);return a},ke=function(a,b){var c=Oa(b);a=new x(ka+"/v0"+c,"DELETE",function(){},a.c);a.h=[200,204];a.a=he(b);return a},le=function(a,b,c){c=c?sa(c):{};c.fullPath=a.path;c.size=b.size;c.contentType||(c.contentType=b&&b.type||"application/octet-stream");return c},me=function(a,b,c,d,e){var f="/b/"+encodeURIComponent(b.bucket)+"/o",g=
{"X-Goog-Upload-Protocol":"multipart"},h;h="";for(var l=0;2>l;l++)h+=Math.random().toString().slice(2);g["Content-Type"]="multipart/related; boundary="+h;e=le(b,d,e);l=Yd(e,c);d=Nd("--"+h+"\r\nContent-Type: application/json; charset=utf-8\r\n\r\n"+l+"\r\n--"+h+"\r\nContent-Type: "+e.contentType+"\r\n\r\n",d,"\r\n--"+h+"--");a=new x(ka+"/v0"+f,"POST",ge(a,c),a.b);a.f={name:e.fullPath};a.b=g;a.c=d;a.a=ie(b);return a},ne=function(a,b,c,d){this.a=a;this.total=b;this.b=!!c;this.c=d||null},oe=function(a,
b){var c;try{c=Hd(a,"X-Goog-Upload-Status")}catch(d){fe(!1)}a=0<=eb(b||["active"],c);fe(a);return c},pe=function(a,b,c,d,e){var f="/b/"+encodeURIComponent(b.bucket)+"/o",g=le(b,d,e);e={name:g.fullPath};f=ka+"/v0"+f;d={"X-Goog-Upload-Protocol":"resumable","X-Goog-Upload-Command":"start","X-Goog-Upload-Header-Content-Length":d.size,"X-Goog-Upload-Header-Content-Type":g.contentType,"Content-Type":"application/json; charset=utf-8"};c=Yd(g,c);a=new x(f,"POST",function(a){oe(a);var b;try{b=Hd(a,"X-Goog-Upload-URL")}catch(c){fe(!1)}fe(wa(b));
return b},a.b);a.f=e;a.b=d;a.c=c;a.a=ie(b);return a},qe=function(a,b,c,d){a=new x(c,"POST",function(a){var b=oe(a,["active","final"]),c;try{c=Hd(a,"X-Goog-Upload-Size-Received")}catch(h){fe(!1)}a=c;isFinite(a)&&(a=String(a));a=q(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN;fe(!isNaN(a));return new ne(a,d.size,"final"===b)},a.b);a.b={"X-Goog-Upload-Command":"query"};a.a=ie(b);return a},re=function(a,b,c,d,e,f){var g=new ne(0,0);f?(g.a=f.a,g.total=f.total):(g.a=0,g.total=d.size);if(d.size!==
g.total)throw new w("server-file-wrong-size","Server recorded incorrect upload file size, please retry the upload.");var h=f=g.total-g.a,h=Math.min(h,262144),l=g.a;f={"X-Goog-Upload-Command":h===f?"upload, finalize":"upload","X-Goog-Upload-Offset":g.a};l=Od(d,l,l+h);if(null===l)throw new w("cannot-slice-blob","Cannot slice blob for upload. Please retry the upload.");c=new x(c,"POST",function(a,c){var f=oe(a,["active","final"]),l=g.a+h,Cd=d.size,Va;"final"===f?Va=ge(b,e)(a,c):Va=null;return new ne(l,
Cd,"final"===f,Va)},b.b);c.b=f;c.c=l;c.g=null;c.a=ie(a);return c};var W=function(a,b,c,d,e,f){this.K=a;this.c=b;this.i=c;this.f=e;this.h=f||null;this.l=d;this.j=0;this.B=this.s=!1;this.v=[];this.R=262144<this.f.size;this.b="running";this.a=this.m=this.g=null;var g=this;this.V=function(a){g.a=null;"storage/canceled"===a.code?(g.s=!0,se(g)):(g.g=a,V(g,"error"))};this.P=function(a){g.a=null;"storage/canceled"===a.code?se(g):(g.g=a,V(g,"error"))};te(this)},te=function(a){"running"===a.b&&null===a.a&&(a.R?null===a.m?ue(a):a.s?ve(a):a.B?we(a):xe(a):ye(a))},ze=function(a,
b){Td(a.c).then(function(c){switch(a.b){case "running":b(c);break;case "canceling":V(a,"canceled");break;case "pausing":V(a,"paused")}})},ue=function(a){ze(a,function(b){var c=pe(a.c,a.i,a.l,a.f,a.h);a.a=R(a.c,c,b);a.a.a().then(function(b){a.a=null;a.m=b;a.s=!1;se(a)},this.V)})},ve=function(a){var b=a.m;ze(a,function(c){var d=qe(a.c,a.i,b,a.f);a.a=R(a.c,d,c);a.a.a().then(function(b){a.a=null;Ae(a,b.a);a.s=!1;b.b&&(a.B=!0);se(a)},a.V)})},xe=function(a){var b=new ne(a.j,a.f.size),c=a.m;ze(a,function(d){var e;
try{e=re(a.i,a.c,c,a.f,a.l,b)}catch(f){a.g=f;V(a,"error");return}a.a=R(a.c,e,d);a.a.a().then(function(b){a.a=null;Ae(a,b.a);b.b?(a.h=b.c,V(a,"success")):se(a)},a.V)})},we=function(a){ze(a,function(b){var c=je(a.c,a.i,a.l);a.a=R(a.c,c,b);a.a.a().then(function(b){a.a=null;a.h=b;V(a,"success")},a.P)})},ye=function(a){ze(a,function(b){var c=me(a.c,a.i,a.l,a.f,a.h);a.a=R(a.c,c,b);a.a.a().then(function(b){a.a=null;a.h=b;Ae(a,a.f.size);V(a,"success")},a.V)})},Ae=function(a,b){var c=a.j;a.j=b;a.j>c&&Be(a)},
V=function(a,b){if(a.b!==b)switch(b){case "canceling":a.b=b;null!==a.a&&a.a.b();break;case "pausing":a.b=b;null!==a.a&&a.a.b();break;case "running":var c="paused"===a.b;a.b=b;c&&(Be(a),te(a));break;case "paused":a.b=b;Be(a);break;case "canceled":a.g=oa();a.b=b;Be(a);break;case "error":a.b=b;Be(a);break;case "success":a.b=b,Be(a)}},se=function(a){switch(a.b){case "pausing":V(a,"paused");break;case "canceling":V(a,"canceled");break;case "running":te(a)}};
W.prototype.C=function(){return new A(this.j,this.f.size,va(this.b),this.h,this,this.K)};
W.prototype.I=function(a,b,c,d){function e(a){try{g(a);return}catch(b){}try{if(h(a),!(n(a.next)||n(a.error)||n(a.complete)))throw"";}catch(b){throw"Expected a function or an Object with one of `next`, `error`, `complete` properties.";}}function f(a){return function(b,c,d){null!==a&&T("on",a,arguments);var e=new Qa(b,c,d);Ce(l,e);return function(){mb(l.v,e)}}}var g=ee().a,h=de(null,!0).a;T("on",[ae(function(){if("state_changed"!==a)throw"Expected one of the event types: [state_changed].";}),de(e,!0),
ee(),ee()],arguments);var l=this,B=[de(function(a){if(null===a)throw"Expected a function or an Object with one of `next`, `error`, `complete` properties.";e(a)}),ee(),ee()];return n(b)||n(c)||n(d)?f(null)(b,c,d):f(B)};
var Ce=function(a,b){a.v.push(b);De(a,b)},Be=function(a){var b=nb(a.v);fb(b,function(b){De(a,b)})},De=function(a,b){switch(va(a.b)){case "running":case "paused":null!==b.next&&Gc(b.next.bind(b,a.C()))();break;case "success":null!==b.a&&Gc(b.a.bind(b))();break;case "canceled":case "error":null!==b.error&&Gc(b.error.bind(b,a.g))();break;default:null!==b.error&&Gc(b.error.bind(b,a.g))()}};
W.prototype.M=function(){T("resume",[],arguments);var a="paused"===this.b||"pausing"===this.b;a&&V(this,"running");return a};W.prototype.L=function(){T("pause",[],arguments);var a="running"===this.b;a&&V(this,"pausing");return a};W.prototype.H=function(){T("cancel",[],arguments);var a="running"===this.b||"pausing"===this.b;a&&V(this,"canceling");return a};var X=function(a,b){this.b=a;if(b)this.a=b instanceof z?b:Pa(b);else if(a=a.bucket(),null!==a)this.a=new z(a,"");else throw new w("no-default-bucket","No default bucket found. Did you set the 'storageBucket' property when initializing the app?");};X.prototype.toString=function(){T("toString",[],arguments);return"gs://"+this.a.bucket+"/"+this.a.path};var Ee=function(a,b){return new X(a,b)};k=X.prototype;
k.ga=function(a){T("child",[ae()],arguments);var b=wb(this.a.path,a);return Ee(this.b,new z(this.a.bucket,b))};k.Fa=function(){var a;a=this.a.path;if(0==a.length)a=null;else{var b=a.lastIndexOf("/");a=-1===b?"":a.slice(0,b)}return null===a?null:Ee(this.b,new z(this.a.bucket,a))};k.Ha=function(){return Ee(this.b,new z(this.a.bucket,""))};k.pa=function(){return this.a.bucket};k.Aa=function(){return this.a.path};k.Ea=function(){return xb(this.a.path)};k.Ja=function(){return this.b.i};
k.ua=function(a,b){T("put",[be(),new U(Zd,!0)],arguments);Fe(this,"put");return new W(this,this.b,this.a,Wd(),a,b)};k.delete=function(){T("delete",[],arguments);Fe(this,"delete");var a=this;return Td(this.b).then(function(b){var c=ke(a.b,a.a);return R(a.b,c,b).a()})};k.ha=function(){T("getMetadata",[],arguments);Fe(this,"getMetadata");var a=this;return Td(this.b).then(function(b){var c=je(a.b,a.a,Wd());return R(a.b,c,b).a()})};
k.va=function(a){T("updateMetadata",[new U(Zd,void 0)],arguments);Fe(this,"updateMetadata");var b=this;return Td(this.b).then(function(c){var d=b.b,e=b.a,f=a,g=Wd(),h=Oa(e),h=ka+"/v0"+h,f=Yd(f,g),d=new x(h,"PATCH",ge(d,g),d.c);d.b={"Content-Type":"application/json; charset=utf-8"};d.c=f;d.a=he(e);return R(b.b,d,c).a()})};
k.ta=function(){T("getDownloadURL",[],arguments);Fe(this,"getDownloadURL");return this.ha().then(function(a){a=a.downloadURLs[0];if(y(a))return a;throw new w("no-download-url","The given file does not have any download URLs.");})};var Fe=function(a,b){if(""===a.a.path)throw new w("invalid-root-operation","The operation '"+b+"' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");};var Y=function(a){this.a=new Sd(a,function(a,c){return new X(a,c)},Md,this);this.b=a;this.c=new Ge(this)};k=Y.prototype;k.wa=function(a){T("ref",[ae(function(a){if(/^[A-Za-z]+:\/\//.test(a))throw"Expected child path but got a URL, use refFromURL instead.";},!0)],arguments);var b=new X(this.a);return n(a)?b.ga(a):b};
k.xa=function(a){T("refFromURL",[ae(function(a){if(!/^[A-Za-z]+:\/\//.test(a))throw"Expected full URL but got a child path, use ref instead.";try{Pa(a)}catch(c){throw"Expected valid full URL but got an invalid one.";}},!1)],arguments);return new X(this.a,a)};k.Ca=function(){return this.a.b};k.za=function(a){T("setMaxUploadRetryTime",[ce()],arguments);this.a.b=a};k.Ba=function(){return this.a.c};k.ya=function(a){T("setMaxOperationRetryTime",[ce()],arguments);this.a.c=a};k.oa=function(){return this.b};
k.la=function(){return this.c};var Ge=function(a){this.a=a};Ge.prototype.delete=function(){var a=this.a.a;a.g=!0;a.a=null;a.h.clear()};var Z=function(a,b,c){Object.defineProperty(a,b,{get:c})};X.prototype.toString=X.prototype.toString;X.prototype.child=X.prototype.ga;X.prototype.put=X.prototype.ua;X.prototype["delete"]=X.prototype.delete;X.prototype.getMetadata=X.prototype.ha;X.prototype.updateMetadata=X.prototype.va;X.prototype.getDownloadURL=X.prototype.ta;Z(X.prototype,"parent",X.prototype.Fa);Z(X.prototype,"root",X.prototype.Ha);Z(X.prototype,"bucket",X.prototype.pa);Z(X.prototype,"fullPath",X.prototype.Aa);
Z(X.prototype,"name",X.prototype.Ea);Z(X.prototype,"storage",X.prototype.Ja);Y.prototype.ref=Y.prototype.wa;Y.prototype.refFromURL=Y.prototype.xa;Z(Y.prototype,"maxOperationRetryTime",Y.prototype.Ba);Y.prototype.setMaxOperationRetryTime=Y.prototype.ya;Z(Y.prototype,"maxUploadRetryTime",Y.prototype.Ca);Y.prototype.setMaxUploadRetryTime=Y.prototype.za;Z(Y.prototype,"app",Y.prototype.oa);Z(Y.prototype,"INTERNAL",Y.prototype.la);Ge.prototype["delete"]=Ge.prototype.delete;
Y.prototype.capi_=function(a){ka=a};W.prototype.on=W.prototype.I;W.prototype.resume=W.prototype.M;W.prototype.pause=W.prototype.L;W.prototype.cancel=W.prototype.H;Z(W.prototype,"snapshot",W.prototype.C);Z(A.prototype,"bytesTransferred",A.prototype.qa);Z(A.prototype,"totalBytes",A.prototype.La);Z(A.prototype,"state",A.prototype.Ia);Z(A.prototype,"metadata",A.prototype.Da);Z(A.prototype,"downloadURL",A.prototype.sa);Z(A.prototype,"task",A.prototype.Ka);Z(A.prototype,"ref",A.prototype.Ga);
ta.STATE_CHANGED="state_changed";ua.RUNNING="running";ua.PAUSED="paused";ua.SUCCESS="success";ua.CANCELED="canceled";ua.ERROR="error";H.prototype["catch"]=H.prototype.l;H.prototype.then=H.prototype.then;
(function(){function a(a){return new Y(a)}var b={TaskState:ua,TaskEvent:ta,Storage:Y,Reference:X};if(window.firebase&&firebase.INTERNAL&&firebase.INTERNAL.registerService)firebase.INTERNAL.registerService("storage",a,b);else throw Error("Cannot install Firebase Storage - be sure to load firebase-app.js first.");})();})();

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/firebase/firebase.js","/../../node_modules/firebase")
},{"buffer":2,"rH1JPG":8}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/ieee754/index.js","/../../node_modules/ieee754")
},{"buffer":2,"rH1JPG":8}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {
		var key;

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );
	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	// Support: Opera 12.1x only
	// Fall back to style even without computed
	// computed is undefined for elems on document fragments
	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
		ret = jQuery.style( elem, name );
	}

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/jquery/dist/jquery.js","/../../node_modules/jquery/dist")
},{"buffer":2,"rH1JPG":8}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * JavaScript Cookie v2.1.2
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var result;
			if (typeof document === 'undefined') {
				return;
			}

			// Write

			if (arguments.length > 1) {
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				if (!converter.write) {
					value = encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
				} else {
					value = converter.write(value, key);
				}

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				return (document.cookie = [
					key, '=', value,
					attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
					attributes.path    && '; path=' + attributes.path,
					attributes.domain  && '; domain=' + attributes.domain,
					attributes.secure ? '; secure' : ''
				].join(''));
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()"
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = parts[0].replace(rdecode, decodeURIComponent);
					cookie = converter.read ?
						converter.read(cookie, name) : converter(cookie, name) ||
						cookie.replace(rdecode, decodeURIComponent);

					if (this.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.set = api;
		api.get = function (key) {
			return api(key);
		};
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/js-cookie/src/js.cookie.js","/../../node_modules/js-cookie/src")
},{"buffer":2,"rH1JPG":8}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/process/browser.js","/../../node_modules/process")
},{"buffer":2,"rH1JPG":8}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
	Ractive.js v0.7.3
	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Ractive = factory()
}(this, function () { 'use strict';

  var TEMPLATE_VERSION = 3;

  var defaultOptions = {

  	// render placement:
  	el: void 0,
  	append: false,

  	// template:
  	template: { v: TEMPLATE_VERSION, t: [] },

  	// parse:     // TODO static delimiters?
  	preserveWhitespace: false,
  	sanitize: false,
  	stripComments: true,
  	delimiters: ["{{", "}}"],
  	tripleDelimiters: ["{{{", "}}}"],
  	interpolate: false,

  	// data & binding:
  	data: {},
  	computed: {},
  	magic: false,
  	modifyArrays: true,
  	adapt: [],
  	isolated: false,
  	twoway: true,
  	lazy: false,

  	// transitions:
  	noIntro: false,
  	transitionsEnabled: true,
  	complete: void 0,

  	// css:
  	css: null,
  	noCssTransform: false
  };

  var config_defaults = defaultOptions;

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.

  var static_easing = {
  	linear: function (pos) {
  		return pos;
  	},
  	easeIn: function (pos) {
  		return Math.pow(pos, 3);
  	},
  	easeOut: function (pos) {
  		return Math.pow(pos - 1, 3) + 1;
  	},
  	easeInOut: function (pos) {
  		if ((pos /= 0.5) < 1) {
  			return 0.5 * Math.pow(pos, 3);
  		}
  		return 0.5 * (Math.pow(pos - 2, 3) + 2);
  	}
  };

  /*global console, navigator */
  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;

  isClient = typeof document === "object";

  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);

  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";

  try {
  	Object.defineProperty({}, "test", { value: 0 });
  	environment__magic = true;
  } catch (e) {
  	environment__magic = false;
  }

  namespaces = {
  	html: "http://www.w3.org/1999/xhtml",
  	mathml: "http://www.w3.org/1998/Math/MathML",
  	svg: "http://www.w3.org/2000/svg",
  	xlink: "http://www.w3.org/1999/xlink",
  	xml: "http://www.w3.org/XML/1998/namespace",
  	xmlns: "http://www.w3.org/2000/xmlns/"
  };

  if (typeof document === "undefined") {
  	svg = false;
  } else {
  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
  }

  vendors = ["o", "ms", "moz", "webkit"];

  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;

  // Test for SVG support
  if (!svg) {
  	createElement = function (type, ns) {
  		if (ns && ns !== namespaces.html) {
  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";
  		}

  		return document.createElement(type);
  	};
  } else {
  	createElement = function (type, ns) {
  		if (!ns || ns === namespaces.html) {
  			return document.createElement(type);
  		}

  		return document.createElementNS(ns, type);
  	};
  }

  function getElement(input) {
  	var output;

  	if (!input || typeof input === "boolean") {
  		return;
  	}

  	if (typeof window === "undefined" || !document || !input) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if (input.nodeType) {
  		return input;
  	}

  	// Get node from string
  	if (typeof input === "string") {
  		// try ID first
  		output = document.getElementById(input);

  		// then as selector, if possible
  		if (!output && document.querySelector) {
  			output = document.querySelector(input);
  		}

  		// did it work?
  		if (output && output.nodeType) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if (input[0] && input[0].nodeType) {
  		return input[0];
  	}

  	return null;
  }

  if (!isClient) {
  	matches = null;
  } else {
  	dom__div = createElement("div");
  	methodNames = ["matches", "matchesSelector"];

  	makeFunction = function (methodName) {
  		return function (node, selector) {
  			return node[methodName](selector);
  		};
  	};

  	dom__i = methodNames.length;

  	while (dom__i-- && !matches) {
  		unprefixed = methodNames[dom__i];

  		if (dom__div[unprefixed]) {
  			matches = makeFunction(unprefixed);
  		} else {
  			j = vendors.length;
  			while (j--) {
  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

  				if (dom__div[prefixed]) {
  					matches = makeFunction(prefixed);
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if (!matches) {
  		matches = function (node, selector) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if (!parentNode) {
  				// empty dummy <div>
  				dom__div.innerHTML = "";

  				parentNode = dom__div;
  				node = node.cloneNode();

  				dom__div.appendChild(node);
  			}

  			nodes = parentNode.querySelectorAll(selector);

  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] === node) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode(node) {
  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {
  		node.parentNode.removeChild(node);
  	}

  	return node;
  }

  function safeToStringValue(value) {
  	return value == null || !value.toString ? "" : value;
  }

  var legacy = null;

  var create, defineProperty, defineProperties;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	if (isClient) {
  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch (err) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function (obj, prop, desc) {
  		obj[prop] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch (err) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if (isClient) {
  		Object.defineProperties(createElement("div"), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch (err) {
  	defineProperties = function (obj, props) {
  		var prop;

  		for (prop in props) {
  			if (props.hasOwnProperty(prop)) {
  				defineProperty(obj, prop, props[prop]);
  			}
  		}
  	};
  }

  try {
  	Object.create(null);

  	create = Object.create;
  } catch (err) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function (proto, props) {
  			var obj;

  			if (proto === null) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if (props) {
  				Object.defineProperties(obj, props);
  			}

  			return obj;
  		};
  	})();
  }

  function utils_object__extend(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	var prop, source;

  	while (source = sources.shift()) {
  		for (prop in source) {
  			if (hasOwn.call(source, prop)) {
  				target[prop] = source[prop];
  			}
  		}
  	}

  	return target;
  }

  function fillGaps(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	sources.forEach(function (s) {
  		for (var key in s) {
  			if (s.hasOwnProperty(key) && !(key in target)) {
  				target[key] = s[key];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  var is__toString = Object.prototype.toString,
      arrayLikePattern = /^\[object (?:Array|FileList)\]$/;
  function isArray(thing) {
  	return is__toString.call(thing) === "[object Array]";
  }

  function isArrayLike(obj) {
  	return arrayLikePattern.test(is__toString.call(obj));
  }

  function isEqual(a, b) {
  	if (a === null && b === null) {
  		return true;
  	}

  	if (typeof a === "object" || typeof b === "object") {
  		return false;
  	}

  	return a === b;
  }

  function is__isNumeric(thing) {
  	return !isNaN(parseFloat(thing)) && isFinite(thing);
  }

  function isObject(thing) {
  	return thing && is__toString.call(thing) === "[object Object]";
  }

  var noop = function () {};

  /* global console */
  var alreadyWarned = {},
      log,
      printWarning,
      welcome;

  if (hasConsole) {
  	(function () {
  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];
  		var welcomeMessage = "You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  		welcome = function () {
  			var hasGroup = !!console.groupCollapsed;
  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);
  			console.log(welcomeMessage);
  			if (hasGroup) {
  				console.groupEnd(welcomeIntro);
  			}

  			welcome = noop;
  		};

  		printWarning = function (message, args) {
  			welcome();

  			// extract information about the instance this message pertains to, if applicable
  			if (typeof args[args.length - 1] === "object") {
  				var options = args.pop();
  				var ractive = options ? options.ractive : null;

  				if (ractive) {
  					// if this is an instance of a component that we know the name of, add
  					// it to the message
  					var _name = undefined;
  					if (ractive.component && (_name = ractive.component.name)) {
  						message = "<" + _name + "> " + message;
  					}

  					var node = undefined;
  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {
  						args.push(node);
  					}
  				}
  			}

  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));
  		};

  		log = function () {
  			console.log.apply(console, arguments);
  		};
  	})();
  } else {
  	printWarning = log = welcome = noop;
  }

  function format(message, args) {
  	return message.replace(/%s/g, function () {
  		return args.shift();
  	});
  }

  function fatal(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	throw new Error(message);
  }

  function logIfDebug() {
  	if (_Ractive.DEBUG) {
  		log.apply(null, arguments);
  	}
  }

  function warn(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	printWarning(message, args);
  }

  function warnOnce(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);

  	if (alreadyWarned[message]) {
  		return;
  	}

  	alreadyWarned[message] = true;
  	printWarning(message, args);
  }

  function warnIfDebug() {
  	if (_Ractive.DEBUG) {
  		warn.apply(null, arguments);
  	}
  }

  function warnOnceIfDebug() {
  	if (_Ractive.DEBUG) {
  		warnOnce.apply(null, arguments);
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = "Bad arguments";
  var noRegistryFunctionReturn = "A function was specified for \"%s\" %s, but no %s was returned";
  var missingPlugin = function (name, type) {
    return "Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";
  };

  function findInViewHierarchy(registryName, ractive, name) {
  	var instance = findInstance(registryName, ractive, name);
  	return instance ? instance[registryName][name] : null;
  }

  function findInstance(registryName, ractive, name) {
  	while (ractive) {
  		if (name in ractive[registryName]) {
  			return ractive;
  		}

  		if (ractive.isolated) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  var interpolate = function (from, to, ractive, type) {
  	if (from === to) {
  		return snap(to);
  	}

  	if (type) {

  		var interpol = findInViewHierarchy("interpolators", ractive, type);
  		if (interpol) {
  			return interpol(from, to) || snap(to);
  		}

  		fatal(missingPlugin(type, "interpolator"));
  	}

  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);
  };

  var shared_interpolate = interpolate;

  function snap(to) {
  	return function () {
  		return to;
  	};
  }

  var interpolators = {
  	number: function (from, to) {
  		var delta;

  		if (!is__isNumeric(from) || !is__isNumeric(to)) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if (!delta) {
  			return function () {
  				return from;
  			};
  		}

  		return function (t) {
  			return from + t * delta;
  		};
  	},

  	array: function (from, to) {
  		var intermediate, interpolators, len, i;

  		if (!isArray(from) || !isArray(to)) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min(from.length, to.length);
  		while (i--) {
  			interpolators[i] = shared_interpolate(from[i], to[i]);
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for (i = len; i < from.length; i += 1) {
  			intermediate[i] = from[i];
  		}

  		for (i = len; i < to.length; i += 1) {
  			intermediate[i] = to[i];
  		}

  		return function (t) {
  			var i = len;

  			while (i--) {
  				intermediate[i] = interpolators[i](t);
  			}

  			return intermediate;
  		};
  	},

  	object: function (from, to) {
  		var properties, len, interpolators, intermediate, prop;

  		if (!isObject(from) || !isObject(to)) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for (prop in from) {
  			if (hasOwn.call(from, prop)) {
  				if (hasOwn.call(to, prop)) {
  					properties.push(prop);
  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);
  				} else {
  					intermediate[prop] = from[prop];
  				}
  			}
  		}

  		for (prop in to) {
  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {
  				intermediate[prop] = to[prop];
  			}
  		}

  		len = properties.length;

  		return function (t) {
  			var i = len,
  			    prop;

  			while (i--) {
  				prop = properties[i];

  				intermediate[prop] = interpolators[prop](t);
  			}

  			return intermediate;
  		};
  	}
  };

  var static_interpolators = interpolators;

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;

  var starMaps = {};
  function getPotentialWildcardMatches(keypath) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = keypath.split(".");
  	if (!(starMap = starMaps[keys.length])) {
  		starMap = getStarMap(keys.length);
  	}

  	result = [];

  	mapper = function (star, i) {
  		return star ? "*" : keys[i];
  	};

  	i = starMap.length;
  	while (i--) {
  		wildcardKeypath = starMap[i].map(mapper).join(".");

  		if (!result.hasOwnProperty(wildcardKeypath)) {
  			result.push(wildcardKeypath);
  			result[wildcardKeypath] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap(num) {
  	var ones = "",
  	    max,
  	    binary,
  	    starMap,
  	    mapper,
  	    i,
  	    j,
  	    l,
  	    map;

  	if (!starMaps[num]) {
  		starMap = [];

  		while (ones.length < num) {
  			ones += 1;
  		}

  		max = parseInt(ones, 2);

  		mapper = function (digit) {
  			return digit === "1";
  		};

  		for (i = 0; i <= max; i += 1) {
  			binary = i.toString(2);
  			while (binary.length < num) {
  				binary = "0" + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push(mapper(binary[j]));
  			}
  			starMap[i] = map;
  		}

  		starMaps[num] = starMap;
  	}

  	return starMaps[num];
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var patternPattern = /\*/;
  var keypathCache = {};

  var Keypath = function (str) {
  	var keys = str.split(".");

  	this.str = str;

  	if (str[0] === "@") {
  		this.isSpecial = true;
  		this.value = decodeKeypath(str);
  	}

  	this.firstKey = keys[0];
  	this.lastKey = keys.pop();

  	this.isPattern = patternPattern.test(str);

  	this.parent = str === "" ? null : getKeypath(keys.join("."));
  	this.isRoot = !str;
  };

  Keypath.prototype = {
  	equalsOrStartsWith: function (keypath) {
  		return keypath === this || this.startsWith(keypath);
  	},

  	join: function (str) {
  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);
  	},

  	replace: function (oldKeypath, newKeypath) {
  		if (this === oldKeypath) {
  			return newKeypath;
  		}

  		if (this.startsWith(oldKeypath)) {
  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));
  		}
  	},

  	startsWith: function (keypath) {
  		if (!keypath) {
  			// TODO under what circumstances does this happen?
  			return false;
  		}

  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";
  	},

  	toString: function () {
  		throw new Error("Bad coercion");
  	},

  	valueOf: function () {
  		throw new Error("Bad coercion");
  	},

  	wildcardMatches: function () {
  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));
  	}
  };
  function assignNewKeypath(target, property, oldKeypath, newKeypath) {
  	var existingKeypath = target[property];

  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {
  		return;
  	}

  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;
  	return true;
  }

  function decodeKeypath(keypath) {
  	var value = keypath.slice(2);

  	if (keypath[1] === "i") {
  		return is__isNumeric(value) ? +value : value;
  	} else {
  		return value;
  	}
  }

  function getKeypath(str) {
  	if (str == null) {
  		return str;
  	}

  	// TODO it *may* be worth having two versions of this function - one where
  	// keypathCache inherits from null, and one for IE8. Depends on how
  	// much of an overhead hasOwnProperty is - probably negligible
  	if (!keypathCache.hasOwnProperty(str)) {
  		keypathCache[str] = new Keypath(str);
  	}

  	return keypathCache[str];
  }

  function getMatchingKeypaths(ractive, keypath) {
  	var keys, key, matchingKeypaths;

  	keys = keypath.str.split(".");
  	matchingKeypaths = [rootKeypath];

  	while (key = keys.shift()) {
  		if (key === "*") {
  			// expand to find all valid child keypaths
  			matchingKeypaths = matchingKeypaths.reduce(expand, []);
  		} else {
  			if (matchingKeypaths[0] === rootKeypath) {
  				// first key
  				matchingKeypaths[0] = getKeypath(key);
  			} else {
  				matchingKeypaths = matchingKeypaths.map(concatenate(key));
  			}
  		}
  	}

  	return matchingKeypaths;

  	function expand(matchingKeypaths, keypath) {
  		var wrapper, value, keys;

  		if (keypath.isRoot) {
  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));
  		} else {
  			wrapper = ractive.viewmodel.wrapped[keypath.str];
  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);

  			keys = value ? Object.keys(value) : null;
  		}

  		if (keys) {
  			keys.forEach(function (key) {
  				if (key !== "_ractive" || !isArray(value)) {
  					matchingKeypaths.push(keypath.join(key));
  				}
  			});
  		}

  		return matchingKeypaths;
  	}
  }

  function concatenate(key) {
  	return function (keypath) {
  		return keypath.join(key);
  	};
  }
  function normalise(ref) {
  	return ref ? ref.replace(refPattern, ".$1") : "";
  }

  var rootKeypath = getKeypath("");

  var shared_add = add;
  var shared_add__errorMessage = "Cannot add to a non-numeric value";
  function add(root, keypath, d) {
  	if (typeof keypath !== "string" || !is__isNumeric(d)) {
  		throw new Error("Bad arguments");
  	}

  	var value = undefined,
  	    changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			var value = root.viewmodel.get(keypath);

  			if (!is__isNumeric(value)) {
  				throw new Error(shared_add__errorMessage);
  			}

  			changes[keypath.str] = value + d;
  		});

  		return root.set(changes);
  	}

  	value = root.get(keypath);

  	if (!is__isNumeric(value)) {
  		throw new Error(shared_add__errorMessage);
  	}

  	return root.set(keypath, +value + d);
  }

  var prototype_add = Ractive$add;
  function Ractive$add(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? 1 : +d);
  }

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if (typeof window === "undefined") {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function (vendors, lastTime, window) {

  		var x, setTimeout;

  		if (window.requestAnimationFrame) {
  			return;
  		}

  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
  		}

  		if (!window.requestAnimationFrame) {
  			setTimeout = window.setTimeout;

  			window.requestAnimationFrame = function (callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max(0, 16 - (currTime - lastTime));
  				id = setTimeout(function () {
  					callback(currTime + timeToCall);
  				}, timeToCall);

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}
  	})(vendors, 0, window);

  	requestAnimationFrame = window.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime;

  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {
  	getTime = function () {
  		return window.performance.now();
  	};
  } else {
  	getTime = function () {
  		return Date.now();
  	};
  }

  var utils_getTime = getTime;

  var deprecations = {
  	construct: {
  		deprecated: "beforeInit",
  		replacement: "onconstruct"
  	},
  	render: {
  		deprecated: "init",
  		message: "The \"init\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \"oninit\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \"onrender\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."
  	},
  	complete: {
  		deprecated: "complete",
  		replacement: "oncomplete"
  	}
  };

  function Hook(event) {
  	this.event = event;
  	this.method = "on" + event;
  	this.deprecate = deprecations[event];
  }

  Hook.prototype.fire = function (ractive, arg) {
  	function call(method) {
  		if (ractive[method]) {
  			arg ? ractive[method](arg) : ractive[method]();
  			return true;
  		}
  	}

  	call(this.method);

  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {
  		if (this.deprecate.message) {
  			warnIfDebug(this.deprecate.message);
  		} else {
  			warnIfDebug("The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);
  		}
  	}

  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);
  };

  var hooks_Hook = Hook;

  function addToArray(array, value) {
  	var index = array.indexOf(value);

  	if (index === -1) {
  		array.push(value);
  	}
  }

  function arrayContains(array, value) {
  	for (var i = 0, c = array.length; i < c; i++) {
  		if (array[i] == value) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch(a, b) {
  	var i;

  	if (!isArray(a) || !isArray(b)) {
  		return false;
  	}

  	if (a.length !== b.length) {
  		return false;
  	}

  	i = a.length;
  	while (i--) {
  		if (a[i] !== b[i]) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray(x) {
  	if (typeof x === "string") {
  		return [x];
  	}

  	if (x === undefined) {
  		return [];
  	}

  	return x;
  }

  function lastItem(array) {
  	return array[array.length - 1];
  }

  function removeFromArray(array, member) {
  	var index = array.indexOf(member);

  	if (index !== -1) {
  		array.splice(index, 1);
  	}
  }

  function toArray(arrayLike) {
  	var array = [],
  	    i = arrayLike.length;
  	while (i--) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise,
      PENDING = {},
      FULFILLED = {},
      REJECTED = {};

  if (typeof Promise === "function") {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function (callback) {
  		var fulfilledHandlers = [],
  		    rejectedHandlers = [],
  		    state = PENDING,
  		    result,
  		    dispatchHandlers,
  		    makeResolver,
  		    fulfil,
  		    reject,
  		    promise;

  		makeResolver = function (newState) {
  			return function (value) {
  				if (state !== PENDING) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait(dispatchHandlers);
  			};
  		};

  		fulfil = makeResolver(FULFILLED);
  		reject = makeResolver(REJECTED);

  		try {
  			callback(fulfil, reject);
  		} catch (err) {
  			reject(err);
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function (onFulfilled, onRejected) {
  				var promise2 = new _Promise(function (fulfil, reject) {

  					var processResolutionHandler = function (handler, handlers, forward) {

  						// 2.2.1.1
  						if (typeof handler === "function") {
  							handlers.push(function (p1result) {
  								var x;

  								try {
  									x = handler(p1result);
  									utils_Promise__resolve(promise2, x, fulfil, reject);
  								} catch (err) {
  									reject(err);
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push(forward);
  						}
  					};

  					// 2.2
  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
  					processResolutionHandler(onRejected, rejectedHandlers, reject);

  					if (state !== PENDING) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait(dispatchHandlers);
  					}
  				});

  				return promise2;
  			}
  		};

  		promise["catch"] = function (onRejected) {
  			return this.then(null, onRejected);
  		};

  		return promise;
  	};

  	_Promise.all = function (promises) {
  		return new _Promise(function (fulfil, reject) {
  			var result = [],
  			    pending,
  			    i,
  			    processPromise;

  			if (!promises.length) {
  				fulfil(result);
  				return;
  			}

  			processPromise = function (promise, i) {
  				if (promise && typeof promise.then === "function") {
  					promise.then(function (value) {
  						result[i] = value;
  						--pending || fulfil(result);
  					}, reject);
  				} else {
  					result[i] = promise;
  					--pending || fulfil(result);
  				}
  			};

  			pending = i = promises.length;
  			while (i--) {
  				processPromise(promises[i], i);
  			}
  		});
  	};

  	_Promise.resolve = function (value) {
  		return new _Promise(function (fulfil) {
  			fulfil(value);
  		});
  	};

  	_Promise.reject = function (reason) {
  		return new _Promise(function (fulfil, reject) {
  			reject(reason);
  		});
  	};
  }

  var utils_Promise = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait(callback) {
  	setTimeout(callback, 0);
  }

  function makeDispatcher(handlers, result) {
  	return function () {
  		var handler;

  		while (handler = handlers.shift()) {
  			handler(result);
  		}
  	};
  }

  function utils_Promise__resolve(promise, x, fulfil, reject) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if (x === promise) {
  		throw new TypeError("A promise's fulfillment handler cannot return the same promise");
  	}

  	// 2.3.2
  	if (x instanceof _Promise) {
  		x.then(fulfil, reject);
  	}

  	// 2.3.3
  	else if (x && (typeof x === "object" || typeof x === "function")) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch (e) {
  			reject(e); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if (typeof then === "function") {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function (y) {
  				if (called) {
  					return;
  				}
  				called = true;
  				utils_Promise__resolve(promise, y, fulfil, reject);
  			};

  			rejectPromise = function (r) {
  				if (called) {
  					return;
  				}
  				called = true;
  				reject(r);
  			};

  			try {
  				then.call(x, resolvePromise, rejectPromise);
  			} catch (e) {
  				if (!called) {
  					// 2.3.3.3.4.1
  					reject(e); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		} else {
  			fulfil(x);
  		}
  	} else {
  		fulfil(x);
  	}
  }

  var getInnerContext = function (fragment) {
  	do {
  		if (fragment.context !== undefined) {
  			return fragment.context;
  		}
  	} while (fragment = fragment.parent);

  	return rootKeypath;
  };

  var shared_resolveRef = resolveRef;

  function resolveRef(ractive, ref, fragment) {
  	var keypath;

  	ref = normalise(ref);

  	// If a reference begins '~/', it's a top-level reference
  	if (ref.substr(0, 2) === "~/") {
  		keypath = getKeypath(ref.substring(2));
  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  	}

  	// If a reference begins with '.', it's either a restricted reference or
  	// an ancestor reference...
  	else if (ref[0] === ".") {
  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);

  		if (keypath) {
  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  		}
  	}

  	// ...otherwise we need to figure out the keypath based on context
  	else {
  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);
  	}

  	return keypath;
  }

  function resolveAncestorRef(baseContext, ref) {
  	var contextKeys;

  	// TODO...
  	if (baseContext != undefined && typeof baseContext !== "string") {
  		baseContext = baseContext.str;
  	}

  	// {{.}} means 'current context'
  	if (ref === ".") return getKeypath(baseContext);

  	contextKeys = baseContext ? baseContext.split(".") : [];

  	// ancestor references (starting "../") go up the tree
  	if (ref.substr(0, 3) === "../") {
  		while (ref.substr(0, 3) === "../") {
  			if (!contextKeys.length) {
  				throw new Error("Could not resolve reference - too many \"../\" prefixes");
  			}

  			contextKeys.pop();
  			ref = ref.substring(3);
  		}

  		contextKeys.push(ref);
  		return getKeypath(contextKeys.join("."));
  	}

  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
  	if (!baseContext) {
  		return getKeypath(ref.replace(/^\.\/?/, ""));
  	}

  	return getKeypath(baseContext + ref.replace(/^\.\//, "."));
  }

  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {
  	var context, key, parentValue, hasContextChain, parentKeypath;

  	if (ref.isRoot) {
  		return ref;
  	}

  	key = ref.firstKey;

  	while (fragment) {
  		context = fragment.context;
  		fragment = fragment.parent;

  		if (!context) {
  			continue;
  		}

  		hasContextChain = true;
  		parentValue = ractive.viewmodel.get(context);

  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {
  			return context.join(ref.str);
  		}
  	}

  	// Root/computed/mapped property?
  	if (isRootProperty(ractive.viewmodel, key)) {
  		return ref;
  	}

  	// If this is an inline component, and it's not isolated, we
  	// can try going up the scope chain
  	if (ractive.parent && !ractive.isolated) {
  		hasContextChain = true;
  		fragment = ractive.component.parentFragment;

  		key = getKeypath(key);

  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {
  			// We need to create an inter-component binding
  			ractive.viewmodel.map(key, {
  				origin: ractive.parent.viewmodel,
  				keypath: parentKeypath
  			});

  			return ref;
  		}
  	}

  	// If there's no context chain, and the instance is either a) isolated or
  	// b) an orphan, then we know that the keypath is identical to the reference
  	if (!isParentLookup && !hasContextChain) {
  		// the data object needs to have a property by this name,
  		// to prevent future failed lookups
  		ractive.viewmodel.set(ref, undefined);
  		return ref;
  	}
  }

  function createMappingIfNecessary(ractive, key) {
  	var parentKeypath;

  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {
  		return;
  	}

  	key = getKeypath(key);

  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {
  		ractive.viewmodel.map(key, {
  			origin: ractive.parent.viewmodel,
  			keypath: parentKeypath
  		});
  	}
  }

  function isRootProperty(viewmodel, key) {
  	// special case for reference to root
  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;
  }

  function teardown(x) {
    x.teardown();
  }

  function methodCallers__unbind(x) {
    x.unbind();
  }

  function methodCallers__unrender(x) {
    x.unrender();
  }

  function cancel(x) {
    x.cancel();
  }

  var TransitionManager = function (callback, parent) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.decoratorQueue = [];
  	this.outrosComplete = false;

  	if (parent) {
  		parent.addChild(this);
  	}
  };

  TransitionManager.prototype = {
  	addChild: function (child) {
  		this.children.push(child);

  		this.totalChildren += 1;
  		this.outroChildren += 1;
  	},

  	decrementOutros: function () {
  		this.outroChildren -= 1;
  		check(this);
  	},

  	decrementTotal: function () {
  		this.totalChildren -= 1;
  		check(this);
  	},

  	add: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		list.push(transition);
  	},

  	addDecorator: function (decorator) {
  		this.decoratorQueue.push(decorator);
  	},

  	remove: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		removeFromArray(list, transition);
  		check(this);
  	},

  	init: function () {
  		this.ready = true;
  		check(this);
  	},

  	detachNodes: function () {
  		this.decoratorQueue.forEach(teardown);
  		this.detachQueue.forEach(detach);
  		this.children.forEach(detachNodes);
  	}
  };

  function detach(element) {
  	element.detach();
  }

  function detachNodes(tm) {
  	tm.detachNodes();
  }

  function check(tm) {
  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if (!tm.outrosComplete) {
  		if (tm.parent) {
  			tm.parent.decrementOutros(tm);
  		} else {
  			tm.detachNodes();
  		}

  		tm.outrosComplete = true;
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if (!tm.intros.length && !tm.totalChildren) {
  		if (typeof tm.callback === "function") {
  			tm.callback();
  		}

  		if (tm.parent) {
  			tm.parent.decrementTotal();
  		}
  	}
  }

  var global_TransitionManager = TransitionManager;

  var batch,
      runloop,
      unresolved = [],
      changeHook = new hooks_Hook("change");

  runloop = {
  	start: function (instance, returnPromise) {
  		var promise, fulfilPromise;

  		if (returnPromise) {
  			promise = new utils_Promise(function (f) {
  				return fulfilPromise = f;
  			});
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),
  			views: [],
  			tasks: [],
  			ractives: [],
  			instance: instance
  		};

  		if (instance) {
  			batch.ractives.push(instance);
  		}

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		batch.transitionManager.init();
  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];
  		batch = batch.previousBatch;
  	},

  	addRactive: function (ractive) {
  		if (batch) {
  			addToArray(batch.ractives, ractive);
  		}
  	},

  	registerTransition: function (transition) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add(transition);
  	},

  	registerDecorator: function (decorator) {
  		batch.transitionManager.addDecorator(decorator);
  	},

  	addView: function (view) {
  		batch.views.push(view);
  	},

  	addUnresolved: function (thing) {
  		unresolved.push(thing);
  	},

  	removeUnresolved: function (thing) {
  		removeFromArray(unresolved, thing);
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function (thing) {
  		batch.transitionManager.detachQueue.push(thing);
  	},

  	scheduleTask: function (task, postRender) {
  		var _batch;

  		if (!batch) {
  			task();
  		} else {
  			_batch = batch;
  			while (postRender && _batch.previousBatch) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push(task);
  		}
  	}
  };

  var global_runloop = runloop;

  function flushChanges() {
  	var i, thing, changeHash;

  	while (batch.ractives.length) {
  		thing = batch.ractives.pop();
  		changeHash = thing.viewmodel.applyChanges();

  		if (changeHash) {
  			changeHook.fire(thing, changeHash);
  		}
  	}

  	attemptKeypathResolution();

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	for (i = 0; i < batch.views.length; i += 1) {
  		batch.views[i].update();
  	}
  	batch.views.length = 0;

  	for (i = 0; i < batch.tasks.length; i += 1) {
  		batch.tasks[i]();
  	}
  	batch.tasks.length = 0;

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if (batch.ractives.length) return flushChanges();
  }

  function attemptKeypathResolution() {
  	var i, item, keypath, resolved;

  	i = unresolved.length;

  	// see if we can resolve any unresolved references
  	while (i--) {
  		item = unresolved[i];

  		if (item.keypath) {
  			// it resolved some other way. TODO how? two-way binding? Seems
  			// weird that we'd still end up here
  			unresolved.splice(i, 1);
  			continue; // avoid removing the wrong thing should the next condition be true
  		}

  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {
  			(resolved || (resolved = [])).push({
  				item: item,
  				keypath: keypath
  			});

  			unresolved.splice(i, 1);
  		}
  	}

  	if (resolved) {
  		resolved.forEach(global_runloop__resolve);
  	}
  }

  function global_runloop__resolve(resolved) {
  	resolved.item.resolve(resolved.keypath);
  }

  var queue = [];

  var animations = {
  	tick: function () {
  		var i, animation, now;

  		now = utils_getTime();

  		global_runloop.start();

  		for (i = 0; i < queue.length; i += 1) {
  			animation = queue[i];

  			if (!animation.tick(now)) {
  				// animation is complete, remove it from the stack, and decrement i so we don't miss one
  				queue.splice(i--, 1);
  			}
  		}

  		global_runloop.end();

  		if (queue.length) {
  			rAF(animations.tick);
  		} else {
  			animations.running = false;
  		}
  	},

  	add: function (animation) {
  		queue.push(animation);

  		if (!animations.running) {
  			animations.running = true;
  			rAF(animations.tick);
  		}
  	},

  	// TODO optimise this
  	abort: function (keypath, root) {
  		var i = queue.length,
  		    animation;

  		while (i--) {
  			animation = queue[i];

  			if (animation.root === root && animation.keypath === keypath) {
  				animation.stop();
  			}
  		}
  	}
  };

  var shared_animations = animations;

  var Animation = function (options) {
  	var key;

  	this.startTime = Date.now();

  	// from and to
  	for (key in options) {
  		if (options.hasOwnProperty(key)) {
  			this[key] = options[key];
  		}
  	}

  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);
  	this.running = true;

  	this.tick();
  };

  Animation.prototype = {
  	tick: function () {
  		var elapsed, t, value, timeNow, index, keypath;

  		keypath = this.keypath;

  		if (this.running) {
  			timeNow = Date.now();
  			elapsed = timeNow - this.startTime;

  			if (elapsed >= this.duration) {
  				if (keypath !== null) {
  					global_runloop.start(this.root);
  					this.root.viewmodel.set(keypath, this.to);
  					global_runloop.end();
  				}

  				if (this.step) {
  					this.step(1, this.to);
  				}

  				this.complete(this.to);

  				index = this.root._animations.indexOf(this);

  				// TODO investigate why this happens
  				if (index === -1) {
  					warnIfDebug("Animation was not found");
  				}

  				this.root._animations.splice(index, 1);

  				this.running = false;
  				return false; // remove from the stack
  			}

  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;

  			if (keypath !== null) {
  				value = this.interpolator(t);
  				global_runloop.start(this.root);
  				this.root.viewmodel.set(keypath, value);
  				global_runloop.end();
  			}

  			if (this.step) {
  				this.step(t, value);
  			}

  			return true; // keep in the stack
  		}

  		return false; // remove from the stack
  	},

  	stop: function () {
  		var index;

  		this.running = false;

  		index = this.root._animations.indexOf(this);

  		// TODO investigate why this happens
  		if (index === -1) {
  			warnIfDebug("Animation was not found");
  		}

  		this.root._animations.splice(index, 1);
  	}
  };

  var animate_Animation = Animation;

  var prototype_animate = Ractive$animate;

  var noAnimation = { stop: noop };
  function Ractive$animate(keypath, to, options) {
  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;

  	promise = new utils_Promise(function (fulfil) {
  		return fulfilPromise = fulfil;
  	});

  	// animate multiple keypaths
  	if (typeof keypath === "object") {
  		options = to || {};
  		easing = options.easing;
  		duration = options.duration;

  		animations = [];

  		// we don't want to pass the `step` and `complete` handlers, as they will
  		// run for each animation! So instead we'll store the handlers and create
  		// our own...
  		step = options.step;
  		complete = options.complete;

  		if (step || complete) {
  			currentValues = {};

  			options.step = null;
  			options.complete = null;

  			makeValueCollector = function (keypath) {
  				return function (t, value) {
  					currentValues[keypath] = value;
  				};
  			};
  		}

  		for (k in keypath) {
  			if (keypath.hasOwnProperty(k)) {
  				if (step || complete) {
  					collectValue = makeValueCollector(k);
  					options = { easing: easing, duration: duration };

  					if (step) {
  						options.step = collectValue;
  					}
  				}

  				options.complete = complete ? collectValue : noop;
  				animations.push(animate(this, k, keypath[k], options));
  			}
  		}

  		// Create a dummy animation, to facilitate step/complete
  		// callbacks, and Promise fulfilment
  		dummyOptions = { easing: easing, duration: duration };

  		if (step) {
  			dummyOptions.step = function (t) {
  				return step(t, currentValues);
  			};
  		}

  		if (complete) {
  			promise.then(function (t) {
  				return complete(t, currentValues);
  			});
  		}

  		dummyOptions.complete = fulfilPromise;

  		dummy = animate(this, null, null, dummyOptions);
  		animations.push(dummy);

  		promise.stop = function () {
  			var animation;

  			while (animation = animations.pop()) {
  				animation.stop();
  			}

  			if (dummy) {
  				dummy.stop();
  			}
  		};

  		return promise;
  	}

  	// animate a single keypath
  	options = options || {};

  	if (options.complete) {
  		promise.then(options.complete);
  	}

  	options.complete = fulfilPromise;
  	animation = animate(this, keypath, to, options);

  	promise.stop = function () {
  		return animation.stop();
  	};
  	return promise;
  }

  function animate(root, keypath, to, options) {
  	var easing, duration, animation, from;

  	if (keypath) {
  		keypath = getKeypath(normalise(keypath));
  	}

  	if (keypath !== null) {
  		from = root.viewmodel.get(keypath);
  	}

  	// cancel any existing animation
  	// TODO what about upstream/downstream keypaths?
  	shared_animations.abort(keypath, root);

  	// don't bother animating values that stay the same
  	if (isEqual(from, to)) {
  		if (options.complete) {
  			options.complete(options.to);
  		}

  		return noAnimation;
  	}

  	// easing function
  	if (options.easing) {
  		if (typeof options.easing === "function") {
  			easing = options.easing;
  		} else {
  			easing = root.easing[options.easing];
  		}

  		if (typeof easing !== "function") {
  			easing = null;
  		}
  	}

  	// duration
  	duration = options.duration === undefined ? 400 : options.duration;

  	// TODO store keys, use an internal set method
  	animation = new animate_Animation({
  		keypath: keypath,
  		from: from,
  		to: to,
  		root: root,
  		duration: duration,
  		easing: easing,
  		interpolator: options.interpolator,

  		// TODO wrap callbacks if necessary, to use instance as context
  		step: options.step,
  		complete: options.complete
  	});

  	shared_animations.add(animation);
  	root._animations.push(animation);

  	return animation;
  }

  var prototype_detach = Ractive$detach;
  var prototype_detach__detachHook = new hooks_Hook("detach");
  function Ractive$detach() {
  	if (this.detached) {
  		return this.detached;
  	}

  	if (this.el) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}
  	this.detached = this.fragment.detach();
  	prototype_detach__detachHook.fire(this);
  	return this.detached;
  }

  var prototype_find = Ractive$find;

  function Ractive$find(selector) {
  	if (!this.el) {
  		return null;
  	}

  	return this.fragment.find(selector);
  }

  var test = Query$test;
  function Query$test(item, noDirty) {
  	var itemMatches;

  	if (this._isComponentQuery) {
  		itemMatches = !this.selector || item.name === this.selector;
  	} else {
  		itemMatches = item.node ? matches(item.node, this.selector) : null;
  	}

  	if (itemMatches) {
  		this.push(item.node || item.instance);

  		if (!noDirty) {
  			this._makeDirty();
  		}

  		return true;
  	}
  }

  var makeQuery_cancel = function () {
  	var liveQueries, selector, index;

  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];
  	selector = this.selector;

  	index = liveQueries.indexOf(selector);

  	if (index !== -1) {
  		liveQueries.splice(index, 1);
  		liveQueries[selector] = null;
  	}
  };

  var sortByItemPosition = function (a, b) {
  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;

  	ancestryA = getAncestry(a.component || a._ractive.proxy);
  	ancestryB = getAncestry(b.component || b._ractive.proxy);

  	oldestA = lastItem(ancestryA);
  	oldestB = lastItem(ancestryB);

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while (oldestA && oldestA === oldestB) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem(ancestryA);
  		oldestB = lastItem(ancestryB);
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	fragmentA = oldestA.parentFragment;
  	fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if (fragmentA === fragmentB) {
  		indexA = fragmentA.items.indexOf(oldestA);
  		indexB = fragmentB.items.indexOf(oldestB);

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	if (fragments = mutualAncestor.fragments) {
  		indexA = fragments.indexOf(fragmentA);
  		indexB = fragments.indexOf(fragmentB);

  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");
  };

  function getParent(item) {
  	var parentFragment;

  	if (parentFragment = item.parentFragment) {
  		return parentFragment.owner;
  	}

  	if (item.component && (parentFragment = item.component.parentFragment)) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry(item) {
  	var ancestry, ancestor;

  	ancestry = [item];

  	ancestor = getParent(item);

  	while (ancestor) {
  		ancestry.push(ancestor);
  		ancestor = getParent(ancestor);
  	}

  	return ancestry;
  }

  var sortByDocumentPosition = function (node, otherNode) {
  	var bitmask;

  	if (node.compareDocumentPosition) {
  		bitmask = node.compareDocumentPosition(otherNode);
  		return bitmask & 2 ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition(node, otherNode);
  };

  var sort = function () {
  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);
  	this._dirty = false;
  };

  var makeQuery_dirty = function () {
  	var _this = this;

  	if (!this._dirty) {
  		this._dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		global_runloop.scheduleTask(function () {
  			_this._sort();
  		});
  	}
  };

  var remove = function (nodeOrComponent) {
  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);

  	if (index !== -1) {
  		this.splice(index, 1);
  	}
  };

  var _makeQuery = makeQuery;
  function makeQuery(ractive, selector, live, isComponentQuery) {
  	var query = [];

  	defineProperties(query, {
  		selector: { value: selector },
  		live: { value: live },

  		_isComponentQuery: { value: isComponentQuery },
  		_test: { value: test }
  	});

  	if (!live) {
  		return query;
  	}

  	defineProperties(query, {
  		cancel: { value: makeQuery_cancel },

  		_root: { value: ractive },
  		_sort: { value: sort },
  		_makeDirty: { value: makeQuery_dirty },
  		_remove: { value: remove },

  		_dirty: { value: false, writable: true }
  	});

  	return query;
  }

  var prototype_findAll = Ractive$findAll;
  function Ractive$findAll(selector, options) {
  	var liveQueries, query;

  	if (!this.el) {
  		return [];
  	}

  	options = options || {};
  	liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, false);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAll(selector, query);
  	return query;
  }

  var prototype_findAllComponents = Ractive$findAllComponents;
  function Ractive$findAllComponents(selector, options) {
  	var liveQueries, query;

  	options = options || {};
  	liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, true);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAllComponents(selector, query);
  	return query;
  }

  var prototype_findComponent = Ractive$findComponent;

  function Ractive$findComponent(selector) {
  	return this.fragment.findComponent(selector);
  }

  var findContainer = Ractive$findContainer;

  function Ractive$findContainer(selector) {
  	if (this.container) {
  		if (this.container.component && this.container.component.name === selector) {
  			return this.container;
  		} else {
  			return this.container.findContainer(selector);
  		}
  	}

  	return null;
  }

  var findParent = Ractive$findParent;

  function Ractive$findParent(selector) {

  	if (this.parent) {
  		if (this.parent.component && this.parent.component.name === selector) {
  			return this.parent;
  		} else {
  			return this.parent.findParent(selector);
  		}
  	}

  	return null;
  }

  var eventStack = {
  	enqueue: function (ractive, event) {
  		if (ractive.event) {
  			ractive._eventQueue = ractive._eventQueue || [];
  			ractive._eventQueue.push(ractive.event);
  		}
  		ractive.event = event;
  	},
  	dequeue: function (ractive) {
  		if (ractive._eventQueue && ractive._eventQueue.length) {
  			ractive.event = ractive._eventQueue.pop();
  		} else {
  			delete ractive.event;
  		}
  	}
  };

  var shared_eventStack = eventStack;

  var shared_fireEvent = fireEvent;

  function fireEvent(ractive, eventName) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	if (!eventName) {
  		return;
  	}

  	if (!options.event) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getKeypath(eventName).wildcardMatches();
  	fireEventAs(ractive, eventNames, options.event, options.args, true);
  }

  function fireEventAs(ractive, eventNames, event, args) {
  	var initialFire = arguments[4] === undefined ? false : arguments[4];

  	var subscribers,
  	    i,
  	    bubble = true;

  	shared_eventStack.enqueue(ractive, event);

  	for (i = eventNames.length; i >= 0; i--) {
  		subscribers = ractive._subs[eventNames[i]];

  		if (subscribers) {
  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;
  		}
  	}

  	shared_eventStack.dequeue(ractive);

  	if (ractive.parent && bubble) {

  		if (initialFire && ractive.component) {
  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];
  			eventNames = getKeypath(fullName).wildcardMatches();

  			if (event) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs(ractive.parent, eventNames, event, args);
  	}
  }

  function notifySubscribers(ractive, subscribers, event, args) {
  	var originalEvent = null,
  	    stopEvent = false;

  	if (event && !event._noArg) {
  		args = [event].concat(args);
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for (var i = 0, len = subscribers.length; i < len; i += 1) {
  		if (subscribers[i].apply(ractive, args) === false) {
  			stopEvent = true;
  		}
  	}

  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  var prototype_fire = Ractive$fire;
  function Ractive$fire(eventName) {

  	var options = {
  		args: Array.prototype.slice.call(arguments, 1)
  	};

  	shared_fireEvent(this, eventName, options);
  }

  var prototype_get = Ractive$get;
  var options = {
  	capture: true, // top-level calls should be intercepted
  	noUnwrap: true, // wrapped values should NOT be unwrapped
  	fullRootGet: true // root get should return mappings
  };
  function Ractive$get(keypath) {
  	var value;

  	keypath = getKeypath(normalise(keypath));
  	value = this.viewmodel.get(keypath, options);

  	// Create inter-component binding, if necessary
  	if (value === undefined && this.parent && !this.isolated) {
  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {
  			// creates binding as side-effect, if appropriate
  			value = this.viewmodel.get(keypath);
  		}
  	}

  	return value;
  }

  var insert = Ractive$insert;

  var insertHook = new hooks_Hook("insert");
  function Ractive$insert(target, anchor) {
  	if (!this.fragment.rendered) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");
  	}

  	target = getElement(target);
  	anchor = getElement(anchor) || null;

  	if (!target) {
  		throw new Error("You must specify a valid target to insert into");
  	}

  	target.insertBefore(this.detach(), anchor);
  	this.el = target;

  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
  	this.detached = null;

  	fireInsertHook(this);
  }

  function fireInsertHook(ractive) {
  	insertHook.fire(ractive);

  	ractive.findAllComponents("*").forEach(function (child) {
  		fireInsertHook(child.instance);
  	});
  }

  var prototype_merge = Ractive$merge;
  function Ractive$merge(keypath, array, options) {
  	var currentArray, promise;

  	keypath = getKeypath(normalise(keypath));
  	currentArray = this.viewmodel.get(keypath);

  	// If either the existing value or the new value isn't an
  	// array, just do a regular set
  	if (!isArray(currentArray) || !isArray(array)) {
  		return this.set(keypath, array, options && options.complete);
  	}

  	// Manage transitions
  	promise = global_runloop.start(this, true);
  	this.viewmodel.merge(keypath, currentArray, array, options);
  	global_runloop.end();

  	return promise;
  }

  var Observer = function (ractive, keypath, callback, options) {
  	this.root = ractive;
  	this.keypath = keypath;
  	this.callback = callback;
  	this.defer = options.defer;

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  Observer.prototype = {
  	init: function (immediate) {
  		this.value = this.root.get(this.keypath.str);

  		if (immediate !== false) {
  			this.update();
  		} else {
  			this.oldValue = this.value;
  		}
  	},

  	setValue: function (value) {
  		var _this = this;

  		if (!isEqual(value, this.value)) {
  			this.value = value;

  			if (this.defer && this.ready) {
  				global_runloop.scheduleTask(function () {
  					return _this.update();
  				});
  			} else {
  				this.update();
  			}
  		}
  	},

  	update: function () {
  		// Prevent infinite loops
  		if (this.updating) {
  			return;
  		}

  		this.updating = true;

  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);
  		this.oldValue = this.value;

  		this.updating = false;
  	}
  };

  var observe_Observer = Observer;

  var observe_getPattern = getPattern;
  function getPattern(ractive, pattern) {
  	var matchingKeypaths, values;

  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);

  	values = {};
  	matchingKeypaths.forEach(function (keypath) {
  		values[keypath.str] = ractive.get(keypath.str);
  	});

  	return values;
  }

  var PatternObserver,
      slice = Array.prototype.slice;

  PatternObserver = function (ractive, keypath, callback, options) {
  	this.root = ractive;

  	this.callback = callback;
  	this.defer = options.defer;

  	this.keypath = keypath;
  	this.regex = new RegExp("^" + keypath.str.replace(/\./g, "\\.").replace(/\*/g, "([^\\.]+)") + "$");
  	this.values = {};

  	if (this.defer) {
  		this.proxies = [];
  	}

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  PatternObserver.prototype = {
  	init: function (immediate) {
  		var values, keypath;

  		values = observe_getPattern(this.root, this.keypath);

  		if (immediate !== false) {
  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}
  		} else {
  			this.values = values;
  		}
  	},

  	update: function (keypath) {
  		var _this = this;

  		var values;

  		if (keypath.isPattern) {
  			values = observe_getPattern(this.root, keypath);

  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}

  			return;
  		}

  		// special case - array mutation should not trigger `array.*`
  		// pattern observer with `array.length`
  		if (this.root.viewmodel.implicitChanges[keypath.str]) {
  			return;
  		}

  		if (this.defer && this.ready) {
  			global_runloop.scheduleTask(function () {
  				return _this.getProxy(keypath).update();
  			});
  			return;
  		}

  		this.reallyUpdate(keypath);
  	},

  	reallyUpdate: function (keypath) {
  		var keypathStr, value, keys, args;

  		keypathStr = keypath.str;
  		value = this.root.viewmodel.get(keypath);

  		// Prevent infinite loops
  		if (this.updating) {
  			this.values[keypathStr] = value;
  			return;
  		}

  		this.updating = true;

  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {
  			keys = slice.call(this.regex.exec(keypathStr), 1);
  			args = [value, this.values[keypathStr], keypathStr].concat(keys);

  			this.values[keypathStr] = value;
  			this.callback.apply(this.context, args);
  		}

  		this.updating = false;
  	},

  	getProxy: function (keypath) {
  		var _this = this;

  		if (!this.proxies[keypath.str]) {
  			this.proxies[keypath.str] = {
  				update: function () {
  					return _this.reallyUpdate(keypath);
  				}
  			};
  		}

  		return this.proxies[keypath.str];
  	}
  };

  var observe_PatternObserver = PatternObserver;

  var observe_getObserverFacade = getObserverFacade;
  var emptyObject = {};
  function getObserverFacade(ractive, keypath, callback, options) {
  	var observer, isPatternObserver, cancelled;

  	keypath = getKeypath(normalise(keypath));
  	options = options || emptyObject;

  	// pattern observers are treated differently
  	if (keypath.isPattern) {
  		observer = new observe_PatternObserver(ractive, keypath, callback, options);
  		ractive.viewmodel.patternObservers.push(observer);
  		isPatternObserver = true;
  	} else {
  		observer = new observe_Observer(ractive, keypath, callback, options);
  	}

  	observer.init(options.init);
  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");

  	// This flag allows observers to initialise even with undefined values
  	observer.ready = true;

  	var facade = {
  		cancel: function () {
  			var index;

  			if (cancelled) {
  				return;
  			}

  			if (isPatternObserver) {
  				index = ractive.viewmodel.patternObservers.indexOf(observer);

  				ractive.viewmodel.patternObservers.splice(index, 1);
  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");
  			} else {
  				ractive.viewmodel.unregister(keypath, observer, "observers");
  			}
  			cancelled = true;
  		}
  	};

  	ractive._observers.push(facade);
  	return facade;
  }

  var observe = Ractive$observe;
  function Ractive$observe(keypath, callback, options) {

  	var observers, map, keypaths, i;

  	// Allow a map of keypaths to handlers
  	if (isObject(keypath)) {
  		options = callback;
  		map = keypath;

  		observers = [];

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				callback = map[keypath];
  				observers.push(this.observe(keypath, callback, options));
  			}
  		}

  		return {
  			cancel: function () {
  				while (observers.length) {
  					observers.pop().cancel();
  				}
  			}
  		};
  	}

  	// Allow `ractive.observe( callback )` - i.e. observe entire model
  	if (typeof keypath === "function") {
  		options = callback;
  		callback = keypath;
  		keypath = "";

  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	keypaths = keypath.split(" ");

  	// Single keypath
  	if (keypaths.length === 1) {
  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	// Multiple space-separated keypaths
  	observers = [];

  	i = keypaths.length;
  	while (i--) {
  		keypath = keypaths[i];

  		if (keypath) {
  			observers.push(observe_getObserverFacade(this, keypath, callback, options));
  		}
  	}

  	return {
  		cancel: function () {
  			while (observers.length) {
  				observers.pop().cancel();
  			}
  		}
  	};
  }

  var observeOnce = Ractive$observeOnce;

  function Ractive$observeOnce(property, callback, options) {

  	var observer = this.observe(property, function () {
  		callback.apply(this, arguments);
  		observer.cancel();
  	}, { init: false, defer: options && options.defer });

  	return observer;
  }

  var shared_trim = function (str) {
    return str.trim();
  };

  var notEmptyString = function (str) {
    return str !== "";
  };

  var off = Ractive$off;
  function Ractive$off(eventName, callback) {
  	var _this = this;

  	var eventNames;

  	// if no arguments specified, remove all callbacks
  	if (!eventName) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for (eventName in this._subs) {
  			delete this._subs[eventName];
  		}
  	} else {
  		// Handle multiple space-separated event names
  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  		eventNames.forEach(function (eventName) {
  			var subscribers, index;

  			// If we have subscribers for this event...
  			if (subscribers = _this._subs[eventName]) {
  				// ...if a callback was specified, only remove that
  				if (callback) {
  					index = subscribers.indexOf(callback);
  					if (index !== -1) {
  						subscribers.splice(index, 1);
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					_this._subs[eventName] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  var on = Ractive$on;
  function Ractive$on(eventName, callback) {
  	var _this = this;

  	var listeners, n, eventNames;

  	// allow mutliple listeners to be bound in one go
  	if (typeof eventName === "object") {
  		listeners = [];

  		for (n in eventName) {
  			if (eventName.hasOwnProperty(n)) {
  				listeners.push(this.on(n, eventName[n]));
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;

  				while (listener = listeners.pop()) {
  					listener.cancel();
  				}
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  	eventNames.forEach(function (eventName) {
  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);
  	});

  	return {
  		cancel: function () {
  			return _this.off(eventName, callback);
  		}
  	};
  }

  var once = Ractive$once;

  function Ractive$once(eventName, handler) {

  	var listener = this.on(eventName, function () {
  		handler.apply(this, arguments);
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  var shared_getNewIndices = getNewIndices;

  function getNewIndices(array, methodName, args) {
  	var spliceArguments,
  	    len,
  	    newIndices = [],
  	    removeStart,
  	    removeEnd,
  	    balance,
  	    i;

  	spliceArguments = getSpliceEquivalent(array, methodName, args);

  	if (!spliceArguments) {
  		return null; // TODO support reverse and sort?
  	}

  	len = array.length;
  	balance = spliceArguments.length - 2 - spliceArguments[1];

  	removeStart = Math.min(len, spliceArguments[0]);
  	removeEnd = removeStart + spliceArguments[1];

  	for (i = 0; i < removeStart; i += 1) {
  		newIndices.push(i);
  	}

  	for (; i < removeEnd; i += 1) {
  		newIndices.push(-1);
  	}

  	for (; i < len; i += 1) {
  		newIndices.push(i + balance);
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if (balance !== 0) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = array.length;
  	}

  	return newIndices;
  }

  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent(array, methodName, args) {
  	switch (methodName) {
  		case "splice":
  			if (args[0] !== undefined && args[0] < 0) {
  				args[0] = array.length + Math.max(args[0], -array.length);
  			}

  			while (args.length < 2) {
  				args.push(0);
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min(args[1], array.length - args[0]);

  			return args;

  		case "sort":
  		case "reverse":
  			return null;

  		case "pop":
  			if (array.length) {
  				return [array.length - 1, 1];
  			}
  			return [0, 0];

  		case "push":
  			return [array.length, 0].concat(args);

  		case "shift":
  			return [0, array.length ? 1 : 0];

  		case "unshift":
  			return [0, 0].concat(args);
  	}
  }

  var arrayProto = Array.prototype;

  var makeArrayMethod = function (methodName) {
  	return function (keypath) {
  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  			args[_key - 1] = arguments[_key];
  		}

  		var array,
  		    newIndices = [],
  		    len,
  		    promise,
  		    result;

  		keypath = getKeypath(normalise(keypath));

  		array = this.viewmodel.get(keypath);
  		len = array.length;

  		if (!isArray(array)) {
  			throw new Error("Called ractive." + methodName + "('" + keypath.str + "'), but '" + keypath.str + "' does not refer to an array");
  		}

  		newIndices = shared_getNewIndices(array, methodName, args);

  		result = arrayProto[methodName].apply(array, args);
  		promise = global_runloop.start(this, true).then(function () {
  			return result;
  		});

  		if (!!newIndices) {
  			this.viewmodel.smartUpdate(keypath, array, newIndices);
  		} else {
  			this.viewmodel.mark(keypath);
  		}

  		global_runloop.end();

  		return promise;
  	};
  };

  var pop = makeArrayMethod("pop");

  var push = makeArrayMethod("push");

  var css,
      update,
      styleElement,
      head,
      styleSheet,
      inDom,
      global_css__prefix = "/* Ractive.js component styles */\n",
      styles = [],
      dirty = false;

  if (!isClient) {
  	// TODO handle encapsulated CSS in server-rendered HTML!
  	css = {
  		add: noop,
  		apply: noop
  	};
  } else {
  	styleElement = document.createElement("style");
  	styleElement.type = "text/css";

  	head = document.getElementsByTagName("head")[0];

  	inDom = false;

  	// Internet Exploder won't let you use styleSheet.innerHTML - we have to
  	// use styleSheet.cssText instead
  	styleSheet = styleElement.styleSheet;

  	update = function () {
  		var css = global_css__prefix + styles.map(function (s) {
  			return "\n/* {" + s.id + "} */\n" + s.styles;
  		}).join("\n");

  		if (styleSheet) {
  			styleSheet.cssText = css;
  		} else {
  			styleElement.innerHTML = css;
  		}

  		if (!inDom) {
  			head.appendChild(styleElement);
  			inDom = true;
  		}
  	};

  	css = {
  		add: function (s) {
  			styles.push(s);
  			dirty = true;
  		},

  		apply: function () {
  			if (dirty) {
  				update();
  				dirty = false;
  			}
  		}
  	};
  }

  var global_css = css;

  var prototype_render = Ractive$render;

  var renderHook = new hooks_Hook("render"),
      completeHook = new hooks_Hook("complete");
  function Ractive$render(target, anchor) {
  	var _this = this;

  	var promise, instances, transitionsEnabled;

  	// if `noIntro` is `true`, temporarily disable transitions
  	transitionsEnabled = this.transitionsEnabled;
  	if (this.noIntro) {
  		this.transitionsEnabled = false;
  	}

  	promise = global_runloop.start(this, true);
  	global_runloop.scheduleTask(function () {
  		return renderHook.fire(_this);
  	}, true);

  	if (this.fragment.rendered) {
  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");
  	}

  	target = getElement(target) || this.el;
  	anchor = getElement(anchor) || this.anchor;

  	this.el = target;
  	this.anchor = anchor;

  	if (!this.append && target) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if (others && others.length) {
  			removeOtherInstances(others);
  		}

  		// make sure we are the only occupants
  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive
  	}

  	if (this.cssId) {
  		// ensure encapsulated CSS is up-to-date
  		global_css.apply();
  	}

  	if (target) {
  		if (!(instances = target.__ractive_instances__)) {
  			target.__ractive_instances__ = [this];
  		} else {
  			instances.push(this);
  		}

  		if (anchor) {
  			target.insertBefore(this.fragment.render(), anchor);
  		} else {
  			target.appendChild(this.fragment.render());
  		}
  	}

  	global_runloop.end();

  	this.transitionsEnabled = transitionsEnabled;

  	return promise.then(function () {
  		return completeHook.fire(_this);
  	});
  }

  function removeOtherInstances(others) {
  	others.splice(0, others.length).forEach(teardown);
  }

  var adaptConfigurator = {
  	extend: function (Parent, proto, options) {
  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));
  	},

  	init: function () {}
  };

  var custom_adapt = adaptConfigurator;

  function custom_adapt__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  var transform = transformCss;

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
      commentsPattern = /\/\*.*?\*\//g,
      selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~\(]+(?:\([^\)]+\))?)?\s*[\s\+\>\~]?)\s*/g,
      mediaQueryPattern = /^@media/,
      dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
  function transformCss(css, id) {
  	var transformed, dataAttr, addGuid;

  	dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	addGuid = function (selector) {
  		var selectorUnits,
  		    match,
  		    unit,
  		    base,
  		    prepended,
  		    appended,
  		    i,
  		    transformed = [];

  		selectorUnits = [];

  		while (match = selectorUnitPattern.exec(selector)) {
  			selectorUnits.push({
  				str: match[0],
  				base: match[1],
  				modifiers: match[2]
  			});
  		}

  		// For each simple selector within the selector, we need to create a version
  		// that a) combines with the id, and b) is inside the id
  		base = selectorUnits.map(extractString);

  		i = selectorUnits.length;
  		while (i--) {
  			appended = base.slice();

  			// Pseudo-selectors should go after the attribute selector
  			unit = selectorUnits[i];
  			appended[i] = unit.base + dataAttr + unit.modifiers || "";

  			prepended = base.slice();
  			prepended[i] = dataAttr + " " + prepended[i];

  			transformed.push(appended.join(" "), prepended.join(" "));
  		}

  		return transformed.join(", ");
  	};

  	if (dataRvcGuidPattern.test(css)) {
  		transformed = css.replace(dataRvcGuidPattern, dataAttr);
  	} else {
  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {
  			var selectors, transformed;

  			// don't transform media queries!
  			if (mediaQueryPattern.test($1)) return match;

  			selectors = $1.split(",").map(trim);
  			transformed = selectors.map(addGuid).join(", ") + " ";

  			return match.replace($1, transformed);
  		});
  	}

  	return transformed;
  }

  function trim(str) {
  	if (str.trim) {
  		return str.trim();
  	}

  	return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function extractString(unit) {
  	return unit.str;
  }

  var css_css__uid = 1;

  var cssConfigurator = {
  	name: "css",

  	extend: function (Parent, proto, options) {
  		if (options.css) {
  			var id = css_css__uid++;
  			var styles = options.noCssTransform ? options.css : transform(options.css, id);

  			proto.cssId = id;
  			global_css.add({ id: id, styles: styles });
  		}
  	},

  	init: function () {}
  };

  var css_css = cssConfigurator;

  function validate(data) {
  	// Warn if userOptions.data is a non-POJO
  	if (data && data.constructor !== Object) {
  		if (typeof data === "function") {} else if (typeof data !== "object") {
  			fatal("data option must be an object or a function, `" + data + "` is not valid");
  		} else {
  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");
  		}
  	}
  }

  var dataConfigurator = {
  	name: "data",

  	extend: function (Parent, proto, options) {
  		var key = undefined,
  		    value = undefined;

  		// check for non-primitives, which could cause mutation-related bugs
  		if (options.data && isObject(options.data)) {
  			for (key in options.data) {
  				value = options.data[key];

  				if (value && typeof value === "object") {
  					if (isObject(value) || isArray(value)) {
  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
  					}
  				}
  			}
  		}

  		proto.data = custom_data__combine(proto.data, options.data);
  	},

  	init: function (Parent, ractive, options) {
  		var result = custom_data__combine(Parent.prototype.data, options.data);

  		if (typeof result === "function") {
  			result = result.call(ractive);
  		}

  		return result || {};
  	},

  	reset: function (ractive) {
  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);

  		ractive.viewmodel.reset(result);
  		return true;
  	}
  };

  var custom_data = dataConfigurator;

  function custom_data__combine(parentValue, childValue) {
  	validate(childValue);

  	var parentIsFn = typeof parentValue === "function";
  	var childIsFn = typeof childValue === "function";

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if (!childValue && !parentIsFn) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if (!parentIsFn && !childIsFn) {
  		return fromProperties(childValue, parentValue);
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;
  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

  		return fromProperties(child, parent);
  	};
  }

  function callDataFunction(fn, context) {
  	var data = fn.call(context);

  	if (!data) return;

  	if (typeof data !== "object") {
  		fatal("Data function must return an object");
  	}

  	if (data.constructor !== Object) {
  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");
  	}

  	return data;
  }

  function fromProperties(primary, secondary) {
  	if (primary && secondary) {
  		for (var key in secondary) {
  			if (!(key in primary)) {
  				primary[key] = secondary[key];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  // TODO do we need to support this in the new Ractive() case?

  var Parser,
      ParseError,
      parse_Parser__leadingWhitespace = /^\s+/;

  ParseError = function (message) {
  	this.name = "ParseError";
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function (str, options) {
  	var items,
  	    item,
  	    lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split("\n");
  	this.lineEnds = this.lines.map(function (line) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0);

  	// Custom init logic
  	if (this.init) this.init(str, options);

  	items = [];

  	while (this.pos < this.str.length && (item = this.read())) {
  		items.push(item);
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess(items, options) : items;
  };

  Parser.prototype = {
  	read: function (converters) {
  		var pos, i, len, item;

  		if (!converters) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for (i = 0; i < len; i += 1) {
  			this.pos = pos; // reset for each attempt

  			if (item = converters[i](this)) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getLinePos: function (char) {
  		var lineNum = 0,
  		    lineStart = 0,
  		    columnNum;

  		while (char >= this.lineEnds[lineNum]) {
  			lineStart = this.lineEnds[lineNum];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
  	},

  	error: function (message) {
  		var pos = this.getLinePos(this.pos);
  		var lineNum = pos[0];
  		var columnNum = pos[1];

  		var line = this.lines[pos[0] - 1];
  		var numTabs = 0;
  		var annotation = line.replace(/\t/g, function (match, char) {
  			if (char < pos[1]) {
  				numTabs += 1;
  			}

  			return "  ";
  		}) + "\n" + new Array(pos[1] + numTabs).join(" ") + "^----";

  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation);

  		error.line = pos[0];
  		error.character = pos[1];
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function (string) {
  		if (this.str.substr(this.pos, string.length) === string) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function (pattern) {
  		var match;

  		if (match = pattern.exec(this.remaining())) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern(parse_Parser__leadingWhitespace);
  	},

  	remaining: function () {
  		return this.str.substring(this.pos);
  	},

  	nextChar: function () {
  		return this.str.charAt(this.pos);
  	}
  };

  Parser.extend = function (proto) {
  	var Parent = this,
  	    Child,
  	    key;

  	Child = function (str, options) {
  		Parser.call(this, str, options);
  	};

  	Child.prototype = create(Parent.prototype);

  	for (key in proto) {
  		if (hasOwn.call(proto, key)) {
  			Child.prototype[key] = proto[key];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var parse_Parser = Parser;

  var TEXT = 1;
  var INTERPOLATOR = 2;
  var TRIPLE = 3;
  var SECTION = 4;
  var INVERTED = 5;
  var CLOSING = 6;
  var ELEMENT = 7;
  var PARTIAL = 8;
  var COMMENT = 9;
  var DELIMCHANGE = 10;
  var ATTRIBUTE = 13;
  var CLOSING_TAG = 14;
  var COMPONENT = 15;
  var YIELDER = 16;
  var INLINE_PARTIAL = 17;
  var DOCTYPE = 18;

  var NUMBER_LITERAL = 20;
  var STRING_LITERAL = 21;
  var ARRAY_LITERAL = 22;
  var OBJECT_LITERAL = 23;
  var BOOLEAN_LITERAL = 24;
  var REGEXP_LITERAL = 25;

  var GLOBAL = 26;
  var KEY_VALUE_PAIR = 27;

  var REFERENCE = 30;
  var REFINEMENT = 31;
  var MEMBER = 32;
  var PREFIX_OPERATOR = 33;
  var BRACKETED = 34;
  var CONDITIONAL = 35;
  var INFIX_OPERATOR = 36;

  var INVOCATION = 40;

  var SECTION_IF = 50;
  var SECTION_UNLESS = 51;
  var SECTION_EACH = 52;
  var SECTION_WITH = 53;
  var SECTION_IF_WITH = 54;

  var ELSE = 60;
  var ELSEIF = 61;

  var mustache_readDelimiterChange = readDelimiterChange;
  var delimiterChangePattern = /^[^\s=]+/,
      whitespacePattern = /^\s+/;
  function readDelimiterChange(parser) {
  	var start, opening, closing;

  	if (!parser.matchString("=")) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern(delimiterChangePattern);
  	if (!opening) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if (!parser.matchPattern(whitespacePattern)) {
  		return null;
  	}

  	closing = parser.matchPattern(delimiterChangePattern);
  	if (!closing) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	return [opening, closing];
  }

  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;
  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
  function readRegexpLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(regexpPattern)) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var converters_readMustache = readMustache;

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
  function readMustache(parser) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if (parser.interpolate[parser.inside] === false) {
  		return null;
  	}

  	for (i = 0; i < parser.tags.length; i += 1) {
  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType(parser, tag) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if (parser.matchString("\\" + tag.open)) {
  		if (start === 0 || parser.str[start - 1] !== "\\") {
  			return tag.open;
  		}
  	} else if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	// delimiter change?
  	if (mustache = mustache_readDelimiterChange(parser)) {
  		// find closing delimiter or abort...
  		if (!parser.matchString(tag.close)) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if (parser.matchString("/")) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if (!readRegexpLiteral(parser)) {
  			parser.pos = rewind - tag.close.length;
  			parser.error("Attempted to close a section that wasn't open");
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for (i = 0; i < tag.readers.length; i += 1) {
  		reader = tag.readers[i];

  		if (mustache = reader(parser, tag)) {
  			if (tag.isStatic) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if (parser.includeLinePositions) {
  				mustache.p = parser.getLinePos(start);
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  var expectedExpression = "Expected a JavaScript expression";
  var expectedParen = "Expected closing paren";

  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;
  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  function literal_readNumberLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var literal_readBooleanLiteral = readBooleanLiteral;
  function readBooleanLiteral(parser) {
  	var remaining = parser.remaining();

  	if (remaining.substr(0, 4) === "true") {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "true"
  		};
  	}

  	if (remaining.substr(0, 5) === "false") {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "false"
  		};
  	}

  	return null;
  }

  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;

  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  var makeQuotedStringMatcher = function (okQuote) {
  	return function (parser) {
  		var start, literal, done, next;

  		start = parser.pos;
  		literal = "\"";
  		done = false;

  		while (!done) {
  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);
  			if (next) {
  				if (next === "\"") {
  					literal += "\\\"";
  				} else if (next === "\\'") {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern(lineContinuationPattern);
  				if (next) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += "\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += "\"";

  		// use JSON.parse to interpret escapes
  		return JSON.parse(literal);
  	};
  };

  var getSingleQuotedString = makeQuotedStringMatcher("\"");
  var getDoubleQuotedString = makeQuotedStringMatcher("'");

  var readStringLiteral = function (parser) {
  	var start, string;

  	start = parser.pos;

  	if (parser.matchString("\"")) {
  		string = getDoubleQuotedString(parser);

  		if (!parser.matchString("\"")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if (parser.matchString("'")) {
  		string = getSingleQuotedString(parser);

  		if (!parser.matchString("'")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  };

  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  var shared_readKey = readKey;
  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  function readKey(parser) {
  	var token;

  	if (token = readStringLiteral(parser)) {
  		return identifier.test(token.v) ? token.v : "\"" + token.v.replace(/"/g, "\\\"") + "\"";
  	}

  	if (token = literal_readNumberLiteral(parser)) {
  		return token.v;
  	}

  	if (token = parser.matchPattern(patterns__name)) {
  		return token;
  	}
  }

  var keyValuePair = readKeyValuePair;
  function readKeyValuePair(parser) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	key = shared_readKey(parser);
  	if (key === null) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// next character must be ':'
  	if (!parser.matchString(":")) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = converters_readExpression(parser);
  	if (value === null) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  var objectLiteral_keyValuePairs = readKeyValuePairs;
  function readKeyValuePairs(parser) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = keyValuePair(parser);
  	if (pair === null) {
  		return null;
  	}

  	pairs = [pair];

  	if (parser.matchString(",")) {
  		keyValuePairs = readKeyValuePairs(parser);

  		if (!keyValuePairs) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat(keyValuePairs);
  	}

  	return pairs;
  }

  var readObjectLiteral = function (parser) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if (!parser.matchString("{")) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = objectLiteral_keyValuePairs(parser);

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if (!parser.matchString("}")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  };

  var shared_readExpressionList = readExpressionList;
  function readExpressionList(parser) {
  	var start, expressions, expr, next;

  	start = parser.pos;

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);

  	if (expr === null) {
  		return null;
  	}

  	expressions = [expr];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if (parser.matchString(",")) {
  		next = readExpressionList(parser);
  		if (next === null) {
  			parser.error(expectedExpression);
  		}

  		next.forEach(append);
  	}

  	function append(expression) {
  		expressions.push(expression);
  	}

  	return expressions;
  }

  var readArrayLiteral = function (parser) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if (!parser.matchString("[")) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = shared_readExpressionList(parser);

  	if (!parser.matchString("]")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  };

  var primary_readLiteral = readLiteral;
  function readLiteral(parser) {
  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);
  }

  var primary_readReference = readReference;
  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/,
      globals,
      keywords;

  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\.[a-zA-Z$_0-9]+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;
  function readReference(parser) {
  	var startPos, prefix, name, global, reference, lastDotIndex;

  	startPos = parser.pos;

  	name = parser.matchPattern(/^@(?:keypath|index|key)/);

  	if (!name) {
  		prefix = parser.matchPattern(prefixPattern) || "";
  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);

  		if (!name && prefix === ".") {
  			prefix = "";
  			name = ".";
  		}
  	}

  	if (!name) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if (!prefix && globals.test(name)) {
  		global = globals.exec(name)[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: global
  		};
  	}

  	reference = (prefix || "") + normalise(name);

  	if (parser.matchString("(")) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		lastDotIndex = reference.lastIndexOf(".");
  		if (lastDotIndex !== -1) {
  			reference = reference.substr(0, lastDotIndex);
  			parser.pos = startPos + reference.length;
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: reference.replace(/^this\./, "./").replace(/^this$/, ".")
  	};
  }

  var primary_readBracketedExpression = readBracketedExpression;
  function readBracketedExpression(parser) {
  	var start, expr;

  	start = parser.pos;

  	if (!parser.matchString("(")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);
  	if (!expr) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(")")) {
  		parser.error(expectedParen);
  	}

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  var readPrimary = function (parser) {
  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);
  };

  var shared_readRefinement = readRefinement;
  function readRefinement(parser) {
  	var start, name, expr;

  	start = parser.pos;

  	parser.allowWhitespace();

  	// "." name
  	if (parser.matchString(".")) {
  		parser.allowWhitespace();

  		if (name = parser.matchPattern(patterns__name)) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error("Expected a property name");
  	}

  	// "[" expression "]"
  	if (parser.matchString("[")) {
  		parser.allowWhitespace();

  		expr = converters_readExpression(parser);
  		if (!expr) {
  			parser.error(expectedExpression);
  		}

  		parser.allowWhitespace();

  		if (!parser.matchString("]")) {
  			parser.error("Expected ']'");
  		}

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  var readMemberOrInvocation = function (parser) {
  	var current, expression, refinement, expressionList;

  	expression = readPrimary(parser);

  	if (!expression) {
  		return null;
  	}

  	while (expression) {
  		current = parser.pos;

  		if (refinement = shared_readRefinement(parser)) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		} else if (parser.matchString("(")) {
  			parser.allowWhitespace();
  			expressionList = shared_readExpressionList(parser);

  			parser.allowWhitespace();

  			if (!parser.matchString(")")) {
  				parser.error(expectedParen);
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if (expressionList) {
  				expression.o = expressionList;
  			}
  		} else {
  			break;
  		}
  	}

  	return expression;
  };

  var readTypeOf, makePrefixSequenceMatcher;

  makePrefixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var expression;

  		if (expression = fallthrough(parser)) {
  			return expression;
  		}

  		if (!parser.matchString(symbol)) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = converters_readExpression(parser);
  		if (!expression) {
  			parser.error(expectedExpression);
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function () {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = "! ~ + - typeof".split(" ");

  	fallthrough = readMemberOrInvocation;
  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {
  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  })();

  var readTypeof = readTypeOf;

  var readLogicalOr, makeInfixSequenceMatcher;

  makeInfixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var start, left, right;

  		left = fallthrough(parser);
  		if (!left) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while (true) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if (!parser.matchString(symbol)) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough(parser);
  			if (!right) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [left, right]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function () {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for (i = 0, len = infixOperators.length; i < len; i += 1) {
  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  })();

  var expressions_readLogicalOr = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  var readConditional = getConditional;
  function getConditional(parser) {
  	var start, expression, ifTrue, ifFalse;

  	expression = expressions_readLogicalOr(parser);
  	if (!expression) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if (!parser.matchString("?")) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = converters_readExpression(parser);
  	if (!ifTrue) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(":")) {
  		parser.error("Expected \":\"");
  	}

  	parser.allowWhitespace();

  	ifFalse = converters_readExpression(parser);
  	if (!ifFalse) {
  		parser.error(expectedExpression);
  	}

  	return {
  		t: CONDITIONAL,
  		o: [expression, ifTrue, ifFalse]
  	};
  }

  var converters_readExpression = readExpression;
  function readExpression(parser) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return readConditional(parser);
  }

  var utils_flattenExpression = flattenExpression;

  function flattenExpression(expression) {
  	var refs;

  	extractRefs(expression, refs = []);

  	return {
  		r: refs,
  		s: stringify(expression)
  	};

  	function stringify(node) {
  		switch (node.t) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify(String(node.v));

  			case ARRAY_LITERAL:
  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";

  			case OBJECT_LITERAL:
  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";

  			case KEY_VALUE_PAIR:
  				return node.k + ":" + stringify(node.v);

  			case PREFIX_OPERATOR:
  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);

  			case INFIX_OPERATOR:
  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);

  			case INVOCATION:
  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";

  			case BRACKETED:
  				return "(" + stringify(node.x) + ")";

  			case MEMBER:
  				return stringify(node.x) + stringify(node.r);

  			case REFINEMENT:
  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";

  			case CONDITIONAL:
  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);

  			case REFERENCE:
  				return "_" + refs.indexOf(node.n);

  			default:
  				throw new Error("Expected legal JavaScript");
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs(node, refs) {
  	var i, list;

  	if (node.t === REFERENCE) {
  		if (refs.indexOf(node.n) === -1) {
  			refs.unshift(node.n);
  		}
  	}

  	list = node.o || node.m;
  	if (list) {
  		if (isObject(list)) {
  			extractRefs(list, refs);
  		} else {
  			i = list.length;
  			while (i--) {
  				extractRefs(list[i], refs);
  			}
  		}
  	}

  	if (node.x) {
  		extractRefs(node.x, refs);
  	}

  	if (node.r) {
  		extractRefs(node.r, refs);
  	}

  	if (node.v) {
  		extractRefs(node.v, refs);
  	}
  }

  var utils_refineExpression = refineExpression;

  var arrayMemberPattern = /^[0-9][1-9]*$/;
  function refineExpression(expression, mustache) {
  	var referenceExpression;

  	if (expression) {
  		while (expression.t === BRACKETED && expression.x) {
  			expression = expression.x;
  		}

  		// special case - integers should be treated as array members references,
  		// rather than as expressions in their own right
  		if (expression.t === REFERENCE) {
  			mustache.r = expression.n;
  		} else {
  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {
  				mustache.r = expression.v;
  			} else if (referenceExpression = getReferenceExpression(expression)) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = utils_flattenExpression(expression);
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression(expression) {
  	var members = [],
  	    refinement;

  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
  		refinement = expression.r;

  		if (refinement.x) {
  			if (refinement.x.t === REFERENCE) {
  				members.unshift(refinement.x);
  			} else {
  				members.unshift(utils_flattenExpression(refinement.x));
  			}
  		} else {
  			members.unshift(refinement.n);
  		}

  		expression = expression.x;
  	}

  	if (expression.t !== REFERENCE) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  var mustache_readTriple = readTriple;
  function readTriple(parser, tag) {
  	var expression = converters_readExpression(parser),
  	    triple;

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readUnescaped = readUnescaped;
  function readUnescaped(parser, tag) {
  	var expression, triple;

  	if (!parser.matchString("&")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readPartial = readPartial;
  function readPartial(parser, tag) {
  	var start, nameStart, expression, context, partial;

  	start = parser.pos;

  	if (!parser.matchString(">")) {
  		return null;
  	}

  	parser.allowWhitespace();
  	nameStart = parser.pos;

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = true;
  	expression = converters_readExpression(parser);
  	parser.relaxedNames = false;

  	parser.allowWhitespace();
  	context = converters_readExpression(parser);
  	parser.allowWhitespace();

  	if (!expression) {
  		return null;
  	}

  	partial = { t: PARTIAL };
  	utils_refineExpression(expression, partial); // TODO...

  	parser.allowWhitespace();

  	// if we have another expression - e.g. `{{>foo bar}}` - then
  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	if (context) {
  		partial = {
  			t: SECTION,
  			n: SECTION_WITH,
  			f: [partial]
  		};

  		utils_refineExpression(context, partial);
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return partial;
  }

  var readMustacheComment = readComment;
  function readComment(parser, tag) {
  	var index;

  	if (!parser.matchString("!")) {
  		return null;
  	}

  	index = parser.remaining().indexOf(tag.close);

  	if (index !== -1) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  var converters_readExpressionOrReference = readExpressionOrReference;
  function readExpressionOrReference(parser, expectedFollowers) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	for (i = 0; i < expectedFollowers.length; i += 1) {
  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return primary_readReference(parser);
  }

  var mustache_readInterpolator = readInterpolator;
  function readInterpolator(parser, tag) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = converters_readExpressionOrReference(parser, [tag.close]);
  	} catch (e) {
  		err = e;
  	}

  	if (!expression) {
  		if (parser.str.charAt(start) === "!") {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if (err) {
  			throw err;
  		}
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "' after reference");

  		if (!expression) {
  			// special case - comment
  			if (parser.nextChar() === "!") {
  				return null;
  			}

  			parser.error("Expected expression or legal reference");
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var mustache_readYielder = readYielder;
  var yieldPattern = /^yield\s*/;
  function readYielder(parser, tag) {
  	var start, name, yielder;

  	if (!parser.matchPattern(yieldPattern)) {
  		return null;
  	}

  	start = parser.pos;
  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("expected legal partial name");
  	}

  	yielder = { t: YIELDER };

  	if (name) {
  		yielder.n = name;
  	}

  	return yielder;
  }

  var section_readClosing = readClosing;
  function readClosing(parser, tag) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("/")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf(tag.close);

  	if (index !== -1) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr(0, index).split(" ")[0]
  		};

  		parser.pos += index;

  		if (!parser.matchString(tag.close)) {
  			parser.error("Expected closing delimiter '" + tag.close + "'");
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var section_readElse = section_readElse__readElse;
  var section_readElse__elsePattern = /^\s*else\s*/;
  function section_readElse__readElse(parser, tag) {
  	var start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(section_readElse__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSE
  	};
  }

  var readElseIf = readElseIf__readElse;
  var readElseIf__elsePattern = /^\s*elseif\s+/;
  function readElseIf__readElse(parser, tag) {
  	var start = parser.pos,
  	    expression;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(readElseIf__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	expression = converters_readExpression(parser);

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	each: SECTION_EACH,
  	"if": SECTION_IF,
  	"if-with": SECTION_IF_WITH,
  	"with": SECTION_WITH,
  	unless: SECTION_UNLESS
  };

  var mustache_readSection = readSection;

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\b");
  function readSection(parser, tag) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;

  	start = parser.pos;

  	if (parser.matchString("^")) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if (parser.matchString("#")) {
  		section = { t: SECTION, f: [] };

  		if (parser.matchString("partial")) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");
  		}

  		if (block = parser.matchPattern(handlebarsBlockPattern)) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[block];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		parser.error("Expected expression");
  	}

  	// optional index and key references
  	if (i = parser.matchPattern(indexRefPattern)) {
  		var extra = undefined;

  		if (extra = parser.matchPattern(keyIndexRefPattern)) {
  			section.i = i + "," + extra;
  		} else {
  			section.i = i;
  		}
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	do {
  		if (child = section_readClosing(parser, tag)) {
  			if (expectedClose && child.r !== expectedClose) {
  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		} else if (child = readElseIf(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("illegal {{elseif...}} after {{else}}");
  			}

  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  			}

  			unlessBlock.f.push({
  				t: SECTION,
  				n: SECTION_IF,
  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),
  				f: children = []
  			});

  			conditions.push(invert(child.x));
  		} else if (child = section_readElse(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("there can only be one {{else}} block, at the end of a section");
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  				children = unlessBlock.f;
  			} else {
  				unlessBlock.f.push({
  					t: SECTION,
  					n: SECTION_IF,
  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),
  					f: children = []
  				});
  			}
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				break;
  			}

  			children.push(child);
  		}
  	} while (!closed);

  	if (unlessBlock) {
  		// special case - `with` should become `if-with` (TODO is this right?
  		// seems to me that `with` ought to behave consistently, regardless
  		// of the presence/absence of `else`. In other words should always
  		// be `if-with`
  		if (section.n === SECTION_WITH) {
  			section.n = SECTION_IF_WITH;
  		}

  		section.l = unlessBlock;
  	}

  	utils_refineExpression(expression, section);

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if (!section.f.length) {
  		delete section.f;
  	}

  	return section;
  }

  function createUnlessBlock(expression, sectionType) {
  	var unlessBlock;

  	if (sectionType === SECTION_WITH) {
  		// special case - a `{{#with foo}}` section will render if `foo` is
  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,
  		// rather than adhering to the normal `{{#unless foo}}` logic (which
  		// treats empty arrays/objects as falsy)
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_IF,
  			f: []
  		};

  		utils_refineExpression(invert(expression), unlessBlock);
  	} else {
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_UNLESS,
  			f: []
  		};

  		utils_refineExpression(expression, unlessBlock);
  	}

  	return unlessBlock;
  }

  function invert(expression) {
  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {
  		return expression.o;
  	}

  	return {
  		t: PREFIX_OPERATOR,
  		s: "!",
  		o: parensIfNecessary(expression)
  	};
  }

  function mustache_readSection__combine(expressions) {
  	if (expressions.length === 1) {
  		return expressions[0];
  	}

  	return {
  		t: INFIX_OPERATOR,
  		s: "&&",
  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]
  	};
  }

  function parensIfNecessary(expression) {
  	// TODO only wrap if necessary
  	return {
  		t: BRACKETED,
  		x: expression
  	};
  }

  var converters_readHtmlComment = readHtmlComment;
  var OPEN_COMMENT = "<!--",
      CLOSE_COMMENT = "-->";
  function readHtmlComment(parser) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if (!parser.matchString(OPEN_COMMENT)) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf(CLOSE_COMMENT);

  	if (endIndex === -1) {
  		parser.error("Illegal HTML - expected closing comment sequence ('-->')");
  	}

  	content = remaining.substr(0, endIndex);
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if (parser.includeLinePositions) {
  		comment.p = parser.getLinePos(start);
  	}

  	return comment;
  }

  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };
  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
  entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");

  function decodeCharacterReferences(html) {
  	return html.replace(entityPattern, function (match, entity) {
  		var code;

  		// Handle named entities
  		if (entity[0] !== "#") {
  			code = htmlEntities[entity];
  		} else if (entity[1] === "x") {
  			code = parseInt(entity.substring(2), 16);
  		} else {
  			code = parseInt(entity.substring(1), 10);
  		}

  		if (!code) {
  			return match;
  		}

  		return String.fromCharCode(validateCode(code));
  	});
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode(code) {
  	if (!code) {
  		return 65533;
  	}

  	// line feed becomes generic whitespace
  	if (code === 10) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if (code < 128) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing  signs and so on
  	if (code <= 159) {
  		return controlCharacters[code - 128];
  	}

  	// basic multilingual plane
  	if (code < 55296) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if (code <= 57343) {
  		return 65533;
  	}

  	// rest of the basic multilingual plane
  	if (code <= 65535) {
  		return code;
  	}

  	return 65533;
  }

  lessThan = /</g;
  greaterThan = />/g;
  amp = /&/g;

  function escapeHtml(str) {
  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");
  }

  var leadingLinebreak = /^\s*\r?\n/,
      trailingLinebreak = /\r?\n\s*$/;

  var stripStandalones = function (items) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for (i = 1; i < items.length; i += 1) {
  		current = items[i];
  		backOne = items[i - 1];
  		backTwo = items[i - 2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if (isString(current) && isComment(backOne) && isString(backTwo)) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i - 2] = backTwo.replace(trailingLinebreak, "\n");

  				// and the leading line break of the second text token
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if (isSection(current) && isString(backOne)) {
  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {
  				items[i - 1] = backOne.replace(trailingLinebreak, "\n");
  				current.f[0] = current.f[0].replace(leadingLinebreak, "");
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if (isString(current) && isSection(backOne)) {
  			lastSectionItem = lastItem(backOne.f);

  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {
  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\n");
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}
  	}

  	return items;
  };

  function isString(item) {
  	return typeof item === "string";
  }

  function isComment(item) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection(item) {
  	return (item.t === SECTION || item.t === INVERTED) && item.f;
  }

  var trimWhitespace = function (items, leadingPattern, trailingPattern) {
  	var item;

  	if (leadingPattern) {
  		item = items[0];
  		if (typeof item === "string") {
  			item = item.replace(leadingPattern, "");

  			if (!item) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if (trailingPattern) {
  		item = lastItem(items);
  		if (typeof item === "string") {
  			item = item.replace(trailingPattern, "");

  			if (!item) {
  				items.pop();
  			} else {
  				items[items.length - 1] = item;
  			}
  		}
  	}
  };

  var utils_cleanup = cleanup;
  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var utils_cleanup__leadingWhitespace = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;
  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {
  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;

  	// First pass - remove standalones and comments etc
  	stripStandalones(items);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if (item.exclude) {
  			items.splice(i, 1);
  		}

  		// Remove comments, unless we want to keep them
  		else if (stripComments && item.t === COMMENT) {
  			items.splice(i, 1);
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Recurse
  		if (item.f) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if (!preserveWhitespace && isPreserveWhitespaceElement) {
  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);
  			}

  			if (!preserveWhitespaceInsideFragment) {
  				previousItem = items[i - 1];
  				nextItem = items[i + 1];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if (item.l) {
  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);

  			items.splice(i + 1, 0, item.l);
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if (item.a) {
  			for (key in item.a) {
  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {
  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  				}
  			}
  		}

  		// Clean up conditional attributes
  		if (item.m) {
  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Clean up event handlers
  		if (item.v) {
  			for (key in item.v) {
  				if (item.v.hasOwnProperty(key)) {
  					// clean up names
  					if (isArray(item.v[key].n)) {
  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}

  					// clean up params
  					if (isArray(item.v[key].d)) {
  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}
  				}
  			}
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while (i--) {
  		if (typeof items[i] === "string") {
  			if (typeof items[i + 1] === "string") {
  				items[i] = items[i] + items[i + 1];
  				items.splice(i + 1, 1);
  			}

  			if (!preserveWhitespace) {
  				items[i] = items[i].replace(contiguousWhitespace, " ");
  			}

  			if (items[i] === "") {
  				items.splice(i, 1);
  			}
  		}
  	}
  }

  var element_readClosingTag = readClosingTag;
  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
  function readClosingTag(parser) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if (!parser.matchString("</")) {
  		return null;
  	}

  	if (tag = parser.matchPattern(closingTagPattern)) {
  		if (parser.inside && tag !== parser.inside) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error("Illegal closing tag");
  }

  var getLowestIndex = function (haystack, needles) {
  	var i, index, lowest;

  	i = needles.length;
  	while (i--) {
  		index = haystack.indexOf(needles[i]);

  		// short circuit
  		if (!index) {
  			return 0;
  		}

  		if (index === -1) {
  			continue;
  		}

  		if (!lowest || index < lowest) {
  			lowest = index;
  		}
  	}

  	return lowest || -1;
  };

  var element_readAttribute = readAttribute;

  var attributeNamePattern = /^[^\s"'>\/=]+/,
      unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute(parser) {
  	var attr, name, value;

  	parser.allowWhitespace();

  	name = parser.matchPattern(attributeNamePattern);
  	if (!name) {
  		return null;
  	}

  	attr = { name: name };

  	value = readAttributeValue(parser);
  	if (value != null) {
  		// not null/undefined
  		attr.value = value;
  	}

  	return attr;
  }

  function readAttributeValue(parser) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if (!/[=\/>\s]/.test(parser.nextChar())) {
  		parser.error("Expected `=`, `/`, `>` or whitespace");
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue(parser, "'") || readQuotedAttributeValue(parser, "\"") || readUnquotedAttributeValue(parser);

  	if (value === null) {
  		parser.error("Expected valid attribute value");
  	}

  	if (parser.sectionDepth !== startDepth) {
  		parser.pos = valueStart;
  		parser.error("An attribute value must contain as many opening section tags as closing section tags");
  	}

  	if (!value.length) {
  		return "";
  	}

  	if (value.length === 1 && typeof value[0] === "string") {
  		return decodeCharacterReferences(value[0]);
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken(parser) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern(unquotedAttributeValueTextPattern);

  	if (!text) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well

  	if ((index = getLowestIndex(haystack, needles)) !== -1) {
  		text = text.substr(0, index);
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue(parser) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	}

  	if (!tokens.length) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue(parser, quoteMark) {
  	var start, tokens, token;

  	start = parser.pos;

  	if (!parser.matchString(quoteMark)) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	}

  	if (!parser.matchString(quoteMark)) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken(parser, quoteMark) {
  	var start, index, haystack, needles;

  	start = parser.pos;
  	haystack = parser.remaining();

  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well
  	needles.push(quoteMark);

  	index = getLowestIndex(haystack, needles);

  	if (index === -1) {
  		parser.error("Quoted attribute value must have a closing quote");
  	}

  	if (!index) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr(0, index);
  }

  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;

  specials = {
  	"true": true,
  	"false": false,
  	undefined: undefined,
  	"null": null
  };

  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");
  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  placeholderPattern = /\$\{([^\}]+)\}/g;
  placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  onlyWhitespace = /^\s*$/;

  JsonParser = parse_Parser.extend({
  	init: function (str, options) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function (result) {
  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [function getPlaceholder(parser) {
  		var placeholder;

  		if (!parser.values) {
  			return null;
  		}

  		placeholder = parser.matchPattern(placeholderAtStartPattern);

  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {
  			return { v: parser.values[placeholder] };
  		}
  	}, function getSpecial(parser) {
  		var special;

  		if (special = parser.matchPattern(specialsPattern)) {
  			return { v: specials[special] };
  		}
  	}, function getNumber(parser) {
  		var number;

  		if (number = parser.matchPattern(parseJSON__numberPattern)) {
  			return { v: +number };
  		}
  	}, function getString(parser) {
  		var stringLiteral = readStringLiteral(parser),
  		    values;

  		if (stringLiteral && (values = parser.values)) {
  			return {
  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {
  					return $1 in values ? values[$1] : $1;
  				})
  			};
  		}

  		return stringLiteral;
  	}, function getObject(parser) {
  		var result, pair;

  		if (!parser.matchString("{")) {
  			return null;
  		}

  		result = {};

  		parser.allowWhitespace();

  		if (parser.matchString("}")) {
  			return { v: result };
  		}

  		while (pair = getKeyValuePair(parser)) {
  			result[pair.key] = pair.value;

  			parser.allowWhitespace();

  			if (parser.matchString("}")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}
  		}

  		return null;
  	}, function getArray(parser) {
  		var result, valueToken;

  		if (!parser.matchString("[")) {
  			return null;
  		}

  		result = [];

  		parser.allowWhitespace();

  		if (parser.matchString("]")) {
  			return { v: result };
  		}

  		while (valueToken = parser.read()) {
  			result.push(valueToken.v);

  			parser.allowWhitespace();

  			if (parser.matchString("]")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}

  			parser.allowWhitespace();
  		}

  		return null;
  	}]
  });

  function getKeyValuePair(parser) {
  	var key, valueToken, pair;

  	parser.allowWhitespace();

  	key = shared_readKey(parser);

  	if (!key) {
  		return null;
  	}

  	pair = { key: key };

  	parser.allowWhitespace();
  	if (!parser.matchString(":")) {
  		return null;
  	}
  	parser.allowWhitespace();

  	valueToken = parser.read();
  	if (!valueToken) {
  		return null;
  	}

  	pair.value = valueToken.v;

  	return pair;
  }

  var parseJSON = function (str, values) {
  	var parser = new JsonParser(str, {
  		values: values
  	});

  	return parser.result;
  };

  // TODO clean this up, it's shocking
  var element_processDirective = processDirective;
  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
      methodCallExcessPattern = /\)\s*$/,
      ExpressionParser;

  ExpressionParser = parse_Parser.extend({
  	converters: [converters_readExpression]
  });
  function processDirective(tokens, parentParser) {
  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;

  	if (typeof tokens === "string") {
  		if (match = methodCallPattern.exec(tokens)) {
  			var end = tokens.lastIndexOf(")");

  			// check for invalid method calls
  			if (!methodCallExcessPattern.test(tokens)) {
  				parentParser.error("Invalid input after method call expression '" + tokens.slice(end + 1) + "'");
  			}

  			result = { m: match[1] };
  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";

  			parser = new ExpressionParser(args);
  			result.a = utils_flattenExpression(parser.result[0]);

  			return result;
  		}

  		if (tokens.indexOf(":") === -1) {
  			return tokens.trim();
  		}

  		tokens = [tokens];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if (tokens) {
  		while (tokens.length) {
  			token = tokens.shift();

  			if (typeof token === "string") {
  				colonIndex = token.indexOf(":");

  				if (colonIndex === -1) {
  					directiveName.push(token);
  				} else {

  					// is the colon the first character?
  					if (colonIndex) {
  						// no
  						directiveName.push(token.substr(0, colonIndex));
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if (token.length > colonIndex + 1) {
  						directiveArgs[0] = token.substring(colonIndex + 1);
  					}

  					break;
  				}
  			} else {
  				directiveName.push(token);
  			}
  		}

  		directiveArgs = directiveArgs.concat(tokens);
  	}

  	if (!directiveName.length) {
  		result = "";
  	} else if (directiveArgs.length || typeof directiveName !== "string") {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName
  		};

  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {
  			parsed = parseJSON("[" + directiveArgs[0] + "]");
  			result.a = parsed ? parsed.value : directiveArgs[0].trim();
  		} else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	return result;
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
      validTagNameFollower = /^[\s\n\/>]/,
      onPattern = /^on/,
      proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },
      exclude = { exclude: true },
      disallowedContents;

  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: ["li"],
  	dt: ["dt", "dd"],
  	dd: ["dt", "dd"],
  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),
  	rt: ["rt", "rp"],
  	rp: ["rt", "rp"],
  	optgroup: ["optgroup"],
  	option: ["option", "optgroup"],
  	thead: ["tbody", "tfoot"],
  	tbody: ["tbody", "tfoot"],
  	tfoot: ["tbody"],
  	tr: ["tr", "tbody"],
  	td: ["td", "th", "tr"],
  	th: ["td", "th", "tr"]
  };

  var converters_readElement = readElement;

  function readElement(parser) {
  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;

  	start = parser.pos;

  	if (parser.inside || parser.inAttribute) {
  		return null;
  	}

  	if (!parser.matchString("<")) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if (parser.nextChar() === "/") {
  		return null;
  	}

  	element = {};
  	if (parser.includeLinePositions) {
  		element.p = parser.getLinePos(start);
  	}

  	if (parser.matchString("!")) {
  		element.t = DOCTYPE;
  		if (!parser.matchPattern(/^doctype/i)) {
  			parser.error("Expected DOCTYPE declaration");
  		}

  		element.a = parser.matchPattern(/^(.+?)>/);
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern(tagNamePattern);
  	if (!element.e) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if (!validTagNameFollower.test(parser.nextChar())) {
  		parser.error("Illegal tag name");
  	}

  	addProxyEvent = function (name, directive) {
  		var directiveName = directive.n || directive;

  		if (reservedEventNames.test(directiveName)) {
  			parser.pos -= directiveName.length;
  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");
  		}

  		element.v[name] = directive;
  	};

  	parser.allowWhitespace();

  	// directives and attributes
  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {
  		// regular attributes
  		if (attribute.name) {
  			// intro, outro, decorator
  			if (directiveName = directives[attribute.name]) {
  				element[directiveName] = element_processDirective(attribute.value, parser);
  			}

  			// on-click etc
  			else if (match = proxyEventPattern.exec(attribute.name)) {
  				if (!element.v) element.v = {};
  				directive = element_processDirective(attribute.value, parser);
  				addProxyEvent(match[1], directive);
  			} else {
  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {
  					if (!element.a) element.a = {};
  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);
  				}
  			}
  		}

  		// {{#if foo}}class='foo'{{/if}}
  		else {
  			if (!element.m) element.m = [];
  			element.m.push(attribute);
  		}

  		parser.allowWhitespace();
  	}

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if (parser.matchString("/")) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if (!parser.matchString(">")) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if (!selfClosing && !voidElementNames.test(element.e)) {
  		parser.elementStack.push(lowerCaseName);

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if (lowerCaseName === "script" || lowerCaseName === "style") {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create(null);

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if (!canContain(lowerCaseName, remaining)) {
  				closed = true;
  			}

  			// closing tag
  			else if (closingTag = element_readClosingTag(parser)) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if (closingTagName !== lowerCaseName) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if (! ~parser.elementStack.indexOf(closingTagName)) {
  						var errorMessage = "Unexpected closing tag";

  						// add additional help for void elements, since component names
  						// might clash with them
  						if (voidElementNames.test(closingTagName)) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error(errorMessage);
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  				closed = true;
  				parser.pos = pos;
  			} else {
  				if (child = parser.read(PARTIAL_READERS)) {
  					if (partials[child.n]) {
  						parser.pos = pos;
  						parser.error("Duplicate partial definition");
  					}

  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  					partials[child.n] = child.f;
  					hasPartials = true;
  				} else {
  					if (child = parser.read(READERS)) {
  						children.push(child);
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while (!closed);

  		if (children.length) {
  			element.f = children;
  		}

  		if (hasPartials) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
  		return exclude;
  	}

  	return element;
  }

  function canContain(name, remaining) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
  	disallowed = disallowedContents[name];

  	if (!match || !disallowed) {
  		return true;
  	}

  	return ! ~disallowed.indexOf(match[1].toLowerCase());
  }

  var converters_readText = readText;
  function readText(parser) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	barrier = parser.inside ? "</" + parser.inside : "<";

  	if (parser.inside && !parser.interpolate[parser.inside]) {
  		index = remaining.indexOf(barrier);
  	} else {
  		disallowed = parser.tags.map(function (t) {
  			return t.open;
  		});
  		disallowed = disallowed.concat(parser.tags.map(function (t) {
  			return "\\" + t.open;
  		}));

  		// http://developers.whatwg.org/syntax.html#syntax-attributes
  		if (parser.inAttribute === true) {
  			// we're inside an unquoted attribute value
  			disallowed.push("\"", "'", "=", "<", ">", "`");
  		} else if (parser.inAttribute) {
  			// quoted attribute value
  			disallowed.push(parser.inAttribute);
  		} else {
  			disallowed.push(barrier);
  		}

  		index = getLowestIndex(remaining, disallowed);
  	}

  	if (!index) {
  		return null;
  	}

  	if (index === -1) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));
  }

  var utils_escapeRegExp = escapeRegExp;
  var utils_escapeRegExp__pattern = /[-/\\^$*+?.()|[\]{}]/g;
  function escapeRegExp(str) {
  	return str.replace(utils_escapeRegExp__pattern, "\\$&");
  }

  var converters_readPartialDefinitionComment = readPartialDefinitionComment;

  var startPattern = /^<!--\s*/,
      namePattern = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/,
      finishPattern = /\s*-->/,
      child;

  function readPartialDefinitionComment(parser) {
  	var firstPos = parser.pos,
  	    open = parser.standardDelimiters[0],
  	    close = parser.standardDelimiters[1],
  	    content = undefined,
  	    closed = undefined;

  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	var name = parser.matchPattern(namePattern);

  	warnOnceIfDebug("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'");

  	// make sure the rest of the comment is in the correct place
  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	content = [];

  	var endPattern = new RegExp("^<!--\\s*" + utils_escapeRegExp(open) + "\\s*\\/\\s*" + name + "\\s*" + utils_escapeRegExp(close) + "\\s*-->");

  	do {
  		if (parser.matchPattern(endPattern)) {
  			closed = true;
  		} else {
  			child = parser.read(READERS);
  			if (!child) {
  				parser.error("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')");
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var converters_readPartialDefinitionSection = readPartialDefinitionSection;
  var partialDefinitionSectionPattern = /^#\s*partial\s+/;
  function readPartialDefinitionSection(parser) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if (!parser.matchString(delimiters[0])) {
  		return null;
  	}

  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	if (!name) {
  		parser.error("expected legal partial name");
  	}

  	if (!parser.matchString(delimiters[1])) {
  		parser.error("Expected closing delimiter '" + delimiters[1] + "'");
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  			if (!child.r === "partial") {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			closed = true;
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  var converters_readTemplate = readTemplate;
  function readTemplate(parser) {
  	var fragment = [];
  	var partials = create(null);
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while (parser.pos < parser.str.length) {
  		var pos = parser.pos,
  		    item = undefined,
  		    partial = undefined;

  		if (partial = parser.read(PARTIAL_READERS)) {
  			if (partials[partial.n]) {
  				parser.pos = pos;
  				parser.error("Duplicated partial definition");
  			}

  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  			partials[partial.n] = partial.f;
  			hasPartials = true;
  		} else if (item = parser.read(READERS)) {
  			fragment.push(item);
  		} else {
  			parser.error("Unexpected template content");
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if (hasPartials) {
  		result.p = partials;
  	}

  	return result;
  }

  var _parse = parse;

  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];
  var TRIPLE_READERS = [mustache_readTriple];
  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?

  var StandardParser = undefined;
  function parse(template, options) {
  	return new StandardParser(template, options || {}).result;
  }

  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];
  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];

  StandardParser = parse_Parser.extend({
  	init: function (str, options) {
  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],
  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],
  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];

  		this.standardDelimiters = options.delimiters || ["{{", "}}"];

  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false
  		};

  		if (options.sanitize === true) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  	},

  	postProcess: function (result) {
  		// special case - empty string
  		if (!result.length) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if (this.sectionDepth > 0) {
  			this.error("A section was left open");
  		}

  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);

  		return result[0];
  	},

  	converters: [converters_readTemplate],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort(function (a, b) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];

  var parser = {
  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,
  	parse: doParse
  };

  function template_parser__createHelper(parseOptions) {
  	var helper = create(parser);
  	helper.parse = function (template, options) {
  		return doParse(template, options || parseOptions);
  	};
  	return helper;
  }

  function doParse(template, parseOptions) {
  	if (!_parse) {
  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");
  	}

  	return _parse(template, parseOptions || this.options);
  }

  function fromId(id, options) {
  	var template;

  	if (!isClient) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");
  	}

  	if (isHashedId(id)) {
  		id = id.substring(1);
  	}

  	if (!(template = document.getElementById(id))) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Could not find template element with id #" + id);
  	}

  	if (template.tagName.toUpperCase() !== "SCRIPT") {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Template element with id #" + id + ", must be a <script> element");
  	}

  	return "textContent" in template ? template.textContent : template.innerHTML;
  }

  function isHashedId(id) {
  	return id && id[0] === "#";
  }

  function isParsed(template) {
  	return !(typeof template === "string");
  }

  function getParseOptions(ractive) {
  	// Could be Ractive or a Component
  	if (ractive.defaults) {
  		ractive = ractive.defaults;
  	}

  	return parseOptions.reduce(function (val, key) {
  		val[key] = ractive[key];
  		return val;
  	}, {});
  }

  var template_parser = parser;

  var templateConfigurator = {
  	name: "template",

  	extend: function extend(Parent, proto, options) {
  		var template;

  		// only assign if exists
  		if ("template" in options) {
  			template = options.template;

  			if (typeof template === "function") {
  				proto.template = template;
  			} else {
  				proto.template = parseIfString(template, proto);
  			}
  		}
  	},

  	init: function init(Parent, ractive, options) {
  		var template, fn;

  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		template = "template" in options ? options.template : Parent.prototype.template;

  		if (typeof template === "function") {
  			fn = template;
  			template = getDynamicTemplate(ractive, fn);

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseIfString(template, ractive);

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if (template.p) {
  			extendPartials(ractive.partials, template.p);
  		}
  	},

  	reset: function (ractive) {
  		var result = resetValue(ractive),
  		    parsed;

  		if (result) {
  			parsed = parseIfString(result, ractive);

  			ractive.template = parsed.t;
  			extendPartials(ractive.partials, parsed.p, true);

  			return true;
  		}
  	}
  };

  function resetValue(ractive) {
  	var initial = ractive._config.template,
  	    result;

  	// If this isn't a dynamic template, there's nothing to do
  	if (!initial || !initial.fn) {
  		return;
  	}

  	result = getDynamicTemplate(ractive, initial.fn);

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if (result !== initial.result) {
  		initial.result = result;
  		result = parseIfString(result, ractive);
  		return result;
  	}
  }

  function getDynamicTemplate(ractive, fn) {
  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));
  	return fn.call(ractive, helper);
  }

  function template_template__createHelper(parseOptions) {
  	var helper = create(template_parser);
  	helper.parse = function (template, options) {
  		return template_parser.parse(template, options || parseOptions);
  	};
  	return helper;
  }

  function parseIfString(template, ractive) {
  	if (typeof template === "string") {
  		// ID of an element containing the template?
  		if (template[0] === "#") {
  			template = template_parser.fromId(template);
  		}

  		template = _parse(template, template_parser.getParseOptions(ractive));
  	}

  	// Check that the template even exists
  	else if (template == undefined) {
  		throw new Error("The template cannot be " + template + ".");
  	}

  	// Check the parsed template has a version at all
  	else if (typeof template.v !== "number") {
  		throw new Error("The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.");
  	}

  	// Check we're using the correct version
  	else if (template.v !== TEMPLATE_VERSION) {
  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");
  	}

  	return template;
  }

  function extendPartials(existingPartials, newPartials, overwrite) {
  	if (!newPartials) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for (var key in newPartials) {
  		if (overwrite || !existingPartials.hasOwnProperty(key)) {
  			existingPartials[key] = newPartials[key];
  		}
  	}
  }

  var template_template = templateConfigurator;

  var config_registries__registryNames, Registry, registries;

  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  Registry = function (name, useDefaults) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype = {
  	constructor: Registry,

  	extend: function (Parent, proto, options) {
  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);
  	},

  	init: function () {},

  	configure: function (Parent, target, options) {
  		var name = this.name,
  		    option = options[name],
  		    registry;

  		registry = create(Parent[name]);

  		for (var key in option) {
  			registry[key] = option[key];
  		}

  		target[name] = registry;
  	},

  	reset: function (ractive) {
  		var registry = ractive[this.name];
  		var changed = false;
  		Object.keys(registry).forEach(function (key) {
  			var item = registry[key];
  			if (item._fn) {
  				if (item._fn.isOwner) {
  					registry[key] = item._fn;
  				} else {
  					delete registry[key];
  				}
  				changed = true;
  			}
  		});
  		return changed;
  	}
  };

  registries = config_registries__registryNames.map(function (name) {
  	return new Registry(name, name === "computed");
  });

  var config_registries = registries;

  /*this.configure(
  	this.useDefaults ? Parent.defaults : Parent,
  	ractive,
  	options );*/

  var wrapPrototype = wrap;

  function wrap(parent, name, method) {
  	if (!/_super/.test(method)) {
  		return method;
  	}

  	var wrapper = function wrapSuper() {
  		var superMethod = getSuperMethod(wrapper._parent, name),
  		    hasSuper = ("_super" in this),
  		    oldSuper = this._super,
  		    result;

  		this._super = superMethod;

  		result = method.apply(this, arguments);

  		if (hasSuper) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	};

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod(parent, name) {
  	var value, method;

  	if (name in parent) {
  		value = parent[name];

  		if (typeof value === "function") {
  			method = value;
  		} else {
  			method = function returnValue() {
  				return value;
  			};
  		}
  	} else {
  		method = noop;
  	}

  	return method;
  }

  var config_deprecate = deprecate;
  function getMessage(deprecated, correct, isError) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");
  }

  function deprecateOption(options, deprecatedOption, correct) {
  	if (deprecatedOption in options) {
  		if (!(correct in options)) {
  			warnIfDebug(getMessage(deprecatedOption, correct));
  			options[correct] = options[deprecatedOption];
  		} else {
  			throw new Error(getMessage(deprecatedOption, correct, true));
  		}
  	}
  }
  function deprecate(options) {
  	deprecateOption(options, "beforeInit", "onconstruct");
  	deprecateOption(options, "init", "onrender");
  	deprecateOption(options, "complete", "oncomplete");
  	deprecateOption(options, "eventDefinitions", "events");

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if (isArray(options.adaptors)) {
  		deprecateOption(options, "adaptors", "adapt");
  	}
  }

  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;

  custom = {
  	adapt: custom_adapt,
  	css: css_css,
  	data: custom_data,
  	template: template_template
  };

  defaultKeys = Object.keys(config_defaults);

  isStandardKey = makeObj(defaultKeys.filter(function (key) {
  	return !custom[key];
  }));

  // blacklisted keys that we don't double extend
  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {
  	return r.name;
  })));

  order = [].concat(defaultKeys.filter(function (key) {
  	return !config_registries[key] && !custom[key];
  }), config_registries, custom.data, custom.template, custom.css);

  config = {
  	extend: function (Parent, proto, options) {
  		return configure("extend", Parent, proto, options);
  	},

  	init: function (Parent, ractive, options) {
  		return configure("init", Parent, ractive, options);
  	},

  	reset: function (ractive) {
  		return order.filter(function (c) {
  			return c.reset && c.reset(ractive);
  		}).map(function (c) {
  			return c.name;
  		});
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order };

  function configure(method, Parent, target, options) {
  	config_deprecate(options);

  	for (var key in options) {
  		if (isStandardKey.hasOwnProperty(key)) {
  			var value = options[key];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if (key !== "el" && typeof value === "function") {
  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);
  			} else {
  				target[key] = value;
  			}
  		}
  	}

  	config_registries.forEach(function (registry) {
  		registry[method](Parent, target, options);
  	});

  	custom_adapt[method](Parent, target, options);
  	template_template[method](Parent, target, options);
  	css_css[method](Parent, target, options);

  	extendOtherMethods(Parent.prototype, target, options);
  }

  function extendOtherMethods(parent, target, options) {
  	for (var key in options) {
  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {
  			var member = options[key];

  			// if this is a method that overwrites a method, wrap it:
  			if (typeof member === "function") {
  				member = wrapPrototype(parent, key, member);
  			}

  			target[key] = member;
  		}
  	}
  }

  function makeObj(array) {
  	var obj = {};
  	array.forEach(function (x) {
  		return obj[x] = true;
  	});
  	return obj;
  }

  var config_config = config;

  var prototype_bubble = Fragment$bubble;

  function Fragment$bubble() {
  	this.dirtyValue = this.dirtyArgs = true;

  	if (this.bound && typeof this.owner.bubble === "function") {
  		this.owner.bubble();
  	}
  }

  var Fragment_prototype_detach = Fragment$detach;

  function Fragment$detach() {
  	var docFrag;

  	if (this.items.length === 1) {
  		return this.items[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.items.forEach(function (item) {
  		var node = item.detach();

  		// TODO The if {...} wasn't previously required - it is now, because we're
  		// forcibly detaching everything to reorder sections after an update. That's
  		// a non-ideal brute force approach, implemented to get all the tests to pass
  		// - as soon as it's replaced with something more elegant, this should
  		// revert to `docFrag.appendChild( item.detach() )`
  		if (node) {
  			docFrag.appendChild(node);
  		}
  	});

  	return docFrag;
  }

  var Fragment_prototype_find = Fragment$find;

  function Fragment$find(selector) {
  	var i, len, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.find && (queryResult = item.find(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var Fragment_prototype_findAll = Fragment$findAll;

  function Fragment$findAll(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAll) {
  				item.findAll(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;

  function Fragment$findAllComponents(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAllComponents) {
  				item.findAllComponents(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findComponent = Fragment$findComponent;

  function Fragment$findComponent(selector) {
  	var len, i, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findComponent && (queryResult = item.findComponent(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var prototype_findNextNode = Fragment$findNextNode;

  function Fragment$findNextNode(item) {
  	var index = item.index,
  	    node;

  	if (this.items[index + 1]) {
  		node = this.items[index + 1].firstNode();
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	else if (this.owner === this.root) {
  		if (!this.owner.component) {
  			// TODO but something else could have been appended to
  			// this.root.el, no?
  			node = null;
  		}

  		// ...unless this is a component
  		else {
  			node = this.owner.component.findNextNode();
  		}
  	} else {
  		node = this.owner.findNextNode(this);
  	}

  	return node;
  }

  var prototype_firstNode = Fragment$firstNode;

  function Fragment$firstNode() {
  	if (this.items && this.items[0]) {
  		return this.items[0].firstNode();
  	}

  	return null;
  }

  var shared_processItems = processItems;

  function processItems(items, values, guid, counter) {
  	counter = counter || 0;

  	return items.map(function (item) {
  		var placeholderId, wrapped, value;

  		if (item.text) {
  			return item.text;
  		}

  		if (item.fragments) {
  			return item.fragments.map(function (fragment) {
  				return processItems(fragment.items, values, guid, counter);
  			}).join("");
  		}

  		placeholderId = guid + "-" + counter++;

  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {
  			value = wrapped.value;
  		} else {
  			value = item.getValue();
  		}

  		values[placeholderId] = value;

  		return "${" + placeholderId + "}";
  	}).join("");
  }

  var getArgsList = Fragment$getArgsList;
  function Fragment$getArgsList() {
  	var values, source, parsed, result;

  	if (this.dirtyArgs) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON("[" + source + "]", values);

  		if (!parsed) {
  			result = [this.toString()];
  		} else {
  			result = parsed.value;
  		}

  		this.argsList = result;
  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  }

  var getNode = Fragment$getNode;

  function Fragment$getNode() {
  	var fragment = this;

  	do {
  		if (fragment.pElement) {
  			return fragment.pElement.node;
  		}
  	} while (fragment = fragment.parent);

  	return this.root.detached || this.root.el;
  }

  var prototype_getValue = Fragment$getValue;
  function Fragment$getValue() {
  	var values, source, parsed, result;

  	if (this.dirtyValue) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON(source, values);

  		if (!parsed) {
  			result = this.toString();
  		} else {
  			result = parsed.value;
  		}

  		this.value = result;
  		this.dirtyValue = false;
  	}

  	return this.value;
  }

  var shared_detach = function () {
  	return detachNode(this.node);
  };

  var Text = function (options) {
  	this.type = TEXT;
  	this.text = options.template;
  };

  Text.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(this.text);
  		}

  		return this.node;
  	},

  	toString: function (escape) {
  		return escape ? escapeHtml(this.text) : this.text;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			return this.detach();
  		}
  	}
  };

  var items_Text = Text;

  var shared_unbind = shared_unbind__unbind;

  function shared_unbind__unbind() {
  	if (this.registered) {
  		// this was registered as a dependant
  		this.root.viewmodel.unregister(this.keypath, this);
  	}

  	if (this.resolver) {
  		this.resolver.unbind();
  	}
  }

  var Mustache_getValue = Mustache$getValue;

  function Mustache$getValue() {
  	return this.value;
  }

  var ReferenceResolver = function (owner, ref, callback) {
  	var keypath;

  	this.ref = ref;
  	this.resolved = false;

  	this.root = owner.root;
  	this.parentFragment = owner.parentFragment;
  	this.callback = callback;

  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);
  	if (keypath != undefined) {
  		this.resolve(keypath);
  	} else {
  		global_runloop.addUnresolved(this);
  	}
  };

  ReferenceResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath && !keypath) {
  			// it was resolved, and now it's not. Can happen if e.g. `bar` in
  			// `{{foo[bar]}}` becomes undefined
  			global_runloop.addUnresolved(this);
  		}

  		this.resolved = true;

  		this.keypath = keypath;
  		this.callback(keypath);
  	},

  	forceResolution: function () {
  		this.resolve(getKeypath(this.ref));
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var keypath;

  		if (this.keypath != undefined) {
  			keypath = this.keypath.replace(oldKeypath, newKeypath);
  			// was a new keypath created?
  			if (keypath !== undefined) {
  				// resolve it
  				this.resolve(keypath);
  			}
  		}
  	},

  	unbind: function () {
  		if (!this.resolved) {
  			global_runloop.removeUnresolved(this);
  		}
  	}
  };

  var Resolvers_ReferenceResolver = ReferenceResolver;

  var SpecialResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	this.rebind();
  };

  var props = {
  	"@keypath": { prefix: "c", prop: ["context"] },
  	"@index": { prefix: "i", prop: ["index"] },
  	"@key": { prefix: "k", prop: ["key", "index"] }
  };

  function getProp(target, prop) {
  	var value;
  	for (var i = 0; i < prop.prop.length; i++) {
  		if ((value = target[prop.prop[i]]) !== undefined) {
  			return value;
  		}
  	}
  }

  SpecialResolver.prototype = {
  	rebind: function () {
  		var ref = this.ref,
  		    fragment = this.parentFragment,
  		    prop = props[ref],
  		    value;

  		if (!prop) {
  			throw new Error("Unknown special reference \"" + ref + "\" - valid references are @index, @key and @keypath");
  		}

  		// have we already found the nearest parent?
  		if (this.cached) {
  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));
  		}

  		// special case for indices, which may cross component boundaries
  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {
  			while (fragment) {
  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {
  					this.cached = fragment;

  					fragment.registerIndexRef(this);

  					return this.callback(getKeypath("@" + prop.prefix + value));
  				}

  				// watch for component boundaries
  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  					fragment = fragment.owner.component.parentFragment;
  				} else {
  					fragment = fragment.parent;
  				}
  			}
  		} else {
  			while (fragment) {
  				if ((value = getProp(fragment, prop)) !== undefined) {
  					return this.callback(getKeypath("@" + prop.prefix + value.str));
  				}

  				fragment = fragment.parent;
  			}
  		}
  	},

  	unbind: function () {
  		if (this.cached) {
  			this.cached.unregisterIndexRef(this);
  		}
  	}
  };

  var Resolvers_SpecialResolver = SpecialResolver;

  var IndexResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	ref.ref.fragment.registerIndexRef(this);

  	this.rebind();
  };

  IndexResolver.prototype = {
  	rebind: function () {
  		var index,
  		    ref = this.ref.ref;

  		if (ref.ref.t === "k") {
  			index = "k" + ref.fragment.key;
  		} else {
  			index = "i" + ref.fragment.index;
  		}

  		if (index !== undefined) {
  			this.callback(getKeypath("@" + index));
  		}
  	},

  	unbind: function () {
  		this.ref.ref.fragment.unregisterIndexRef(this);
  	}
  };

  var Resolvers_IndexResolver = IndexResolver;

  var Resolvers_findIndexRefs = findIndexRefs;

  function findIndexRefs(fragment, refName) {
  	var result = {},
  	    refs,
  	    fragRefs,
  	    ref,
  	    i,
  	    owner,
  	    hit = false;

  	if (!refName) {
  		result.refs = refs = {};
  	}

  	while (fragment) {
  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {

  			// we're looking for a particular ref, and it's here
  			if (refName && (ref = owner.getIndexRef(refName))) {
  				result.ref = {
  					fragment: fragment,
  					ref: ref
  				};
  				return result;
  			}

  			// we're collecting refs up-tree
  			else if (!refName) {
  				for (i in fragRefs) {
  					ref = fragRefs[i];

  					// don't overwrite existing refs - they should shadow parents
  					if (!refs[ref.n]) {
  						hit = true;
  						refs[ref.n] = {
  							fragment: fragment,
  							ref: ref
  						};
  					}
  				}
  			}
  		}

  		// watch for component boundaries
  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  			result.componentBoundary = true;
  			fragment = fragment.owner.component.parentFragment;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if (!hit) {
  		return undefined;
  	} else {
  		return result;
  	}
  }

  findIndexRefs.resolve = function resolve(indices) {
  	var refs = {},
  	    k,
  	    ref;

  	for (k in indices.refs) {
  		ref = indices.refs[k];
  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;
  	}

  	return refs;
  };

  var Resolvers_createReferenceResolver = createReferenceResolver;
  function createReferenceResolver(owner, ref, callback) {
  	var indexRef;

  	if (ref.charAt(0) === "@") {
  		return new Resolvers_SpecialResolver(owner, ref, callback);
  	}

  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {
  		return new Resolvers_IndexResolver(owner, indexRef, callback);
  	}

  	return new Resolvers_ReferenceResolver(owner, ref, callback);
  }

  var shared_getFunctionFromString = getFunctionFromString;
  var cache = {};
  function getFunctionFromString(str, i) {
  	var fn, args;

  	if (cache[str]) {
  		return cache[str];
  	}

  	args = [];
  	while (i--) {
  		args[i] = "_" + i;
  	}

  	fn = new Function(args.join(","), "return(" + str + ")");

  	cache[str] = fn;
  	return fn;
  }

  var ExpressionResolver,
      Resolvers_ExpressionResolver__bind = Function.prototype.bind;

  ExpressionResolver = function (owner, parentFragment, expression, callback) {
  	var _this = this;

  	var ractive;

  	ractive = owner.root;

  	this.root = ractive;
  	this.parentFragment = parentFragment;
  	this.callback = callback;
  	this.owner = owner;
  	this.str = expression.s;
  	this.keypaths = [];

  	// Create resolvers for each reference
  	this.pending = expression.r.length;
  	this.refResolvers = expression.r.map(function (ref, i) {
  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  			_this.resolve(i, keypath);
  		});
  	});

  	this.ready = true;
  	this.bubble();
  };

  ExpressionResolver.prototype = {
  	bubble: function () {
  		if (!this.ready) {
  			return;
  		}

  		this.uniqueString = getUniqueString(this.str, this.keypaths);
  		this.keypath = createExpressionKeypath(this.uniqueString);

  		this.createEvaluator();
  		this.callback(this.keypath);
  	},

  	unbind: function () {
  		var resolver;

  		while (resolver = this.refResolvers.pop()) {
  			resolver.unbind();
  		}
  	},

  	resolve: function (index, keypath) {
  		this.keypaths[index] = keypath;
  		this.bubble();
  	},

  	createEvaluator: function () {
  		var _this = this;

  		var computation, valueGetters, signature, keypath, fn;

  		keypath = this.keypath;
  		computation = this.root.viewmodel.computations[keypath.str];

  		// only if it doesn't exist yet!
  		if (!computation) {
  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);

  			valueGetters = this.keypaths.map(function (keypath) {
  				var value;

  				if (keypath === "undefined") {
  					return function () {
  						return undefined;
  					};
  				}

  				// 'special' keypaths encode a value
  				if (keypath.isSpecial) {
  					value = keypath.value;
  					return function () {
  						return value;
  					};
  				}

  				return function () {
  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });
  					if (typeof value === "function") {
  						value = wrapFunction(value, _this.root);
  					}
  					return value;
  				};
  			});

  			signature = {
  				deps: this.keypaths.filter(isValidDependency),
  				getter: function () {
  					var args = valueGetters.map(call);
  					return fn.apply(null, args);
  				}
  			};

  			computation = this.root.viewmodel.compute(keypath, signature);
  		} else {
  			this.root.viewmodel.mark(keypath);
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// TODO only bubble once, no matter how many references are affected by the rebind
  		this.refResolvers.forEach(function (r) {
  			return r.rebind(oldKeypath, newKeypath);
  		});
  	}
  };

  var Resolvers_ExpressionResolver = ExpressionResolver;

  function call(value) {
  	return value.call();
  }

  function getUniqueString(str, keypaths) {
  	// get string that is unique to this expression
  	return str.replace(/_([0-9]+)/g, function (match, $1) {
  		var keypath, value;

  		// make sure we're not replacing a non-keypath _[0-9]
  		if (+$1 >= keypaths.length) {
  			return "_" + $1;
  		}

  		keypath = keypaths[$1];

  		if (keypath === undefined) {
  			return "undefined";
  		}

  		if (keypath.isSpecial) {
  			value = keypath.value;
  			return typeof value === "number" ? value : "\"" + value + "\"";
  		}

  		return keypath.str;
  	});
  }

  function createExpressionKeypath(uniqueString) {
  	// Sanitize by removing any periods or square brackets. Otherwise
  	// we can't split the keypath into keys!
  	// Remove asterisks too, since they mess with pattern observers
  	return getKeypath("${" + uniqueString.replace(/[\.\[\]]/g, "-").replace(/\*/, "#MUL#") + "}");
  }

  function isValidDependency(keypath) {
  	return keypath !== undefined && keypath[0] !== "@";
  }

  function wrapFunction(fn, ractive) {
  	var wrapped, prop, key;

  	if (fn.__ractive_nowrap) {
  		return fn;
  	}

  	prop = "__ractive_" + ractive._guid;
  	wrapped = fn[prop];

  	if (wrapped) {
  		return wrapped;
  	} else if (/this/.test(fn.toString())) {
  		defineProperty(fn, prop, {
  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),
  			configurable: true
  		});

  		// Add properties/methods to wrapped function
  		for (key in fn) {
  			if (fn.hasOwnProperty(key)) {
  				fn[prop][key] = fn[key];
  			}
  		}

  		ractive._boundFunctions.push({
  			fn: fn,
  			prop: prop
  		});

  		return fn[prop];
  	}

  	defineProperty(fn, "__ractive_nowrap", {
  		value: fn
  	});

  	return fn.__ractive_nowrap;
  }

  var MemberResolver = function (template, resolver, parentFragment) {
  	var _this = this;

  	this.resolver = resolver;
  	this.root = resolver.root;
  	this.parentFragment = parentFragment;
  	this.viewmodel = resolver.root.viewmodel;

  	if (typeof template === "string") {
  		this.value = template;
  	}

  	// Simple reference?
  	else if (template.t === REFERENCE) {
  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}

  	// Otherwise we have an expression in its own right
  	else {
  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}
  };

  MemberResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		this.keypath = keypath;
  		this.value = this.viewmodel.get(keypath);

  		this.bind();

  		this.resolver.bubble();
  	},

  	bind: function () {
  		this.viewmodel.register(this.keypath, this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.refResolver) {
  			this.refResolver.rebind(oldKeypath, newKeypath);
  		}
  	},

  	setValue: function (value) {
  		this.value = value;
  		this.resolver.bubble();
  	},

  	unbind: function () {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		if (this.refResolver) {
  			this.refResolver.unbind();
  		}
  	},

  	forceResolution: function () {
  		if (this.refResolver) {
  			this.refResolver.forceResolution();
  		}
  	}
  };

  var ReferenceExpressionResolver_MemberResolver = MemberResolver;

  var ReferenceExpressionResolver = function (mustache, template, callback) {
  	var _this = this;

  	var ractive, ref, keypath, parentFragment;

  	this.parentFragment = parentFragment = mustache.parentFragment;
  	this.root = ractive = mustache.root;
  	this.mustache = mustache;

  	this.ref = ref = template.r;
  	this.callback = callback;

  	this.unresolved = [];

  	// Find base keypath
  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {
  		this.base = keypath;
  	} else {
  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {
  			_this.base = keypath;
  			_this.baseResolver = null;
  			_this.bubble();
  		});
  	}

  	// Find values for members, or mark them as unresolved
  	this.members = template.m.map(function (template) {
  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);
  	});

  	this.ready = true;
  	this.bubble(); // trigger initial resolution if possible
  };

  ReferenceExpressionResolver.prototype = {
  	getKeypath: function () {
  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);

  		if (!values.every(isDefined) || this.baseResolver) {
  			return null;
  		}

  		return this.base.join(values.join("."));
  	},

  	bubble: function () {
  		if (!this.ready || this.baseResolver) {
  			return;
  		}

  		this.callback(this.getKeypath());
  	},

  	unbind: function () {
  		this.members.forEach(methodCallers__unbind);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var changed;

  		if (this.base) {
  			var newBase = this.base.replace(oldKeypath, newKeypath);
  			if (newBase && newBase !== this.base) {
  				this.base = newBase;
  				changed = true;
  			}
  		}

  		this.members.forEach(function (members) {
  			if (members.rebind(oldKeypath, newKeypath)) {
  				changed = true;
  			}
  		});

  		if (changed) {
  			this.bubble();
  		}
  	},

  	forceResolution: function () {
  		if (this.baseResolver) {
  			this.base = getKeypath(this.ref);

  			this.baseResolver.unbind();
  			this.baseResolver = null;
  		}

  		this.members.forEach(forceResolution);
  		this.bubble();
  	}
  };

  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {
  	return member.value;
  }

  function isDefined(value) {
  	return value != undefined;
  }

  function forceResolution(member) {
  	member.forceResolution();
  }

  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;

  var Mustache_initialise = Mustache$init;
  function Mustache$init(mustache, options) {

  	var ref, parentFragment, template;

  	parentFragment = options.parentFragment;
  	template = options.template;

  	mustache.root = parentFragment.root;
  	mustache.parentFragment = parentFragment;
  	mustache.pElement = parentFragment.pElement;

  	mustache.template = options.template;
  	mustache.index = options.index || 0;
  	mustache.isStatic = options.template.s;

  	mustache.type = options.template.t;

  	mustache.registered = false;

  	// if this is a simple mustache, with a reference, we just need to resolve
  	// the reference to a keypath
  	if (ref = template.r) {
  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);
  	}

  	// if it's an expression, we have a bit more work to do
  	if (options.template.x) {
  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);
  	}

  	if (options.template.rx) {
  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);
  	}

  	// Special case - inverted sections
  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {
  		mustache.setValue(undefined);
  	}

  	function resolve(keypath) {
  		mustache.resolve(keypath);
  	}

  	function resolveAndRebindChildren(newKeypath) {
  		var oldKeypath = mustache.keypath;

  		if (newKeypath != oldKeypath) {
  			mustache.resolve(newKeypath);

  			if (oldKeypath !== undefined) {
  				mustache.fragments && mustache.fragments.forEach(function (f) {
  					f.rebind(oldKeypath, newKeypath);
  				});
  			}
  		}
  	}
  }

  var Mustache_resolve = Mustache$resolve;

  function Mustache$resolve(keypath) {
  	var wasResolved, value, twowayBinding;

  	// 'Special' keypaths, e.g. @foo or @7, encode a value
  	if (keypath && keypath.isSpecial) {
  		this.keypath = keypath;
  		this.setValue(keypath.value);
  		return;
  	}

  	// If we resolved previously, we need to unregister
  	if (this.registered) {
  		// undefined or null
  		this.root.viewmodel.unregister(this.keypath, this);
  		this.registered = false;

  		wasResolved = true;
  	}

  	this.keypath = keypath;

  	// If the new keypath exists, we need to register
  	// with the viewmodel
  	if (keypath != undefined) {
  		// undefined or null
  		value = this.root.viewmodel.get(keypath);
  		this.root.viewmodel.register(keypath, this);

  		this.registered = true;
  	}

  	// Either way we need to queue up a render (`value`
  	// will be `undefined` if there's no keypath)
  	this.setValue(value);

  	// Two-way bindings need to point to their new target keypath
  	if (wasResolved && (twowayBinding = this.twowayBinding)) {
  		twowayBinding.rebound();
  	}
  }

  var Mustache_rebind = Mustache$rebind;

  function Mustache$rebind(oldKeypath, newKeypath) {
  	// Children first
  	if (this.fragments) {
  		this.fragments.forEach(function (f) {
  			return f.rebind(oldKeypath, newKeypath);
  		});
  	}

  	// Expression mustache?
  	if (this.resolver) {
  		this.resolver.rebind(oldKeypath, newKeypath);
  	}
  }

  var Mustache = {
  	getValue: Mustache_getValue,
  	init: Mustache_initialise,
  	resolve: Mustache_resolve,
  	rebind: Mustache_rebind
  };

  var Interpolator = function (options) {
  	this.type = INTERPOLATOR;
  	Mustache.init(this, options);
  };

  Interpolator.prototype = {
  	update: function () {
  		this.node.data = this.value == undefined ? "" : this.value;
  	},
  	resolve: Mustache.resolve,
  	rebind: Mustache.rebind,
  	detach: shared_detach,

  	unbind: shared_unbind,

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(safeToStringValue(this.value));
  		}

  		return this.node;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			detachNode(this.node);
  		}
  	},

  	getValue: Mustache.getValue,

  	// TEMP
  	setValue: function (value) {
  		var wrapper;

  		// TODO is there a better way to approach this?
  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  			value = wrapper.get();
  		}

  		if (!isEqual(value, this.value)) {
  			this.value = value;
  			this.parentFragment.bubble();

  			if (this.node) {
  				global_runloop.addView(this);
  			}
  		}
  	},

  	firstNode: function () {
  		return this.node;
  	},

  	toString: function (escape) {
  		var string = "" + safeToStringValue(this.value);
  		return escape ? escapeHtml(string) : string;
  	}
  };

  var items_Interpolator = Interpolator;

  var Section_prototype_bubble = Section$bubble;

  function Section$bubble() {
  	this.parentFragment.bubble();
  }

  var Section_prototype_detach = Section$detach;

  function Section$detach() {
  	var docFrag;

  	if (this.fragments.length === 1) {
  		return this.fragments[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (item) {
  		docFrag.appendChild(item.detach());
  	});

  	return docFrag;
  }

  var find = Section$find;

  function Section$find(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].find(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findAll = Section$findAll;

  function Section$findAll(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAll(selector, query);
  	}
  }

  var findAllComponents = Section$findAllComponents;

  function Section$findAllComponents(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAllComponents(selector, query);
  	}
  }

  var findComponent = Section$findComponent;

  function Section$findComponent(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].findComponent(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findNextNode = Section$findNextNode;

  function Section$findNextNode(fragment) {
  	if (this.fragments[fragment.index + 1]) {
  		return this.fragments[fragment.index + 1].firstNode();
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var firstNode = Section$firstNode;

  function Section$firstNode() {
  	var len, i, node;

  	if (len = this.fragments.length) {
  		for (i = 0; i < len; i += 1) {
  			if (node = this.fragments[i].firstNode()) {
  				return node;
  			}
  		}
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var shuffle = Section$shuffle;

  function Section$shuffle(newIndices) {
  	var _this = this;

  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;

  	// short circuit any double-updates, and ensure that this isn't applied to
  	// non-list sections
  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {
  		return;
  	}

  	this.shuffling = true;
  	global_runloop.scheduleTask(function () {
  		return _this.shuffling = false;
  	});

  	parentFragment = this.parentFragment;

  	reboundFragments = [];

  	// TODO: need to update this
  	// first, rebind existing fragments
  	newIndices.forEach(function (newIndex, oldIndex) {
  		var fragment, by, oldKeypath, newKeypath, deps;

  		if (newIndex === oldIndex) {
  			reboundFragments[newIndex] = _this.fragments[oldIndex];
  			return;
  		}

  		fragment = _this.fragments[oldIndex];

  		if (firstChange === undefined) {
  			firstChange = oldIndex;
  		}

  		// does this fragment need to be torn down?
  		if (newIndex === -1) {
  			_this.fragmentsToUnrender.push(fragment);
  			fragment.unbind();
  			return;
  		}

  		// Otherwise, it needs to be rebound to a new index
  		by = newIndex - oldIndex;
  		oldKeypath = _this.keypath.join(oldIndex);
  		newKeypath = _this.keypath.join(newIndex);

  		fragment.index = newIndex;

  		// notify any registered index refs directly
  		if (deps = fragment.registeredIndexRefs) {
  			deps.forEach(shuffle__blindRebind);
  		}

  		fragment.rebind(oldKeypath, newKeypath);
  		reboundFragments[newIndex] = fragment;
  	});

  	newLength = this.root.viewmodel.get(this.keypath).length;

  	// If nothing changed with the existing fragments, then we start adding
  	// new fragments at the end...
  	if (firstChange === undefined) {
  		// ...unless there are no new fragments to add
  		if (this.length === newLength) {
  			return;
  		}

  		firstChange = this.length;
  	}

  	this.length = this.fragments.length = newLength;

  	if (this.rendered) {
  		global_runloop.addView(this);
  	}

  	// Prepare new fragment options
  	fragmentOptions = {
  		template: this.template.f,
  		root: this.root,
  		owner: this
  	};

  	// Add as many new fragments as we need to, or add back existing
  	// (detached) fragments
  	for (i = firstChange; i < newLength; i += 1) {
  		fragment = reboundFragments[i];

  		if (!fragment) {
  			this.fragmentsToCreate.push(i);
  		}

  		this.fragments[i] = fragment;
  	}
  }

  function shuffle__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_rebind = function (oldKeypath, newKeypath) {
  	Mustache.rebind.call(this, oldKeypath, newKeypath);
  };

  var Section_prototype_render = Section$render;

  function Section$render() {
  	var _this = this;

  	this.docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (f) {
  		return _this.docFrag.appendChild(f.render());
  	});

  	this.renderedFragments = this.fragments.slice();
  	this.fragmentsToRender = [];

  	this.rendered = true;
  	return this.docFrag;
  }

  var setValue = Section$setValue;

  function Section$setValue(value) {
  	var _this = this;

  	var wrapper, fragmentOptions;

  	if (this.updating) {
  		// If a child of this section causes a re-evaluation - for example, an
  		// expression refers to a function that mutates the array that this
  		// section depends on - we'll end up with a double rendering bug (see
  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.
  		return;
  	}

  	this.updating = true;

  	// with sections, we need to get the fake value if we have a wrapped object
  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  		value = wrapper.get();
  	}

  	// If any fragments are awaiting creation after a splice,
  	// this is the place to do it
  	if (this.fragmentsToCreate.length) {
  		fragmentOptions = {
  			template: this.template.f || [],
  			root: this.root,
  			pElement: this.pElement,
  			owner: this
  		};

  		this.fragmentsToCreate.forEach(function (index) {
  			var fragment;

  			fragmentOptions.context = _this.keypath.join(index);
  			fragmentOptions.index = index;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);
  		});

  		this.fragmentsToCreate.length = 0;
  	} else if (reevaluateSection(this, value)) {
  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}

  	this.value = value;
  	this.updating = false;
  }

  function changeCurrentSubtype(section, value, obj) {
  	if (value === SECTION_EACH) {
  		// make sure ref type is up to date for key or value indices
  		if (section.indexRefs && section.indexRefs[0]) {
  			var ref = section.indexRefs[0];

  			// when switching flavors, make sure the section gets updated
  			if (obj && ref.t === "i" || !obj && ref.t === "k") {
  				// if switching from object to list, unbind all of the old fragments
  				if (!obj) {
  					section.length = 0;
  					section.fragmentsToUnrender = section.fragments.slice(0);
  					section.fragmentsToUnrender.forEach(function (f) {
  						return f.unbind();
  					});
  				}
  			}

  			ref.t = obj ? "k" : "i";
  		}
  	}

  	section.currentSubtype = value;
  }

  function reevaluateSection(section, value) {
  	var fragmentOptions = {
  		template: section.template.f || [],
  		root: section.root,
  		pElement: section.parentFragment.pElement,
  		owner: section
  	};

  	section.hasContext = true;

  	// If we already know the section type, great
  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init
  	// and avoid doing this each time?
  	if (section.subtype) {
  		switch (section.subtype) {
  			case SECTION_IF:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, false, fragmentOptions);

  			case SECTION_UNLESS:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, true, fragmentOptions);

  			case SECTION_WITH:
  				return reevaluateContextSection(section, fragmentOptions);

  			case SECTION_IF_WITH:
  				return reevaluateConditionalContextSection(section, value, fragmentOptions);

  			case SECTION_EACH:
  				if (isObject(value)) {
  					changeCurrentSubtype(section, section.subtype, true);
  					return reevaluateListObjectSection(section, value, fragmentOptions);
  				}

  				// Fallthrough - if it's a conditional or an array we need to continue
  		}
  	}

  	// Otherwise we need to work out what sort of section we're dealing with
  	section.ordered = !!isArrayLike(value);

  	// Ordered list section
  	if (section.ordered) {
  		changeCurrentSubtype(section, SECTION_EACH, false);
  		return reevaluateListSection(section, value, fragmentOptions);
  	}

  	// Unordered list, or context
  	if (isObject(value) || typeof value === "function") {
  		// Index reference indicates section should be treated as a list
  		if (section.template.i) {
  			changeCurrentSubtype(section, SECTION_EACH, true);
  			return reevaluateListObjectSection(section, value, fragmentOptions);
  		}

  		// Otherwise, object provides context for contents
  		changeCurrentSubtype(section, SECTION_WITH, false);
  		return reevaluateContextSection(section, fragmentOptions);
  	}

  	// Conditional section
  	changeCurrentSubtype(section, SECTION_IF, false);
  	section.hasContext = false;
  	return reevaluateConditionalSection(section, value, false, fragmentOptions);
  }

  function reevaluateListSection(section, value, fragmentOptions) {
  	var i, length, fragment;

  	length = value.length;

  	if (length === section.length) {
  		// Nothing to do
  		return false;
  	}

  	// if the array is shorter than it was previously, remove items
  	if (length < section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  	}

  	// otherwise...
  	else {
  		if (length > section.length) {
  			// add any new ones
  			for (i = section.length; i < length; i += 1) {
  				// append list item to context stack
  				fragmentOptions.context = section.keypath.join(i);
  				fragmentOptions.index = i;

  				fragment = new virtualdom_Fragment(fragmentOptions);
  				section.fragmentsToRender.push(section.fragments[i] = fragment);
  			}
  		}
  	}

  	section.length = length;
  	return true;
  }

  function reevaluateListObjectSection(section, value, fragmentOptions) {
  	var id, i, hasKey, fragment, changed, deps;

  	hasKey = section.hasKey || (section.hasKey = {});

  	// remove any fragments that should no longer exist
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (!(fragment.key in value)) {
  			changed = true;

  			fragment.unbind();
  			section.fragmentsToUnrender.push(fragment);
  			section.fragments.splice(i, 1);

  			hasKey[fragment.key] = false;
  		}
  	}

  	// notify any dependents about changed indices
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (fragment.index !== i) {
  			fragment.index = i;
  			if (deps = fragment.registeredIndexRefs) {
  				deps.forEach(setValue__blindRebind);
  			}
  		}
  	}

  	// add any that haven't been created yet
  	i = section.fragments.length;
  	for (id in value) {
  		if (!hasKey[id]) {
  			changed = true;

  			fragmentOptions.context = section.keypath.join(id);
  			fragmentOptions.key = id;
  			fragmentOptions.index = i++;

  			fragment = new virtualdom_Fragment(fragmentOptions);

  			section.fragmentsToRender.push(fragment);
  			section.fragments.push(fragment);
  			hasKey[id] = true;
  		}
  	}

  	section.length = section.fragments.length;
  	return changed;
  }

  function reevaluateConditionalContextSection(section, value, fragmentOptions) {
  	if (value) {
  		return reevaluateContextSection(section, fragmentOptions);
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function reevaluateContextSection(section, fragmentOptions) {
  	var fragment;

  	// ...then if it isn't rendered, render it, adding section.keypath to the context stack
  	// (if it is already rendered, then any children dependent on the context stack
  	// will update themselves without any prompting)
  	if (!section.length) {
  		// append this section to the context stack
  		fragmentOptions.context = section.keypath;
  		fragmentOptions.index = 0;

  		fragment = new virtualdom_Fragment(fragmentOptions);

  		section.fragmentsToRender.push(section.fragments[0] = fragment);
  		section.length = 1;

  		return true;
  	}
  }

  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {
  	var doRender, emptyArray, emptyObject, fragment, name;

  	emptyArray = isArrayLike(value) && value.length === 0;
  	emptyObject = false;
  	if (!isArrayLike(value) && isObject(value)) {
  		emptyObject = true;
  		for (name in value) {
  			emptyObject = false;
  			break;
  		}
  	}

  	if (inverted) {
  		doRender = emptyArray || emptyObject || !value;
  	} else {
  		doRender = value && !emptyArray && !emptyObject;
  	}

  	if (doRender) {
  		if (!section.length) {
  			// no change to context stack
  			fragmentOptions.index = 0;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			section.fragmentsToRender.push(section.fragments[0] = fragment);
  			section.length = 1;

  			return true;
  		}

  		if (section.length > 1) {
  			section.fragmentsToUnrender = section.fragments.splice(1);
  			section.fragmentsToUnrender.forEach(methodCallers__unbind);

  			return true;
  		}
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function removeSectionFragments(section) {
  	if (section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  		section.length = section.fragmentsToRender.length = 0;
  		return true;
  	}
  }

  function isRendered(fragment) {
  	return fragment.rendered;
  }

  function setValue__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_toString = Section$toString;

  function Section$toString(escape) {
  	var str, i, len;

  	str = "";

  	i = 0;
  	len = this.length;

  	for (i = 0; i < len; i += 1) {
  		str += this.fragments[i].toString(escape);
  	}

  	return str;
  }

  var prototype_unbind = Section$unbind;
  function Section$unbind() {
  	var _this = this;

  	this.fragments.forEach(methodCallers__unbind);
  	this.fragmentsToRender.forEach(function (f) {
  		return removeFromArray(_this.fragments, f);
  	});
  	this.fragmentsToRender = [];
  	shared_unbind.call(this);

  	this.length = 0;
  	this.unbound = true;
  }

  var prototype_unrender = Section$unrender;

  function Section$unrender(shouldDestroy) {
  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);
  	this.renderedFragments = [];
  	this.rendered = false;
  }

  function unrenderAndDestroy(fragment) {
  	fragment.unrender(true);
  }

  function prototype_unrender__unrender(fragment) {
  	fragment.unrender(false);
  }

  var prototype_update = Section$update;

  function Section$update() {
  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;

  	// `this.renderedFragments` is in the order of the previous render.
  	// If fragments have shuffled about, this allows us to quickly
  	// reinsert them in the correct place
  	renderedFragments = this.renderedFragments;

  	// Remove fragments that have been marked for destruction
  	while (fragment = this.fragmentsToUnrender.pop()) {
  		fragment.unrender(true);
  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);
  	}

  	// Render new fragments (but don't insert them yet)
  	while (fragment = this.fragmentsToRender.shift()) {
  		fragment.render();
  	}

  	if (this.rendered) {
  		target = this.parentFragment.getNode();
  	}

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		fragment = this.fragments[i];
  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher

  		if (renderIndex === i) {
  			// already in the right place. insert accumulated nodes (if any) and carry on
  			if (this.docFrag.childNodes.length) {
  				anchor = fragment.firstNode();
  				target.insertBefore(this.docFrag, anchor);
  			}

  			continue;
  		}

  		this.docFrag.appendChild(fragment.detach());

  		// update renderedFragments
  		if (renderIndex !== -1) {
  			renderedFragments.splice(renderIndex, 1);
  		}
  		renderedFragments.splice(i, 0, fragment);
  	}

  	if (this.rendered && this.docFrag.childNodes.length) {
  		anchor = this.parentFragment.findNextNode(this);
  		target.insertBefore(this.docFrag, anchor);
  	}

  	// Save the rendering order for next time
  	this.renderedFragments = this.fragments.slice();
  }

  var Section = function (options) {
  	this.type = SECTION;
  	this.subtype = this.currentSubtype = options.template.n;
  	this.inverted = this.subtype === SECTION_UNLESS;

  	this.pElement = options.pElement;

  	this.fragments = [];
  	this.fragmentsToCreate = [];
  	this.fragmentsToRender = [];
  	this.fragmentsToUnrender = [];

  	if (options.template.i) {
  		this.indexRefs = options.template.i.split(",").map(function (k, i) {
  			return { n: k, t: i === 0 ? "k" : "i" };
  		});
  	}

  	this.renderedFragments = [];

  	this.length = 0; // number of times this section is rendered

  	Mustache.init(this, options);
  };

  Section.prototype = {
  	bubble: Section_prototype_bubble,
  	detach: Section_prototype_detach,
  	find: find,
  	findAll: findAll,
  	findAllComponents: findAllComponents,
  	findComponent: findComponent,
  	findNextNode: findNextNode,
  	firstNode: firstNode,
  	getIndexRef: function (name) {
  		if (this.indexRefs) {
  			var i = this.indexRefs.length;
  			while (i--) {
  				var ref = this.indexRefs[i];
  				if (ref.n === name) {
  					return ref;
  				}
  			}
  		}
  	},
  	getValue: Mustache.getValue,
  	shuffle: shuffle,
  	rebind: prototype_rebind,
  	render: Section_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: setValue,
  	toString: prototype_toString,
  	unbind: prototype_unbind,
  	unrender: prototype_unrender,
  	update: prototype_update
  };

  var _Section = Section;

  var Triple_prototype_detach = Triple$detach;

  function Triple$detach() {
  	var len, i;

  	if (this.docFrag) {
  		len = this.nodes.length;
  		for (i = 0; i < len; i += 1) {
  			this.docFrag.appendChild(this.nodes[i]);
  		}

  		return this.docFrag;
  	}
  }

  var Triple_prototype_find = Triple$find;
  function Triple$find(selector) {
  	var i, len, node, queryResult;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			return node;
  		}

  		if (queryResult = node.querySelector(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var Triple_prototype_findAll = Triple$findAll;
  function Triple$findAll(selector, queryResult) {
  	var i, len, node, queryAllResult, numNodes, j;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			queryResult.push(node);
  		}

  		if (queryAllResult = node.querySelectorAll(selector)) {
  			numNodes = queryAllResult.length;
  			for (j = 0; j < numNodes; j += 1) {
  				queryResult.push(queryAllResult[j]);
  			}
  		}
  	}
  }

  var Triple_prototype_firstNode = Triple$firstNode;

  function Triple$firstNode() {
  	if (this.rendered && this.nodes[0]) {
  		return this.nodes[0];
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var elementCache = {},
      ieBug,
      ieBlacklist;

  try {
  	createElement("table").innerHTML = "foo";
  } catch (err) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE: ["<table class=\"x\">", "</table>"],
  		THEAD: ["<table><thead class=\"x\">", "</thead></table>"],
  		TBODY: ["<table><tbody class=\"x\">", "</tbody></table>"],
  		TR: ["<table><tr class=\"x\">", "</tr></table>"],
  		SELECT: ["<select class=\"x\">", "</select>"]
  	};
  }

  var insertHtml = function (html, node, docFrag) {
  	var container,
  	    nodes = [],
  	    wrapper,
  	    selectedOption,
  	    child,
  	    i;

  	// render 0 and false
  	if (html != null && html !== "") {
  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
  			container = element("DIV");
  			container.innerHTML = wrapper[0] + html + wrapper[1];
  			container = container.querySelector(".x");

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		} else if (node.namespaceURI === namespaces.svg) {
  			container = element("DIV");
  			container.innerHTML = "<svg class=\"x\">" + html + "</svg>";
  			container = container.querySelector(".x");
  		} else {
  			container = element(node.tagName);
  			container.innerHTML = html;

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		}

  		while (child = container.firstChild) {
  			nodes.push(child);
  			docFrag.appendChild(child);
  		}

  		// This is really annoying. Extracting <option> nodes from the
  		// temporary container <select> causes the remaining ones to
  		// become selected. So now we have to deselect them. IE8, you
  		// amaze me. You really do
  		// ...and now Chrome too
  		if (node.tagName === "SELECT") {
  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] !== selectedOption) {
  					nodes[i].selected = false;
  				}
  			}
  		}
  	}

  	return nodes;
  };

  function element(tagName) {
  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
  }

  var helpers_updateSelect = updateSelect;

  function updateSelect(parentElement) {
  	var selectedOptions, option, value;

  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {
  		return;
  	}

  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);

  	// If one of them had a `selected` attribute, we need to sync
  	// the model to the view
  	if (parentElement.getAttribute("multiple")) {
  		value = selectedOptions.map(function (o) {
  			return o.value;
  		});
  	} else if (option = selectedOptions[0]) {
  		value = option.value;
  	}

  	if (value !== undefined) {
  		parentElement.binding.setValue(value);
  	}

  	parentElement.bubble();
  }

  function isSelected(option) {
  	return option.selected;
  }

  var Triple_prototype_render = Triple$render;
  function Triple$render() {
  	if (this.rendered) {
  		throw new Error("Attempted to render an item that was already rendered");
  	}

  	this.docFrag = document.createDocumentFragment();
  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);

  	this.rendered = true;
  	return this.docFrag;
  }

  var prototype_setValue = Triple$setValue;
  function Triple$setValue(value) {
  	var wrapper;

  	// TODO is there a better way to approach this?
  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {
  		value = wrapper.get();
  	}

  	if (value !== this.value) {
  		this.value = value;
  		this.parentFragment.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var Triple_prototype_toString = Triple$toString;
  function Triple$toString() {
  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";
  }

  var Triple_prototype_unrender = Triple$unrender;
  function Triple$unrender(shouldDestroy) {
  	if (this.rendered && shouldDestroy) {
  		this.nodes.forEach(detachNode);
  		this.rendered = false;
  	}

  	// TODO update live queries
  }

  var Triple_prototype_update = Triple$update;
  function Triple$update() {
  	var node, parentNode;

  	if (!this.rendered) {
  		return;
  	}

  	// Remove existing nodes
  	while (this.nodes && this.nodes.length) {
  		node = this.nodes.pop();
  		node.parentNode.removeChild(node);
  	}

  	// Insert new nodes
  	parentNode = this.parentFragment.getNode();

  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);
  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);
  }

  var Triple = function (options) {
  	this.type = TRIPLE;
  	Mustache.init(this, options);
  };

  Triple.prototype = {
  	detach: Triple_prototype_detach,
  	find: Triple_prototype_find,
  	findAll: Triple_prototype_findAll,
  	firstNode: Triple_prototype_firstNode,
  	getValue: Mustache.getValue,
  	rebind: Mustache.rebind,
  	render: Triple_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: prototype_setValue,
  	toString: Triple_prototype_toString,
  	unbind: shared_unbind,
  	unrender: Triple_prototype_unrender,
  	update: Triple_prototype_update
  };

  var _Triple = Triple;

  var Element_prototype_bubble = function () {
  	this.parentFragment.bubble();
  };

  var Element_prototype_detach = Element$detach;

  function Element$detach() {
  	var node = this.node,
  	    parentNode;

  	if (node) {
  		// need to check for parent node - DOM may have been altered
  		// by something other than Ractive! e.g. jQuery UI...
  		if (parentNode = node.parentNode) {
  			parentNode.removeChild(node);
  		}

  		return node;
  	}
  }

  var Element_prototype_find = function (selector) {
  	if (!this.node) {
  		// this element hasn't been rendered yet
  		return null;
  	}

  	if (matches(this.node, selector)) {
  		return this.node;
  	}

  	if (this.fragment && this.fragment.find) {
  		return this.fragment.find(selector);
  	}
  };

  var Element_prototype_findAll = function (selector, query) {
  	// Add this node to the query, if applicable, and register the
  	// query on this element
  	if (query._test(this, true) && query.live) {
  		(this.liveQueries || (this.liveQueries = [])).push(query);
  	}

  	if (this.fragment) {
  		this.fragment.findAll(selector, query);
  	}
  };

  var Element_prototype_findAllComponents = function (selector, query) {
  	if (this.fragment) {
  		this.fragment.findAllComponents(selector, query);
  	}
  };

  var Element_prototype_findComponent = function (selector) {
  	if (this.fragment) {
  		return this.fragment.findComponent(selector);
  	}
  };

  var Element_prototype_findNextNode = Element$findNextNode;

  function Element$findNextNode() {
  	return null;
  }

  var Element_prototype_firstNode = Element$firstNode;

  function Element$firstNode() {
  	return this.node;
  }

  var getAttribute = Element$getAttribute;

  function Element$getAttribute(name) {
  	if (!this.attributes || !this.attributes[name]) {
  		return;
  	}

  	return this.attributes[name].value;
  }

  var truthy = /^true|on|yes|1$/i;
  var processBindingAttributes__isNumeric = /^[0-9]+$/;

  var processBindingAttributes = function (element, template) {
  	var val, attrs, attributes;

  	attributes = template.a || {};
  	attrs = {};

  	// attributes that are present but don't have a value (=)
  	// will be set to the number 0, which we condider to be true
  	// the string '0', however is false

  	val = attributes.twoway;
  	if (val !== undefined) {
  		attrs.twoway = val === 0 || truthy.test(val);
  	}

  	val = attributes.lazy;
  	if (val !== undefined) {
  		// check for timeout value
  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {
  			attrs.lazy = parseInt(val);
  		} else {
  			attrs.lazy = val === 0 || truthy.test(val);
  		}
  	}

  	return attrs;
  };

  var Attribute_prototype_bubble = Attribute$bubble;
  function Attribute$bubble() {
  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();

  	// TODO this can register the attribute multiple times (see render test
  	// 'Attribute with nested mustaches')
  	if (!isEqual(value, this.value)) {

  		// Need to clear old id from ractive.nodes
  		if (this.name === "id" && this.value) {
  			delete this.root.nodes[this.value];
  		}

  		this.value = value;

  		if (this.name === "value" && this.node) {
  			// We need to store the value on the DOM like this so we
  			// can retrieve it later without it being coerced to a string
  			this.node._ractive.value = value;
  		}

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");
  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");

  createMap = function (items) {
  	var map = {},
  	    i = items.length;
  	while (i--) {
  		map[items[i].toLowerCase()] = items[i];
  	}
  	return map;
  };

  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));

  var enforceCase = function (elementName) {
  	var lowerCaseElementName = elementName.toLowerCase();
  	return map[lowerCaseElementName] || lowerCaseElementName;
  };

  var determineNameAndNamespace = function (attribute, name) {
  	var colonIndex, namespacePrefix;

  	// are we dealing with a namespaced attribute, e.g. xlink:href?
  	colonIndex = name.indexOf(":");
  	if (colonIndex !== -1) {

  		// looks like we are, yes...
  		namespacePrefix = name.substr(0, colonIndex);

  		// ...unless it's a namespace *declaration*, which we ignore (on the assumption
  		// that only valid namespaces will be used)
  		if (namespacePrefix !== "xmlns") {
  			name = name.substring(colonIndex + 1);

  			attribute.name = enforceCase(name);
  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];
  			attribute.namespacePrefix = namespacePrefix;

  			if (!attribute.namespace) {
  				throw "Unknown namespace (\"" + namespacePrefix + "\")";
  			}

  			return;
  		}
  	}

  	// SVG attribute names are case sensitive
  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;
  };

  var helpers_getInterpolator = getInterpolator;
  function getInterpolator(attribute) {
  	var items = attribute.fragment.items;

  	if (items.length !== 1) {
  		return;
  	}

  	if (items[0].type === INTERPOLATOR) {
  		return items[0];
  	}
  }

  var prototype_init = Attribute$init;
  function Attribute$init(options) {
  	this.type = ATTRIBUTE;
  	this.element = options.element;
  	this.root = options.root;

  	determineNameAndNamespace(this, options.name);
  	this.isBoolean = booleanAttributes.test(this.name);

  	// if it's an empty attribute, or just a straight key-value pair, with no
  	// mustache shenanigans, set the attribute accordingly and go home
  	if (!options.value || typeof options.value === "string") {
  		this.value = this.isBoolean ? true : options.value || "";
  		return;
  	}

  	// otherwise we need to do some work

  	// share parentFragment with parent element
  	this.parentFragment = this.element.parentFragment;

  	this.fragment = new virtualdom_Fragment({
  		template: options.value,
  		root: this.root,
  		owner: this
  	});

  	// TODO can we use this.fragment.toString() in some cases? It's quicker
  	this.value = this.fragment.getValue();

  	// Store a reference to this attribute's interpolator, if its fragment
  	// takes the form `{{foo}}`. This is necessary for two-way binding and
  	// for correctly rendering HTML later
  	this.interpolator = helpers_getInterpolator(this);
  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;

  	// mark as ready
  	this.ready = true;
  }

  var Attribute_prototype_rebind = Attribute$rebind;

  function Attribute$rebind(oldKeypath, newKeypath) {
  	if (this.fragment) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	}
  }

  var Attribute_prototype_render = Attribute$render;
  var propertyNames = {
  	"accept-charset": "acceptCharset",
  	accesskey: "accessKey",
  	bgcolor: "bgColor",
  	"class": "className",
  	codebase: "codeBase",
  	colspan: "colSpan",
  	contenteditable: "contentEditable",
  	datetime: "dateTime",
  	dirname: "dirName",
  	"for": "htmlFor",
  	"http-equiv": "httpEquiv",
  	ismap: "isMap",
  	maxlength: "maxLength",
  	novalidate: "noValidate",
  	pubdate: "pubDate",
  	readonly: "readOnly",
  	rowspan: "rowSpan",
  	tabindex: "tabIndex",
  	usemap: "useMap"
  };
  function Attribute$render(node) {
  	var propertyName;

  	this.node = node;

  	// should we use direct property access, or setAttribute?
  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
  		propertyName = propertyNames[this.name] || this.name;

  		if (node[propertyName] !== undefined) {
  			this.propertyName = propertyName;
  		}

  		// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  		// node.selected = true rather than node.setAttribute( 'selected', '' )
  		if (this.isBoolean || this.isTwoway) {
  			this.useProperty = true;
  		}

  		if (propertyName === "value") {
  			node._ractive.value = this.value;
  		}
  	}

  	this.rendered = true;
  	this.update();
  }

  var Attribute_prototype_toString = Attribute$toString;

  function Attribute$toString() {
  	var _ref = this;

  	var name = _ref.name;
  	var namespacePrefix = _ref.namespacePrefix;
  	var value = _ref.value;
  	var interpolator = _ref.interpolator;
  	var fragment = _ref.fragment;

  	// Special case - select and textarea values (should not be stringified)
  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {
  		return;
  	}

  	// Special case - content editable
  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {
  		return;
  	}

  	// Special case - radio names
  	if (name === "name" && this.element.name === "input" && interpolator) {
  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";
  	}

  	// Boolean attributes
  	if (this.isBoolean) {
  		return value ? name : "";
  	}

  	if (fragment) {
  		// special case - this catches undefined/null values (#1211)
  		if (fragment.items.length === 1 && fragment.items[0].value == null) {
  			return "";
  		}

  		value = fragment.toString();
  	}

  	if (namespacePrefix) {
  		name = namespacePrefix + ":" + name;
  	}

  	return value ? name + "=\"" + Attribute_prototype_toString__escape(value) + "\"" : name;
  }

  function Attribute_prototype_toString__escape(value) {
  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }

  var Attribute_prototype_unbind = Attribute$unbind;

  function Attribute$unbind() {
  	// ignore non-dynamic attributes
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.name === "id") {
  		delete this.root.nodes[this.value];
  	}
  }

  var updateSelectValue = Attribute$updateSelect;

  function Attribute$updateSelect() {
  	var value = this.value,
  	    options,
  	    option,
  	    optionValue,
  	    i;

  	if (!this.locked) {
  		this.node._ractive.value = value;

  		options = this.node.options;
  		i = options.length;

  		while (i--) {
  			option = options[i];
  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

  			if (optionValue == value) {
  				// double equals as we may be comparing numbers with strings
  				option.selected = true;
  				break;
  			}
  		}
  	}

  	// if we're still here, it means the new value didn't match any of the options...
  	// TODO figure out what to do in this situation
  }

  var updateMultipleSelectValue = Attribute$updateMultipleSelect;
  function Attribute$updateMultipleSelect() {
  	var value = this.value,
  	    options,
  	    i,
  	    option,
  	    optionValue;

  	if (!isArray(value)) {
  		value = [value];
  	}

  	options = this.node.options;
  	i = options.length;

  	while (i--) {
  		option = options[i];
  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
  		option.selected = arrayContains(value, optionValue);
  	}
  }

  var updateRadioName = Attribute$updateRadioName;

  function Attribute$updateRadioName() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	node.checked = value == node._ractive.value;
  }

  var updateRadioValue = Attribute$updateRadioValue;
  function Attribute$updateRadioValue() {
  	var wasChecked,
  	    node = this.node,
  	    binding,
  	    bindings,
  	    i;

  	wasChecked = node.checked;

  	node.value = this.element.getAttribute("value");
  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if (wasChecked && !node.checked && this.element.binding) {
  		bindings = this.element.binding.siblings;

  		if (i = bindings.length) {
  			while (i--) {
  				binding = bindings[i];

  				if (!binding.element.node) {
  					// this is the initial render, siblings are still rendering!
  					// we'll come back later...
  					return;
  				}

  				if (binding.element.node.checked) {
  					global_runloop.addRactive(binding.root);
  					return binding.handleChange();
  				}
  			}

  			this.root.viewmodel.set(binding.keypath, undefined);
  		}
  	}
  }

  var updateCheckboxName = Attribute$updateCheckboxName;
  function Attribute$updateCheckboxName() {
  	var _ref = this;

  	var element = _ref.element;
  	var node = _ref.node;
  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;

  	valueAttribute = element.getAttribute("value");

  	if (!isArray(value)) {
  		binding.isChecked = node.checked = value == valueAttribute;
  	} else {
  		i = value.length;
  		while (i--) {
  			if (valueAttribute == value[i]) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  var updateClassName = Attribute$updateClassName;
  function Attribute$updateClassName() {
  	this.node.className = safeToStringValue(this.value);
  }

  var updateIdAttribute = Attribute$updateIdAttribute;

  function Attribute$updateIdAttribute() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	this.root.nodes[value] = node;
  	node.id = value;
  }

  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;

  function Attribute$updateIEStyleAttribute() {
  	var node, value;

  	node = this.node;
  	value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	node.style.setAttribute("cssText", value);
  }

  var updateContentEditableValue = Attribute$updateContentEditableValue;

  function Attribute$updateContentEditableValue() {
  	var value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	if (!this.locked) {
  		this.node.innerHTML = value;
  	}
  }

  var updateValue = Attribute$updateValue;

  function Attribute$updateValue() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	// store actual value, so it doesn't get coerced to a string
  	node._ractive.value = value;

  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		node.value = value == undefined ? "" : value;
  	}
  }

  var updateBoolean = Attribute$updateBooleanAttribute;

  function Attribute$updateBooleanAttribute() {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		this.node[this.propertyName] = this.value;
  	}
  }

  var updateEverythingElse = Attribute$updateEverythingElse;

  function Attribute$updateEverythingElse() {
  	var _ref = this;

  	var node = _ref.node;
  	var namespace = _ref.namespace;
  	var name = _ref.name;
  	var value = _ref.value;
  	var fragment = _ref.fragment;

  	if (namespace) {
  		node.setAttributeNS(namespace, name, (fragment || value).toString());
  	} else if (!this.isBoolean) {
  		if (value == null) {
  			node.removeAttribute(name);
  		} else {
  			node.setAttribute(name, (fragment || value).toString());
  		}
  	}

  	// Boolean attributes - truthy becomes '', falsy means 'remove attribute'
  	else {
  		if (value) {
  			node.setAttribute(name, "");
  		} else {
  			node.removeAttribute(name);
  		}
  	}
  }

  // There are a few special cases when it comes to updating attributes. For this reason,
  // the prototype .update() method points to this method, which waits until the
  // attribute has finished initialising, then replaces the prototype method with a more
  // suitable one. That way, we save ourselves doing a bunch of tests on each call
  var Attribute_prototype_update = Attribute$update;
  function Attribute$update() {
  	var _ref = this;

  	var name = _ref.name;
  	var element = _ref.element;
  	var node = _ref.node;var type;var updateMethod;

  	if (name === "id") {
  		updateMethod = updateIdAttribute;
  	} else if (name === "value") {
  		// special case - selects
  		if (element.name === "select" && name === "value") {
  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;
  		} else if (element.name === "textarea") {
  			updateMethod = updateValue;
  		}

  		// special case - contenteditable
  		else if (element.getAttribute("contenteditable") != null) {
  			updateMethod = updateContentEditableValue;
  		}

  		// special case - <input>
  		else if (element.name === "input") {
  			type = element.getAttribute("type");

  			// type='file' value='{{fileList}}'>
  			if (type === "file") {
  				updateMethod = noop; // read-only
  			}

  			// type='radio' name='{{twoway}}'
  			else if (type === "radio" && element.binding && element.binding.name === "name") {
  				updateMethod = updateRadioValue;
  			} else {
  				updateMethod = updateValue;
  			}
  		}
  	}

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	else if (this.isTwoway && name === "name") {
  		if (node.type === "radio") {
  			updateMethod = updateRadioName;
  		} else if (node.type === "checkbox") {
  			updateMethod = updateCheckboxName;
  		}
  	}

  	// special case - style attributes in Internet Exploder
  	else if (name === "style" && node.style.setAttribute) {
  		updateMethod = updateIEStyleAttribute;
  	}

  	// special case - class names. IE fucks things up, again
  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {
  		updateMethod = updateClassName;
  	} else if (this.useProperty) {
  		updateMethod = updateBoolean;
  	}

  	if (!updateMethod) {
  		updateMethod = updateEverythingElse;
  	}

  	this.update = updateMethod;
  	this.update();
  }

  var Attribute = function (options) {
  	this.init(options);
  };

  Attribute.prototype = {
  	bubble: Attribute_prototype_bubble,
  	init: prototype_init,
  	rebind: Attribute_prototype_rebind,
  	render: Attribute_prototype_render,
  	toString: Attribute_prototype_toString,
  	unbind: Attribute_prototype_unbind,
  	update: Attribute_prototype_update
  };

  var _Attribute = Attribute;

  var createAttributes = function (element, attributes) {
  	var name,
  	    attribute,
  	    result = [];

  	for (name in attributes) {
  		// skip binding attributes
  		if (name === "twoway" || name === "lazy") {
  			continue;
  		}

  		if (attributes.hasOwnProperty(name)) {
  			attribute = new _Attribute({
  				element: element,
  				name: name,
  				value: attributes[name],
  				root: element.root
  			});

  			result[name] = attribute;

  			if (name !== "value") {
  				result.push(attribute);
  			}
  		}
  	}

  	// value attribute goes last. This is because it
  	// may get clamped on render otherwise, e.g. in
  	// `<input type='range' value='999' min='0' max='1000'>`
  	// since default max is 100
  	if (attribute = result.value) {
  		result.push(attribute);
  	}

  	return result;
  };

  var _ConditionalAttribute__div;

  if (typeof document !== "undefined") {
  	_ConditionalAttribute__div = createElement("div");
  }

  var ConditionalAttribute = function (element, template) {
  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;

  	this.attributes = [];

  	this.fragment = new virtualdom_Fragment({
  		root: element.root,
  		owner: this,
  		template: [template]
  	});
  };

  ConditionalAttribute.prototype = {
  	bubble: function () {
  		if (this.node) {
  			this.update();
  		}

  		this.element.bubble();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	render: function (node) {
  		this.node = node;
  		this.isSvg = node.namespaceURI === namespaces.svg;

  		this.update();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	update: function () {
  		var _this = this;

  		var str, attrs;

  		str = this.fragment.toString();
  		attrs = parseAttributes(str, this.isSvg);

  		// any attributes that previously existed but no longer do
  		// must be removed
  		this.attributes.filter(function (a) {
  			return notIn(attrs, a);
  		}).forEach(function (a) {
  			_this.node.removeAttribute(a.name);
  		});

  		attrs.forEach(function (a) {
  			_this.node.setAttribute(a.name, a.value);
  		});

  		this.attributes = attrs;
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var _ConditionalAttribute = ConditionalAttribute;

  function parseAttributes(str, isSvg) {
  	var tag = isSvg ? "svg" : "div";
  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";

  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);
  }

  function notIn(haystack, needle) {
  	var i = haystack.length;

  	while (i--) {
  		if (haystack[i].name === needle.name) {
  			return false;
  		}
  	}

  	return true;
  }

  var createConditionalAttributes = function (element, attributes) {
  	if (!attributes) {
  		return [];
  	}

  	return attributes.map(function (a) {
  		return new _ConditionalAttribute(element, a);
  	});
  };

  var Binding = function (element) {
  	var interpolator, keypath, value, parentForm;

  	this.element = element;
  	this.root = element.root;
  	this.attribute = element.attributes[this.name || "value"];

  	interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	if (keypath = interpolator.keypath) {
  		if (keypath.str.slice(-1) === "}") {
  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });
  			return false;
  		}

  		if (keypath.isSpecial) {
  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });
  			return false;
  		}
  	} else {
  		// A mustache may be *ambiguous*. Let's say we were given
  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
  		// *wasn't* `undefined`, the keypath would be `foo.bar`.
  		// Then, any user input would result in `foo.bar` being updated.
  		//
  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
  		// left with an unresolved partial keypath - so we are forced to make an
  		// assumption. That assumption is that the input in question should
  		// be forced to resolve to `bar`, and any user input would affect `bar`
  		// and not `foo.bar`.
  		//
  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
  		// be explicit when using two-way data-binding about what keypath you're
  		// updating. Using it in lists is probably a recipe for confusion...
  		var ref = interpolator.template.r ? "'" + interpolator.template.r + "' reference" : "expression";
  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });
  		interpolator.resolver.forceResolution();
  		keypath = interpolator.keypath;
  	}

  	this.attribute.isTwoway = true;
  	this.keypath = keypath;

  	// initialise value, if it's undefined
  	value = this.root.viewmodel.get(keypath);

  	if (value === undefined && this.getInitialValue) {
  		value = this.getInitialValue();

  		if (value !== undefined) {
  			this.root.viewmodel.set(keypath, value);
  		}
  	}

  	if (parentForm = findParentForm(element)) {
  		this.resetValue = value;
  		parentForm.formBindings.push(this);
  	}
  };

  Binding.prototype = {
  	handleChange: function () {
  		var _this = this;

  		global_runloop.start(this.root);
  		this.attribute.locked = true;
  		this.root.viewmodel.set(this.keypath, this.getValue());
  		global_runloop.scheduleTask(function () {
  			return _this.attribute.locked = false;
  		});
  		global_runloop.end();
  	},

  	rebound: function () {
  		var bindings, oldKeypath, newKeypath;

  		oldKeypath = this.keypath;
  		newKeypath = this.attribute.interpolator.keypath;

  		// The attribute this binding is linked to has already done the work
  		if (oldKeypath === newKeypath) {
  			return;
  		}

  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);

  		this.keypath = newKeypath;

  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);
  		bindings.push(this);
  	},

  	unbind: function () {}
  };

  Binding.extend = function (properties) {
  	var Parent = this,
  	    SpecialisedBinding;

  	SpecialisedBinding = function (element) {
  		Binding.call(this, element);

  		if (this.init) {
  			this.init();
  		}
  	};

  	SpecialisedBinding.prototype = create(Parent.prototype);
  	utils_object__extend(SpecialisedBinding.prototype, properties);

  	SpecialisedBinding.extend = Binding.extend;

  	return SpecialisedBinding;
  };

  var Binding_Binding = Binding;

  function findParentForm(element) {
  	while (element = element.parent) {
  		if (element.name === "form") {
  			return element;
  		}
  	}
  }

  // this is called when the element is unbound.
  // Specialised bindings can override it

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  var handleDomEvent = handleChange;

  function handleChange() {
  	this._ractive.binding.handleChange();
  }

  var GenericBinding;

  GenericBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		return "";
  	},

  	getValue: function () {
  		return this.element.node.value;
  	},

  	render: function () {
  		var node = this.element.node,
  		    lazy,
  		    timeout = false;
  		this.rendered = true;

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		lazy = this.root.lazy;
  		if (this.element.lazy === true) {
  			lazy = true;
  		} else if (this.element.lazy === false) {
  			lazy = false;
  		} else if (is__isNumeric(this.element.lazy)) {
  			lazy = false;
  			timeout = +this.element.lazy;
  		} else if (is__isNumeric(lazy || "")) {
  			timeout = +lazy;
  			lazy = false;

  			// make sure the timeout is available to the handler
  			this.element.lazy = timeout;
  		}

  		this.handler = timeout ? handleDelay : handleDomEvent;

  		node.addEventListener("change", handleDomEvent, false);

  		if (!lazy) {
  			node.addEventListener("input", this.handler, false);

  			if (node.attachEvent) {
  				node.addEventListener("keyup", this.handler, false);
  			}
  		}

  		node.addEventListener("blur", handleBlur, false);
  	},

  	unrender: function () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("input", this.handler, false);
  		node.removeEventListener("keyup", this.handler, false);
  		node.removeEventListener("blur", handleBlur, false);
  	}
  });

  var Binding_GenericBinding = GenericBinding;

  function handleBlur() {
  	var value;

  	handleDomEvent.call(this);

  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);
  	this.value = value == undefined ? "" : value;
  }

  function handleDelay() {
  	var binding = this._ractive.binding,
  	    el = this;

  	if (!!binding._timeout) clearTimeout(binding._timeout);

  	binding._timeout = setTimeout(function () {
  		if (binding.rendered) handleDomEvent.call(el);
  		binding._timeout = undefined;
  	}, binding.element.lazy);
  }

  var ContentEditableBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return this.element.fragment ? this.element.fragment.toString() : "";
  	},

  	getValue: function () {
  		return this.element.node.innerHTML;
  	}
  });

  var Binding_ContentEditableBinding = ContentEditableBinding;

  var shared_getSiblings = getSiblings;
  var sets = {};
  function getSiblings(id, group, keypath) {
  	var hash = id + group + keypath;
  	return sets[hash] || (sets[hash] = []);
  }

  var RadioBinding = Binding_Binding.extend({
  	name: "checked",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));
  		this.siblings.push(this);
  	},

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	handleChange: function () {
  		global_runloop.start(this.root);

  		this.siblings.forEach(function (binding) {
  			binding.root.viewmodel.set(binding.keypath, binding.getValue());
  		});

  		global_runloop.end();
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioBinding = RadioBinding;

  var RadioNameBinding = Binding_Binding.extend({
  	name: "name",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);
  		this.siblings.push(this);

  		this.radioName = true; // so that ractive.updateModel() knows what to do with this
  	},

  	getInitialValue: function () {
  		if (this.element.getAttribute("checked")) {
  			return this.element.getAttribute("value");
  		}
  	},

  	render: function () {
  		var node = this.element.node;

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		var node = this.element.node;
  		return node._ractive ? node._ractive.value : node.value;
  	},

  	handleChange: function () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` keypath gets set to its value
  		if (this.element.node.checked) {
  			Binding_Binding.prototype.handleChange.call(this);
  		}
  	},

  	rebound: function (oldKeypath, newKeypath) {
  		var node;

  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);

  		if (node = this.element.node) {
  			node.name = "{{" + this.keypath.str + "}}";
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioNameBinding = RadioNameBinding;

  var CheckboxNameBinding = Binding_Binding.extend({
  	name: "name",

  	getInitialValue: function () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true;
  		return [];
  	},

  	init: function () {
  		var existingValue, bindingValue;

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// siblings, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);
  		this.siblings.push(this);

  		if (this.noInitialValue) {
  			this.siblings.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {
  			existingValue = this.root.viewmodel.get(this.keypath);
  			bindingValue = this.element.getAttribute("value");

  			existingValue.push(bindingValue);
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	},

  	render: function () {
  		var node = this.element.node,
  		    existingValue,
  		    bindingValue;

  		existingValue = this.root.viewmodel.get(this.keypath);
  		bindingValue = this.element.getAttribute("value");

  		if (isArray(existingValue)) {
  			this.isChecked = arrayContains(existingValue, bindingValue);
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.isChecked;

  		node.addEventListener("change", handleDomEvent, false);

  		// in case of IE emergency, bind to click event as well
  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	changed: function () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.element.node.checked;
  		return this.isChecked === wasChecked;
  	},

  	handleChange: function () {
  		this.isChecked = this.element.node.checked;
  		Binding_Binding.prototype.handleChange.call(this);
  	},

  	getValue: function () {
  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);
  	}
  });

  function isChecked(binding) {
  	return binding.isChecked;
  }

  function Binding_CheckboxNameBinding__getValue(binding) {
  	return binding.element.getAttribute("value");
  }

  var Binding_CheckboxNameBinding = CheckboxNameBinding;

  var CheckboxBinding = Binding_Binding.extend({
  	name: "checked",

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	}
  });

  var Binding_CheckboxBinding = CheckboxBinding;

  var SelectBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		var options = this.element.options,
  		    len,
  		    i,
  		    value,
  		    optionWasSelected;

  		if (this.element.getAttribute("value") !== undefined) {
  			return;
  		}

  		i = len = options.length;

  		if (!len) {
  			return;
  		}

  		// take the final selected option...
  		while (i--) {
  			if (options[i].getAttribute("selected")) {
  				value = options[i].getAttribute("value");
  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if (!optionWasSelected) {
  			while (++i < len) {
  				if (!options[i].getAttribute("disabled")) {
  					value = options[i].getAttribute("value");
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		if (value !== undefined) {
  			this.element.attributes.value.value = value;
  		}

  		return value;
  	},

  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	// TODO this method is an anomaly... is it necessary?
  	setValue: function (value) {
  		this.root.viewmodel.set(this.keypath, value);
  	},

  	getValue: function () {
  		var options, i, len, option, optionValue;

  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (options[i].selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				return optionValue;
  			}
  		}
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	}
  });

  var Binding_SelectBinding = SelectBinding;

  var MultipleSelectBinding = Binding_SelectBinding.extend({
  	getInitialValue: function () {
  		return this.element.options.filter(function (option) {
  			return option.getAttribute("selected");
  		}).map(function (option) {
  			return option.getAttribute("value");
  		});
  	},

  	render: function () {
  		var valueFromModel;

  		this.element.node.addEventListener("change", handleDomEvent, false);

  		valueFromModel = this.root.viewmodel.get(this.keypath);

  		if (valueFromModel === undefined) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	setValue: function () {
  		throw new Error("TODO not implemented yet");
  	},

  	getValue: function () {
  		var selectedValues, options, i, len, option, optionValue;

  		selectedValues = [];
  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (option.selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push(optionValue);
  			}
  		}

  		return selectedValues;
  	},

  	handleChange: function () {
  		var attribute, previousValue, value;

  		attribute = this.attribute;
  		previousValue = attribute.value;

  		value = this.getValue();

  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {
  			Binding_SelectBinding.prototype.handleChange.call(this);
  		}

  		return this;
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	},

  	updateModel: function () {
  		if (this.attribute.value === undefined || !this.attribute.value.length) {
  			this.root.viewmodel.set(this.keypath, this.initialValue);
  		}
  	}
  });

  var Binding_MultipleSelectBinding = MultipleSelectBinding;

  var FileListBinding = Binding_Binding.extend({
  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.files;
  	}
  });

  var Binding_FileListBinding = FileListBinding;

  var NumericBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return undefined;
  	},

  	getValue: function () {
  		var value = parseFloat(this.element.node.value);
  		return isNaN(value) ? undefined : value;
  	}
  });

  var init_createTwowayBinding = createTwowayBinding;

  function createTwowayBinding(element) {
  	var attributes = element.attributes,
  	    type,
  	    Binding,
  	    bindName,
  	    bindChecked,
  	    binding;

  	// if this is a late binding, and there's already one, it
  	// needs to be torn down
  	if (element.binding) {
  		element.binding.teardown();
  		element.binding = null;
  	}

  	// contenteditable
  	if (
  	// if the contenteditable attribute is true or is bindable and may thus become true
  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {
  		Binding = Binding_ContentEditableBinding;
  	}

  	// <input>
  	else if (element.name === "input") {
  		type = element.getAttribute("type");

  		if (type === "radio" || type === "checkbox") {
  			bindName = isBindable(attributes.name);
  			bindChecked = isBindable(attributes.checked);

  			// we can either bind the name attribute, or the checked attribute - not both
  			if (bindName && bindChecked) {
  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });
  			}

  			if (bindName) {
  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;
  			} else if (bindChecked) {
  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;
  			}
  		} else if (type === "file" && isBindable(attributes.value)) {
  			Binding = Binding_FileListBinding;
  		} else if (isBindable(attributes.value)) {
  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;
  		}
  	}

  	// <select>
  	else if (element.name === "select" && isBindable(attributes.value)) {
  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;
  	}

  	// <textarea>
  	else if (element.name === "textarea" && isBindable(attributes.value)) {
  		Binding = Binding_GenericBinding;
  	}

  	if (Binding && (binding = new Binding(element)) && binding.keypath) {
  		return binding;
  	}
  }

  function isBindable(attribute) {
  	return attribute && attribute.isBindable;
  }

  // and this element also has a value attribute to bind

  var EventHandler_prototype_bubble = EventHandler$bubble;

  function EventHandler$bubble() {
  	var hasAction = this.getAction();

  	if (hasAction && !this.hasListener) {
  		this.listen();
  	} else if (!hasAction && this.hasListener) {
  		this.unrender();
  	}
  }

  // This function may be overwritten, if the event directive
  // includes parameters
  var EventHandler_prototype_fire = EventHandler$fire;
  function EventHandler$fire(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event });
  }

  var getAction = EventHandler$getAction;

  function EventHandler$getAction() {
  	return this.action.toString().trim();
  }

  var EventHandler_prototype_init = EventHandler$init;

  var eventPattern = /^event(?:\.(.+))?/;
  function EventHandler$init(element, name, template) {
  	var _this = this;

  	var action, refs, ractive;

  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;
  	this.name = name;

  	if (name.indexOf("*") !== -1) {
  		fatal("Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid", element.name, name);
  		this.invalid = true;
  	}

  	if (template.m) {
  		refs = template.a.r;

  		// This is a method call
  		this.method = template.m;
  		this.keypaths = [];
  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);

  		this.parentFragment = element.parentFragment;
  		ractive = this.root;

  		// Create resolvers for each reference
  		this.refResolvers = [];
  		refs.forEach(function (ref, i) {
  			var match = undefined;

  			// special case - the `event` object
  			if (match = eventPattern.exec(ref)) {
  				_this.keypaths[i] = {
  					eventObject: true,
  					refinements: match[1] ? match[1].split(".") : []
  				};
  			} else {
  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  					return _this.resolve(i, keypath);
  				}));
  			}
  		});

  		this.fire = fireMethodCall;
  	} else {
  		// Get action ('foo' in 'on-click='foo')
  		action = template.n || template;
  		if (typeof action !== "string") {
  			action = new virtualdom_Fragment({
  				template: action,
  				root: this.root,
  				owner: this
  			});
  		}

  		this.action = action;

  		// Get parameters
  		if (template.d) {
  			this.dynamicParams = new virtualdom_Fragment({
  				template: template.d,
  				root: this.root,
  				owner: this.element
  			});

  			this.fire = fireEventWithDynamicParams;
  		} else if (template.a) {
  			this.params = template.a;
  			this.fire = fireEventWithParams;
  		}
  	}
  }

  function fireMethodCall(event) {
  	var ractive, values, args;

  	ractive = this.root;

  	if (typeof ractive[this.method] !== "function") {
  		throw new Error("Attempted to call a non-existent method (\"" + this.method + "\")");
  	}

  	values = this.keypaths.map(function (keypath) {
  		var value, len, i;

  		if (keypath === undefined) {
  			// not yet resolved
  			return undefined;
  		}

  		// TODO the refinements stuff would be better handled at parse time
  		if (keypath.eventObject) {
  			value = event;

  			if (len = keypath.refinements.length) {
  				for (i = 0; i < len; i += 1) {
  					value = value[keypath.refinements[i]];
  				}
  			}
  		} else {
  			value = ractive.viewmodel.get(keypath);
  		}

  		return value;
  	});

  	shared_eventStack.enqueue(ractive, event);

  	args = this.fn.apply(null, values);
  	ractive[this.method].apply(ractive, args);

  	shared_eventStack.dequeue(ractive);
  }

  function fireEventWithParams(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });
  }

  function fireEventWithDynamicParams(event) {
  	var args = this.dynamicParams.getArgsList();

  	// need to strip [] from ends if a string!
  	if (typeof args === "string") {
  		args = args.substr(1, args.length - 2);
  	}

  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });
  }

  var shared_genericHandler = genericHandler;
  function genericHandler(event) {
  	var storage,
  	    handler,
  	    indices,
  	    index = {};

  	storage = this._ractive;
  	handler = storage.events[event.type];

  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {
  		index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	handler.fire({
  		node: this,
  		original: event,
  		index: index,
  		keypath: storage.keypath.str,
  		context: storage.root.viewmodel.get(storage.keypath)
  	});
  }

  var listen = EventHandler$listen;

  var customHandlers = {},
      touchEvents = {
  	touchstart: true,
  	touchmove: true,
  	touchend: true,
  	touchcancel: true,
  	//not w3c, but supported in some browsers
  	touchleave: true
  };
  function EventHandler$listen() {
  	var definition,
  	    name = this.name;

  	if (this.invalid) {
  		return;
  	}

  	if (definition = findInViewHierarchy("events", this.root, name)) {
  		this.custom = definition(this.node, getCustomHandler(name));
  	} else {
  		// Looks like we're dealing with a standard DOM event... but let's check
  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {

  			// okay to use touch events if this browser doesn't support them
  			if (!touchEvents[name]) {
  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });
  			}

  			return;
  		}

  		this.node.addEventListener(name, shared_genericHandler, false);
  	}

  	this.hasListener = true;
  }

  function getCustomHandler(name) {
  	if (!customHandlers[name]) {
  		customHandlers[name] = function (event) {
  			var storage = event.node._ractive;

  			event.index = storage.index;
  			event.keypath = storage.keypath.str;
  			event.context = storage.root.viewmodel.get(storage.keypath);

  			storage.events[name].fire(event);
  		};
  	}

  	return customHandlers[name];
  }

  var EventHandler_prototype_rebind = EventHandler$rebind;

  function EventHandler$rebind(oldKeypath, newKeypath) {
  	var fragment;
  	if (this.method) {
  		fragment = this.element.parentFragment;
  		this.refResolvers.forEach(rebind);

  		return;
  	}

  	if (typeof this.action !== "string") {
  		rebind(this.action);
  	}

  	if (this.dynamicParams) {
  		rebind(this.dynamicParams);
  	}

  	function rebind(thing) {
  		thing && thing.rebind(oldKeypath, newKeypath);
  	}
  }

  var EventHandler_prototype_render = EventHandler$render;

  function EventHandler$render() {
  	this.node = this.element.node;
  	// store this on the node itself, so it can be retrieved by a
  	// universal handler
  	this.node._ractive.events[this.name] = this;

  	if (this.method || this.getAction()) {
  		this.listen();
  	}
  }

  var prototype_resolve = EventHandler$resolve;

  function EventHandler$resolve(index, keypath) {
  	this.keypaths[index] = keypath;
  }

  var EventHandler_prototype_unbind = EventHandler$unbind;
  function EventHandler$unbind() {
  	if (this.method) {
  		this.refResolvers.forEach(methodCallers__unbind);
  		return;
  	}

  	// Tear down dynamic name
  	if (typeof this.action !== "string") {
  		this.action.unbind();
  	}

  	// Tear down dynamic parameters
  	if (this.dynamicParams) {
  		this.dynamicParams.unbind();
  	}
  }

  var EventHandler_prototype_unrender = EventHandler$unrender;
  function EventHandler$unrender() {

  	if (this.custom) {
  		this.custom.teardown();
  	} else {
  		this.node.removeEventListener(this.name, shared_genericHandler, false);
  	}

  	this.hasListener = false;
  }

  var EventHandler = function (element, name, template) {
  	this.init(element, name, template);
  };

  EventHandler.prototype = {
  	bubble: EventHandler_prototype_bubble,
  	fire: EventHandler_prototype_fire,
  	getAction: getAction,
  	init: EventHandler_prototype_init,
  	listen: listen,
  	rebind: EventHandler_prototype_rebind,
  	render: EventHandler_prototype_render,
  	resolve: prototype_resolve,
  	unbind: EventHandler_prototype_unbind,
  	unrender: EventHandler_prototype_unrender
  };

  var _EventHandler = EventHandler;

  var createEventHandlers = function (element, template) {
  	var i,
  	    name,
  	    names,
  	    handler,
  	    result = [];

  	for (name in template) {
  		if (template.hasOwnProperty(name)) {
  			names = name.split("-");
  			i = names.length;

  			while (i--) {
  				handler = new _EventHandler(element, names[i], template[name]);
  				result.push(handler);
  			}
  		}
  	}

  	return result;
  };

  var Decorator = function (element, template) {
  	var self = this,
  	    ractive,
  	    name,
  	    fragment;

  	this.element = element;
  	this.root = ractive = element.root;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no decorator
  			return;
  		}
  	}

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = this.fragment.getArgsList();

  		this.fragment.bubble = function () {
  			this.dirtyArgs = this.dirtyValue = true;
  			self.params = this.getArgsList();

  			if (self.ready) {
  				self.update();
  			}
  		};
  	}

  	this.fn = findInViewHierarchy("decorators", ractive, name);

  	if (!this.fn) {
  		fatal(missingPlugin(name, "decorator"));
  	}
  };

  Decorator.prototype = {
  	init: function () {
  		var node, result, args;

  		node = this.element.node;

  		if (this.params) {
  			args = [node].concat(this.params);
  			result = this.fn.apply(this.root, args);
  		} else {
  			result = this.fn.call(this.root, node);
  		}

  		if (!result || !result.teardown) {
  			throw new Error("Decorator definition must return an object with a teardown method");
  		}

  		// TODO does this make sense?
  		this.actual = result;
  		this.ready = true;
  	},

  	update: function () {
  		if (this.actual.update) {
  			this.actual.update.apply(this.root, this.params);
  		} else {
  			this.actual.teardown(true);
  			this.init();
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	teardown: function (updating) {
  		this.torndown = true;
  		if (this.ready) {
  			this.actual.teardown();
  		}

  		if (!updating && this.fragment) {
  			this.fragment.unbind();
  		}
  	}
  };

  var _Decorator = Decorator;

  function select__bubble() {
  	var _this = this;

  	if (!this.dirty) {
  		this.dirty = true;

  		global_runloop.scheduleTask(function () {
  			sync(_this);
  			_this.dirty = false;
  		});
  	}

  	this.parentFragment.bubble(); // default behaviour
  }

  function sync(selectElement) {
  	var selectNode, selectValue, isMultiple, options, optionWasSelected;

  	selectNode = selectElement.node;

  	if (!selectNode) {
  		return;
  	}

  	options = toArray(selectNode.options);

  	selectValue = selectElement.getAttribute("value");
  	isMultiple = selectElement.getAttribute("multiple");

  	// If the <select> has a specified value, that should override
  	// these options
  	if (selectValue !== undefined) {
  		options.forEach(function (o) {
  			var optionValue, shouldSelect;

  			optionValue = o._ractive ? o._ractive.value : o.value;
  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;

  			if (shouldSelect) {
  				optionWasSelected = true;
  			}

  			o.selected = shouldSelect;
  		});

  		if (!optionWasSelected) {
  			if (options[0]) {
  				options[0].selected = true;
  			}

  			if (selectElement.binding) {
  				selectElement.binding.forceUpdate();
  			}
  		}
  	}

  	// Otherwise the value should be initialised according to which
  	// <option> element is selected, if twoway binding is in effect
  	else if (selectElement.binding) {
  		selectElement.binding.forceUpdate();
  	}
  }

  function valueContains(selectValue, optionValue) {
  	var i = selectValue.length;
  	while (i--) {
  		if (selectValue[i] == optionValue) {
  			return true;
  		}
  	}
  }

  function special_option__init(option, template) {
  	option.select = findParentSelect(option.parent);

  	// we might be inside a <datalist> element
  	if (!option.select) {
  		return;
  	}

  	option.select.options.push(option);

  	// If the value attribute is missing, use the element's content
  	if (!template.a) {
  		template.a = {};
  	}

  	// ...as long as it isn't disabled
  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {
  		template.a.value = template.f;
  	}

  	// If there is a `selected` attribute, but the <select>
  	// already has a value, delete it
  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {
  		delete template.a.selected;
  	}
  }

  function special_option__unbind(option) {
  	if (option.select) {
  		removeFromArray(option.select.options, option);
  	}
  }

  function findParentSelect(element) {
  	if (!element) {
  		return;
  	}

  	do {
  		if (element.name === "select") {
  			return element;
  		}
  	} while (element = element.parent);
  }

  var Element_prototype_init = Element$init;
  function Element$init(options) {
  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;

  	this.type = ELEMENT;

  	// stuff we'll need later
  	parentFragment = this.parentFragment = options.parentFragment;
  	template = this.template = options.template;

  	this.parent = options.pElement || parentFragment.pElement;

  	this.root = ractive = parentFragment.root;
  	this.index = options.index;
  	this.key = options.key;

  	this.name = enforceCase(template.e);

  	// Special case - <option> elements
  	if (this.name === "option") {
  		special_option__init(this, template);
  	}

  	// Special case - <select> elements
  	if (this.name === "select") {
  		this.options = [];
  		this.bubble = select__bubble; // TODO this is a kludge
  	}

  	// Special case - <form> elements
  	if (this.name === "form") {
  		this.formBindings = [];
  	}

  	// handle binding attributes first (twoway, lazy)
  	bindingAttrs = processBindingAttributes(this, template);

  	// create attributes
  	this.attributes = createAttributes(this, template.a);
  	this.conditionalAttributes = createConditionalAttributes(this, template.m);

  	// append children, if there are any
  	if (template.f) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.f,
  			root: ractive,
  			owner: this,
  			pElement: this,
  			cssIds: null
  		});
  	}

  	// the element setting should override the ractive setting
  	twoway = ractive.twoway;
  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;

  	this.twoway = twoway;
  	this.lazy = bindingAttrs.lazy;

  	// create twoway binding
  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {
  		this.binding = binding;

  		// register this with the root, so that we can do ractive.updateModel()
  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);
  		bindings.push(binding);
  	}

  	// create event proxies
  	if (template.v) {
  		this.eventHandlers = createEventHandlers(this, template.v);
  	}

  	// create decorator
  	if (template.o) {
  		this.decorator = new _Decorator(this, template.o);
  	}

  	// create transitions
  	this.intro = template.t0 || template.t1;
  	this.outro = template.t0 || template.t2;
  }

  var Element_prototype_rebind = Element$rebind;
  function Element$rebind(oldKeypath, newKeypath) {
  	var i, storage, liveQueries, ractive;

  	if (this.attributes) {
  		this.attributes.forEach(rebind);
  	}

  	if (this.conditionalAttributes) {
  		this.conditionalAttributes.forEach(rebind);
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(rebind);
  	}

  	if (this.decorator) {
  		rebind(this.decorator);
  	}

  	// rebind children
  	if (this.fragment) {
  		rebind(this.fragment);
  	}

  	// Update live queries, if necessary
  	if (liveQueries = this.liveQueries) {
  		ractive = this.root;

  		i = liveQueries.length;
  		while (i--) {
  			liveQueries[i]._makeDirty();
  		}
  	}

  	if (this.node && (storage = this.node._ractive)) {

  		// adjust keypath if needed
  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);
  	}

  	function rebind(thing) {
  		thing.rebind(oldKeypath, newKeypath);
  	}
  }

  function special_img__render(img) {
  	var loadHandler;

  	// if this is an <img>, and we're in a crap browser, we may need to prevent it
  	// from overriding width and height when it loads the src
  	if (img.attributes.width || img.attributes.height) {
  		img.node.addEventListener("load", loadHandler = function () {
  			var width = img.getAttribute("width"),
  			    height = img.getAttribute("height");

  			if (width !== undefined) {
  				img.node.setAttribute("width", width);
  			}

  			if (height !== undefined) {
  				img.node.setAttribute("height", height);
  			}

  			img.node.removeEventListener("load", loadHandler, false);
  		}, false);
  	}
  }

  function form__render(element) {
  	element.node.addEventListener("reset", handleReset, false);
  }

  function form__unrender(element) {
  	element.node.removeEventListener("reset", handleReset, false);
  }

  function handleReset() {
  	var element = this._ractive.proxy;

  	global_runloop.start();
  	element.formBindings.forEach(updateModel);
  	global_runloop.end();
  }

  function updateModel(binding) {
  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);
  }

  var Transition_prototype_init = Transition$init;
  function Transition$init(element, template, isIntro) {
  	var ractive, name, fragment;

  	this.element = element;
  	this.root = ractive = element.root;
  	this.isIntro = isIntro;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no transition
  			return;
  		}
  	}

  	this.name = name;

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		// TODO is there a way to interpret dynamic arguments without all the
  		// 'dependency thrashing'?
  		fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = fragment.getArgsList();
  		fragment.unbind();
  	}

  	this._fn = findInViewHierarchy("transitions", ractive, name);

  	if (!this._fn) {
  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });
  	}
  }

  var camelCase = function (hyphenatedStr) {
  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {
  		return $1.toUpperCase();
  	});
  };

  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;

  if (!isClient) {
  	helpers_prefix__prefix = null;
  } else {
  	prefixCache = {};
  	helpers_prefix__testStyle = createElement("div").style;

  	helpers_prefix__prefix = function (prop) {
  		var i, vendor, capped;

  		prop = camelCase(prop);

  		if (!prefixCache[prop]) {
  			if (helpers_prefix__testStyle[prop] !== undefined) {
  				prefixCache[prop] = prop;
  			} else {
  				// test vendors...
  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);

  				i = vendors.length;
  				while (i--) {
  					vendor = vendors[i];
  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {
  						prefixCache[prop] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[prop];
  	};
  }

  var helpers_prefix = helpers_prefix__prefix;

  var getStyle, prototype_getStyle__getComputedStyle;

  if (!isClient) {
  	getStyle = null;
  } else {
  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	getStyle = function (props) {
  		var computedStyle, styles, i, prop, value;

  		computedStyle = prototype_getStyle__getComputedStyle(this.node);

  		if (typeof props === "string") {
  			value = computedStyle[helpers_prefix(props)];
  			if (value === "0px") {
  				value = 0;
  			}
  			return value;
  		}

  		if (!isArray(props)) {
  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");
  		}

  		styles = {};

  		i = props.length;
  		while (i--) {
  			prop = props[i];
  			value = computedStyle[helpers_prefix(prop)];
  			if (value === "0px") {
  				value = 0;
  			}
  			styles[prop] = value;
  		}

  		return styles;
  	};
  }

  var prototype_getStyle = getStyle;

  var setStyle = function (style, value) {
  	var prop;

  	if (typeof style === "string") {
  		this.node.style[helpers_prefix(style)] = value;
  	} else {
  		for (prop in style) {
  			if (style.hasOwnProperty(prop)) {
  				this.node.style[helpers_prefix(prop)] = style[prop];
  			}
  		}
  	}

  	return this;
  };

  var Ticker = function (options) {
  	var easing;

  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;

  	// easing
  	if (typeof options.easing === "string") {
  		easing = options.root.easing[options.easing];

  		if (!easing) {
  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));
  			easing = linear;
  		}
  	} else if (typeof options.easing === "function") {
  		easing = options.easing;
  	} else {
  		easing = linear;
  	}

  	this.easing = easing;

  	this.start = utils_getTime();
  	this.end = this.start + this.duration;

  	this.running = true;
  	shared_animations.add(this);
  };

  Ticker.prototype = {
  	tick: function (now) {
  		var elapsed, eased;

  		if (!this.running) {
  			return false;
  		}

  		if (now > this.end) {
  			if (this.step) {
  				this.step(1);
  			}

  			if (this.complete) {
  				this.complete(1);
  			}

  			return false;
  		}

  		elapsed = now - this.start;
  		eased = this.easing(elapsed / this.duration);

  		if (this.step) {
  			this.step(eased);
  		}

  		return true;
  	},

  	stop: function () {
  		if (this.abort) {
  			this.abort();
  		}

  		this.running = false;
  	}
  };

  var shared_Ticker = Ticker;
  function linear(t) {
  	return t;
  }

  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");

  var unprefix = function (prop) {
  	return prop.replace(unprefixPattern, "");
  };

  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");

  var hyphenate = function (str) {
  	var hyphenated;

  	if (!str) {
  		return ""; // edge case
  	}

  	if (vendorPattern.test(str)) {
  		str = "-" + str;
  	}

  	hyphenated = str.replace(/[A-Z]/g, function (match) {
  		return "-" + match.toLowerCase();
  	});

  	return hyphenated;
  };

  var createTransitions,
      animateStyle_createTransitions__testStyle,
      TRANSITION,
      TRANSITIONEND,
      CSS_TRANSITIONS_ENABLED,
      TRANSITION_DURATION,
      TRANSITION_PROPERTY,
      TRANSITION_TIMING_FUNCTION,
      canUseCssTransitions = {},
      cannotUseCssTransitions = {};

  if (!isClient) {
  	createTransitions = null;
  } else {
  	animateStyle_createTransitions__testStyle = createElement("div").style;

  	// determine some facts about our environment
  	(function () {
  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {
  			TRANSITION = "transition";
  			TRANSITIONEND = "transitionend";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {
  			TRANSITION = "webkitTransition";
  			TRANSITIONEND = "webkitTransitionEnd";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else {
  			CSS_TRANSITIONS_ENABLED = false;
  		}
  	})();

  	if (TRANSITION) {
  		TRANSITION_DURATION = TRANSITION + "Duration";
  		TRANSITION_PROPERTY = TRANSITION + "Property";
  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";
  	}

  	createTransitions = function (t, to, options, changedProperties, resolve) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout(function () {

  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;

  			checkComplete = function () {
  				if (jsTransitionsComplete && cssTransitionsComplete) {
  					// will changes to events and fire have an unexpected consequence here?
  					t.root.fire(t.name + ":end", t.node, t.isIntro);
  					resolve();
  				}
  			};

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;

  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");
  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");
  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";

  			transitionEndHandler = function (event) {
  				var index;

  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));
  				if (index !== -1) {
  					changedProperties.splice(index, 1);
  				}

  				if (changedProperties.length) {
  					// still transitioning...
  					return;
  				}

  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

  				cssTransitionsComplete = true;
  				checkComplete();
  			};

  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

  			setTimeout(function () {
  				var i = changedProperties.length,
  				    hash,
  				    originalValue,
  				    index,
  				    propertiesToTransitionInJs = [],
  				    prop,
  				    suffix;

  				while (i--) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
  						t.node.style[helpers_prefix(prop)] = to[prop];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if (!canUseCssTransitions[hash]) {
  							originalValue = t.getStyle(prop);

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

  							// Reset, if we're going to use timers after all
  							if (cannotUseCssTransitions[hash]) {
  								t.node.style[helpers_prefix(prop)] = originalValue;
  							}
  						}
  					}

  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
  						// we need to fall back to timer-based stuff
  						if (originalValue === undefined) {
  							originalValue = t.getStyle(prop);
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf(prop);
  						if (index === -1) {
  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });
  						} else {
  							changedProperties.splice(index, 1);
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec(to[prop])[0];

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: helpers_prefix(prop),
  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if (propertiesToTransitionInJs.length) {
  					new shared_Ticker({
  						root: t.root,
  						duration: options.duration,
  						easing: camelCase(options.easing || ""),
  						step: function (pos) {
  							var prop, i;

  							i = propertiesToTransitionInJs.length;
  							while (i--) {
  								prop = propertiesToTransitionInJs[i];
  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if (!changedProperties.length) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0);
  		}, options.delay || 0);
  	};
  }

  var animateStyle_createTransitions = createTransitions;

  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;

  if (typeof document !== "undefined") {
  	hidden = "hidden";

  	visibility = {};

  	if (hidden in document) {
  		animateStyle_visibility__prefix = "";
  	} else {
  		animateStyle_visibility__i = vendors.length;
  		while (animateStyle_visibility__i--) {
  			vendor = vendors[animateStyle_visibility__i];
  			hidden = vendor + "Hidden";

  			if (hidden in document) {
  				animateStyle_visibility__prefix = vendor;
  			}
  		}
  	}

  	if (animateStyle_visibility__prefix !== undefined) {
  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);

  		// initialise
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ("onfocusout" in document) {
  			document.addEventListener("focusout", onHide);
  			document.addEventListener("focusin", onShow);
  		} else {
  			window.addEventListener("pagehide", onHide);
  			window.addEventListener("blur", onHide);

  			window.addEventListener("pageshow", onShow);
  			window.addEventListener("focus", onShow);
  		}

  		visibility.hidden = false; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange() {
  	visibility.hidden = document[hidden];
  }

  function onHide() {
  	visibility.hidden = true;
  }

  function onShow() {
  	visibility.hidden = false;
  }

  var animateStyle_visibility = visibility;

  var animateStyle, _animateStyle__getComputedStyle, resolved;

  if (!isClient) {
  	animateStyle = null;
  } else {
  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	animateStyle = function (style, value, options) {
  		var _this = this;

  		var to;

  		if (arguments.length === 4) {
  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");
  		}

  		// Special case - page isn't visible. Don't animate anything, because
  		// that way you'll never get CSS transitionend events
  		if (animateStyle_visibility.hidden) {
  			this.setStyle(style, value);
  			return resolved || (resolved = utils_Promise.resolve());
  		}

  		if (typeof style === "string") {
  			to = {};
  			to[style] = value;
  		} else {
  			to = style;

  			// shuffle arguments
  			options = value;
  		}

  		// As of 0.3.9, transition authors should supply an `option` object with
  		// `duration` and `easing` properties (and optional `delay`), plus a
  		// callback function that gets called after the animation completes

  		// TODO remove this check in a future version
  		if (!options) {
  			warnOnceIfDebug("The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);
  			options = this;
  		}

  		var promise = new utils_Promise(function (resolve) {
  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;

  			// Edge case - if duration is zero, set style synchronously and complete
  			if (!options.duration) {
  				_this.setStyle(to);
  				resolve();
  				return;
  			}

  			// Get a list of the properties we're animating
  			propertyNames = Object.keys(to);
  			changedProperties = [];

  			// Store the current styles
  			computedStyle = _animateStyle__getComputedStyle(_this.node);

  			from = {};
  			i = propertyNames.length;
  			while (i--) {
  				prop = propertyNames[i];
  				current = computedStyle[helpers_prefix(prop)];

  				if (current === "0px") {
  					current = 0;
  				}

  				// we need to know if we're actually changing anything
  				if (current != to[prop]) {
  					// use != instead of !==, so we can compare strings with numbers
  					changedProperties.push(prop);

  					// make the computed style explicit, so we can animate where
  					// e.g. height='auto'
  					_this.node.style[helpers_prefix(prop)] = current;
  				}
  			}

  			// If we're not actually changing anything, the transitionend event
  			// will never fire! So we complete early
  			if (!changedProperties.length) {
  				resolve();
  				return;
  			}

  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);
  		});

  		return promise;
  	};
  }

  var _animateStyle = animateStyle;

  var processParams = function (params, defaults) {
  	if (typeof params === "number") {
  		params = { duration: params };
  	} else if (typeof params === "string") {
  		if (params === "slow") {
  			params = { duration: 600 };
  		} else if (params === "fast") {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if (!params) {
  		params = {};
  	}

  	return fillGaps({}, params, defaults);
  };

  var prototype_start = Transition$start;

  function Transition$start() {
  	var _this = this;

  	var node, originalStyle, completed;

  	node = this.node = this.element.node;
  	originalStyle = node.getAttribute("style");

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function (noReset) {
  		if (completed) {
  			return;
  		}

  		if (!noReset && _this.isIntro) {
  			resetStyle(node, originalStyle);
  		}

  		node._ractive.transition = null;
  		_this._manager.remove(_this);

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if (!this._fn) {
  		this.complete();
  		return;
  	}

  	this._fn.apply(this.root, [this].concat(this.params));
  }

  function resetStyle(node, style) {
  	if (style) {
  		node.setAttribute("style", style);
  	} else {

  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute("style");
  		node.removeAttribute("style");
  	}
  }

  var Transition = function (owner, template, isIntro) {
  	this.init(owner, template, isIntro);
  };

  Transition.prototype = {
  	init: Transition_prototype_init,
  	start: prototype_start,
  	getStyle: prototype_getStyle,
  	setStyle: setStyle,
  	animateStyle: _animateStyle,
  	processParams: processParams
  };

  var _Transition = Transition;

  var Element_prototype_render = Element$render;

  var updateCss, updateScript;

  updateCss = function () {
  	var node = this.node,
  	    content = this.fragment.toString(false);

  	// IE8 has no styleSheet unless there's a type text/css
  	if (window && window.appearsToBeIELessEqual8) {
  		node.type = "text/css";
  	}

  	if (node.styleSheet) {
  		node.styleSheet.cssText = content;
  	} else {

  		while (node.hasChildNodes()) {
  			node.removeChild(node.firstChild);
  		}

  		node.appendChild(document.createTextNode(content));
  	}
  };

  updateScript = function () {
  	if (!this.node.type || this.node.type === "text/javascript") {
  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });
  		// As it happens, we ARE in a position to re-evaluate the code if we wanted
  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.
  		// But this would be a terrible idea with unpredictable results, so let's not.
  	}

  	this.node.text = this.fragment.toString(false);
  };
  function Element$render() {
  	var _this = this;

  	var root = this.root,
  	    namespace,
  	    node,
  	    transition;

  	namespace = getNamespace(this);
  	node = this.node = createElement(this.name, namespace);

  	// Is this a top-level node of a component? If so, we may need to add
  	// a data-ractive-css attribute, for CSS encapsulation
  	if (this.parentFragment.cssIds) {
  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {
  			return "{" + x + "}";
  		}).join(" "));
  	}

  	// Add _ractive property to the node - we use this object to store stuff
  	// related to proxy events, two-way bindings etc
  	defineProperty(this.node, "_ractive", {
  		value: {
  			proxy: this,
  			keypath: getInnerContext(this.parentFragment),
  			events: create(null),
  			root: root
  		}
  	});

  	// Render attributes
  	this.attributes.forEach(function (a) {
  		return a.render(node);
  	});
  	this.conditionalAttributes.forEach(function (a) {
  		return a.render(node);
  	});

  	// Render children
  	if (this.fragment) {
  		// Special case - <script> element
  		if (this.name === "script") {
  			this.bubble = updateScript;
  			this.node.text = this.fragment.toString(false); // bypass warning initially
  			this.fragment.unrender = noop; // TODO this is a kludge
  		}

  		// Special case - <style> element
  		else if (this.name === "style") {
  			this.bubble = updateCss;
  			this.bubble();
  			this.fragment.unrender = noop;
  		}

  		// Special case - contenteditable
  		else if (this.binding && this.getAttribute("contenteditable")) {
  			this.fragment.unrender = noop;
  		} else {
  			this.node.appendChild(this.fragment.render());
  		}
  	}

  	// deal with two-way bindings
  	if (this.binding) {
  		this.binding.render();
  		this.node._ractive.binding = this.binding;
  	}

  	// Add proxy event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(function (h) {
  			return h.render();
  		});
  	}

  	if (this.name === "option") {
  		processOption(this);
  	}

  	// Special cases
  	if (this.name === "img") {
  		// if this is an <img>, and we're in a crap browser, we may
  		// need to prevent it from overriding width and height when
  		// it loads the src
  		special_img__render(this);
  	} else if (this.name === "form") {
  		// forms need to keep track of their bindings, in case of reset
  		form__render(this);
  	} else if (this.name === "input" || this.name === "textarea") {
  		// inputs and textareas should store their initial value as
  		// `defaultValue` in case of reset
  		this.node.defaultValue = this.node.value;
  	} else if (this.name === "option") {
  		// similarly for option nodes
  		this.node.defaultSelected = this.node.selected;
  	}

  	// apply decorator(s)
  	if (this.decorator && this.decorator.fn) {
  		global_runloop.scheduleTask(function () {
  			if (!_this.decorator.torndown) {
  				_this.decorator.init();
  			}
  		}, true);
  	}

  	// trigger intro transition
  	if (root.transitionsEnabled && this.intro) {
  		transition = new _Transition(this, this.intro, true);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		}, true);

  		this.transition = transition;
  	}

  	if (this.node.autofocus) {
  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem
  		// with dynamically-generated elements having autofocus, and they won't
  		// allow you to programmatically focus the element until it's in the DOM
  		global_runloop.scheduleTask(function () {
  			return _this.node.focus();
  		}, true);
  	}

  	updateLiveQueries(this);
  	return this.node;
  }

  function getNamespace(element) {
  	var namespace, xmlns, parent;

  	// Use specified namespace...
  	if (xmlns = element.getAttribute("xmlns")) {
  		namespace = xmlns;
  	}

  	// ...or SVG namespace, if this is an <svg> element
  	else if (element.name === "svg") {
  		namespace = namespaces.svg;
  	} else if (parent = element.parent) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if (parent.name === "foreignObject") {
  			namespace = namespaces.html;
  		}

  		// ...or inherit from the parent node
  		else {
  			namespace = parent.node.namespaceURI;
  		}
  	} else {
  		namespace = element.root.el.namespaceURI;
  	}

  	return namespace;
  }

  function processOption(option) {
  	var optionValue, selectValue, i;

  	if (!option.select) {
  		return;
  	}

  	selectValue = option.select.getAttribute("value");
  	if (selectValue === undefined) {
  		return;
  	}

  	optionValue = option.getAttribute("value");

  	if (option.select.node.multiple && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (optionValue == selectValue[i]) {
  				option.node.selected = true;
  				break;
  			}
  		}
  	} else {
  		option.node.selected = optionValue == selectValue;
  	}
  }

  function updateLiveQueries(element) {
  	var instance, liveQueries, i, selector, query;

  	// Does this need to be added to any live queries?
  	instance = element.root;

  	do {
  		liveQueries = instance._liveQueries;

  		i = liveQueries.length;
  		while (i--) {
  			selector = liveQueries[i];
  			query = liveQueries["_" + selector];

  			if (query._test(element)) {
  				// keep register of applicable selectors, for when we teardown
  				(element.liveQueries || (element.liveQueries = [])).push(query);
  			}
  		}
  	} while (instance = instance.parent);
  }

  var Element_prototype_toString = function () {
  	var str, escape;

  	if (this.template.y) {
  		// DOCTYPE declaration
  		return "<!DOCTYPE" + this.template.dd + ">";
  	}

  	str = "<" + this.template.e;

  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");

  	// Special case - selected options
  	if (this.name === "option" && optionIsSelected(this)) {
  		str += " selected";
  	}

  	// Special case - two-way radio name bindings
  	if (this.name === "input" && inputIsCheckedRadio(this)) {
  		str += " checked";
  	}

  	str += ">";

  	// Special case - textarea
  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {
  		str += escapeHtml(this.getAttribute("value"));
  	}

  	// Special case - contenteditable
  	else if (this.getAttribute("contenteditable") !== undefined) {
  		str += this.getAttribute("value") || "";
  	}

  	if (this.fragment) {
  		escape = this.name !== "script" && this.name !== "style";
  		str += this.fragment.toString(escape);
  	}

  	// add a closing tag if this isn't a void element
  	if (!voidElementNames.test(this.template.e)) {
  		str += "</" + this.template.e + ">";
  	}

  	return str;
  };

  function optionIsSelected(element) {
  	var optionValue, selectValue, i;

  	optionValue = element.getAttribute("value");

  	if (optionValue === undefined || !element.select) {
  		return false;
  	}

  	selectValue = element.select.getAttribute("value");

  	if (selectValue == optionValue) {
  		return true;
  	}

  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (selectValue[i] == optionValue) {
  				return true;
  			}
  		}
  	}
  }

  function inputIsCheckedRadio(element) {
  	var attributes, typeAttribute, valueAttribute, nameAttribute;

  	attributes = element.attributes;

  	typeAttribute = attributes.type;
  	valueAttribute = attributes.value;
  	nameAttribute = attributes.name;

  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {
  		return;
  	}

  	if (valueAttribute.value === nameAttribute.interpolator.value) {
  		return true;
  	}
  }

  function stringifyAttribute(attribute) {
  	var str = attribute.toString();
  	return str ? " " + str : "";
  }

  var Element_prototype_unbind = Element$unbind;
  function Element$unbind() {
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.binding) {
  		this.binding.unbind();
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unbind);
  	}

  	// Special case - <option>
  	if (this.name === "option") {
  		special_option__unbind(this);
  	}

  	this.attributes.forEach(methodCallers__unbind);
  	this.conditionalAttributes.forEach(methodCallers__unbind);
  }

  var Element_prototype_unrender = Element$unrender;

  function Element$unrender(shouldDestroy) {
  	var binding, bindings, transition;

  	if (transition = this.transition) {
  		transition.complete();
  	}

  	// Detach as soon as we can
  	if (this.name === "option") {
  		// <option> elements detach immediately, so that
  		// their parent <select> element syncs correctly, and
  		// since option elements can't have transitions anyway
  		this.detach();
  	} else if (shouldDestroy) {
  		global_runloop.detachWhenReady(this);
  	}

  	// Children first. that way, any transitions on child elements will be
  	// handled by the current transitionManager
  	if (this.fragment) {
  		this.fragment.unrender(false);
  	}

  	if (binding = this.binding) {
  		this.binding.unrender();

  		this.node._ractive.binding = null;
  		bindings = this.root._twowayBindings[binding.keypath.str];
  		bindings.splice(bindings.indexOf(binding), 1);
  	}

  	// Remove event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unrender);
  	}

  	if (this.decorator) {
  		global_runloop.registerDecorator(this.decorator);
  	}

  	// trigger outro transition if necessary
  	if (this.root.transitionsEnabled && this.outro) {
  		transition = new _Transition(this, this.outro, false);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		});
  	}

  	// Remove this node from any live queries
  	if (this.liveQueries) {
  		removeFromLiveQueries(this);
  	}

  	if (this.name === "form") {
  		form__unrender(this);
  	}
  }

  function removeFromLiveQueries(element) {
  	var query, selector, i;

  	i = element.liveQueries.length;
  	while (i--) {
  		query = element.liveQueries[i];
  		selector = query.selector;

  		query._remove(element.node);
  	}
  }

  var Element = function (options) {
  	this.init(options);
  };

  Element.prototype = {
  	bubble: Element_prototype_bubble,
  	detach: Element_prototype_detach,
  	find: Element_prototype_find,
  	findAll: Element_prototype_findAll,
  	findAllComponents: Element_prototype_findAllComponents,
  	findComponent: Element_prototype_findComponent,
  	findNextNode: Element_prototype_findNextNode,
  	firstNode: Element_prototype_firstNode,
  	getAttribute: getAttribute,
  	init: Element_prototype_init,
  	rebind: Element_prototype_rebind,
  	render: Element_prototype_render,
  	toString: Element_prototype_toString,
  	unbind: Element_prototype_unbind,
  	unrender: Element_prototype_unrender
  };

  var _Element = Element;

  var deIndent__empty = /^\s*$/,
      deIndent__leadingWhitespace = /^\s*/;

  var deIndent = function (str) {
  	var lines, firstLine, lastLine, minIndent;

  	lines = str.split("\n");

  	// remove first and last line, if they only contain whitespace
  	firstLine = lines[0];
  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {
  		lines.shift();
  	}

  	lastLine = lastItem(lines);
  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {
  		lines.pop();
  	}

  	minIndent = lines.reduce(reducer, null);

  	if (minIndent) {
  		str = lines.map(function (line) {
  			return line.replace(minIndent, "");
  		}).join("\n");
  	}

  	return str;
  };

  function reducer(previous, line) {
  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];

  	if (previous === null || lineIndent.length < previous.length) {
  		return lineIndent;
  	}

  	return previous;
  }

  var Partial_getPartialTemplate = getPartialTemplate;

  function getPartialTemplate(ractive, name, parentFragment) {
  	var partial;

  	// If the partial in instance or view heirarchy instances, great
  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {
  		return partial;
  	}

  	// Does it exist on the page as a script tag?
  	partial = template_parser.fromId(name, { noThrow: true });

  	if (partial) {
  		// is this necessary?
  		partial = deIndent(partial);

  		// parse and register to this ractive instance
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[name] = parsed.t;
  	}
  }

  function getPartialFromRegistry(ractive, name, parentFragment) {
  	var fn = undefined,
  	    partial = findParentPartial(name, parentFragment.owner);

  	// if there was an instance up-hierarchy, cool
  	if (partial) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance("partials", ractive, name);

  	if (!instance) {
  		return;
  	}

  	partial = instance.partials[name];

  	// partial is a function?
  	if (typeof partial === "function") {
  		fn = partial.bind(instance);
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call(ractive, template_parser);
  	}

  	if (!partial && partial !== "") {
  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if (!template_parser.isParsed(partial)) {

  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if (parsed.p) {
  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner(instance, name);

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[name] = partial = parsed.t;
  	}

  	// store for reset
  	if (fn) {
  		partial._fn = fn;
  	}

  	return partial.v ? partial.t : partial;
  }

  function findOwner(ractive, key) {
  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);
  }

  function findConstructor(constructor, key) {
  	if (!constructor) {
  		return;
  	}
  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);
  }

  function findParentPartial(name, parent) {
  	if (parent) {
  		if (parent.template && parent.template.p && parent.template.p[name]) {
  			return parent.template.p[name];
  		} else if (parent.parentFragment && parent.parentFragment.owner) {
  			return findParentPartial(name, parent.parentFragment.owner);
  		}
  	}
  }

  var applyIndent = function (string, indent) {
  	var indented;

  	if (!indent) {
  		return string;
  	}

  	indented = string.split("\n").map(function (line, notFirstLine) {
  		return notFirstLine ? indent + line : line;
  	}).join("\n");

  	return indented;
  };

  var missingPartialMessage = "Could not find template for partial \"%s\"";

  var Partial = function (options) {
  	var parentFragment, template;

  	parentFragment = this.parentFragment = options.parentFragment;

  	this.root = parentFragment.root;
  	this.type = PARTIAL;
  	this.index = options.index;
  	this.name = options.template.r;
  	this.rendered = false;

  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;

  	Mustache.init(this, options);

  	// If this didn't resolve, it most likely means we have a named partial
  	// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
  	// whose name is the value of `foo`')
  	if (!this.keypath) {
  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {
  			shared_unbind.call(this); // prevent any further changes
  			this.isNamed = true;
  			this.setTemplate(template);
  		} else {
  			warnOnceIfDebug(missingPartialMessage, this.name);
  		}
  	}
  };

  Partial.prototype = {
  	bubble: function () {
  		this.parentFragment.bubble();
  	},

  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	findNextNode: function () {
  		return this.parentFragment.findNextNode(this);
  	},

  	getPartialName: function () {
  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;
  	},

  	getValue: function () {
  		return this.fragment.getValue();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// named partials aren't bound, so don't rebind
  		if (!this.isNamed) {
  			Mustache_rebind.call(this, oldKeypath, newKeypath);
  		}

  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	render: function () {
  		this.docFrag = document.createDocumentFragment();
  		this.update();

  		this.rendered = true;
  		return this.docFrag;
  	},

  	resolve: Mustache.resolve,

  	setValue: function (value) {
  		var template;

  		if (value !== undefined && value === this.value) {
  			// nothing has changed, so no work to be done
  			return;
  		}

  		if (value !== undefined) {
  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);
  		}

  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the
  		// name of both a data property (whose value ISN'T the name of a partial)
  		// and a partial. In those cases, this becomes a named partial
  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {
  			shared_unbind.call(this);
  			this.isNamed = true;
  		}

  		if (!template) {
  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });
  		}

  		this.value = value;

  		this.setTemplate(template || []);

  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	},

  	setTemplate: function (template) {
  		if (this.fragment) {
  			this.fragment.unbind();
  			if (this.rendered) {
  				this.fragmentToUnrender = this.fragment;
  			}
  		}

  		this.fragment = new virtualdom_Fragment({
  			template: template,
  			root: this.root,
  			owner: this,
  			pElement: this.parentFragment.pElement
  		});

  		this.fragmentToRender = this.fragment;
  	},

  	toString: function (toString) {
  		var string, previousItem, lastLine, match;

  		string = this.fragment.toString(toString);

  		previousItem = this.parentFragment.items[this.index - 1];

  		if (!previousItem || previousItem.type !== TEXT) {
  			return string;
  		}

  		lastLine = previousItem.text.split("\n").pop();

  		if (match = /^\s+$/.exec(lastLine)) {
  			return applyIndent(string, match[0]);
  		}

  		return string;
  	},

  	unbind: function () {
  		if (!this.isNamed) {
  			// dynamic partial - need to unbind self
  			shared_unbind.call(this);
  		}

  		if (this.fragment) {
  			this.fragment.unbind();
  		}
  	},

  	unrender: function (shouldDestroy) {
  		if (this.rendered) {
  			if (this.fragment) {
  				this.fragment.unrender(shouldDestroy);
  			}
  			this.rendered = false;
  		}
  	},

  	update: function () {
  		var target, anchor;

  		if (this.fragmentToUnrender) {
  			this.fragmentToUnrender.unrender(true);
  			this.fragmentToUnrender = null;
  		}

  		if (this.fragmentToRender) {
  			this.docFrag.appendChild(this.fragmentToRender.render());
  			this.fragmentToRender = null;
  		}

  		if (this.rendered) {
  			target = this.parentFragment.getNode();
  			anchor = this.parentFragment.findNextNode(this);
  			target.insertBefore(this.docFrag, anchor);
  		}
  	}
  };

  var _Partial = Partial;

  // finds the component constructor in the registry or view hierarchy registries

  var Component_getComponent = getComponent;
  function getComponent(ractive, name) {

  	var Component,
  	    instance = findInstance("components", ractive, name);

  	if (instance) {
  		Component = instance.components[name];

  		// best test we have for not Ractive.extend
  		if (!Component._Parent) {
  			// function option, execute and store for reset
  			var fn = Component.bind(instance);
  			fn.isOwner = instance.components.hasOwnProperty(name);
  			Component = fn();

  			if (!Component) {
  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });

  				return;
  			}

  			if (typeof Component === "string") {
  				// allow string lookup
  				Component = getComponent(ractive, Component);
  			}

  			Component._fn = fn;
  			instance.components[name] = Component;
  		}
  	}

  	return Component;
  }

  var Component_prototype_detach = Component$detach;
  var Component_prototype_detach__detachHook = new hooks_Hook("detach");
  function Component$detach() {
  	var detached = this.instance.fragment.detach();
  	Component_prototype_detach__detachHook.fire(this.instance);
  	return detached;
  }

  var Component_prototype_find = Component$find;

  function Component$find(selector) {
  	return this.instance.fragment.find(selector);
  }

  var Component_prototype_findAll = Component$findAll;

  function Component$findAll(selector, query) {
  	return this.instance.fragment.findAll(selector, query);
  }

  var Component_prototype_findAllComponents = Component$findAllComponents;

  function Component$findAllComponents(selector, query) {
  	query._test(this, true);

  	if (this.instance.fragment) {
  		this.instance.fragment.findAllComponents(selector, query);
  	}
  }

  var Component_prototype_findComponent = Component$findComponent;

  function Component$findComponent(selector) {
  	if (!selector || selector === this.name) {
  		return this.instance;
  	}

  	if (this.instance.fragment) {
  		return this.instance.fragment.findComponent(selector);
  	}

  	return null;
  }

  var Component_prototype_findNextNode = Component$findNextNode;

  function Component$findNextNode() {
  	return this.parentFragment.findNextNode(this);
  }

  var Component_prototype_firstNode = Component$firstNode;

  function Component$firstNode() {
  	if (this.rendered) {
  		return this.instance.fragment.firstNode();
  	}

  	return null;
  }

  var processWrapper = function (wrapper, array, methodName, newIndices) {
  	var root = wrapper.root;
  	var keypath = wrapper.keypath;

  	if (!!newIndices) {
  		root.viewmodel.smartUpdate(keypath, array, newIndices);
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		root.viewmodel.mark(keypath);
  	}
  };

  var patchedArrayProto = [],
      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
      testObj,
      patchArrayMethods,
      unpatchArrayMethods;

  mutatorMethods.forEach(function (methodName) {
  	var method = function () {
  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  			args[_key] = arguments[_key];
  		}

  		var newIndices, result, wrapper, i;

  		newIndices = shared_getNewIndices(this, methodName, args);

  		// apply the underlying method
  		result = Array.prototype[methodName].apply(this, arguments);

  		// trigger changes
  		global_runloop.start();

  		this._ractive.setting = true;
  		i = this._ractive.wrappers.length;
  		while (i--) {
  			wrapper = this._ractive.wrappers[i];

  			global_runloop.addRactive(wrapper.root);
  			processWrapper(wrapper, this, methodName, newIndices);
  		}

  		global_runloop.end();

  		this._ractive.setting = false;
  		return result;
  	};

  	defineProperty(patchedArrayProto, methodName, {
  		value: method
  	});
  });

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  testObj = {};

  if (testObj.__proto__) {
  	// yes, we can
  	patchArrayMethods = function (array) {
  		array.__proto__ = patchedArrayProto;
  	};

  	unpatchArrayMethods = function (array) {
  		array.__proto__ = Array.prototype;
  	};
  } else {
  	// no, we can't
  	patchArrayMethods = function (array) {
  		var i, methodName;

  		i = mutatorMethods.length;
  		while (i--) {
  			methodName = mutatorMethods[i];
  			defineProperty(array, methodName, {
  				value: patchedArrayProto[methodName],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function (array) {
  		var i;

  		i = mutatorMethods.length;
  		while (i--) {
  			delete array[mutatorMethods[i]];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods;
  var patch = patchArrayMethods;

  var arrayAdaptor,

  // helpers
  ArrayWrapper, array_index__errorMessage;

  arrayAdaptor = {
  	filter: function (object) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray(object) && (!object._ractive || !object._ractive.setting);
  	},
  	wrap: function (ractive, array, keypath) {
  		return new ArrayWrapper(ractive, array, keypath);
  	}
  };

  ArrayWrapper = function (ractive, array, keypath) {
  	this.root = ractive;
  	this.value = array;
  	this.keypath = getKeypath(keypath);

  	// if this array hasn't already been ractified, ractify it
  	if (!array._ractive) {

  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty(array, "_ractive", {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch(array);
  	}

  	// store the ractive instance, so we can handle transitions later
  	if (!array._ractive.instances[ractive._guid]) {
  		array._ractive.instances[ractive._guid] = 0;
  		array._ractive.instances.push(ractive);
  	}

  	array._ractive.instances[ractive._guid] += 1;
  	array._ractive.wrappers.push(this);
  };

  ArrayWrapper.prototype = {
  	get: function () {
  		return this.value;
  	},
  	teardown: function () {
  		var array, storage, wrappers, instances, index;

  		array = this.value;
  		storage = array._ractive;
  		wrappers = storage.wrappers;
  		instances = storage.instances;

  		// if teardown() was invoked because we're clearing the cache as a result of
  		// a change that the array itself triggered, we can save ourselves the teardown
  		// and immediate setup
  		if (storage.setting) {
  			return false; // so that we don't remove it from this.root.viewmodel.wrapped
  		}

  		index = wrappers.indexOf(this);
  		if (index === -1) {
  			throw new Error(array_index__errorMessage);
  		}

  		wrappers.splice(index, 1);

  		// if nothing else depends on this array, we can revert it to its
  		// natural state
  		if (!wrappers.length) {
  			delete array._ractive;
  			patch.unpatch(this.value);
  		} else {
  			// remove ractive instance if possible
  			instances[this.root._guid] -= 1;
  			if (!instances[this.root._guid]) {
  				index = instances.indexOf(this.root);

  				if (index === -1) {
  					throw new Error(array_index__errorMessage);
  				}

  				instances.splice(index, 1);
  			}
  		}
  	}
  };

  array_index__errorMessage = "Something went wrong in a rather interesting way";
  var array_index = arrayAdaptor;

  var numeric = /^\s*[0-9]+\s*$/;

  var createBranch = function (key) {
  	return numeric.test(key) ? [] : {};
  };

  var magicAdaptor, MagicWrapper;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	magicAdaptor = {
  		filter: function (object, keypath, ractive) {
  			var parentWrapper, parentValue;

  			if (!keypath) {
  				return false;
  			}

  			keypath = getKeypath(keypath);

  			// If the parent value is a wrapper, other than a magic wrapper,
  			// we shouldn't wrap this property
  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {
  				return false;
  			}

  			parentValue = ractive.viewmodel.get(keypath.parent);

  			// if parentValue is an array that doesn't include this member,
  			// we should return false otherwise lengths will get messed up
  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {
  				return false;
  			}

  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");
  		},
  		wrap: function (ractive, property, keypath) {
  			return new MagicWrapper(ractive, property, keypath);
  		}
  	};

  	MagicWrapper = function (ractive, value, keypath) {
  		var objKeypath, template, siblings;

  		keypath = getKeypath(keypath);

  		this.magic = true;

  		this.ractive = ractive;
  		this.keypath = keypath;
  		this.value = value;

  		this.prop = keypath.lastKey;

  		objKeypath = keypath.parent;
  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);

  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);

  		// Has this property already been wrapped?
  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {

  			// Yes. Register this wrapper to this property, if it hasn't been already
  			if (siblings.indexOf(this) === -1) {
  				siblings.push(this);
  			}

  			return; // already wrapped
  		}

  		// No, it hasn't been wrapped
  		createAccessors(this, value, template);
  	};

  	MagicWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		reset: function (value) {
  			if (this.updating) {
  				return;
  			}

  			this.updating = true;
  			this.obj[this.prop] = value; // trigger set() accessor
  			global_runloop.addRactive(this.ractive);
  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });
  			this.updating = false;
  			return true;
  		},
  		set: function (key, value) {
  			if (this.updating) {
  				return;
  			}

  			if (!this.obj[this.prop]) {
  				this.updating = true;
  				this.obj[this.prop] = createBranch(key);
  				this.updating = false;
  			}

  			this.obj[this.prop][key] = value;
  		},
  		teardown: function () {
  			var template, set, value, wrappers, index;

  			// If this method was called because the cache was being cleared as a
  			// result of a set()/update() call made by this wrapper, we return false
  			// so that it doesn't get torn down
  			if (this.updating) {
  				return false;
  			}

  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);
  			set = template && template.set;

  			if (!set) {
  				// most likely, this was an array member that was spliced out
  				return;
  			}

  			wrappers = set._ractiveWrappers;

  			index = wrappers.indexOf(this);
  			if (index !== -1) {
  				wrappers.splice(index, 1);
  			}

  			// Last one out, turn off the lights
  			if (!wrappers.length) {
  				value = this.obj[this.prop];

  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {
  					writable: true,
  					enumerable: true,
  					configurable: true
  				});

  				this.obj[this.prop] = value;
  			}
  		}
  	};
  } catch (err) {
  	magicAdaptor = false; // no magic in this browser
  }

  var adaptors_magic = magicAdaptor;

  function createAccessors(originalWrapper, value, template) {

  	var object, property, oldGet, oldSet, get, set;

  	object = originalWrapper.obj;
  	property = originalWrapper.prop;

  	// Is this template configurable?
  	if (template && !template.configurable) {
  		// Special case - array length
  		if (property === "length") {
  			return;
  		}

  		throw new Error("Cannot use magic mode with property \"" + property + "\" - object is not configurable");
  	}

  	// Time to wrap this property
  	if (template) {
  		oldGet = template.get;
  		oldSet = template.set;
  	}

  	get = oldGet || function () {
  		return value;
  	};

  	set = function (v) {
  		if (oldSet) {
  			oldSet(v);
  		}

  		value = oldGet ? oldGet() : v;
  		set._ractiveWrappers.forEach(updateWrapper);
  	};

  	function updateWrapper(wrapper) {
  		var keypath, ractive;

  		wrapper.value = value;

  		if (wrapper.updating) {
  			return;
  		}

  		ractive = wrapper.ractive;
  		keypath = wrapper.keypath;

  		wrapper.updating = true;
  		global_runloop.start(ractive);

  		ractive.viewmodel.mark(keypath);

  		global_runloop.end();
  		wrapper.updating = false;
  	}

  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.
  	// Handily, we can store them as a property of the set function. Yay JavaScript.
  	set._ractiveWrappers = [originalWrapper];
  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });
  }

  var magicArrayAdaptor, MagicArrayWrapper;

  if (adaptors_magic) {
  	magicArrayAdaptor = {
  		filter: function (object, keypath, ractive) {
  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);
  		},

  		wrap: function (ractive, array, keypath) {
  			return new MagicArrayWrapper(ractive, array, keypath);
  		}
  	};

  	MagicArrayWrapper = function (ractive, array, keypath) {
  		this.value = array;

  		this.magic = true;

  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);
  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);
  	};

  	MagicArrayWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		teardown: function () {
  			this.arrayWrapper.teardown();
  			this.magicWrapper.teardown();
  		},
  		reset: function (value) {
  			return this.magicWrapper.reset(value);
  		}
  	};
  }

  var magicArray = magicArrayAdaptor;

  var prototype_adapt = Viewmodel$adapt;

  var prefixers = {};
  function Viewmodel$adapt(keypath, value) {
  	var len, i, adaptor, wrapped;

  	if (!this.adaptors) return;

  	// Do we have an adaptor for this value?
  	len = this.adaptors.length;
  	for (i = 0; i < len; i += 1) {
  		adaptor = this.adaptors[i];

  		if (adaptor.filter(value, keypath, this.ractive)) {
  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));
  			wrapped.value = value;
  			return;
  		}
  	}
  }

  function prefixKeypath(obj, prefix) {
  	var prefixed = {},
  	    key;

  	if (!prefix) {
  		return obj;
  	}

  	prefix += ".";

  	for (key in obj) {
  		if (obj.hasOwnProperty(key)) {
  			prefixed[prefix + key] = obj[key];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer(rootKeypath) {
  	var rootDot;

  	if (!prefixers[rootKeypath]) {
  		rootDot = rootKeypath ? rootKeypath + "." : "";

  		prefixers[rootKeypath] = function (relativeKeypath, value) {
  			var obj;

  			if (typeof relativeKeypath === "string") {
  				obj = {};
  				obj[rootDot + relativeKeypath] = value;
  				return obj;
  			}

  			if (typeof relativeKeypath === "object") {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[rootKeypath];
  }

  // TEMP

  var helpers_getUpstreamChanges = getUpstreamChanges;
  function getUpstreamChanges(changes) {
  	var upstreamChanges = [rootKeypath],
  	    i,
  	    keypath;

  	i = changes.length;
  	while (i--) {
  		keypath = changes[i].parent;

  		while (keypath && !keypath.isRoot) {
  			if (changes.indexOf(keypath) === -1) {
  				addToArray(upstreamChanges, keypath);
  			}
  			keypath = keypath.parent;
  		}
  	}

  	return upstreamChanges;
  }

  var applyChanges_notifyPatternObservers = notifyPatternObservers;

  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {
  	var potentialWildcardMatches;

  	updateMatchingPatternObservers(viewmodel, keypath);

  	if (onlyDirect) {
  		return;
  	}

  	potentialWildcardMatches = keypath.wildcardMatches();
  	potentialWildcardMatches.forEach(function (upstreamPattern) {
  		cascade(viewmodel, upstreamPattern, keypath);
  	});
  }

  function cascade(viewmodel, upstreamPattern, keypath) {
  	var group, map, actualChildKeypath;

  	// TODO should be one or the other
  	upstreamPattern = upstreamPattern.str || upstreamPattern;

  	group = viewmodel.depsMap.patternObservers;
  	map = group && group[upstreamPattern];

  	if (!map) {
  		return;
  	}

  	map.forEach(function (childKeypath) {
  		actualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'

  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);
  		cascade(viewmodel, childKeypath, actualChildKeypath);
  	});
  }

  function updateMatchingPatternObservers(viewmodel, keypath) {
  	viewmodel.patternObservers.forEach(function (observer) {
  		if (observer.regex.test(keypath.str)) {
  			observer.update(keypath);
  		}
  	});
  }

  var applyChanges = Viewmodel$applyChanges;

  function Viewmodel$applyChanges() {
  	var _this = this;

  	var self = this,
  	    changes,
  	    upstreamChanges,
  	    hash = {},
  	    bindings;

  	changes = this.changes;

  	if (!changes.length) {
  		// TODO we end up here on initial render. Perhaps we shouldn't?
  		return;
  	}

  	function invalidateComputation(computation) {
  		var key = computation.key;

  		if (computation.viewmodel === self) {
  			self.clearCache(key.str);
  			computation.invalidate();

  			changes.push(key);
  			cascade(key);
  		} else {
  			computation.viewmodel.mark(key);
  		}
  	}

  	function cascade(keypath) {
  		var map, computations;

  		if (self.noCascade.hasOwnProperty(keypath.str)) {
  			return;
  		}

  		if (computations = self.deps.computed[keypath.str]) {
  			computations.forEach(invalidateComputation);
  		}

  		if (map = self.depsMap.computed[keypath.str]) {
  			map.forEach(cascade);
  		}
  	}

  	changes.slice().forEach(cascade);

  	upstreamChanges = helpers_getUpstreamChanges(changes);
  	upstreamChanges.forEach(function (keypath) {
  		var computations;

  		// make sure we haven't already been down this particular keypath in this turn
  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {
  			computations.forEach(invalidateComputation);
  		}
  	});

  	this.changes = [];

  	// Pattern observers are a weird special case
  	if (this.patternObservers.length) {
  		upstreamChanges.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath, true);
  		});
  		changes.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath);
  		});
  	}

  	if (this.deps.observers) {
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, null, keypath, "observers");
  		});
  		notifyAllDependants(this, changes, "observers");
  	}

  	if (this.deps["default"]) {
  		bindings = [];
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, bindings, keypath, "default");
  		});

  		if (bindings.length) {
  			notifyBindings(this, bindings, changes);
  		}

  		notifyAllDependants(this, changes, "default");
  	}

  	// Return a hash of keypaths to updated values
  	changes.forEach(function (keypath) {
  		hash[keypath.str] = _this.get(keypath);
  	});

  	this.implicitChanges = {};
  	this.noCascade = {};

  	return hash;
  }

  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {
  	var dependants, value;

  	if (dependants = findDependants(viewmodel, keypath, groupName)) {
  		value = viewmodel.get(keypath);

  		dependants.forEach(function (d) {
  			// don't "set" the parent value, refine it
  			// i.e. not data = value, but data[foo] = fooValue
  			if (bindings && d.refineValue) {
  				bindings.push(d);
  			} else {
  				d.setValue(value);
  			}
  		});
  	}
  }

  function notifyBindings(viewmodel, bindings, changes) {

  	bindings.forEach(function (binding) {
  		var useSet = false,
  		    i = 0,
  		    length = changes.length,
  		    refinements = [];

  		while (i < length) {
  			var keypath = changes[i];

  			if (keypath === binding.keypath) {
  				useSet = true;
  				break;
  			}

  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {
  				refinements.push(keypath);
  			}

  			i++;
  		}

  		if (useSet) {
  			binding.setValue(viewmodel.get(binding.keypath));
  		}

  		if (refinements.length) {
  			binding.refineValue(refinements);
  		}
  	});
  }

  function notifyAllDependants(viewmodel, keypaths, groupName) {
  	var queue = [];

  	addKeypaths(keypaths);
  	queue.forEach(dispatch);

  	function addKeypaths(keypaths) {
  		keypaths.forEach(addKeypath);
  		keypaths.forEach(cascade);
  	}

  	function addKeypath(keypath) {
  		var deps = findDependants(viewmodel, keypath, groupName);

  		if (deps) {
  			queue.push({
  				keypath: keypath,
  				deps: deps
  			});
  		}
  	}

  	function cascade(keypath) {
  		var childDeps;

  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {
  			addKeypaths(childDeps);
  		}
  	}

  	function dispatch(set) {
  		var value = viewmodel.get(set.keypath);
  		set.deps.forEach(function (d) {
  			return d.setValue(value);
  		});
  	}
  }

  function findDependants(viewmodel, keypath, groupName) {
  	var group = viewmodel.deps[groupName];
  	return group ? group[keypath.str] : null;
  }

  var capture = Viewmodel$capture;

  function Viewmodel$capture() {
  	this.captureGroups.push([]);
  }

  var clearCache = Viewmodel$clearCache;

  function Viewmodel$clearCache(keypath, keepExistingWrapper) {
  	var cacheMap, wrapper;

  	if (!keepExistingWrapper) {
  		// Is there a wrapped property at this keypath?
  		if (wrapper = this.wrapped[keypath]) {
  			// Did we unwrap it?
  			if (wrapper.teardown() !== false) {
  				// Is this right?
  				// What's the meaning of returning false from teardown?
  				// Could there be a GC ramification if this is a "real" ractive.teardown()?
  				this.wrapped[keypath] = null;
  			}
  		}
  	}

  	this.cache[keypath] = undefined;

  	if (cacheMap = this.cacheMap[keypath]) {
  		while (cacheMap.length) {
  			this.clearCache(cacheMap.pop());
  		}
  	}
  }

  var UnresolvedDependency = function (computation, ref) {
  	this.computation = computation;
  	this.viewmodel = computation.viewmodel;
  	this.ref = ref;

  	// TODO this seems like a red flag!
  	this.root = this.viewmodel.ractive;
  	this.parentFragment = this.root.component && this.root.component.parentFragment;
  };

  UnresolvedDependency.prototype = {
  	resolve: function (keypath) {
  		this.computation.softDeps.push(keypath);
  		this.computation.unresolvedDeps[keypath.str] = null;
  		this.viewmodel.register(keypath, this.computation, "computed");
  	}
  };

  var Computation_UnresolvedDependency = UnresolvedDependency;

  var Computation = function (key, signature) {
  	this.key = key;

  	this.getter = signature.getter;
  	this.setter = signature.setter;

  	this.hardDeps = signature.deps || [];
  	this.softDeps = [];
  	this.unresolvedDeps = {};

  	this.depValues = {};

  	this._dirty = this._firstRun = true;
  };

  Computation.prototype = {
  	constructor: Computation,

  	init: function (viewmodel) {
  		var _this = this;

  		var initial;

  		this.viewmodel = viewmodel;
  		this.bypass = true;

  		initial = viewmodel.get(this.key);
  		viewmodel.clearCache(this.key.str);

  		this.bypass = false;

  		if (this.setter && initial !== undefined) {
  			this.set(initial);
  		}

  		if (this.hardDeps) {
  			this.hardDeps.forEach(function (d) {
  				return viewmodel.register(d, _this, "computed");
  			});
  		}
  	},

  	invalidate: function () {
  		this._dirty = true;
  	},

  	get: function () {
  		var _this = this;

  		var newDeps,
  		    dependenciesChanged,
  		    dependencyValuesChanged = false;

  		if (this.getting) {
  			// prevent double-computation (e.g. caused by array mutation inside computation)
  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`";
  			warnOnce(msg);
  			return this.value;
  		}

  		this.getting = true;

  		if (this._dirty) {
  			// determine whether the inputs have changed, in case this depends on
  			// other computed values
  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {
  				dependencyValuesChanged = true;
  			} else {
  				[this.hardDeps, this.softDeps].forEach(function (deps) {
  					var keypath, value, i;

  					if (dependencyValuesChanged) {
  						return;
  					}

  					i = deps.length;
  					while (i--) {
  						keypath = deps[i];
  						value = _this.viewmodel.get(keypath);

  						if (!isEqual(value, _this.depValues[keypath.str])) {
  							_this.depValues[keypath.str] = value;
  							dependencyValuesChanged = true;

  							return;
  						}
  					}
  				});
  			}

  			if (dependencyValuesChanged) {
  				this.viewmodel.capture();

  				try {
  					this.value = this.getter();
  				} catch (err) {
  					warnIfDebug("Failed to compute \"%s\"", this.key.str);
  					logIfDebug(err.stack || err);

  					this.value = void 0;
  				}

  				newDeps = this.viewmodel.release();
  				dependenciesChanged = this.updateDependencies(newDeps);

  				if (dependenciesChanged) {
  					[this.hardDeps, this.softDeps].forEach(function (deps) {
  						deps.forEach(function (keypath) {
  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);
  						});
  					});
  				}
  			}

  			this._dirty = false;
  		}

  		this.getting = this._firstRun = false;
  		return this.value;
  	},

  	set: function (value) {
  		if (this.setting) {
  			this.value = value;
  			return;
  		}

  		if (!this.setter) {
  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");
  		}

  		this.setter(value);
  	},

  	updateDependencies: function (newDeps) {
  		var i, oldDeps, keypath, dependenciesChanged, unresolved;

  		oldDeps = this.softDeps;

  		// remove dependencies that are no longer used
  		i = oldDeps.length;
  		while (i--) {
  			keypath = oldDeps[i];

  			if (newDeps.indexOf(keypath) === -1) {
  				dependenciesChanged = true;
  				this.viewmodel.unregister(keypath, this, "computed");
  			}
  		}

  		// create references for any new dependencies
  		i = newDeps.length;
  		while (i--) {
  			keypath = newDeps[i];

  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {
  				dependenciesChanged = true;

  				// if this keypath is currently unresolved, we need to mark
  				// it as such. TODO this is a bit muddy...
  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {
  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);
  					newDeps.splice(i, 1);

  					this.unresolvedDeps[keypath.str] = unresolved;
  					global_runloop.addUnresolved(unresolved);
  				} else {
  					this.viewmodel.register(keypath, this, "computed");
  				}
  			}
  		}

  		if (dependenciesChanged) {
  			this.softDeps = newDeps.slice();
  		}

  		return dependenciesChanged;
  	}
  };

  function isUnresolved(viewmodel, keypath) {
  	var key = keypath.firstKey;

  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);
  }

  var Computation_Computation = Computation;

  var compute = Viewmodel$compute;
  function Viewmodel$compute(key, signature) {
  	var computation = new Computation_Computation(key, signature);

  	if (this.ready) {
  		computation.init(this);
  	}

  	return this.computations[key.str] = computation;
  }

  var FAILED_LOOKUP = { FAILED_LOOKUP: true };

  var viewmodel_prototype_get = Viewmodel$get;

  var viewmodel_prototype_get__empty = {};
  function Viewmodel$get(keypath, options) {
  	var cache = this.cache,
  	    value,
  	    computation,
  	    wrapped,
  	    captureGroup,
  	    keypathStr = keypath.str,
  	    key;

  	options = options || viewmodel_prototype_get__empty;

  	// capture the keypath, if we're inside a computation
  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {
  		if (! ~captureGroup.indexOf(keypath)) {
  			captureGroup.push(keypath);
  		}
  	}

  	if (hasOwn.call(this.mappings, keypath.firstKey)) {
  		return this.mappings[keypath.firstKey].get(keypath, options);
  	}

  	if (keypath.isSpecial) {
  		return keypath.value;
  	}

  	if (cache[keypathStr] === undefined) {

  		// Is this a computed property?
  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {
  			value = computation.get();
  			this.adapt(keypathStr, value);
  		}

  		// Is this a wrapped property?
  		else if (wrapped = this.wrapped[keypathStr]) {
  			value = wrapped.value;
  		}

  		// Is it the root?
  		else if (keypath.isRoot) {
  			this.adapt("", this.data);
  			value = this.data;
  		}

  		// No? Then we need to retrieve the value one key at a time
  		else {
  			value = retrieve(this, keypath);
  		}

  		cache[keypathStr] = value;
  	} else {
  		value = cache[keypathStr];
  	}

  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {
  		value = wrapped.get();
  	}

  	if (keypath.isRoot && options.fullRootGet) {
  		for (key in this.mappings) {
  			value[key] = this.mappings[key].getValue();
  		}
  	}

  	return value === FAILED_LOOKUP ? void 0 : value;
  }

  function retrieve(viewmodel, keypath) {

  	var parentValue, cacheMap, value, wrapped;

  	parentValue = viewmodel.get(keypath.parent);

  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {
  		parentValue = wrapped.get();
  	}

  	if (parentValue === null || parentValue === undefined) {
  		return;
  	}

  	// update cache map
  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {
  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];
  	} else {
  		if (cacheMap.indexOf(keypath.str) === -1) {
  			cacheMap.push(keypath.str);
  		}
  	}

  	// If this property doesn't exist, we return a sentinel value
  	// so that we know to query parent scope (if such there be)
  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {
  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;
  	}

  	value = parentValue[keypath.lastKey];

  	// Do we have an adaptor for this value?
  	viewmodel.adapt(keypath.str, value, false);

  	// Update cache
  	viewmodel.cache[keypath.str] = value;
  	return value;
  }

  var viewmodel_prototype_init = Viewmodel$init;

  function Viewmodel$init() {
  	var key;

  	for (key in this.computations) {
  		this.computations[key].init(this);
  	}
  }

  var prototype_map = Viewmodel$map;

  function Viewmodel$map(key, options) {
  	var mapping = this.mappings[key.str] = new Mapping(key, options);
  	mapping.initViewmodel(this);
  	return mapping;
  }

  var Mapping = function (localKey, options) {
  	this.localKey = localKey;
  	this.keypath = options.keypath;
  	this.origin = options.origin;

  	this.deps = [];
  	this.unresolved = [];

  	this.resolved = false;
  };

  Mapping.prototype = {
  	forceResolution: function () {
  		// TODO warn, as per #1692?
  		this.keypath = this.localKey;
  		this.setup();
  	},

  	get: function (keypath, options) {
  		if (!this.resolved) {
  			return undefined;
  		}
  		return this.origin.get(this.map(keypath), options);
  	},

  	getValue: function () {
  		if (!this.keypath) {
  			return undefined;
  		}
  		return this.origin.get(this.keypath);
  	},

  	initViewmodel: function (viewmodel) {
  		this.local = viewmodel;
  		this.setup();
  	},

  	map: function (keypath) {
  		if (typeof this.keypath === undefined) {
  			return this.localKey;
  		}
  		return keypath.replace(this.localKey, this.keypath);
  	},

  	register: function (keypath, dependant, group) {
  		this.deps.push({ keypath: keypath, dep: dependant, group: group });

  		if (this.resolved) {
  			this.origin.register(this.map(keypath), dependant, group);
  		}
  	},

  	resolve: function (keypath) {
  		if (this.keypath !== undefined) {
  			this.unbind(true);
  		}

  		this.keypath = keypath;
  		this.setup();
  	},

  	set: function (keypath, value) {
  		if (!this.resolved) {
  			this.forceResolution();
  		}

  		this.origin.set(this.map(keypath), value);
  	},

  	setup: function () {
  		var _this = this;

  		if (this.keypath === undefined) {
  			return;
  		}

  		this.resolved = true;

  		// accumulated dependants can now be registered
  		if (this.deps.length) {
  			this.deps.forEach(function (d) {
  				var keypath = _this.map(d.keypath);
  				_this.origin.register(keypath, d.dep, d.group);

  				// TODO this is a bit of a red flag... all deps should be the same?
  				if (d.dep.setValue) {
  					d.dep.setValue(_this.origin.get(keypath));
  				} else if (d.dep.invalidate) {
  					d.dep.invalidate();
  				} else {
  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  				}
  			});

  			this.origin.mark(this.keypath);
  		}
  	},

  	setValue: function (value) {
  		if (!this.keypath) {
  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  		}

  		this.origin.set(this.keypath, value);
  	},

  	unbind: function (keepLocal) {
  		var _this = this;

  		if (!keepLocal) {
  			delete this.local.mappings[this.localKey];
  		}

  		if (!this.resolved) {
  			return;
  		}

  		this.deps.forEach(function (d) {
  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);
  		});

  		if (this.tracker) {
  			this.origin.unregister(this.keypath, this.tracker);
  		}
  	},

  	unregister: function (keypath, dependant, group) {
  		var deps, i;

  		if (!this.resolved) {
  			return;
  		}

  		deps = this.deps;
  		i = deps.length;

  		while (i--) {
  			if (deps[i].dep === dependant) {
  				deps.splice(i, 1);
  				break;
  			}
  		}
  		this.origin.unregister(this.map(keypath), dependant, group);
  	}
  };

  var mark = Viewmodel$mark;

  function Viewmodel$mark(keypath, options) {
  	var computation,
  	    keypathStr = keypath.str;

  	// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
  	// should not be picked up by pattern observers
  	if (options) {
  		if (options.implicit) {
  			this.implicitChanges[keypathStr] = true;
  		}
  		if (options.noCascade) {
  			this.noCascade[keypathStr] = true;
  		}
  	}

  	if (computation = this.computations[keypathStr]) {
  		computation.invalidate();
  	}

  	if (this.changes.indexOf(keypath) === -1) {
  		this.changes.push(keypath);
  	}

  	// pass on keepExistingWrapper, if we can
  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;

  	this.clearCache(keypathStr, keepExistingWrapper);

  	if (this.ready) {
  		this.onchange();
  	}
  }

  var mapOldToNewIndex = function (oldArray, newArray) {
  	var usedIndices, firstUnusedIndex, newIndices, changed;

  	usedIndices = {};
  	firstUnusedIndex = 0;

  	newIndices = oldArray.map(function (item, i) {
  		var index, start, len;

  		start = firstUnusedIndex;
  		len = newArray.length;

  		do {
  			index = newArray.indexOf(item, start);

  			if (index === -1) {
  				changed = true;
  				return -1;
  			}

  			start = index + 1;
  		} while (usedIndices[index] && start < len);

  		// keep track of the first unused index, so we don't search
  		// the whole of newArray for each item in oldArray unnecessarily
  		if (index === firstUnusedIndex) {
  			firstUnusedIndex += 1;
  		}

  		if (index !== i) {
  			changed = true;
  		}

  		usedIndices[index] = true;
  		return index;
  	});

  	return newIndices;
  };

  var merge = Viewmodel$merge;

  var comparators = {};
  function Viewmodel$merge(keypath, currentArray, array, options) {
  	var oldArray, newArray, comparator, newIndices;

  	this.mark(keypath);

  	if (options && options.compare) {

  		comparator = getComparatorFunction(options.compare);

  		try {
  			oldArray = currentArray.map(comparator);
  			newArray = array.map(comparator);
  		} catch (err) {
  			// fallback to an identity check - worst case scenario we have
  			// to do more DOM manipulation than we thought...
  			warnIfDebug("merge(): \"%s\" comparison failed. Falling back to identity checking", keypath);

  			oldArray = currentArray;
  			newArray = array;
  		}
  	} else {
  		oldArray = currentArray;
  		newArray = array;
  	}

  	// find new indices for members of oldArray
  	newIndices = mapOldToNewIndex(oldArray, newArray);

  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);
  }

  function stringify(item) {
  	return JSON.stringify(item);
  }

  function getComparatorFunction(comparator) {
  	// If `compare` is `true`, we use JSON.stringify to compare
  	// objects that are the same shape, but non-identical - i.e.
  	// { foo: 'bar' } !== { foo: 'bar' }
  	if (comparator === true) {
  		return stringify;
  	}

  	if (typeof comparator === "string") {
  		if (!comparators[comparator]) {
  			comparators[comparator] = function (item) {
  				return item[comparator];
  			};
  		}

  		return comparators[comparator];
  	}

  	if (typeof comparator === "function") {
  		return comparator;
  	}

  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");
  }

  var register = Viewmodel$register;

  function Viewmodel$register(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, depsByKeypath, deps;

  	if (dependant.isStatic) {
  		return; // TODO we should never get here if a dependant is static...
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		mapping.register(keypath, dependant, group);
  	} else {
  		depsByKeypath = this.deps[group] || (this.deps[group] = {});
  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);

  		deps.push(dependant);

  		if (!this.depsMap[group]) {
  			this.depsMap[group] = {};
  		}

  		if (!keypath.isRoot) {
  			register__updateDependantsMap(this, keypath, group);
  		}
  	}
  }

  function register__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent, keypathStr;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);

  		keypathStr = keypath.str;

  		// TODO find an alternative to this nasty approach
  		if (parent["_" + keypathStr] === undefined) {
  			parent["_" + keypathStr] = 0;
  			parent.push(keypath);
  		}

  		parent["_" + keypathStr] += 1;
  		keypath = keypath.parent;
  	}
  }

  var release = Viewmodel$release;

  function Viewmodel$release() {
  	return this.captureGroups.pop();
  }

  var reset = Viewmodel$reset;

  function Viewmodel$reset(data) {
  	this.data = data;
  	this.clearCache("");
  }

  var prototype_set = Viewmodel$set;

  function Viewmodel$set(keypath, value) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var mapping, computation, wrapper, keepExistingWrapper;

  	// unless data is being set for data tracking purposes
  	if (!options.noMapping) {
  		// If this data belongs to a different viewmodel,
  		// pass the change along
  		if (mapping = this.mappings[keypath.firstKey]) {
  			return mapping.set(keypath, value);
  		}
  	}

  	computation = this.computations[keypath.str];
  	if (computation) {
  		if (computation.setting) {
  			// let the other computation set() handle things...
  			return;
  		}
  		computation.set(value);
  		value = computation.get();
  	}

  	if (isEqual(this.cache[keypath.str], value)) {
  		return;
  	}

  	wrapper = this.wrapped[keypath.str];

  	// If we have a wrapper with a `reset()` method, we try and use it. If the
  	// `reset()` method returns false, the wrapper should be torn down, and
  	// (most likely) a new one should be created later
  	if (wrapper && wrapper.reset) {
  		keepExistingWrapper = wrapper.reset(value) !== false;

  		if (keepExistingWrapper) {
  			value = wrapper.get();
  		}
  	}

  	if (!computation && !keepExistingWrapper) {
  		resolveSet(this, keypath, value);
  	}

  	if (!options.silent) {
  		this.mark(keypath);
  	} else {
  		// We're setting a parent of the original target keypath (i.e.
  		// creating a fresh branch) - we need to clear the cache, but
  		// not mark it as a change
  		this.clearCache(keypath.str);
  	}
  }

  function resolveSet(viewmodel, keypath, value) {
  	var wrapper, parentValue, wrapperSet, valueSet;

  	wrapperSet = function () {
  		if (wrapper.set) {
  			wrapper.set(keypath.lastKey, value);
  		} else {
  			parentValue = wrapper.get();
  			valueSet();
  		}
  	};

  	valueSet = function () {
  		if (!parentValue) {
  			parentValue = createBranch(keypath.lastKey);
  			viewmodel.set(keypath.parent, parentValue, { silent: true });
  		}
  		parentValue[keypath.lastKey] = value;
  	};

  	wrapper = viewmodel.wrapped[keypath.parent.str];

  	if (wrapper) {
  		wrapperSet();
  	} else {
  		parentValue = viewmodel.get(keypath.parent);

  		// may have been wrapped via the above .get()
  		// call on viewmodel if this is first access via .set()!
  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {
  			wrapperSet();
  		} else {
  			valueSet();
  		}
  	}
  }

  var smartUpdate = Viewmodel$smartUpdate;

  var implicitOption = { implicit: true },
      noCascadeOption = { noCascade: true };
  function Viewmodel$smartUpdate(keypath, array, newIndices) {
  	var _this = this;

  	var dependants, oldLength, i;

  	oldLength = newIndices.length;

  	// Indices that are being removed should be marked as dirty
  	newIndices.forEach(function (newIndex, oldIndex) {
  		if (newIndex === -1) {
  			_this.mark(keypath.join(oldIndex), noCascadeOption);
  		}
  	});

  	// Update the model
  	// TODO allow existing array to be updated in place, rather than replaced?
  	this.set(keypath, array, { silent: true });

  	if (dependants = this.deps["default"][keypath.str]) {
  		dependants.filter(canShuffle).forEach(function (d) {
  			return d.shuffle(newIndices, array);
  		});
  	}

  	if (oldLength !== array.length) {
  		this.mark(keypath.join("length"), implicitOption);

  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {
  			this.mark(keypath.join(i));
  		}

  		// don't allow removed indexes beyond end of new array to trigger recomputations
  		// TODO is this still necessary, now that computations are lazy?
  		for (i = array.length; i < oldLength; i += 1) {
  			this.mark(keypath.join(i), noCascadeOption);
  		}
  	}
  }

  function canShuffle(dependant) {
  	return typeof dependant.shuffle === "function";
  }

  var prototype_teardown = Viewmodel$teardown;

  function Viewmodel$teardown() {
  	var _this = this;

  	var unresolvedImplicitDependency;

  	// Clear entire cache - this has the desired side-effect
  	// of unwrapping adapted values (e.g. arrays)
  	Object.keys(this.cache).forEach(function (keypath) {
  		return _this.clearCache(keypath);
  	});

  	// Teardown any failed lookups - we don't need them to resolve any more
  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {
  		unresolvedImplicitDependency.teardown();
  	}
  }

  var unregister = Viewmodel$unregister;

  function Viewmodel$unregister(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, deps, index;

  	if (dependant.isStatic) {
  		return;
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		return mapping.unregister(keypath, dependant, group);
  	}

  	deps = this.deps[group][keypath.str];
  	index = deps.indexOf(dependant);

  	if (index === -1) {
  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");
  	}

  	deps.splice(index, 1);

  	if (keypath.isRoot) {
  		return;
  	}

  	unregister__updateDependantsMap(this, keypath, group);
  }

  function unregister__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str];

  		parent["_" + keypath.str] -= 1;

  		if (!parent["_" + keypath.str]) {
  			// remove from parent deps map
  			removeFromArray(parent, keypath);
  			parent["_" + keypath.str] = undefined;
  		}

  		keypath = keypath.parent;
  	}
  }

  var Viewmodel = function (options) {
  	var adapt = options.adapt;
  	var data = options.data;
  	var ractive = options.ractive;
  	var computed = options.computed;
  	var mappings = options.mappings;
  	var key;
  	var mapping;

  	// TODO is it possible to remove this reference?
  	this.ractive = ractive;

  	this.adaptors = adapt;
  	this.onchange = options.onchange;

  	this.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null
  	this.cacheMap = create(null);

  	this.deps = {
  		computed: create(null),
  		"default": create(null)
  	};
  	this.depsMap = {
  		computed: create(null),
  		"default": create(null)
  	};

  	this.patternObservers = [];

  	this.specials = create(null);

  	this.wrapped = create(null);
  	this.computations = create(null);

  	this.captureGroups = [];
  	this.unresolvedImplicitDependencies = [];

  	this.changes = [];
  	this.implicitChanges = {};
  	this.noCascade = {};

  	this.data = data;

  	// set up explicit mappings
  	this.mappings = create(null);
  	for (key in mappings) {
  		this.map(getKeypath(key), mappings[key]);
  	}

  	if (data) {
  		// if data exists locally, but is missing on the parent,
  		// we transfer ownership to the parent
  		for (key in data) {
  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {
  				mapping.setValue(data[key]);
  			}
  		}
  	}

  	for (key in computed) {
  		if (mappings && key in mappings) {
  			fatal("Cannot map to a computed property ('%s')", key);
  		}

  		this.compute(getKeypath(key), computed[key]);
  	}

  	this.ready = true;
  };

  Viewmodel.prototype = {
  	adapt: prototype_adapt,
  	applyChanges: applyChanges,
  	capture: capture,
  	clearCache: clearCache,
  	compute: compute,
  	get: viewmodel_prototype_get,
  	init: viewmodel_prototype_init,
  	map: prototype_map,
  	mark: mark,
  	merge: merge,
  	register: register,
  	release: release,
  	reset: reset,
  	set: prototype_set,
  	smartUpdate: smartUpdate,
  	teardown: prototype_teardown,
  	unregister: unregister
  };

  var viewmodel_Viewmodel = Viewmodel;

  function HookQueue(event) {
  	this.hook = new hooks_Hook(event);
  	this.inProcess = {};
  	this.queue = {};
  }

  HookQueue.prototype = {

  	constructor: HookQueue,

  	begin: function (ractive) {
  		this.inProcess[ractive._guid] = true;
  	},

  	end: function (ractive) {

  		var parent = ractive.parent;

  		// If this is *isn't* a child of a component that's in process,
  		// it should call methods or fire at this point
  		if (!parent || !this.inProcess[parent._guid]) {
  			fire(this, ractive);
  		}
  		// elsewise, handoff to parent to fire when ready
  		else {
  			getChildQueue(this.queue, parent).push(ractive);
  		}

  		delete this.inProcess[ractive._guid];
  	}
  };

  function getChildQueue(queue, ractive) {
  	return queue[ractive._guid] || (queue[ractive._guid] = []);
  }

  function fire(hookQueue, ractive) {

  	var childQueue = getChildQueue(hookQueue.queue, ractive);

  	hookQueue.hook.fire(ractive);

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while (childQueue.length) {
  		fire(hookQueue, childQueue.shift());
  	}

  	delete hookQueue.queue[ractive._guid];
  }

  var hooks_HookQueue = HookQueue;

  var helpers_getComputationSignatures = getComputationSignatures;

  var helpers_getComputationSignatures__pattern = /\$\{([^\}]+)\}/g;
  function getComputationSignatures(ractive, computed) {
  	var signatures = {},
  	    key;

  	for (key in computed) {
  		signatures[key] = getComputationSignature(ractive, key, computed[key]);
  	}

  	return signatures;
  }

  function getComputationSignature(ractive, key, signature) {
  	var getter, setter;

  	if (typeof signature === "function") {
  		getter = helpers_getComputationSignatures__bind(signature, ractive);
  	}

  	if (typeof signature === "string") {
  		getter = createFunctionFromString(ractive, signature);
  	}

  	if (typeof signature === "object") {
  		if (typeof signature.get === "string") {
  			getter = createFunctionFromString(ractive, signature.get);
  		} else if (typeof signature.get === "function") {
  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);
  		} else {
  			fatal("`%s` computation must have a `get()` method", key);
  		}

  		if (typeof signature.set === "function") {
  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);
  		}
  	}

  	return { getter: getter, setter: setter };
  }

  function createFunctionFromString(ractive, str) {
  	var functionBody, hasThis, fn;

  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {
  		hasThis = true;
  		return "__ractive.get(\"" + keypath + "\")";
  	}) + ");";

  	if (hasThis) {
  		functionBody = "var __ractive = this; " + functionBody;
  	}

  	fn = new Function(functionBody);
  	return hasThis ? fn.bind(ractive) : fn;
  }

  function helpers_getComputationSignatures__bind(fn, context) {
  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;
  }

  var constructHook = new hooks_Hook("construct");
  var configHook = new hooks_Hook("config");
  var initHook = new hooks_HookQueue("init");
  var initialise__uid = 0;

  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  var initialise = initialiseRactiveInstance;

  function initialiseRactiveInstance(ractive) {
  	var userOptions = arguments[1] === undefined ? {} : arguments[1];
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var el, viewmodel;

  	if (_Ractive.DEBUG) {
  		welcome();
  	}

  	initialiseProperties(ractive, options);

  	// TODO remove this, eventually
  	defineProperty(ractive, "data", { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire(ractive, userOptions);

  	// Add registries
  	initialise__registryNames.forEach(function (name) {
  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);
  	});

  	// Create a viewmodel
  	viewmodel = new viewmodel_Viewmodel({
  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),
  		data: custom_data.init(ractive.constructor, ractive, userOptions),
  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),
  		mappings: options.mappings,
  		ractive: ractive,
  		onchange: function () {
  			return global_runloop.addRactive(ractive);
  		}
  	});

  	ractive.viewmodel = viewmodel;

  	// This can't happen earlier, because computed properties may call `ractive.get()`, etc
  	viewmodel.init();

  	// init config from Parent and options
  	config_config.init(ractive.constructor, ractive, userOptions);

  	configHook.fire(ractive);
  	initHook.begin(ractive);

  	// // If this is a component with a function `data` property, call the function
  	// // with `ractive` as context (unless the child was also a function)
  	// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {
  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );
  	// }

  	// Render virtual DOM
  	if (ractive.template) {
  		var cssIds = undefined;

  		if (options.cssIds || ractive.cssId) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if (ractive.cssId) {
  				cssIds.push(ractive.cssId);
  			}
  		}

  		ractive.fragment = new virtualdom_Fragment({
  			template: ractive.template,
  			root: ractive,
  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on
  			cssIds: cssIds
  		});
  	}

  	initHook.end(ractive);

  	// render automatically ( if `el` is specified )
  	if (el = getElement(ractive.el)) {
  		var promise = ractive.render(el, ractive.append);

  		if (_Ractive.DEBUG_PROMISES) {
  			promise["catch"](function (err) {
  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;");
  				warnIfDebug("An error happened during rendering", { ractive: ractive });
  				err.stack && logIfDebug(err.stack);

  				throw err;
  			});
  		}
  	}
  }

  function getAdaptors(ractive, protoAdapt, userOptions) {
  	var adapt, magic, modifyArrays;

  	protoAdapt = protoAdapt.map(lookup);
  	adapt = ensureArray(userOptions.adapt).map(lookup);

  	adapt = initialise__combine(protoAdapt, adapt);

  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;
  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;

  	if (magic) {
  		if (!environment__magic) {
  			throw new Error("Getters and setters (magic mode) are not supported in this browser");
  		}

  		if (modifyArrays) {
  			adapt.push(magicArray);
  		}

  		adapt.push(adaptors_magic);
  	}

  	if (modifyArrays) {
  		adapt.push(array_index);
  	}

  	return adapt;

  	function lookup(adaptor) {
  		if (typeof adaptor === "string") {
  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);

  			if (!adaptor) {
  				fatal(missingPlugin(adaptor, "adaptor"));
  			}
  		}

  		return adaptor;
  	}
  }

  function initialise__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  function initialiseProperties(ractive, options) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = "r-" + initialise__uid++;

  	// events
  	ractive._subs = create(null);

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// two-way bindings
  	ractive._twowayBindings = create(null);

  	// animations (so we can stop any in progress at teardown)
  	ractive._animations = [];

  	// nodes registry
  	ractive.nodes = {};

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// bound data functions
  	ractive._boundFunctions = [];

  	// observers
  	ractive._observers = [];

  	// properties specific to inline components
  	if (options.component) {
  		ractive.parent = options.parent;
  		ractive.container = options.container || null;
  		ractive.root = ractive.parent.root;

  		ractive.component = options.component;
  		options.component.instance = ractive;

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		ractive._inlinePartials = options.inlinePartials;
  	} else {
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null;
  	}
  }

  function deprecateRactiveData() {
  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");
  }

  function ComplexParameter(component, template, callback) {
  	this.parentFragment = component.parentFragment;
  	this.callback = callback;

  	this.fragment = new virtualdom_Fragment({
  		template: template,
  		root: component.root,
  		owner: this
  	});

  	this.update();
  }

  var initialise_ComplexParameter = ComplexParameter;

  ComplexParameter.prototype = {
  	bubble: function () {
  		if (!this.dirty) {
  			this.dirty = true;
  			global_runloop.addView(this);
  		}
  	},

  	update: function () {
  		this.callback(this.fragment.getValue());
  		this.dirty = false;
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	}
  };

  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {
  	var instance,
  	    parentFragment,
  	    ractive,
  	    fragment,
  	    container,
  	    inlinePartials = {},
  	    data = {},
  	    mappings = {},
  	    ready,
  	    resolvers = [];

  	parentFragment = component.parentFragment;
  	ractive = component.root;

  	partials = partials || {};
  	utils_object__extend(inlinePartials, partials);

  	// Make contents available as a {{>content}} partial
  	partials.content = yieldTemplate || [];

  	// set a default partial for yields with no name
  	inlinePartials[""] = partials.content;

  	if (Component.defaults.el) {
  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);
  	}

  	// find container
  	fragment = parentFragment;
  	while (fragment) {
  		if (fragment.owner.type === YIELDER) {
  			container = fragment.owner.container;
  			break;
  		}

  		fragment = fragment.parent;
  	}

  	// each attribute represents either a) data or b) a mapping
  	if (attributes) {
  		Object.keys(attributes).forEach(function (key) {
  			var attribute = attributes[key],
  			    parsed,
  			    resolver;

  			if (typeof attribute === "string") {
  				// it's static data
  				parsed = parseJSON(attribute);
  				data[key] = parsed ? parsed.value : attribute;
  			} else if (attribute === 0) {
  				// it had no '=', so we'll call it true
  				data[key] = true;
  			} else if (isArray(attribute)) {
  				// this represents dynamic data
  				if (isSingleInterpolator(attribute)) {
  					mappings[key] = {
  						origin: component.root.viewmodel,
  						keypath: undefined
  					};

  					resolver = createResolver(component, attribute[0], function (keypath) {
  						if (keypath.isSpecial) {
  							if (ready) {
  								instance.set(key, keypath.value); // TODO use viewmodel?
  							} else {
  								data[key] = keypath.value;

  								// TODO errr.... would be better if we didn't have to do this
  								delete mappings[key];
  							}
  						} else {
  							if (ready) {
  								instance.viewmodel.mappings[key].resolve(keypath);
  							} else {
  								// resolved immediately
  								mappings[key].keypath = keypath;
  							}
  						}
  					});
  				} else {
  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {
  						if (ready) {
  							instance.set(key, value); // TODO use viewmodel?
  						} else {
  							data[key] = value;
  						}
  					});
  				}

  				resolvers.push(resolver);
  			} else {
  				throw new Error("erm wut");
  			}
  		});
  	}

  	instance = create(Component.prototype);

  	initialise(instance, {
  		el: null,
  		append: true,
  		data: data,
  		partials: partials,
  		magic: ractive.magic || Component.defaults.magic,
  		modifyArrays: ractive.modifyArrays,
  		// need to inherit runtime parent adaptors
  		adapt: ractive.adapt
  	}, {
  		parent: ractive,
  		component: component,
  		container: container,
  		mappings: mappings,
  		inlinePartials: inlinePartials,
  		cssIds: parentFragment.cssIds
  	});

  	ready = true;
  	component.resolvers = resolvers;

  	return instance;
  };

  function createResolver(component, template, callback) {
  	var resolver;

  	if (template.r) {
  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);
  	} else if (template.x) {
  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);
  	} else if (template.rx) {
  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);
  	}

  	return resolver;
  }

  function isSingleInterpolator(template) {
  	return template.length === 1 && template[0].t === INTERPOLATOR;
  }

  // TODO how should event arguments be handled? e.g.
  // <widget on-foo='bar:1,2,3'/>
  // The event 'bar' will be fired on the parent instance
  // when 'foo' fires on the child, but the 1,2,3 arguments
  // will be lost

  var initialise_propagateEvents = propagateEvents;

  function propagateEvents(component, eventsDescriptor) {
  	var eventName;

  	for (eventName in eventsDescriptor) {
  		if (eventsDescriptor.hasOwnProperty(eventName)) {
  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);
  		}
  	}
  }

  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {
  	if (typeof proxyEventName !== "string") {
  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");
  	}

  	childInstance.on(eventName, function () {
  		var event, args;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if (arguments.length && arguments[0] && arguments[0].node) {
  			event = Array.prototype.shift.call(arguments);
  		}

  		args = Array.prototype.slice.call(arguments);

  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });

  		// cancel bubbling
  		return false;
  	});
  }

  var initialise_updateLiveQueries = function (component) {
  	var ancestor, query;

  	// If there's a live query for this component type, add it
  	ancestor = component.root;
  	while (ancestor) {
  		if (query = ancestor._liveComponentQueries["_" + component.name]) {
  			query.push(component.instance);
  		}

  		ancestor = ancestor.parent;
  	}
  };

  var Component_prototype_init = Component$init;
  function Component$init(options, Component) {
  	var parentFragment, root;

  	if (!Component) {
  		throw new Error("Component \"" + this.name + "\" not found");
  	}

  	parentFragment = this.parentFragment = options.parentFragment;
  	root = parentFragment.root;

  	this.root = root;
  	this.type = COMPONENT;
  	this.name = options.template.e;
  	this.index = options.index;
  	this.indexRefBindings = {};
  	this.yielders = {};
  	this.resolvers = [];

  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);
  	initialise_propagateEvents(this, options.template.v);

  	// intro, outro and decorator directives have no effect
  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {
  		warnIfDebug("The \"intro\", \"outro\" and \"decorator\" directives have no effect on components", { ractive: this.instance });
  	}

  	initialise_updateLiveQueries(this);
  }

  var Component_prototype_rebind = Component$rebind;

  function Component$rebind(oldKeypath, newKeypath) {
  	var query;

  	this.resolvers.forEach(rebind);

  	for (var k in this.yielders) {
  		if (this.yielders[k][0]) {
  			rebind(this.yielders[k][0]);
  		}
  	}

  	if (query = this.root._liveComponentQueries["_" + this.name]) {
  		query._makeDirty();
  	}

  	function rebind(x) {
  		x.rebind(oldKeypath, newKeypath);
  	}
  }

  var Component_prototype_render = Component$render;

  function Component$render() {
  	var instance = this.instance;

  	instance.render(this.parentFragment.getNode());

  	this.rendered = true;
  	return instance.fragment.detach();
  }

  var Component_prototype_toString = Component$toString;

  function Component$toString() {
  	return this.instance.fragment.toString();
  }

  var Component_prototype_unbind = Component$unbind;

  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");
  function Component$unbind() {
  	var instance = this.instance;

  	this.resolvers.forEach(methodCallers__unbind);

  	removeFromLiveComponentQueries(this);

  	instance._observers.forEach(cancel);

  	// teardown the instance
  	instance.fragment.unbind();
  	instance.viewmodel.teardown();

  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {
  		removeFromArray(instance.el.__ractive_instances__, instance);
  	}

  	Component_prototype_unbind__teardownHook.fire(instance);
  }

  function removeFromLiveComponentQueries(component) {
  	var instance, query;

  	instance = component.root;

  	do {
  		if (query = instance._liveComponentQueries["_" + component.name]) {
  			query._remove(component);
  		}
  	} while (instance = instance.parent);
  }

  var Component_prototype_unrender = Component$unrender;

  function Component$unrender(shouldDestroy) {
  	this.shouldDestroy = shouldDestroy;
  	this.instance.unrender();
  }

  var Component = function (options, Constructor) {
  	this.init(options, Constructor);
  };

  Component.prototype = {
  	detach: Component_prototype_detach,
  	find: Component_prototype_find,
  	findAll: Component_prototype_findAll,
  	findAllComponents: Component_prototype_findAllComponents,
  	findComponent: Component_prototype_findComponent,
  	findNextNode: Component_prototype_findNextNode,
  	firstNode: Component_prototype_firstNode,
  	init: Component_prototype_init,
  	rebind: Component_prototype_rebind,
  	render: Component_prototype_render,
  	toString: Component_prototype_toString,
  	unbind: Component_prototype_unbind,
  	unrender: Component_prototype_unrender
  };

  var _Component = Component;

  var Comment = function (options) {
  	this.type = COMMENT;
  	this.value = options.template.c;
  };

  Comment.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createComment(this.value);
  		}

  		return this.node;
  	},

  	toString: function () {
  		return "<!--" + this.value + "-->";
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			this.node.parentNode.removeChild(this.node);
  		}
  	}
  };

  var items_Comment = Comment;

  var Yielder = function (options) {
  	var container, component;

  	this.type = YIELDER;

  	this.container = container = options.parentFragment.root;
  	this.component = component = container.component;

  	this.container = container;
  	this.containerFragment = options.parentFragment;
  	this.parentFragment = component.parentFragment;

  	var name = this.name = options.template.n || "";

  	var template = container._inlinePartials[name];

  	if (!template) {
  		warnIfDebug("Could not find template for partial \"" + name + "\"", { ractive: options.root });
  		template = [];
  	}

  	this.fragment = new virtualdom_Fragment({
  		owner: this,
  		root: container.parent,
  		template: template,
  		pElement: this.containerFragment.pElement
  	});

  	// even though only one yielder is allowed, we need to have an array of them
  	// as it's possible to cause a yielder to be created before the last one
  	// was destroyed in the same turn of the runloop
  	if (!isArray(component.yielders[name])) {
  		component.yielders[name] = [this];
  	} else {
  		component.yielders[name].push(this);
  	}

  	global_runloop.scheduleTask(function () {
  		if (component.yielders[name].length > 1) {
  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");
  		}
  	});
  };

  Yielder.prototype = {
  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	findNextNode: function () {
  		return this.containerFragment.findNextNode(this);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	getValue: function (options) {
  		return this.fragment.getValue(options);
  	},

  	render: function () {
  		return this.fragment.render();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	unrender: function (shouldDestroy) {
  		this.fragment.unrender(shouldDestroy);
  		removeFromArray(this.component.yielders[this.name], this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var items_Yielder = Yielder;

  var Doctype = function (options) {
  	this.declaration = options.template.a;
  };

  Doctype.prototype = {
  	init: noop,
  	render: noop,
  	unrender: noop,
  	teardown: noop,
  	toString: function () {
  		return "<!DOCTYPE" + this.declaration + ">";
  	}
  };

  var items_Doctype = Doctype;

  var Fragment_prototype_init = Fragment$init;

  function Fragment$init(options) {
  	var _this = this;

  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
  	this.parent = this.owner.parentFragment;

  	// inherited properties
  	this.root = options.root;
  	this.pElement = options.pElement;
  	this.context = options.context;
  	this.index = options.index;
  	this.key = options.key;
  	this.registeredIndexRefs = [];

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

  	this.items = options.template.map(function (template, i) {
  		return createItem({
  			parentFragment: _this,
  			pElement: options.pElement,
  			template: template,
  			index: i
  		});
  	});

  	this.value = this.argsList = null;
  	this.dirtyArgs = this.dirtyValue = true;

  	this.bound = true;
  }

  function createItem(options) {
  	if (typeof options.template === "string") {
  		return new items_Text(options);
  	}

  	switch (options.template.t) {
  		case YIELDER:
  			return new items_Yielder(options);
  		case INTERPOLATOR:
  			return new items_Interpolator(options);
  		case SECTION:
  			return new _Section(options);
  		case TRIPLE:
  			return new _Triple(options);
  		case ELEMENT:
  			var constructor = undefined;
  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {
  				return new _Component(options, constructor);
  			}
  			return new _Element(options);
  		case PARTIAL:
  			return new _Partial(options);
  		case COMMENT:
  			return new items_Comment(options);
  		case DOCTYPE:
  			return new items_Doctype(options);

  		default:
  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");
  	}
  }

  var Fragment_prototype_rebind = Fragment$rebind;
  function Fragment$rebind(oldKeypath, newKeypath) {

  	// assign new context keypath if needed
  	if (!this.owner || this.owner.hasContext) {
  		assignNewKeypath(this, "context", oldKeypath, newKeypath);
  	}

  	this.items.forEach(function (item) {
  		if (item.rebind) {
  			item.rebind(oldKeypath, newKeypath);
  		}
  	});
  }

  var Fragment_prototype_render = Fragment$render;

  function Fragment$render() {
  	var result;

  	if (this.items.length === 1) {
  		result = this.items[0].render();
  	} else {
  		result = document.createDocumentFragment();

  		this.items.forEach(function (item) {
  			result.appendChild(item.render());
  		});
  	}

  	this.rendered = true;
  	return result;
  }

  var Fragment_prototype_toString = Fragment$toString;

  function Fragment$toString(escape) {
  	if (!this.items) {
  		return "";
  	}

  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");
  }

  function Fragment_prototype_toString__toString(item) {
  	return item.toString();
  }

  function toEscapedString(item) {
  	return item.toString(true);
  }

  var Fragment_prototype_unbind = Fragment$unbind;

  function Fragment$unbind() {
  	if (!this.bound) {
  		return;
  	}

  	this.items.forEach(unbindItem);
  	this.bound = false;
  }

  function unbindItem(item) {
  	if (item.unbind) {
  		item.unbind();
  	}
  }

  var Fragment_prototype_unrender = Fragment$unrender;

  function Fragment$unrender(shouldDestroy) {
  	if (!this.rendered) {
  		throw new Error("Attempted to unrender a fragment that was not rendered");
  	}

  	this.items.forEach(function (i) {
  		return i.unrender(shouldDestroy);
  	});
  	this.rendered = false;
  }

  var Fragment = function (options) {
  	this.init(options);
  };

  Fragment.prototype = {
  	bubble: prototype_bubble,
  	detach: Fragment_prototype_detach,
  	find: Fragment_prototype_find,
  	findAll: Fragment_prototype_findAll,
  	findAllComponents: Fragment_prototype_findAllComponents,
  	findComponent: Fragment_prototype_findComponent,
  	findNextNode: prototype_findNextNode,
  	firstNode: prototype_firstNode,
  	getArgsList: getArgsList,
  	getNode: getNode,
  	getValue: prototype_getValue,
  	init: Fragment_prototype_init,
  	rebind: Fragment_prototype_rebind,
  	registerIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		if (idxs.indexOf(idx) === -1) {
  			idxs.push(idx);
  		}
  	},
  	render: Fragment_prototype_render,
  	toString: Fragment_prototype_toString,
  	unbind: Fragment_prototype_unbind,
  	unregisterIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		idxs.splice(idxs.indexOf(idx), 1);
  	},
  	unrender: Fragment_prototype_unrender
  };

  var virtualdom_Fragment = Fragment;

  var prototype_reset = Ractive$reset;
  var shouldRerender = ["template", "partials", "components", "decorators", "events"],
      resetHook = new hooks_Hook("reset");
  function Ractive$reset(data) {
  	var promise, wrapper, changes, i, rerender;

  	data = data || {};

  	if (typeof data !== "object") {
  		throw new Error("The reset method takes either no arguments, or an object containing new data");
  	}

  	// If the root object is wrapped, try and use the wrapper's reset value
  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {
  		if (wrapper.reset(data) === false) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.reset(data);
  		}
  	} else {
  		this.viewmodel.reset(data);
  	}

  	// reset config items and track if need to rerender
  	changes = config_config.reset(this);

  	i = changes.length;
  	while (i--) {
  		if (shouldRerender.indexOf(changes[i]) > -1) {
  			rerender = true;
  			break;
  		}
  	}

  	if (rerender) {
  		var component = undefined;

  		this.viewmodel.mark(rootKeypath);

  		// Is this is a component, we need to set the `shouldDestroy`
  		// flag, otherwise it will assume by default that a parent node
  		// will be detached, and therefore it doesn't need to bother
  		// detaching its own nodes
  		if (component = this.component) {
  			component.shouldDestroy = true;
  		}

  		this.unrender();

  		if (component) {
  			component.shouldDestroy = false;
  		}

  		// If the template changed, we need to destroy the parallel DOM
  		// TODO if we're here, presumably it did?
  		if (this.fragment.template !== this.template) {
  			this.fragment.unbind();

  			this.fragment = new virtualdom_Fragment({
  				template: this.template,
  				root: this,
  				owner: this
  			});
  		}

  		promise = this.render(this.el, this.anchor);
  	} else {
  		promise = global_runloop.start(this, true);
  		this.viewmodel.mark(rootKeypath);
  		global_runloop.end();
  	}

  	resetHook.fire(this, data);

  	return promise;
  }

  var resetPartial = function (name, partial) {
  	var promise,
  	    collection = [];

  	function collect(source, dest, ractive) {
  		// if this is a component and it has its own partial, bail
  		if (ractive && ractive.partials[name]) return;

  		source.forEach(function (item) {
  			// queue to rerender if the item is a partial and the current name matches
  			if (item.type === PARTIAL && item.getPartialName() === name) {
  				dest.push(item);
  			}

  			// if it has a fragment, process its items
  			if (item.fragment) {
  				collect(item.fragment.items, dest, ractive);
  			}

  			// or if it has fragments
  			if (isArray(item.fragments)) {
  				collect(item.fragments, dest, ractive);
  			}

  			// or if it is itself a fragment, process its items
  			else if (isArray(item.items)) {
  				collect(item.items, dest, ractive);
  			}

  			// or if it is a component, step in and process its items
  			else if (item.type === COMPONENT && item.instance) {
  				collect(item.instance.fragment.items, dest, item.instance);
  			}

  			// if the item is an element, process its attributes too
  			if (item.type === ELEMENT) {
  				if (isArray(item.attributes)) {
  					collect(item.attributes, dest, ractive);
  				}

  				if (isArray(item.conditionalAttributes)) {
  					collect(item.conditionalAttributes, dest, ractive);
  				}
  			}
  		});
  	}

  	collect(this.fragment.items, collection);
  	this.partials[name] = partial;

  	promise = global_runloop.start(this, true);

  	collection.forEach(function (item) {
  		item.value = undefined;
  		item.setValue(name);
  	});

  	global_runloop.end();

  	return promise;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  var resetTemplate = Ractive$resetTemplate;
  function Ractive$resetTemplate(template) {
  	var transitionsEnabled, component;

  	template_template.init(null, this, { template: template });

  	transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	if (component = this.component) {
  		component.shouldDestroy = true;
  	}

  	this.unrender();

  	if (component) {
  		component.shouldDestroy = false;
  	}

  	// remove existing fragment and create new one
  	this.fragment.unbind();
  	this.fragment = new virtualdom_Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	this.render(this.el, this.anchor);

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse = makeArrayMethod("reverse");

  var Ractive_prototype_set = Ractive$set;

  function Ractive$set(keypath, value) {
  	var map, promise;

  	promise = global_runloop.start(this, true);

  	// Set multiple keypaths in one go
  	if (isObject(keypath)) {
  		map = keypath;

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				value = map[keypath];
  				set(this, keypath, value);
  			}
  		}
  	}

  	// Set a single keypath
  	else {
  		set(this, keypath, value);
  	}

  	global_runloop.end();

  	return promise;
  }

  function set(ractive, keypath, value) {
  	keypath = getKeypath(normalise(keypath));

  	if (keypath.isPattern) {
  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {
  			ractive.viewmodel.set(keypath, value);
  		});
  	} else {
  		ractive.viewmodel.set(keypath, value);
  	}
  }

  var shift = makeArrayMethod("shift");

  var prototype_sort = makeArrayMethod("sort");

  var splice = makeArrayMethod("splice");

  var subtract = Ractive$subtract;
  function Ractive$subtract(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? -1 : -d);
  }

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  var Ractive_prototype_teardown = Ractive$teardown;

  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");
  function Ractive$teardown() {
  	var promise;

  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach(cancel);

  	if (this.fragment.rendered && this.el.__ractive_instances__) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}

  	this.shouldDestroy = true;
  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();

  	Ractive_prototype_teardown__teardownHook.fire(this);

  	this._boundFunctions.forEach(deleteFunctionCopy);

  	return promise;
  }

  function deleteFunctionCopy(bound) {
  	delete bound.fn[bound.prop];
  }

  var toggle = Ractive$toggle;
  function Ractive$toggle(keypath) {
  	var _this = this;

  	if (typeof keypath !== "string") {
  		throw new TypeError(badArguments);
  	}

  	var changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			changes[keypath.str] = !_this.viewmodel.get(keypath);
  		});

  		return this.set(changes);
  	}

  	return this.set(keypath, !this.get(keypath));
  }

  var toHTML = Ractive$toHTML;

  function Ractive$toHTML() {
  	return this.fragment.toString(true);
  }

  var Ractive_prototype_unrender = Ractive$unrender;
  var unrenderHook = new hooks_Hook("unrender");
  function Ractive$unrender() {
  	var promise, shouldDestroy;

  	if (!this.fragment.rendered) {
  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");
  		return utils_Promise.resolve();
  	}

  	promise = global_runloop.start(this, true);

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;

  	// Cancel any animations in progress
  	while (this._animations[0]) {
  		this._animations[0].stop(); // it will remove itself from the index
  	}

  	this.fragment.unrender(shouldDestroy);

  	removeFromArray(this.el.__ractive_instances__, this);

  	unrenderHook.fire(this);

  	global_runloop.end();
  	return promise;
  }

  var unshift = makeArrayMethod("unshift");

  var Ractive_prototype_update = Ractive$update;
  var updateHook = new hooks_Hook("update");
  function Ractive$update(keypath) {
  	var promise;

  	keypath = getKeypath(keypath) || rootKeypath;

  	promise = global_runloop.start(this, true);
  	this.viewmodel.mark(keypath);
  	global_runloop.end();

  	updateHook.fire(this, keypath);

  	return promise;
  }

  var prototype_updateModel = Ractive$updateModel;

  function Ractive$updateModel(keypath, cascade) {
  	var values, key, bindings;

  	if (typeof keypath === "string" && !cascade) {
  		bindings = this._twowayBindings[keypath];
  	} else {
  		bindings = [];

  		for (key in this._twowayBindings) {
  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {
  				// TODO is this right?
  				bindings.push.apply(bindings, this._twowayBindings[key]);
  			}
  		}
  	}

  	values = consolidate(this, bindings);
  	return this.set(values);
  }

  function consolidate(ractive, bindings) {
  	var values = {},
  	    checkboxGroups = [];

  	bindings.forEach(function (b) {
  		var oldValue, newValue;

  		// special case - radio name bindings
  		if (b.radioName && !b.element.node.checked) {
  			return;
  		}

  		// special case - checkbox name bindings come in groups, so
  		// we want to get the value once at most
  		if (b.checkboxName) {
  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {
  				checkboxGroups.push(b.keypath);
  				checkboxGroups[b.keypath.str] = b;
  			}

  			return;
  		}

  		oldValue = b.attribute.value;
  		newValue = b.getValue();

  		if (arrayContentsMatch(oldValue, newValue)) {
  			return;
  		}

  		if (!isEqual(oldValue, newValue)) {
  			values[b.keypath.str] = newValue;
  		}
  	});

  	// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
  	if (checkboxGroups.length) {
  		checkboxGroups.forEach(function (keypath) {
  			var binding, oldValue, newValue;

  			binding = checkboxGroups[keypath.str]; // one to represent the entire group
  			oldValue = binding.attribute.value;
  			newValue = binding.getValue();

  			if (!arrayContentsMatch(oldValue, newValue)) {
  				values[keypath.str] = newValue;
  			}
  		});
  	}

  	return values;
  }

  var prototype = {
  	add: prototype_add,
  	animate: prototype_animate,
  	detach: prototype_detach,
  	find: prototype_find,
  	findAll: prototype_findAll,
  	findAllComponents: prototype_findAllComponents,
  	findComponent: prototype_findComponent,
  	findContainer: findContainer,
  	findParent: findParent,
  	fire: prototype_fire,
  	get: prototype_get,
  	insert: insert,
  	merge: prototype_merge,
  	observe: observe,
  	observeOnce: observeOnce,
  	off: off,
  	on: on,
  	once: once,
  	pop: pop,
  	push: push,
  	render: prototype_render,
  	reset: prototype_reset,
  	resetPartial: resetPartial,
  	resetTemplate: resetTemplate,
  	reverse: reverse,
  	set: Ractive_prototype_set,
  	shift: shift,
  	sort: prototype_sort,
  	splice: splice,
  	subtract: subtract,
  	teardown: Ractive_prototype_teardown,
  	toggle: toggle,
  	toHTML: toHTML,
  	toHtml: toHTML,
  	unrender: Ractive_prototype_unrender,
  	unshift: unshift,
  	update: Ractive_prototype_update,
  	updateModel: prototype_updateModel
  };

  var wrapMethod = function (method, superMethod, force) {

  	if (force || needsSuper(method, superMethod)) {

  		return function () {

  			var hasSuper = ("_super" in this),
  			    _super = this._super,
  			    result;

  			this._super = superMethod;

  			result = method.apply(this, arguments);

  			if (hasSuper) {
  				this._super = _super;
  			}

  			return result;
  		};
  	} else {
  		return method;
  	}
  };

  function needsSuper(method, superMethod) {
  	return typeof superMethod === "function" && /_super/.test(method);
  }

  var unwrapExtended = unwrap;

  function unwrap(Child) {
  	var options = {};

  	while (Child) {
  		addRegistries(Child, options);
  		addOtherOptions(Child, options);

  		if (Child._Parent !== _Ractive) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries(Child, options) {
  	config_registries.forEach(function (r) {
  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);
  	});
  }

  function addRegistry(target, options, name) {
  	var registry,
  	    keys = Object.keys(target[name]);

  	if (!keys.length) {
  		return;
  	}

  	if (!(registry = options[name])) {
  		registry = options[name] = {};
  	}

  	keys.filter(function (key) {
  		return !(key in registry);
  	}).forEach(function (key) {
  		return registry[key] = target[name][key];
  	});
  }

  function addOtherOptions(Child, options) {
  	Object.keys(Child.prototype).forEach(function (key) {
  		if (key === "computed") {
  			return;
  		}

  		var value = Child.prototype[key];

  		if (!(key in options)) {
  			options[key] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {

  			var result = undefined,
  			    needsSuper = value._method;

  			if (needsSuper) {
  				value = value._method;
  			}

  			// rewrap bound directly to parent fn
  			result = wrapMethod(options[key]._method, value);

  			if (needsSuper) {
  				result._method = result;
  			}

  			options[key] = result;
  		}
  	});
  }

  var _extend = _extend__extend;

  function _extend__extend() {
  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
  		options[_key] = arguments[_key];
  	}

  	if (!options.length) {
  		return extendOne(this);
  	} else {
  		return options.reduce(extendOne, this);
  	}
  }

  function extendOne(Parent) {
  	var options = arguments[1] === undefined ? {} : arguments[1];

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if (options.prototype instanceof _Ractive) {
  		options = unwrapExtended(options);
  	}

  	Child = function (options) {
  		if (!(this instanceof Child)) return new Child(options);
  		initialise(this, options);
  	};

  	proto = create(Parent.prototype);
  	proto.constructor = Child;

  	// Static properties
  	defineProperties(Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: _extend__extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config_config.extend(Parent, proto, options);

  	custom_data.extend(Parent, proto, options);

  	if (options.computed) {
  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);
  	}

  	Child.prototype = proto;

  	return Child;
  }

  var getNodeInfo = function (node) {
  	var info = {},
  	    priv,
  	    indices;

  	if (!node || !(priv = node._ractive)) {
  		return info;
  	}

  	info.ractive = priv.root;
  	info.keypath = priv.keypath.str;
  	info.index = {};

  	// find all index references and resolve them
  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {
  		info.index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	return info;
  };

  var Ractive, properties;

  // Main Ractive required object
  Ractive = function (options) {
  	if (!(this instanceof Ractive)) return new Ractive(options);
  	initialise(this, options);
  };

  // Ractive properties
  properties = {

  	// debug flag
  	DEBUG: { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend: { value: _extend },
  	getNodeInfo: { value: getNodeInfo },
  	parse: { value: _parse },

  	// Namespaced constructors
  	Promise: { value: utils_Promise },

  	// support
  	svg: { value: svg },
  	magic: { value: environment__magic },

  	// version
  	VERSION: { value: "0.7.3" },

  	// Plugins
  	adaptors: { writable: true, value: {} },
  	components: { writable: true, value: {} },
  	decorators: { writable: true, value: {} },
  	easing: { writable: true, value: static_easing },
  	events: { writable: true, value: {} },
  	interpolators: { writable: true, value: static_interpolators },
  	partials: { writable: true, value: {} },
  	transitions: { writable: true, value: {} }
  };

  // Ractive properties
  defineProperties(Ractive, properties);

  Ractive.prototype = utils_object__extend(prototype, config_defaults);

  Ractive.prototype.constructor = Ractive;

  // alias prototype as defaults
  Ractive.defaults = Ractive.prototype;

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = "function";

  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {
  	throw new Error("It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");
  }

  var _Ractive = Ractive;

  return _Ractive;

}));
//# sourceMappingURL=ractive.js.map

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/ractive/ractive.js","/../../node_modules/ractive")
},{"buffer":2,"rH1JPG":8}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ractive = require('ractive');
var firebase = require('firebase');
var $ = require('jquery');
var cookie = require('js-cookie');

var config = {
    apiKey: "AIzaSyCM6QLlRjQfkRSfG_lsi3zNS2qBGccYLhw",
    authDomain: "chatapp-53089.firebaseapp.com",
    databaseURL: "https://chatapp-53089.firebaseio.com",
    storageBucket: "chatapp-53089.appspot.com",
};
firebase.initializeApp(config);

var chatRef = firebase.database().ref();

global.fb = firebase;
global.cRef = chatRef;

function generateRef(refno) {
    return firebase.database().ref(refno);
}

function getLastKey(message) {
    chatRef.limitToLast(1).once(
        'child_added', function(snapshot) {
            var newRef = parseInt(snapshot.key, 10) + 1;
            var ref = generateRef(newRef);
            addMessage(ref, message);
        }
    );
}

function addMessage(ref, message) {
    ref.transaction(function (messagePos) {
        console.log(messagePos);
        if (messagePos) {  // message exists
            console.log('fail, incrementing index');
            var newIndex = parseInt(messagePos.key, 10) + 1;
            var newRef = generateRef(newIndex);
        } else {
            console.log('success');
            ref.set(message);
        }
    });
}

function genMessage(message, time, username) {
   return {
       message, time, username
   };
}

var msg = genMessage('testmsg', '1111', 'es');
getLastKey(msg);
global.msg = msg;
global.aM = addMessage;

}).call(this,require("rH1JPG"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_35c78192.js","/")
},{"buffer":2,"firebase":3,"jquery":6,"js-cookie":7,"rH1JPG":8,"ractive":9}]},{},[10])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcy9Db2Rlcy93ZWJzaXRlL2hvd2FyZC9maXJlY2hhdDMvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9lcy9Db2Rlcy93ZWJzaXRlL2hvd2FyZC9maXJlY2hhdDMvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZWJhc2UtYnJvd3Nlci5qcyIsIi9Vc2Vycy9lcy9Db2Rlcy93ZWJzaXRlL2hvd2FyZC9maXJlY2hhdDMvbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2ZpcmViYXNlLmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9lcy9Db2Rlcy93ZWJzaXRlL2hvd2FyZC9maXJlY2hhdDMvbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIi9Vc2Vycy9lcy9Db2Rlcy93ZWJzaXRlL2hvd2FyZC9maXJlY2hhdDMvbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9zcmMvanMuY29va2llLmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9ub2RlX21vZHVsZXMvcmFjdGl2ZS9yYWN0aXZlLmpzIiwiL1VzZXJzL2VzL0NvZGVzL3dlYnNpdGUvaG93YXJkL2ZpcmVjaGF0My9zcmMvanMvZmFrZV8zNWM3ODE5Mi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3VnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwickgxSlBHXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKipcbiAqICBGaXJlYmFzZSBsaWJyYXJpZXMgZm9yIGJyb3dzZXIgLSBucG0gcGFja2FnZS5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKTtcbiAqL1xucmVxdWlyZSgnLi9maXJlYmFzZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmaXJlYmFzZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZWJhc2UtYnJvd3Nlci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9maXJlYmFzZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qISBAbGljZW5zZSBGaXJlYmFzZSB2My4wLjNcbiAgICBCdWlsZDogMy4wLjMtcmMuMVxuICAgIFRlcm1zOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS90ZXJtcyAqL1xuKGZ1bmN0aW9uKCkgeyB2YXIgaD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3c9PT10aGlzP3RoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dGhpcyxsPWZ1bmN0aW9uKCl7aC5TeW1ib2x8fChoLlN5bWJvbD1hYSk7bD1mdW5jdGlvbigpe319LGJhPTAsYWE9ZnVuY3Rpb24oYSl7cmV0dXJuXCJqc2NvbXBfc3ltYm9sX1wiK2ErYmErK30sbT1mdW5jdGlvbigpe2woKTtoLlN5bWJvbC5pdGVyYXRvcnx8KGguU3ltYm9sLml0ZXJhdG9yPWguU3ltYm9sKFwiaXRlcmF0b3JcIikpO209ZnVuY3Rpb24oKXt9fSxjYT1mdW5jdGlvbigpe3ZhciBhPVtcIm5leHRcIixcImVycm9yXCIsXCJjb21wbGV0ZVwiXTttKCk7aWYoYVtoLlN5bWJvbC5pdGVyYXRvcl0pcmV0dXJuIGFbaC5TeW1ib2wuaXRlcmF0b3JdKCk7dmFyIGI9MDtyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybiBiPT1hLmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6YVtiKytdfX19fSxwPWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ITAsXG52YWx1ZTp2b2lkIDB9fSxxPWZ1bmN0aW9uKGEsYil7YSBpbnN0YW5jZW9mIFN0cmluZyYmKGE9U3RyaW5nKGEpKTt2YXIgYz0wO2woKTttKCk7dmFyIGQ9e30sZT0oZC5uZXh0PWZ1bmN0aW9uKCl7aWYoYzxhLmxlbmd0aCl7dmFyIGQ9YysrO3JldHVybnt2YWx1ZTpiKGQsYVtkXSksZG9uZTohMX19ZS5uZXh0PXA7cmV0dXJuIHAoKX0sZFtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LGQpO3JldHVybiBlfSxyPWZ1bmN0aW9uKGEsYil7IUFycmF5LnByb3RvdHlwZVthXSYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSxhLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCx2YWx1ZTpifSl9LHQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1hKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgJ3RoaXMnIHZhbHVlIGZvciBTdHJpbmcucHJvdG90eXBlLlwiK1xuYitcIiBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZFwiKTt9LHU9ZnVuY3Rpb24oYSxiKXtpZihhIGluc3RhbmNlb2YgUmVnRXhwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBTdHJpbmcucHJvdG90eXBlLlwiK2IrXCIgbXVzdCBub3QgYmUgYSByZWd1bGFyIGV4cHJlc3Npb25cIik7fSxkYT1mdW5jdGlvbihhKXt0KHRoaXMsXCJyZXBlYXRcIik7dmFyIGI9U3RyaW5nKHRoaXMpO2lmKDA+YXx8MTM0MjE3NzI3OTxhKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb3VudCB2YWx1ZVwiKTthfD0wO2Zvcih2YXIgYz1cIlwiO2E7KWlmKGEmMSYmKGMrPWIpLGE+Pj49MSliKz1iO3JldHVybiBjfSxlYT1mdW5jdGlvbihhKXt0KHRoaXMsXCJjb2RlUG9pbnRBdFwiKTt2YXIgYj1TdHJpbmcodGhpcyksYz1iLmxlbmd0aDthPU51bWJlcihhKXx8MDtpZigwPD1hJiZhPGMpe2F8PTA7dmFyIGQ9Yi5jaGFyQ29kZUF0KGEpO2lmKDU1Mjk2PmR8fDU2MzE5PGR8fGErMT09PWMpcmV0dXJuIGQ7XG5hPWIuY2hhckNvZGVBdChhKzEpO3JldHVybiA1NjMyMD5hfHw1NzM0MzxhP2Q6MTAyNCooZC01NTI5NikrYSs5MjE2fX0sZmE9ZnVuY3Rpb24oYSxiKXtiPXZvaWQgMD09PWI/MDpiO3UoYSxcImluY2x1ZGVzXCIpO3QodGhpcyxcImluY2x1ZGVzXCIpO3JldHVybi0xIT09U3RyaW5nKHRoaXMpLmluZGV4T2YoYSxiKX0sZ2E9ZnVuY3Rpb24oYSxiKXtiPXZvaWQgMD09PWI/MDpiO3UoYSxcInN0YXJ0c1dpdGhcIik7dCh0aGlzLFwic3RhcnRzV2l0aFwiKTt2YXIgYz1TdHJpbmcodGhpcyk7YSs9XCJcIjt2YXIgZD1jLmxlbmd0aCxlPWEubGVuZ3RoO2I9TWF0aC5tYXgoMCxNYXRoLm1pbihifDAsYy5sZW5ndGgpKTtmb3IodmFyIGY9MDtmPGUmJmI8ZDspaWYoY1tiKytdIT1hW2YrK10pcmV0dXJuITE7cmV0dXJuIGY+PWV9LGhhPWZ1bmN0aW9uKGEsYil7dShhLFwiZW5kc1dpdGhcIik7dCh0aGlzLFwiZW5kc1dpdGhcIik7dmFyIGM9U3RyaW5nKHRoaXMpO2ErPVwiXCI7dm9pZCAwPT09YiYmKGI9Yy5sZW5ndGgpO1xuYj1NYXRoLm1heCgwLE1hdGgubWluKGJ8MCxjLmxlbmd0aCkpO2Zvcih2YXIgZD1hLmxlbmd0aDswPGQmJjA8YjspaWYoY1stLWJdIT1hWy0tZF0pcmV0dXJuITE7cmV0dXJuIDA+PWR9O1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGh8fChTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoPWhhKTtTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGh8fChTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg9Z2EpO1N0cmluZy5wcm90b3R5cGUuaW5jbHVkZXN8fChTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzPWZhKTtTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0fHwoU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdD1lYSk7U3RyaW5nLnByb3RvdHlwZS5yZXBlYXR8fChTdHJpbmcucHJvdG90eXBlLnJlcGVhdD1kYSk7cihcInZhbHVlc1wiLGZ1bmN0aW9uKCl7cmV0dXJuIHEodGhpcyxmdW5jdGlvbihhLGIpe3JldHVybiBifSl9KTtyKFwia2V5c1wiLGZ1bmN0aW9uKCl7cmV0dXJuIHEodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gYX0pfSk7XG5yKFwiZW50cmllc1wiLGZ1bmN0aW9uKCl7cmV0dXJuIHEodGhpcyxmdW5jdGlvbihhLGIpe3JldHVyblthLGJdfSl9KTtcbnZhciB2PXRoaXMsdz1mdW5jdGlvbigpe30seD1mdW5jdGlvbihhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKXJldHVyblwiZnVuY3Rpb25cIn1lbHNlIHJldHVyblwibnVsbFwiO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn0seT1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXgoYSl9LGlhPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfSxqYT1mdW5jdGlvbihhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX0sej1mdW5jdGlvbihhLGIsYyl7ej1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP1xuaWE6amE7cmV0dXJuIHouYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrYT1mdW5jdGlvbihhLGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYj1jLnNsaWNlKCk7Yi5wdXNoLmFwcGx5KGIsYXJndW1lbnRzKTtyZXR1cm4gYS5hcHBseSh0aGlzLGIpfX0sbGE9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuYmE9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLmFhPWZ1bmN0aW9uKGEsYyxmKXtmb3IodmFyIGs9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0yKSxnPTI7Zzxhcmd1bWVudHMubGVuZ3RoO2crKylrW2ctMl09YXJndW1lbnRzW2ddO3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLGspfX07ZnVuY3Rpb24gX19leHRlbmRzKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTthLnByb3RvdHlwZT1udWxsPT09Yj9PYmplY3QuY3JlYXRlKGIpOihjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxuZXcgYyl9XG5mdW5jdGlvbiBfX2RlY29yYXRlKGEsYixjLGQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGgsZj0zPmU/YjpudWxsPT09ZD9kPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYixjKTpkLGs7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlmPVJlZmxlY3QuZGVjb3JhdGUoYSxiLGMsZCk7ZWxzZSBmb3IodmFyIGc9YS5sZW5ndGgtMTswPD1nO2ctLSlpZihrPWFbZ10pZj0oMz5lP2soZik6MzxlP2soYixjLGYpOmsoYixjKSl8fGY7cmV0dXJuIDM8ZSYmZiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsYyxmKSxmfWZ1bmN0aW9uIF9fbWV0YWRhdGEoYSxiKXtpZihcIm9iamVjdFwiPT09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhKXJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGEsYil9XG52YXIgX19wYXJhbT1mdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbihjLGQpe2IoYyxkLGEpfX0sX19hd2FpdGVyPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBuZXcgKGN8fChjPVByb21pc2UpKShmdW5jdGlvbihlLGYpe2Z1bmN0aW9uIGsoYSl7dHJ5e24oZC5uZXh0KGEpKX1jYXRjaChiKXtmKGIpfX1mdW5jdGlvbiBnKGEpe3RyeXtuKGQudGhyb3coYSkpfWNhdGNoKGIpe2YoYil9fWZ1bmN0aW9uIG4oYSl7YS5kb25lP2UoYS52YWx1ZSk6KG5ldyBjKGZ1bmN0aW9uKGIpe2IoYS52YWx1ZSl9KSkudGhlbihrLGcpfW4oKGQ9ZC5hcHBseShhLGIpKS5uZXh0KCkpfSl9O3ZhciBBPWZ1bmN0aW9uKGEpe2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsQSk7ZWxzZXt2YXIgYj1FcnJvcigpLnN0YWNrO2ImJih0aGlzLnN0YWNrPWIpfWEmJih0aGlzLm1lc3NhZ2U9U3RyaW5nKGEpKX07bGEoQSxFcnJvcik7QS5wcm90b3R5cGUubmFtZT1cIkN1c3RvbUVycm9yXCI7dmFyIG1hPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEuc3BsaXQoXCIlc1wiKSxkPVwiXCIsZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7ZS5sZW5ndGgmJjE8Yy5sZW5ndGg7KWQrPWMuc2hpZnQoKStlLnNoaWZ0KCk7cmV0dXJuIGQrYy5qb2luKFwiJXNcIil9O3ZhciBCPWZ1bmN0aW9uKGEsYil7Yi51bnNoaWZ0KGEpO0EuY2FsbCh0aGlzLG1hLmFwcGx5KG51bGwsYikpO2Iuc2hpZnQoKX07bGEoQixBKTtCLnByb3RvdHlwZS5uYW1lPVwiQXNzZXJ0aW9uRXJyb3JcIjt2YXIgbmE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJBc3NlcnRpb24gZmFpbGVkXCI7aWYoYyl2YXIgZT1lKyhcIjogXCIrYyksZj1kO2Vsc2UgYSYmKGUrPVwiOiBcIithLGY9Yik7dGhyb3cgbmV3IEIoXCJcIitlLGZ8fFtdKTt9LEM9ZnVuY3Rpb24oYSxiLGMpe2F8fG5hKFwiXCIsbnVsbCxiLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSl9LEQ9ZnVuY3Rpb24oYSxiLGMpe3koYSl8fG5hKFwiRXhwZWN0ZWQgZnVuY3Rpb24gYnV0IGdvdCAlczogJXMuXCIsW3goYSksYV0sYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpfTt2YXIgRT1mdW5jdGlvbihhLGIsYyl7dGhpcy5TPWM7dGhpcy5MPWE7dGhpcy5VPWI7dGhpcy5zPTA7dGhpcy5vPW51bGx9O0UucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhOzA8dGhpcy5zPyh0aGlzLnMtLSxhPXRoaXMubyx0aGlzLm89YS5uZXh0LGEubmV4dD1udWxsKTphPXRoaXMuTCgpO3JldHVybiBhfTtFLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYSl7dGhpcy5VKGEpO3RoaXMuczx0aGlzLlMmJih0aGlzLnMrKyxhLm5leHQ9dGhpcy5vLHRoaXMubz1hKX07dmFyIEY7YTp7dmFyIG9hPXYubmF2aWdhdG9yO2lmKG9hKXt2YXIgcGE9b2EudXNlckFnZW50O2lmKHBhKXtGPXBhO2JyZWFrIGF9fUY9XCJcIn07dmFyIHFhPWZ1bmN0aW9uKGEpe3Yuc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGE7fSwwKX0sRyxyYT1mdW5jdGlvbigpe3ZhciBhPXYuTWVzc2FnZUNoYW5uZWw7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93LnBvc3RNZXNzYWdlJiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciYmLTE9PUYuaW5kZXhPZihcIlByZXN0b1wiKSYmKGE9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSUZSQU1FXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjthLnNyYz1cIlwiO2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTt2YXIgYj1hLmNvbnRlbnRXaW5kb3csYT1iLmRvY3VtZW50O2Eub3BlbigpO2Eud3JpdGUoXCJcIik7YS5jbG9zZSgpO3ZhciBjPVwiY2FsbEltbWVkaWF0ZVwiK01hdGgucmFuZG9tKCksZD1cImZpbGU6XCI9PWIubG9jYXRpb24ucHJvdG9jb2w/XCIqXCI6Yi5sb2NhdGlvbi5wcm90b2NvbCtcblwiLy9cIitiLmxvY2F0aW9uLmhvc3QsYT16KGZ1bmN0aW9uKGEpe2lmKChcIipcIj09ZHx8YS5vcmlnaW49PWQpJiZhLmRhdGE9PWMpdGhpcy5wb3J0MS5vbm1lc3NhZ2UoKX0sdGhpcyk7Yi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGEsITEpO3RoaXMucG9ydDE9e307dGhpcy5wb3J0Mj17cG9zdE1lc3NhZ2U6ZnVuY3Rpb24oKXtiLnBvc3RNZXNzYWdlKGMsZCl9fX0pO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmLTE9PUYuaW5kZXhPZihcIlRyaWRlbnRcIikmJi0xPT1GLmluZGV4T2YoXCJNU0lFXCIpKXt2YXIgYj1uZXcgYSxjPXt9LGQ9YztiLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKHZvaWQgMCE9PWMubmV4dCl7Yz1jLm5leHQ7dmFyIGE9Yy5GO2MuRj1udWxsO2EoKX19O3JldHVybiBmdW5jdGlvbihhKXtkLm5leHQ9e0Y6YX07ZD1kLm5leHQ7Yi5wb3J0Mi5wb3N0TWVzc2FnZSgwKX19cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluXG5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiU0NSSVBUXCIpP2Z1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJTQ1JJUFRcIik7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPW51bGw7YSgpO2E9bnVsbH07ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXt2LnNldFRpbWVvdXQoYSwwKX19O3ZhciBIPWZ1bmN0aW9uKCl7dGhpcy52PXRoaXMuZj1udWxsfSxzYT1uZXcgRShmdW5jdGlvbigpe3JldHVybiBuZXcgSX0sZnVuY3Rpb24oYSl7YS5yZXNldCgpfSwxMDApO0gucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGIpe3ZhciBjPXNhLmdldCgpO2Muc2V0KGEsYik7dGhpcy52P3RoaXMudi5uZXh0PWM6KEMoIXRoaXMuZiksdGhpcy5mPWMpO3RoaXMudj1jfTtILnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt2YXIgYT1udWxsO3RoaXMuZiYmKGE9dGhpcy5mLHRoaXMuZj10aGlzLmYubmV4dCx0aGlzLmZ8fCh0aGlzLnY9bnVsbCksYS5uZXh0PW51bGwpO3JldHVybiBhfTt2YXIgST1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLnNjb3BlPXRoaXMuQj1udWxsfTtJLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLkI9YTt0aGlzLnNjb3BlPWI7dGhpcy5uZXh0PW51bGx9O1xuSS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLm5leHQ9dGhpcy5zY29wZT10aGlzLkI9bnVsbH07dmFyIEw9ZnVuY3Rpb24oYSxiKXtKfHx0YSgpO0t8fChKKCksSz0hMCk7dWEuYWRkKGEsYil9LEosdGE9ZnVuY3Rpb24oKXtpZih2LlByb21pc2UmJnYuUHJvbWlzZS5yZXNvbHZlKXt2YXIgYT12LlByb21pc2UucmVzb2x2ZSh2b2lkIDApO0o9ZnVuY3Rpb24oKXthLnRoZW4odmEpfX1lbHNlIEo9ZnVuY3Rpb24oKXt2YXIgYT12YSxjOyEoYz0heSh2LnNldEltbWVkaWF0ZSkpJiYoYz12LldpbmRvdyYmdi5XaW5kb3cucHJvdG90eXBlKSYmKGM9LTE9PUYuaW5kZXhPZihcIkVkZ2VcIikmJnYuV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PXYuc2V0SW1tZWRpYXRlKTtjPyhHfHwoRz1yYSgpKSxHKGEpKTp2LnNldEltbWVkaWF0ZShhKX19LEs9ITEsdWE9bmV3IEgsdmE9ZnVuY3Rpb24oKXtmb3IodmFyIGE7YT11YS5yZW1vdmUoKTspe3RyeXthLkIuY2FsbChhLnNjb3BlKX1jYXRjaChiKXtxYShiKX1zYS5wdXQoYSl9Sz0hMX07dmFyIE89ZnVuY3Rpb24oYSxiKXt0aGlzLmI9MDt0aGlzLks9dm9pZCAwO3RoaXMuaj10aGlzLmc9dGhpcy51PW51bGw7dGhpcy5tPXRoaXMuQT0hMTtpZihhIT13KXRyeXt2YXIgYz10aGlzO2EuY2FsbChiLGZ1bmN0aW9uKGEpe00oYywyLGEpfSxmdW5jdGlvbihhKXt0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goYil7fU0oYywzLGEpfSl9Y2F0Y2goZCl7TSh0aGlzLDMsZCl9fSx3YT1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLmNvbnRleHQ9dGhpcy5oPXRoaXMuYz10aGlzLmNoaWxkPW51bGw7dGhpcy53PSExfTt3YS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmNvbnRleHQ9dGhpcy5oPXRoaXMuYz10aGlzLmNoaWxkPW51bGw7dGhpcy53PSExfTtcbnZhciB4YT1uZXcgRShmdW5jdGlvbigpe3JldHVybiBuZXcgd2F9LGZ1bmN0aW9uKGEpe2EucmVzZXQoKX0sMTAwKSx5YT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9eGEuZ2V0KCk7ZC5jPWE7ZC5oPWI7ZC5jb250ZXh0PWM7cmV0dXJuIGR9LEFhPWZ1bmN0aW9uKGEsYixjKXt6YShhLGIsYyxudWxsKXx8TChrYShiLGEpKX07Ty5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YSYmRChhLFwib3B0X29uRnVsZmlsbGVkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtudWxsIT1iJiZEKGIsXCJvcHRfb25SZWplY3RlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBwYXNzIG9wdF9jb250ZXh0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZCBvZiB0aGUgdGhpcmQ/XCIpO3JldHVybiBCYSh0aGlzLHkoYSk/YTpudWxsLHkoYik/YjpudWxsLGMpfTtPLnByb3RvdHlwZS50aGVuPU8ucHJvdG90eXBlLnRoZW47Ty5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGU9ITA7XG5PLnByb3RvdHlwZS5YPWZ1bmN0aW9uKGEsYil7cmV0dXJuIEJhKHRoaXMsbnVsbCxhLGIpfTt2YXIgRGE9ZnVuY3Rpb24oYSxiKXthLmd8fDIhPWEuYiYmMyE9YS5ifHxDYShhKTtDKG51bGwhPWIuYyk7YS5qP2Euai5uZXh0PWI6YS5nPWI7YS5qPWJ9LEJhPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXlhKG51bGwsbnVsbCxudWxsKTtlLmNoaWxkPW5ldyBPKGZ1bmN0aW9uKGEsayl7ZS5jPWI/ZnVuY3Rpb24oYyl7dHJ5e3ZhciBlPWIuY2FsbChkLGMpO2EoZSl9Y2F0Y2goTil7ayhOKX19OmE7ZS5oPWM/ZnVuY3Rpb24oYil7dHJ5e3ZhciBlPWMuY2FsbChkLGIpO2EoZSl9Y2F0Y2goTil7ayhOKX19Omt9KTtlLmNoaWxkLnU9YTtEYShhLGUpO3JldHVybiBlLmNoaWxkfTtPLnByb3RvdHlwZS5ZPWZ1bmN0aW9uKGEpe0MoMT09dGhpcy5iKTt0aGlzLmI9MDtNKHRoaXMsMixhKX07Ty5wcm90b3R5cGUuWj1mdW5jdGlvbihhKXtDKDE9PXRoaXMuYik7dGhpcy5iPTA7TSh0aGlzLDMsYSl9O1xudmFyIE09ZnVuY3Rpb24oYSxiLGMpezA9PWEuYiYmKGE9PWMmJihiPTMsYz1uZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW5ub3QgcmVzb2x2ZSB0byBpdHNlbGZcIikpLGEuYj0xLHphKGMsYS5ZLGEuWixhKXx8KGEuSz1jLGEuYj1iLGEudT1udWxsLENhKGEpLDMhPWJ8fEVhKGEsYykpKX0semE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSBpbnN0YW5jZW9mIE8pcmV0dXJuIG51bGwhPWImJkQoYixcIm9wdF9vbkZ1bGZpbGxlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIiksbnVsbCE9YyYmRChjLFwib3B0X29uUmVqZWN0ZWQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgcGFzcyBvcHRfY29udGV4dCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IGluc3RlYWQgb2YgdGhlIHRoaXJkP1wiKSxEYShhLHlhKGJ8fHcsY3x8bnVsbCxkKSksITA7dmFyIGU7aWYoYSl0cnl7ZT0hIWEuJGdvb2dfVGhlbmFibGV9Y2F0Y2goayl7ZT0hMX1lbHNlIGU9ITE7aWYoZSlyZXR1cm4gYS50aGVuKGIsYyxkKSwhMDtcbmU9dHlwZW9mIGE7aWYoXCJvYmplY3RcIj09ZSYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1lKXRyeXt2YXIgZj1hLnRoZW47aWYoeShmKSlyZXR1cm4gRmEoYSxmLGIsYyxkKSwhMH1jYXRjaChrKXtyZXR1cm4gYy5jYWxsKGQsayksITB9cmV0dXJuITF9LEZhPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9ITEsaz1mdW5jdGlvbihhKXtmfHwoZj0hMCxjLmNhbGwoZSxhKSl9LGc9ZnVuY3Rpb24oYSl7Znx8KGY9ITAsZC5jYWxsKGUsYSkpfTt0cnl7Yi5jYWxsKGEsayxnKX1jYXRjaChuKXtnKG4pfX0sQ2E9ZnVuY3Rpb24oYSl7YS5BfHwoYS5BPSEwLEwoYS5OLGEpKX0sR2E9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDthLmcmJihiPWEuZyxhLmc9Yi5uZXh0LGIubmV4dD1udWxsKTthLmd8fChhLmo9bnVsbCk7bnVsbCE9YiYmQyhudWxsIT1iLmMpO3JldHVybiBifTtcbk8ucHJvdG90eXBlLk49ZnVuY3Rpb24oKXtmb3IodmFyIGE7YT1HYSh0aGlzKTspe3ZhciBiPXRoaXMuYixjPXRoaXMuSztpZigzPT1iJiZhLmgmJiFhLncpe3ZhciBkO2ZvcihkPXRoaXM7ZCYmZC5tO2Q9ZC51KWQubT0hMX1pZihhLmNoaWxkKWEuY2hpbGQudT1udWxsLEhhKGEsYixjKTtlbHNlIHRyeXthLnc/YS5jLmNhbGwoYS5jb250ZXh0KTpIYShhLGIsYyl9Y2F0Y2goZSl7SWEuY2FsbChudWxsLGUpfXhhLnB1dChhKX10aGlzLkE9ITF9O3ZhciBIYT1mdW5jdGlvbihhLGIsYyl7Mj09Yj9hLmMuY2FsbChhLmNvbnRleHQsYyk6YS5oJiZhLmguY2FsbChhLmNvbnRleHQsYyl9LEVhPWZ1bmN0aW9uKGEsYil7YS5tPSEwO0woZnVuY3Rpb24oKXthLm0mJklhLmNhbGwobnVsbCxiKX0pfSxJYT1xYTtmdW5jdGlvbiBQKGEsYil7aWYoIShiIGluc3RhbmNlb2YgT2JqZWN0KSlyZXR1cm4gYjtzd2l0Y2goYi5jb25zdHJ1Y3Rvcil7Y2FzZSBEYXRlOnJldHVybiBuZXcgRGF0ZShiLmdldFRpbWUoKSk7Y2FzZSBPYmplY3Q6dm9pZCAwPT09YSYmKGE9e30pO2JyZWFrO2Nhc2UgQXJyYXk6YT1bXTticmVhaztkZWZhdWx0OnJldHVybiBifWZvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJihhW2NdPVAoYVtjXSxiW2NdKSk7cmV0dXJuIGF9O3ZhciBKYT1FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSxSPWZ1bmN0aW9uKGEsYil7dGhpcy5jb2RlPWE7dGhpcy5tZXNzYWdlPWI7aWYoSmEpSmEodGhpcyxRLnByb3RvdHlwZS5jcmVhdGUpO2Vsc2V7dmFyIGM9RXJyb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMubmFtZT1cIkZpcmViYXNlRXJyb3JcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInN0YWNrXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLnN0YWNrfX0pfX07Ui5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1IucHJvdG90eXBlLmNvbnN0cnVjdG9yPVI7Ui5wcm90b3R5cGUubmFtZT1cIkZpcmViYXNlRXJyb3JcIjt2YXIgUT1mdW5jdGlvbihhLGIsYyl7dGhpcy5WPWE7dGhpcy5XPWI7dGhpcy5NPWM7dGhpcy5wYXR0ZXJuPS9cXHtcXCQoW159XSspfS9nfTtcblEucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPXt9KTt2YXIgYz10aGlzLk1bYV0sYz12b2lkIDA9PT1jP1wiRXJyb3JcIjpjLnJlcGxhY2UodGhpcy5wYXR0ZXJuLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIHZvaWQgMCE9PWJbY10/YltjXS50b1N0cmluZygpOlwiPFwiK2MrXCI/PlwifSksYz10aGlzLlcrXCI6IFwiK2MrXCIgKFwiK3RoaXMuVitcIi9cIithK1wiKS5cIjthPW5ldyBSKGEsYyk7Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmXCJfXCIhPT1kLnNsaWNlKC0xKSYmKGFbZF09YltkXSk7cmV0dXJuIGF9O08uYWxsPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgTyhmdW5jdGlvbihiLGMpe3ZhciBkPWEubGVuZ3RoLGU9W107aWYoZClmb3IodmFyIGY9ZnVuY3Rpb24oYSxjKXtkLS07ZVthXT1jOzA9PWQmJmIoZSl9LGs9ZnVuY3Rpb24oYSl7YyhhKX0sZz0wLG47ZzxhLmxlbmd0aDtnKyspbj1hW2ddLEFhKG4sa2EoZixnKSxrKTtlbHNlIGIoZSl9KX07Ty5yZXNvbHZlPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBPKXJldHVybiBhO3ZhciBiPW5ldyBPKHcpO00oYiwyLGEpO3JldHVybiBifTtPLnJlamVjdD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IE8oZnVuY3Rpb24oYixjKXtjKGEpfSl9O08ucHJvdG90eXBlW1wiY2F0Y2hcIl09Ty5wcm90b3R5cGUuWDt2YXIgUz1PO1widW5kZWZpbmVkXCIhPT10eXBlb2YgUHJvbWlzZSYmKFM9UHJvbWlzZSk7dmFyIEthPVM7ZnVuY3Rpb24gTGEoYSxiKXthPW5ldyBUKGEsYik7cmV0dXJuIGEuc3Vic2NyaWJlLmJpbmQoYSl9dmFyIFQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3RoaXMuYT1bXTt0aGlzLko9MDt0aGlzLnRhc2s9S2EucmVzb2x2ZSgpO3RoaXMubD0hMTt0aGlzLkQ9Yjt0aGlzLnRhc2sudGhlbihmdW5jdGlvbigpe2EoYyl9KS5jYXRjaChmdW5jdGlvbihhKXtjLmVycm9yKGEpfSl9O1QucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oYSl7VSh0aGlzLGZ1bmN0aW9uKGIpe2IubmV4dChhKX0pfTtULnByb3RvdHlwZS5lcnJvcj1mdW5jdGlvbihhKXtVKHRoaXMsZnVuY3Rpb24oYil7Yi5lcnJvcihhKX0pO3RoaXMuY2xvc2UoYSl9O1QucHJvdG90eXBlLmNvbXBsZXRlPWZ1bmN0aW9uKCl7VSh0aGlzLGZ1bmN0aW9uKGEpe2EuY29tcGxldGUoKX0pO3RoaXMuY2xvc2UoKX07XG5ULnByb3RvdHlwZS5zdWJzY3JpYmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZTtpZih2b2lkIDA9PT1hJiZ2b2lkIDA9PT1iJiZ2b2lkIDA9PT1jKXRocm93IEVycm9yKFwiTWlzc2luZyBPYnNlcnZlci5cIik7ZT1NYShhKT9hOntuZXh0OmEsZXJyb3I6Yixjb21wbGV0ZTpjfTt2b2lkIDA9PT1lLm5leHQmJihlLm5leHQ9Vik7dm9pZCAwPT09ZS5lcnJvciYmKGUuZXJyb3I9Vik7dm9pZCAwPT09ZS5jb21wbGV0ZSYmKGUuY29tcGxldGU9Vik7YT10aGlzLiQuYmluZCh0aGlzLHRoaXMuYS5sZW5ndGgpO3RoaXMubCYmdGhpcy50YXNrLnRoZW4oZnVuY3Rpb24oKXt0cnl7ZC5HP2UuZXJyb3IoZC5HKTplLmNvbXBsZXRlKCl9Y2F0Y2goYSl7fX0pO3RoaXMuYS5wdXNoKGUpO3JldHVybiBhfTtcblQucHJvdG90eXBlLiQ9ZnVuY3Rpb24oYSl7dm9pZCAwIT09dGhpcy5hJiZ2b2lkIDAhPT10aGlzLmFbYV0mJih0aGlzLmFbYV09dm9pZCAwLC0tdGhpcy5KLDA9PT10aGlzLkomJnZvaWQgMCE9PXRoaXMuRCYmdGhpcy5EKHRoaXMpKX07dmFyIFU9ZnVuY3Rpb24oYSxiKXtpZighYS5sKWZvcih2YXIgYz0wO2M8YS5hLmxlbmd0aDtjKyspTmEoYSxjLGIpfSxOYT1mdW5jdGlvbihhLGIsYyl7YS50YXNrLnRoZW4oZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1hLmEmJnZvaWQgMCE9PWEuYVtiXSl0cnl7YyhhLmFbYl0pfWNhdGNoKGQpe319KX07VC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLmx8fCh0aGlzLmw9ITAsdm9pZCAwIT09YSYmKHRoaXMuRz1hKSx0aGlzLnRhc2sudGhlbihmdW5jdGlvbigpe2IuYT12b2lkIDA7Yi5EPXZvaWQgMH0pKX07XG5mdW5jdGlvbiBNYShhKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiExO2Zvcih2YXIgYj1jYSgpLGM9Yi5uZXh0KCk7IWMuZG9uZTtjPWIubmV4dCgpKWlmKGM9Yy52YWx1ZSxjIGluIGEmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhW2NdKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIFYoKXt9O3ZhciBXPVMsWD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpczt0aGlzLkg9Yzt0aGlzLkk9ITE7dGhpcy5pPXt9O3RoaXMuUD17fTt0aGlzLkM9Yjt0aGlzLlQ9UCh2b2lkIDAsYSk7T2JqZWN0LmtleXMoYy5JTlRFUk5BTC5mYWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24oYSl7ZFthXT1kLlIuYmluZChkLGEpfSl9O1gucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuKG5ldyBXKGZ1bmN0aW9uKGIpe1koYSk7YigpfSkpLnRoZW4oZnVuY3Rpb24oKXthLkguSU5URVJOQUwucmVtb3ZlQXBwKGEuQyk7cmV0dXJuIFcuYWxsKE9iamVjdC5rZXlzKGEuaSkubWFwKGZ1bmN0aW9uKGIpe3JldHVybiBhLmlbYl0uSU5URVJOQUwuZGVsZXRlKCl9KSl9KS50aGVuKGZ1bmN0aW9uKCl7YS5JPSEwO2EuaT1udWxsO2EuUD1udWxsfSl9O1xuWC5wcm90b3R5cGUuUj1mdW5jdGlvbihhKXtZKHRoaXMpO3ZvaWQgMD09PXRoaXMuaVthXSYmKHRoaXMuaVthXT10aGlzLkguSU5URVJOQUwuZmFjdG9yaWVzW2FdKHRoaXMsdGhpcy5PLmJpbmQodGhpcykpKTtyZXR1cm4gdGhpcy5pW2FdfTtYLnByb3RvdHlwZS5PPWZ1bmN0aW9uKGEpe1AodGhpcyxhKX07dmFyIFk9ZnVuY3Rpb24oYSl7YS5JJiZaKE9hKFwiZGVsZXRlZFwiLHtuYW1lOmEuQ30pKX07T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoWC5wcm90b3R5cGUse25hbWU6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe1kodGhpcyk7cmV0dXJuIHRoaXMuQ319LG9wdGlvbnM6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe1kodGhpcyk7cmV0dXJuIHRoaXMuVH19fSk7WC5wcm90b3R5cGUubmFtZSYmWC5wcm90b3R5cGUub3B0aW9uc3x8WC5wcm90b3R5cGUuZGVsZXRlfHxjb25zb2xlLmxvZyhcImRjXCIpO1xuZnVuY3Rpb24gUGEoKXtmdW5jdGlvbiBhKGEpe2E9YXx8XCJbREVGQVVMVF1cIjt2YXIgYz1iW2FdO3ZvaWQgMD09PWMmJlooXCJub0FwcFwiLHtuYW1lOmF9KTtyZXR1cm4gY312YXIgYj17fSxjPXt9LGQ9W10sZT17aW5pdGlhbGl6ZUFwcDpmdW5jdGlvbihhLGMpe3ZvaWQgMD09PWM/Yz1cIltERUZBVUxUXVwiOlwic3RyaW5nXCI9PT10eXBlb2YgYyYmXCJcIiE9PWN8fFooXCJiYWQtYXBwLW5hbWVcIix7bmFtZTpjK1wiXCJ9KTt2b2lkIDAhPT1iW2NdJiZaKFwiZHVwQXBwXCIse25hbWU6Y30pO3ZhciBnPW5ldyBYKGEsYyxlKTtiW2NdPWc7ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBhKFwiY3JlYXRlXCIsZyl9KTt2b2lkIDAhPWcuSU5URVJOQUwmJnZvaWQgMCE9Zy5JTlRFUk5BTC5nZXRUb2tlbnx8UChnLHtJTlRFUk5BTDp7Z2V0VG9rZW46ZnVuY3Rpb24oKXtyZXR1cm4gVy5yZXNvbHZlKG51bGwpfSxhZGRBdXRoVG9rZW5MaXN0ZW5lcjpmdW5jdGlvbigpe30scmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI6ZnVuY3Rpb24oKXt9fX0pO1xucmV0dXJuIGd9LGFwcDphLGFwcHM6bnVsbCxQcm9taXNlOlcsU0RLX1ZFUlNJT046XCIwLjAuMFwiLElOVEVSTkFMOntyZWdpc3RlclNlcnZpY2U6ZnVuY3Rpb24oYixkLGcpe2NbYl0mJlooXCJkdXBTZXJ2aWNlXCIse25hbWU6Yn0pO2NbYl09ZDtkPWZ1bmN0aW9uKGMpe3ZvaWQgMD09PWMmJihjPWEoKSk7cmV0dXJuIGNbYl0oKX07dm9pZCAwIT09ZyYmUChkLGcpO3JldHVybiBlW2JdPWR9LGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlOlBhLGV4dGVuZE5hbWVzcGFjZTpmdW5jdGlvbihhKXtQKGUsYSl9LGNyZWF0ZVN1YnNjcmliZTpMYSxFcnJvckZhY3Rvcnk6USxyZWdpc3RlckFwcEhvb2s6ZnVuY3Rpb24oYSl7ZC5wdXNoKGEpfSxyZW1vdmVBcHA6ZnVuY3Rpb24oYSl7ZC5mb3JFYWNoKGZ1bmN0aW9uKGMpe3JldHVybiBjKFwiZGVsZXRlXCIsYlthXSl9KTtkZWxldGUgYlthXX0sZmFjdG9yaWVzOmMsUHJvbWlzZTpPLGRlZXBFeHRlbmQ6UH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiYXBwc1wiLFxue2dldDpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyhiKS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX19KTthLkFwcD1YO3JldHVybiBlfWZ1bmN0aW9uIFooYSxiKXt0aHJvdyBFcnJvcihPYShhLGIpKTt9XG5mdW5jdGlvbiBPYShhLGIpe2I9Ynx8e307Yj17bm9BcHA6XCJObyBGaXJlYmFzZSBBcHAgJ1wiK2IubmFtZStcIicgaGFzIGJlZW4gY3JlYXRlZCAtIGNhbGwgRmlyZWJhc2UgQXBwLmluaXRpYWxpemVBcHAoKS5cIixcImJhZC1hcHAtbmFtZVwiOlwiSWxsZWdhbCBBcHAgbmFtZTogJ1wiK2IubmFtZStcIicuXCIsZHVwQXBwOlwiRmlyZWJhc2UgQXBwIG5hbWVkICdcIitiLm5hbWUrXCInIGFscmVhZHkgZXhpc3RzLlwiLGRlbGV0ZWQ6XCJGaXJlYmFzZSBBcHAgbmFtZWQgJ1wiK2IubmFtZStcIicgYWxyZWFkeSBkZWxldGVkLlwiLGR1cFNlcnZpY2U6XCJGaXJlYmFzZSBTZXJ2aWNlIG5hbWVkICdcIitiLm5hbWUrXCInIGFscmVhZHkgcmVnaXN0ZXJlZC5cIn1bYV07cmV0dXJuIHZvaWQgMD09PWI/XCJBcHBsaWNhdGlvbiBFcnJvcjogKFwiK2ErXCIpXCI6Yn07XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJih3aW5kb3cuZmlyZWJhc2U9UGEoKSk7IH0pKCk7XG5maXJlYmFzZS5TREtfVkVSU0lPTiA9IFwiMy4wLjNcIjtcbihmdW5jdGlvbigpe3ZhciBrLGFhPWFhfHx7fSxsPXRoaXMsYmE9ZnVuY3Rpb24oKXt9LGNhPWZ1bmN0aW9uKGEpe3ZhciBiPXR5cGVvZiBhO2lmKFwib2JqZWN0XCI9PWIpaWYoYSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5KXJldHVyblwiYXJyYXlcIjtpZihhIGluc3RhbmNlb2YgT2JqZWN0KXJldHVybiBiO3ZhciBjPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtpZihcIltvYmplY3QgV2luZG93XVwiPT1jKXJldHVyblwib2JqZWN0XCI7aWYoXCJbb2JqZWN0IEFycmF5XVwiPT1jfHxcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGgmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnNwbGljZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwic3BsaWNlXCIpKXJldHVyblwiYXJyYXlcIjtpZihcIltvYmplY3QgRnVuY3Rpb25dXCI9PWN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNhbGwmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiZcbiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSlyZXR1cm5cImZ1bmN0aW9uXCJ9ZWxzZSByZXR1cm5cIm51bGxcIjtlbHNlIGlmKFwiZnVuY3Rpb25cIj09YiYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGEuY2FsbClyZXR1cm5cIm9iamVjdFwiO3JldHVybiBifSxkYT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09PWF9LGVhPWZ1bmN0aW9uKGEpe3JldHVyblwiYXJyYXlcIj09Y2EoYSl9LGZhPWZ1bmN0aW9uKGEpe3ZhciBiPWNhKGEpO3JldHVyblwiYXJyYXlcIj09Ynx8XCJvYmplY3RcIj09YiYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RofSxuPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfSxnYT1mdW5jdGlvbihhKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYX0scD1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PWNhKGEpfSxoYT1mdW5jdGlvbihhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9LGlhPWZ1bmN0aW9uKGEsXG5iLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9LGphPWZ1bmN0aW9uKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYyxkKTtyZXR1cm4gYS5hcHBseShiLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fSxxPWZ1bmN0aW9uKGEsYixjKXtxPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/aWE6amE7cmV0dXJuIHEuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrYT1mdW5jdGlvbihhLGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyxcbjEpO3JldHVybiBmdW5jdGlvbigpe3ZhciBiPWMuc2xpY2UoKTtiLnB1c2guYXBwbHkoYixhcmd1bWVudHMpO3JldHVybiBhLmFwcGx5KHRoaXMsYil9fSxsYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9LHI9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EueWM9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLkFlPWZ1bmN0aW9uKGEsYyxmKXtmb3IodmFyIGc9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0yKSxoPTI7aDxhcmd1bWVudHMubGVuZ3RoO2grKylnW2gtMl09YXJndW1lbnRzW2hdO3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLGcpfX07dmFyIHQ9ZnVuY3Rpb24oYSl7aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0KTtlbHNle3ZhciBiPUVycm9yKCkuc3RhY2s7YiYmKHRoaXMuc3RhY2s9Yil9YSYmKHRoaXMubWVzc2FnZT1TdHJpbmcoYSkpfTtyKHQsRXJyb3IpO3QucHJvdG90eXBlLm5hbWU9XCJDdXN0b21FcnJvclwiO3ZhciBtYT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1hLnNwbGl0KFwiJXNcIiksZD1cIlwiLGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2UubGVuZ3RoJiYxPGMubGVuZ3RoOylkKz1jLnNoaWZ0KCkrZS5zaGlmdCgpO3JldHVybiBkK2Muam9pbihcIiVzXCIpfSxuYT1TdHJpbmcucHJvdG90eXBlLnRyaW0/ZnVuY3Rpb24oYSl7cmV0dXJuIGEudHJpbSgpfTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csXCJcIil9LG9hPS8mL2cscGE9LzwvZyxxYT0vPi9nLHJhPS9cIi9nLHNhPS8nL2csdGE9L1xceDAwL2csdWE9L1tcXHgwMCY8PlwiJ10vLHU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4tMSE9YS5pbmRleE9mKGIpfSx2YT1mdW5jdGlvbihhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07dmFyIHdhPWZ1bmN0aW9uKGEsYil7Yi51bnNoaWZ0KGEpO3QuY2FsbCh0aGlzLG1hLmFwcGx5KG51bGwsYikpO2Iuc2hpZnQoKX07cih3YSx0KTt3YS5wcm90b3R5cGUubmFtZT1cIkFzc2VydGlvbkVycm9yXCI7XG52YXIgeGE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJBc3NlcnRpb24gZmFpbGVkXCI7aWYoYyl2YXIgZT1lKyhcIjogXCIrYyksZj1kO2Vsc2UgYSYmKGUrPVwiOiBcIithLGY9Yik7dGhyb3cgbmV3IHdhKFwiXCIrZSxmfHxbXSk7fSx2PWZ1bmN0aW9uKGEsYixjKXthfHx4YShcIlwiLG51bGwsYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpfSx5YT1mdW5jdGlvbihhLGIpe3Rocm93IG5ldyB3YShcIkZhaWx1cmVcIisoYT9cIjogXCIrYTpcIlwiKSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO30semE9ZnVuY3Rpb24oYSxiLGMpe2dhKGEpfHx4YShcIkV4cGVjdGVkIG51bWJlciBidXQgZ290ICVzOiAlcy5cIixbY2EoYSksYV0sYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpO3JldHVybiBhfSxBYT1mdW5jdGlvbihhLGIsYyl7bihhKXx8eGEoXCJFeHBlY3RlZCBzdHJpbmcgYnV0IGdvdCAlczogJXMuXCIsW2NhKGEpLGFdLGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLFxuMikpO3JldHVybiBhfSxCYT1mdW5jdGlvbihhLGIsYyl7cChhKXx8eGEoXCJFeHBlY3RlZCBmdW5jdGlvbiBidXQgZ290ICVzOiAlcy5cIixbY2EoYSksYV0sYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpfTt2YXIgQ2E9QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3YobnVsbCE9YS5sZW5ndGgpO3JldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbD09Yz8wOjA+Yz9NYXRoLm1heCgwLGEubGVuZ3RoK2MpOmM7aWYobihhKSlyZXR1cm4gbihiKSYmMT09Yi5sZW5ndGg/YS5pbmRleE9mKGIsYyk6LTE7Zm9yKDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSx3PUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt2KG51bGwhPWEubGVuZ3RoKTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPW4oYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfSxEYT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1uKGEpP1xuYS5zcGxpdChcIlwiKTphLGQ9YS5sZW5ndGgtMTswPD1kOy0tZClkIGluIGMmJmIuY2FsbCh2b2lkIDAsY1tkXSxkLGEpfSxFYT1BcnJheS5wcm90b3R5cGUubWFwP2Z1bmN0aW9uKGEsYixjKXt2KG51bGwhPWEubGVuZ3RoKTtyZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9bihhKT9hLnNwbGl0KFwiXCIpOmEsZz0wO2c8ZDtnKyspZyBpbiBmJiYoZVtnXT1iLmNhbGwoYyxmW2ddLGcsYSkpO3JldHVybiBlfSxGYT1BcnJheS5wcm90b3R5cGUuc29tZT9mdW5jdGlvbihhLGIsYyl7dihudWxsIT1hLmxlbmd0aCk7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9bihhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuITA7cmV0dXJuITF9LFxuSGE9ZnVuY3Rpb24oYSl7dmFyIGI7YTp7Yj1HYTtmb3IodmFyIGM9YS5sZW5ndGgsZD1uKGEpP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKylpZihlIGluIGQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpKXtiPWU7YnJlYWsgYX1iPS0xfXJldHVybiAwPmI/bnVsbDpuKGEpP2EuY2hhckF0KGIpOmFbYl19LElhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDA8PUNhKGEsYil9LEthPWZ1bmN0aW9uKGEsYil7dmFyIGM9Q2EoYSxiKSxkOyhkPTA8PWMpJiZKYShhLGMpO3JldHVybiBkfSxKYT1mdW5jdGlvbihhLGIpe3YobnVsbCE9YS5sZW5ndGgpO3JldHVybiAxPT1BcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYSxiLDEpLmxlbmd0aH0sTGE9ZnVuY3Rpb24oYSxiKXt2YXIgYz0wO0RhKGEsZnVuY3Rpb24oZCxlKXtiLmNhbGwodm9pZCAwLGQsZSxhKSYmSmEoYSxlKSYmYysrfSl9LE1hPWZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KEFycmF5LnByb3RvdHlwZSxcbmFyZ3VtZW50cyl9LE5hPWZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KEFycmF5LnByb3RvdHlwZSxhcmd1bWVudHMpfSxPYT1mdW5jdGlvbihhKXt2YXIgYj1hLmxlbmd0aDtpZigwPGIpe2Zvcih2YXIgYz1BcnJheShiKSxkPTA7ZDxiO2QrKyljW2RdPWFbZF07cmV0dXJuIGN9cmV0dXJuW119LFBhPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyl7dmFyIGQ9YXJndW1lbnRzW2NdO2lmKGZhKGQpKXt2YXIgZT1hLmxlbmd0aHx8MCxmPWQubGVuZ3RofHwwO2EubGVuZ3RoPWUrZjtmb3IodmFyIGc9MDtnPGY7ZysrKWFbZStnXT1kW2ddfWVsc2UgYS5wdXNoKGQpfX07dmFyIFFhPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjIGluIGEpYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSl9LFJhPWZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWFbZF07cmV0dXJuIGJ9LFNhPWZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWQ7cmV0dXJuIGJ9LFRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09YSYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIGF9LFVhPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfSxWYT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKCEoYyBpbiBiKXx8YVtjXSE9PWJbY10pcmV0dXJuITE7Zm9yKGMgaW4gYilpZighKGMgaW4gYSkpcmV0dXJuITE7cmV0dXJuITB9LFlhPWZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9LFphPVwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpLFxuJGE9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZCxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKHZhciBmPTA7ZjxaYS5sZW5ndGg7ZisrKWM9WmFbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pfX07dmFyIGFiO2E6e3ZhciBiYj1sLm5hdmlnYXRvcjtpZihiYil7dmFyIGNiPWJiLnVzZXJBZ2VudDtpZihjYil7YWI9Y2I7YnJlYWsgYX19YWI9XCJcIn12YXIgeD1mdW5jdGlvbihhKXtyZXR1cm4gdShhYixhKX07dmFyIGRiPXgoXCJPcGVyYVwiKSx5PXgoXCJUcmlkZW50XCIpfHx4KFwiTVNJRVwiKSxlYj14KFwiRWRnZVwiKSxmYj1lYnx8eSxnYj14KFwiR2Vja29cIikmJiEodShhYi50b0xvd2VyQ2FzZSgpLFwid2Via2l0XCIpJiYheChcIkVkZ2VcIikpJiYhKHgoXCJUcmlkZW50XCIpfHx4KFwiTVNJRVwiKSkmJiF4KFwiRWRnZVwiKSxoYj11KGFiLnRvTG93ZXJDYXNlKCksXCJ3ZWJraXRcIikmJiF4KFwiRWRnZVwiKSxpYj1mdW5jdGlvbigpe3ZhciBhPWwuZG9jdW1lbnQ7cmV0dXJuIGE/YS5kb2N1bWVudE1vZGU6dm9pZCAwfSxqYjtcbmE6e3ZhciBrYj1cIlwiLGxiPWZ1bmN0aW9uKCl7dmFyIGE9YWI7aWYoZ2IpcmV0dXJuL3J2XFw6KFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYoZWIpcmV0dXJuL0VkZ2VcXC8oW1xcZFxcLl0rKS8uZXhlYyhhKTtpZih5KXJldHVybi9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZihoYilyZXR1cm4vV2ViS2l0XFwvKFxcUyspLy5leGVjKGEpO2lmKGRiKXJldHVybi8oPzpWZXJzaW9uKVsgXFwvXT8oXFxTKykvLmV4ZWMoYSl9KCk7bGImJihrYj1sYj9sYlsxXTpcIlwiKTtpZih5KXt2YXIgbWI9aWIoKTtpZihudWxsIT1tYiYmbWI+cGFyc2VGbG9hdChrYikpe2piPVN0cmluZyhtYik7YnJlYWsgYX19amI9a2J9XG52YXIgbmI9amIsb2I9e30sej1mdW5jdGlvbihhKXt2YXIgYjtpZighKGI9b2JbYV0pKXtiPTA7Zm9yKHZhciBjPW5hKFN0cmluZyhuYikpLnNwbGl0KFwiLlwiKSxkPW5hKFN0cmluZyhhKSkuc3BsaXQoXCIuXCIpLGU9TWF0aC5tYXgoYy5sZW5ndGgsZC5sZW5ndGgpLGY9MDswPT1iJiZmPGU7ZisrKXt2YXIgZz1jW2ZdfHxcIlwiLGg9ZFtmXXx8XCJcIixtPVJlZ0V4cChcIihcXFxcZCopKFxcXFxEKilcIixcImdcIiksUz1SZWdFeHAoXCIoXFxcXGQqKShcXFxcRCopXCIsXCJnXCIpO2Rve3ZhciBXYT1tLmV4ZWMoZyl8fFtcIlwiLFwiXCIsXCJcIl0sWGE9Uy5leGVjKGgpfHxbXCJcIixcIlwiLFwiXCJdO2lmKDA9PVdhWzBdLmxlbmd0aCYmMD09WGFbMF0ubGVuZ3RoKWJyZWFrO2I9dmEoMD09V2FbMV0ubGVuZ3RoPzA6cGFyc2VJbnQoV2FbMV0sMTApLDA9PVhhWzFdLmxlbmd0aD8wOnBhcnNlSW50KFhhWzFdLDEwKSl8fHZhKDA9PVdhWzJdLmxlbmd0aCwwPT1YYVsyXS5sZW5ndGgpfHx2YShXYVsyXSxYYVsyXSl9d2hpbGUoMD09Yil9Yj1vYlthXT1cbjA8PWJ9cmV0dXJuIGJ9LHBiPWwuZG9jdW1lbnQscWI9cGImJnk/aWIoKXx8KFwiQ1NTMUNvbXBhdFwiPT1wYi5jb21wYXRNb2RlP3BhcnNlSW50KG5iLDEwKTo1KTp2b2lkIDA7dmFyIHJiPW51bGwsc2I9bnVsbCx1Yj1mdW5jdGlvbihhKXt2YXIgYj1cIlwiO3RiKGEsZnVuY3Rpb24oYSl7Yis9U3RyaW5nLmZyb21DaGFyQ29kZShhKX0pO3JldHVybiBifSx0Yj1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYil7Zm9yKDtkPGEubGVuZ3RoOyl7dmFyIGM9YS5jaGFyQXQoZCsrKSxlPXNiW2NdO2lmKG51bGwhPWUpcmV0dXJuIGU7aWYoIS9eW1xcc1xceGEwXSokLy50ZXN0KGMpKXRocm93IEVycm9yKFwiVW5rbm93biBiYXNlNjQgZW5jb2RpbmcgYXQgY2hhcjogXCIrYyk7fXJldHVybiBifXZiKCk7Zm9yKHZhciBkPTA7Oyl7dmFyIGU9YygtMSksZj1jKDApLGc9Yyg2NCksaD1jKDY0KTtpZig2ND09PWgmJi0xPT09ZSlicmVhaztiKGU8PDJ8Zj4+NCk7NjQhPWcmJihiKGY8PDQmMjQwfGc+PjIpLDY0IT1oJiZiKGc8PDYmMTkyfGgpKX19LHZiPWZ1bmN0aW9uKCl7aWYoIXJiKXtyYj17fTtzYj17fTtmb3IodmFyIGE9MDs2NT5hO2ErKylyYlthXT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIuY2hhckF0KGEpLFxuc2JbcmJbYV1dPWEsNjI8PWEmJihzYltcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8uXCIuY2hhckF0KGEpXT1hKX19O3ZhciB4Yj1mdW5jdGlvbigpe3RoaXMuUGI9XCJcIjt0aGlzLndkPXdifTt4Yi5wcm90b3R5cGUuaWM9ITA7eGIucHJvdG90eXBlLmdjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUGJ9O3hiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiQ29uc3R7XCIrdGhpcy5QYitcIn1cIn07dmFyIHliPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiB4YiYmYS5jb25zdHJ1Y3Rvcj09PXhiJiZhLndkPT09d2IpcmV0dXJuIGEuUGI7eWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBDb25zdCwgZ290ICdcIithK1wiJ1wiKTtyZXR1cm5cInR5cGVfZXJyb3I6Q29uc3RcIn0sd2I9e307dmFyIEE9ZnVuY3Rpb24oKXt0aGlzLmFhPVwiXCI7dGhpcy52ZD16Yn07QS5wcm90b3R5cGUuaWM9ITA7QS5wcm90b3R5cGUuZ2M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hYX07QS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlNhZmVVcmx7XCIrdGhpcy5hYStcIn1cIn07XG52YXIgQWI9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIEEmJmEuY29uc3RydWN0b3I9PT1BJiZhLnZkPT09emIpcmV0dXJuIGEuYWE7eWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBTYWZlVXJsLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrY2EoYSkpO3JldHVyblwidHlwZV9lcnJvcjpTYWZlVXJsXCJ9LEJiPS9eKD86KD86aHR0cHM/fG1haWx0b3xmdHApOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvaSxEYj1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgQSlyZXR1cm4gYTthPWEuaWM/YS5nYygpOlN0cmluZyhhKTtCYi50ZXN0KGEpfHwoYT1cImFib3V0OmludmFsaWQjekNsb3N1cmV6XCIpO3JldHVybiBDYihhKX0semI9e30sQ2I9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IEE7Yi5hYT1hO3JldHVybiBifTtDYihcImFib3V0OmJsYW5rXCIpO3ZhciBGYj1mdW5jdGlvbigpe3RoaXMuYWE9XCJcIjt0aGlzLnVkPUVifTtGYi5wcm90b3R5cGUuaWM9ITA7RmIucHJvdG90eXBlLmdjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWF9O0ZiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiU2FmZUh0bWx7XCIrdGhpcy5hYStcIn1cIn07dmFyIEdiPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBGYiYmYS5jb25zdHJ1Y3Rvcj09PUZiJiZhLnVkPT09RWIpcmV0dXJuIGEuYWE7eWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBTYWZlSHRtbCwgZ290ICdcIithK1wiJyBvZiB0eXBlIFwiK2NhKGEpKTtyZXR1cm5cInR5cGVfZXJyb3I6U2FmZUh0bWxcIn0sRWI9e307RmIucHJvdG90eXBlLlpkPWZ1bmN0aW9uKGEpe3RoaXMuYWE9YTtyZXR1cm4gdGhpc307dmFyIEhiPWZ1bmN0aW9uKGEsYil7dmFyIGM7Yz1iIGluc3RhbmNlb2YgQT9iOkRiKGIpO2EuaHJlZj1BYihjKX07dmFyIEliPWZ1bmN0aW9uKGEpe0liW1wiIFwiXShhKTtyZXR1cm4gYX07SWJbXCIgXCJdPWJhO3ZhciBKYj0heXx8OTw9TnVtYmVyKHFiKSxLYj15JiYheihcIjlcIik7IWhifHx6KFwiNTI4XCIpO2diJiZ6KFwiMS45YlwiKXx8eSYmeihcIjhcIil8fGRiJiZ6KFwiOS41XCIpfHxoYiYmeihcIjUyOFwiKTtnYiYmIXooXCI4XCIpfHx5JiZ6KFwiOVwiKTt2YXIgTGI9ZnVuY3Rpb24oKXt0aGlzLnJhPXRoaXMucmE7dGhpcy5HYj10aGlzLkdifTtMYi5wcm90b3R5cGUucmE9ITE7TGIucHJvdG90eXBlLmlzRGlzcG9zZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yYX07TGIucHJvdG90eXBlLkdhPWZ1bmN0aW9uKCl7aWYodGhpcy5HYilmb3IoO3RoaXMuR2IubGVuZ3RoOyl0aGlzLkdiLnNoaWZ0KCkoKX07dmFyIE1iPWZ1bmN0aW9uKGEsYil7dGhpcy50eXBlPWE7dGhpcy5jdXJyZW50VGFyZ2V0PXRoaXMudGFyZ2V0PWI7dGhpcy5kZWZhdWx0UHJldmVudGVkPXRoaXMuTmE9ITE7dGhpcy5nZD0hMH07TWIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3RoaXMuZ2Q9ITF9O3ZhciBOYj1mdW5jdGlvbihhLGIpe01iLmNhbGwodGhpcyxhP2EudHlwZTpcIlwiKTt0aGlzLnJlbGF0ZWRUYXJnZXQ9dGhpcy5jdXJyZW50VGFyZ2V0PXRoaXMudGFyZ2V0PW51bGw7dGhpcy5jaGFyQ29kZT10aGlzLmtleUNvZGU9dGhpcy5idXR0b249dGhpcy5zY3JlZW5ZPXRoaXMuc2NyZWVuWD10aGlzLmNsaWVudFk9dGhpcy5jbGllbnRYPXRoaXMub2Zmc2V0WT10aGlzLm9mZnNldFg9MDt0aGlzLm1ldGFLZXk9dGhpcy5zaGlmdEtleT10aGlzLmFsdEtleT10aGlzLmN0cmxLZXk9ITE7dGhpcy51Yj10aGlzLnN0YXRlPW51bGw7YSYmdGhpcy5pbml0KGEsYil9O3IoTmIsTWIpO1xuTmIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnR5cGU9YS50eXBlLGQ9YS5jaGFuZ2VkVG91Y2hlcz9hLmNoYW5nZWRUb3VjaGVzWzBdOm51bGw7dGhpcy50YXJnZXQ9YS50YXJnZXR8fGEuc3JjRWxlbWVudDt0aGlzLmN1cnJlbnRUYXJnZXQ9Yjt2YXIgZT1hLnJlbGF0ZWRUYXJnZXQ7aWYoZSl7aWYoZ2Ipe3ZhciBmO2E6e3RyeXtJYihlLm5vZGVOYW1lKTtmPSEwO2JyZWFrIGF9Y2F0Y2goZyl7fWY9ITF9Znx8KGU9bnVsbCl9fWVsc2VcIm1vdXNlb3ZlclwiPT1jP2U9YS5mcm9tRWxlbWVudDpcIm1vdXNlb3V0XCI9PWMmJihlPWEudG9FbGVtZW50KTt0aGlzLnJlbGF0ZWRUYXJnZXQ9ZTtudWxsPT09ZD8odGhpcy5vZmZzZXRYPWhifHx2b2lkIDAhPT1hLm9mZnNldFg/YS5vZmZzZXRYOmEubGF5ZXJYLHRoaXMub2Zmc2V0WT1oYnx8dm9pZCAwIT09YS5vZmZzZXRZP2Eub2Zmc2V0WTphLmxheWVyWSx0aGlzLmNsaWVudFg9dm9pZCAwIT09YS5jbGllbnRYP2EuY2xpZW50WDpcbmEucGFnZVgsdGhpcy5jbGllbnRZPXZvaWQgMCE9PWEuY2xpZW50WT9hLmNsaWVudFk6YS5wYWdlWSx0aGlzLnNjcmVlblg9YS5zY3JlZW5YfHwwLHRoaXMuc2NyZWVuWT1hLnNjcmVlbll8fDApOih0aGlzLmNsaWVudFg9dm9pZCAwIT09ZC5jbGllbnRYP2QuY2xpZW50WDpkLnBhZ2VYLHRoaXMuY2xpZW50WT12b2lkIDAhPT1kLmNsaWVudFk/ZC5jbGllbnRZOmQucGFnZVksdGhpcy5zY3JlZW5YPWQuc2NyZWVuWHx8MCx0aGlzLnNjcmVlblk9ZC5zY3JlZW5ZfHwwKTt0aGlzLmJ1dHRvbj1hLmJ1dHRvbjt0aGlzLmtleUNvZGU9YS5rZXlDb2RlfHwwO3RoaXMuY2hhckNvZGU9YS5jaGFyQ29kZXx8KFwia2V5cHJlc3NcIj09Yz9hLmtleUNvZGU6MCk7dGhpcy5jdHJsS2V5PWEuY3RybEtleTt0aGlzLmFsdEtleT1hLmFsdEtleTt0aGlzLnNoaWZ0S2V5PWEuc2hpZnRLZXk7dGhpcy5tZXRhS2V5PWEubWV0YUtleTt0aGlzLnN0YXRlPWEuc3RhdGU7dGhpcy51Yj1hO2EuZGVmYXVsdFByZXZlbnRlZCYmXG50aGlzLnByZXZlbnREZWZhdWx0KCl9O05iLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe05iLnljLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7dmFyIGE9dGhpcy51YjtpZihhLnByZXZlbnREZWZhdWx0KWEucHJldmVudERlZmF1bHQoKTtlbHNlIGlmKGEucmV0dXJuVmFsdWU9ITEsS2IpdHJ5e2lmKGEuY3RybEtleXx8MTEyPD1hLmtleUNvZGUmJjEyMz49YS5rZXlDb2RlKWEua2V5Q29kZT0tMX1jYXRjaChiKXt9fTt2YXIgT2I9XCJjbG9zdXJlX2xpc3RlbmFibGVfXCIrKDFFNipNYXRoLnJhbmRvbSgpfDApLFBiPTA7dmFyIFFiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5saXN0ZW5lcj1hO3RoaXMuSWI9bnVsbDt0aGlzLnNyYz1iO3RoaXMudHlwZT1jO3RoaXMucmI9ISFkO3RoaXMuemI9ZTt0aGlzLmtleT0rK1BiO3RoaXMuUGE9dGhpcy5xYj0hMX0sUmI9ZnVuY3Rpb24oYSl7YS5QYT0hMDthLmxpc3RlbmVyPW51bGw7YS5JYj1udWxsO2Euc3JjPW51bGw7YS56Yj1udWxsfTt2YXIgU2I9ZnVuY3Rpb24oYSl7dGhpcy5zcmM9YTt0aGlzLnY9e307dGhpcy5wYj0wfTtTYi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS50b1N0cmluZygpO2E9dGhpcy52W2ZdO2F8fChhPXRoaXMudltmXT1bXSx0aGlzLnBiKyspO3ZhciBnPVRiKGEsYixkLGUpOy0xPGc/KGI9YVtnXSxjfHwoYi5xYj0hMSkpOihiPW5ldyBRYihiLHRoaXMuc3JjLGYsISFkLGUpLGIucWI9YyxhLnB1c2goYikpO3JldHVybiBifTtTYi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEsYixjLGQpe2E9YS50b1N0cmluZygpO2lmKCEoYSBpbiB0aGlzLnYpKXJldHVybiExO3ZhciBlPXRoaXMudlthXTtiPVRiKGUsYixjLGQpO3JldHVybi0xPGI/KFJiKGVbYl0pLEphKGUsYiksMD09ZS5sZW5ndGgmJihkZWxldGUgdGhpcy52W2FdLHRoaXMucGItLSksITApOiExfTtcbnZhciBVYj1mdW5jdGlvbihhLGIpe3ZhciBjPWIudHlwZTtjIGluIGEudiYmS2EoYS52W2NdLGIpJiYoUmIoYiksMD09YS52W2NdLmxlbmd0aCYmKGRlbGV0ZSBhLnZbY10sYS5wYi0tKSl9O1NiLnByb3RvdHlwZS5lYz1mdW5jdGlvbihhLGIsYyxkKXthPXRoaXMudlthLnRvU3RyaW5nKCldO3ZhciBlPS0xO2EmJihlPVRiKGEsYixjLGQpKTtyZXR1cm4tMTxlP2FbZV06bnVsbH07dmFyIFRiPWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKCFmLlBhJiZmLmxpc3RlbmVyPT1iJiZmLnJiPT0hIWMmJmYuemI9PWQpcmV0dXJuIGV9cmV0dXJuLTF9O3ZhciBWYj1cImNsb3N1cmVfbG1fXCIrKDFFNipNYXRoLnJhbmRvbSgpfDApLFdiPXt9LFhiPTAsWWI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihlYShiKSlmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKylZYihhLGJbZl0sYyxkLGUpO2Vsc2UgYz1aYihjKSxhJiZhW09iXT8kYihhLGIsYyxkLGUpOmFjKGEsYixjLCExLGQsZSl9LGFjPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighYil0aHJvdyBFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTt2YXIgZz0hIWUsaD1iYyhhKTtofHwoYVtWYl09aD1uZXcgU2IoYSkpO2M9aC5hZGQoYixjLGQsZSxmKTtpZighYy5JYil7ZD1jYygpO2MuSWI9ZDtkLnNyYz1hO2QubGlzdGVuZXI9YztpZihhLmFkZEV2ZW50TGlzdGVuZXIpYS5hZGRFdmVudExpc3RlbmVyKGIudG9TdHJpbmcoKSxkLGcpO2Vsc2UgaWYoYS5hdHRhY2hFdmVudClhLmF0dGFjaEV2ZW50KGRjKGIudG9TdHJpbmcoKSksZCk7ZWxzZSB0aHJvdyBFcnJvcihcImFkZEV2ZW50TGlzdGVuZXIgYW5kIGF0dGFjaEV2ZW50IGFyZSB1bmF2YWlsYWJsZS5cIik7XG5YYisrfX0sY2M9ZnVuY3Rpb24oKXt2YXIgYT1lYyxiPUpiP2Z1bmN0aW9uKGMpe3JldHVybiBhLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKX06ZnVuY3Rpb24oYyl7Yz1hLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKTtpZighYylyZXR1cm4gY307cmV0dXJuIGJ9LGZjPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoZWEoYikpZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspZmMoYSxiW2ZdLGMsZCxlKTtlbHNlIGM9WmIoYyksYSYmYVtPYl0/Z2MoYSxiLGMsZCxlKTphYyhhLGIsYywhMCxkLGUpfSxoYz1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKGVhKGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKWhjKGEsYltmXSxjLGQsZSk7ZWxzZSBjPVpiKGMpLGEmJmFbT2JdP2EuTy5yZW1vdmUoU3RyaW5nKGIpLGMsZCxlKTphJiYoYT1iYyhhKSkmJihiPWEuZWMoYixjLCEhZCxlKSkmJmljKGIpfSxpYz1mdW5jdGlvbihhKXtpZighZ2EoYSkmJmEmJiFhLlBhKXt2YXIgYj1hLnNyYztpZihiJiZcbmJbT2JdKVViKGIuTyxhKTtlbHNle3ZhciBjPWEudHlwZSxkPWEuSWI7Yi5yZW1vdmVFdmVudExpc3RlbmVyP2IucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLGQsYS5yYik6Yi5kZXRhY2hFdmVudCYmYi5kZXRhY2hFdmVudChkYyhjKSxkKTtYYi0tOyhjPWJjKGIpKT8oVWIoYyxhKSwwPT1jLnBiJiYoYy5zcmM9bnVsbCxiW1ZiXT1udWxsKSk6UmIoYSl9fX0sZGM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW4gV2I/V2JbYV06V2JbYV09XCJvblwiK2F9LGtjPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPSEwO2lmKGE9YmMoYSkpaWYoYj1hLnZbYi50b1N0cmluZygpXSlmb3IoYj1iLmNvbmNhdCgpLGE9MDthPGIubGVuZ3RoO2ErKyl7dmFyIGY9YlthXTtmJiZmLnJiPT1jJiYhZi5QYSYmKGY9amMoZixkKSxlPWUmJiExIT09Zil9cmV0dXJuIGV9LGpjPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5saXN0ZW5lcixkPWEuemJ8fGEuc3JjO2EucWImJmljKGEpO3JldHVybiBjLmNhbGwoZCxiKX0sZWM9ZnVuY3Rpb24oYSxcbmIpe2lmKGEuUGEpcmV0dXJuITA7aWYoIUpiKXt2YXIgYztpZighKGM9YikpYTp7Yz1bXCJ3aW5kb3dcIixcImV2ZW50XCJdO2Zvcih2YXIgZD1sLGU7ZT1jLnNoaWZ0KCk7KWlmKG51bGwhPWRbZV0pZD1kW2VdO2Vsc2V7Yz1udWxsO2JyZWFrIGF9Yz1kfWU9YztjPW5ldyBOYihlLHRoaXMpO2Q9ITA7aWYoISgwPmUua2V5Q29kZXx8dm9pZCAwIT1lLnJldHVyblZhbHVlKSl7YTp7dmFyIGY9ITE7aWYoMD09ZS5rZXlDb2RlKXRyeXtlLmtleUNvZGU9LTE7YnJlYWsgYX1jYXRjaChtKXtmPSEwfWlmKGZ8fHZvaWQgMD09ZS5yZXR1cm5WYWx1ZSllLnJldHVyblZhbHVlPSEwfWU9W107Zm9yKGY9Yy5jdXJyZW50VGFyZ2V0O2Y7Zj1mLnBhcmVudE5vZGUpZS5wdXNoKGYpO2Zvcih2YXIgZj1hLnR5cGUsZz1lLmxlbmd0aC0xOyFjLk5hJiYwPD1nO2ctLSl7Yy5jdXJyZW50VGFyZ2V0PWVbZ107dmFyIGg9a2MoZVtnXSxmLCEwLGMpLGQ9ZCYmaH1mb3IoZz0wOyFjLk5hJiZnPGUubGVuZ3RoO2crKyljLmN1cnJlbnRUYXJnZXQ9XG5lW2ddLGg9a2MoZVtnXSxmLCExLGMpLGQ9ZCYmaH1yZXR1cm4gZH1yZXR1cm4gamMoYSxuZXcgTmIoYix0aGlzKSl9LGJjPWZ1bmN0aW9uKGEpe2E9YVtWYl07cmV0dXJuIGEgaW5zdGFuY2VvZiBTYj9hOm51bGx9LGxjPVwiX19jbG9zdXJlX2V2ZW50c19mbl9cIisoMUU5Kk1hdGgucmFuZG9tKCk+Pj4wKSxaYj1mdW5jdGlvbihhKXt2KGEsXCJMaXN0ZW5lciBjYW4gbm90IGJlIG51bGwuXCIpO2lmKHAoYSkpcmV0dXJuIGE7dihhLmhhbmRsZUV2ZW50LFwiQW4gb2JqZWN0IGxpc3RlbmVyIG11c3QgaGF2ZSBoYW5kbGVFdmVudCBtZXRob2QuXCIpO2FbbGNdfHwoYVtsY109ZnVuY3Rpb24oYil7cmV0dXJuIGEuaGFuZGxlRXZlbnQoYil9KTtyZXR1cm4gYVtsY119O3ZhciBtYz0vXlsrYS16QS1aMC05Xy4hIyQlJicqXFwvPT9eYHt8fX4tXStAKFthLXpBLVowLTktXStcXC4pK1thLXpBLVowLTldezIsNjN9JC87dmFyIG5jPWZ1bmN0aW9uKGEpe2E9U3RyaW5nKGEpO2lmKC9eXFxzKiQvLnRlc3QoYSk/MDovXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZyxcIkBcIikucmVwbGFjZSgvKD86XCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/KVtcXHNcXHUyMDI4XFx1MjAyOV0qKD89OnwsfF18fXwkKS9nLFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpbXFxzXFx1MjAyOFxcdTIwMjldKlxcWykrL2csXCJcIikpKXRyeXtyZXR1cm4gZXZhbChcIihcIithK1wiKVwiKX1jYXRjaChiKXt9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIithKTt9LHFjPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO29jKG5ldyBwYyxhLGIpO3JldHVybiBiLmpvaW4oXCJcIil9LHBjPWZ1bmN0aW9uKCl7dGhpcy5MYj12b2lkIDB9LG9jPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT1cbmIpYy5wdXNoKFwibnVsbFwiKTtlbHNle2lmKFwib2JqZWN0XCI9PXR5cGVvZiBiKXtpZihlYShiKSl7dmFyIGQ9YjtiPWQubGVuZ3RoO2MucHVzaChcIltcIik7Zm9yKHZhciBlPVwiXCIsZj0wO2Y8YjtmKyspYy5wdXNoKGUpLGU9ZFtmXSxvYyhhLGEuTGI/YS5MYi5jYWxsKGQsU3RyaW5nKGYpLGUpOmUsYyksZT1cIixcIjtjLnB1c2goXCJdXCIpO3JldHVybn1pZihiIGluc3RhbmNlb2YgU3RyaW5nfHxiIGluc3RhbmNlb2YgTnVtYmVyfHxiIGluc3RhbmNlb2YgQm9vbGVhbiliPWIudmFsdWVPZigpO2Vsc2V7Yy5wdXNoKFwie1wiKTtmPVwiXCI7Zm9yKGQgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixkKSYmKGU9YltkXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoYy5wdXNoKGYpLHJjKGQsYyksYy5wdXNoKFwiOlwiKSxvYyhhLGEuTGI/YS5MYi5jYWxsKGIsZCxlKTplLGMpLGY9XCIsXCIpKTtjLnB1c2goXCJ9XCIpO3JldHVybn19c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwic3RyaW5nXCI6cmMoYixcbmMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJiFpc05hTihiKT9TdHJpbmcoYik6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKFN0cmluZyhiKSk7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX19LHNjPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LHRjPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nOi9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nLHJjPWZ1bmN0aW9uKGEsYil7Yi5wdXNoKCdcIicsYS5yZXBsYWNlKHRjLGZ1bmN0aW9uKGEpe3ZhciBiPXNjW2FdO2J8fChiPVwiXFxcXHVcIisoYS5jaGFyQ29kZUF0KDApfDY1NTM2KS50b1N0cmluZygxNikuc3Vic3RyKDEpLFxuc2NbYV09Yik7cmV0dXJuIGJ9KSwnXCInKX07dmFyIHVjPWZ1bmN0aW9uKCl7fTt1Yy5wcm90b3R5cGUuQmM9bnVsbDt2YXIgdmM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuQmN8fChhLkJjPWEuVWMoKSl9O3ZhciB3Yyx4Yz1mdW5jdGlvbigpe307cih4Yyx1Yyk7eGMucHJvdG90eXBlLiRiPWZ1bmN0aW9uKCl7dmFyIGE9eWModGhpcyk7cmV0dXJuIGE/bmV3IEFjdGl2ZVhPYmplY3QoYSk6bmV3IFhNTEh0dHBSZXF1ZXN0fTt4Yy5wcm90b3R5cGUuVWM9ZnVuY3Rpb24oKXt2YXIgYT17fTt5Yyh0aGlzKSYmKGFbMF09ITAsYVsxXT0hMCk7cmV0dXJuIGF9O1xudmFyIHljPWZ1bmN0aW9uKGEpe2lmKCFhLlFjJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgWE1MSHR0cFJlcXVlc3QmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBBY3RpdmVYT2JqZWN0KXtmb3IodmFyIGI9W1wiTVNYTUwyLlhNTEhUVFAuNi4wXCIsXCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcIk1TWE1MMi5YTUxIVFRQXCIsXCJNaWNyb3NvZnQuWE1MSFRUUFwiXSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChkKSxhLlFjPWR9Y2F0Y2goZSl7fX10aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgQWN0aXZlWE9iamVjdC4gQWN0aXZlWCBtaWdodCBiZSBkaXNhYmxlZCwgb3IgTVNYTUwgbWlnaHQgbm90IGJlIGluc3RhbGxlZFwiKTt9cmV0dXJuIGEuUWN9O3djPW5ldyB4Yzt2YXIgemM9ZnVuY3Rpb24oKXt9O3IoemMsdWMpO3pjLnByb3RvdHlwZS4kYj1mdW5jdGlvbigpe3ZhciBhPW5ldyBYTUxIdHRwUmVxdWVzdDtpZihcIndpdGhDcmVkZW50aWFsc1wiaW4gYSlyZXR1cm4gYTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgWERvbWFpblJlcXVlc3QpcmV0dXJuIG5ldyBBYzt0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGJyb3dzZXJcIik7fTt6Yy5wcm90b3R5cGUuVWM9ZnVuY3Rpb24oKXtyZXR1cm57fX07XG52YXIgQWM9ZnVuY3Rpb24oKXt0aGlzLmZhPW5ldyBYRG9tYWluUmVxdWVzdDt0aGlzLnJlYWR5U3RhdGU9MDt0aGlzLnJlc3BvbnNlVGV4dD10aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO3RoaXMuc3RhdHVzPS0xO3RoaXMuc3RhdHVzVGV4dD10aGlzLnJlc3BvbnNlWE1MPW51bGw7dGhpcy5mYS5vbmxvYWQ9cSh0aGlzLk5kLHRoaXMpO3RoaXMuZmEub25lcnJvcj1xKHRoaXMuT2MsdGhpcyk7dGhpcy5mYS5vbnByb2dyZXNzPXEodGhpcy5PZCx0aGlzKTt0aGlzLmZhLm9udGltZW91dD1xKHRoaXMuUGQsdGhpcyl9O2s9QWMucHJvdG90eXBlO2sub3Blbj1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YyYmIWMpdGhyb3cgRXJyb3IoXCJPbmx5IGFzeW5jIHJlcXVlc3RzIGFyZSBzdXBwb3J0ZWQuXCIpO3RoaXMuZmEub3BlbihhLGIpfTtcbmsuc2VuZD1mdW5jdGlvbihhKXtpZihhKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXRoaXMuZmEuc2VuZChhKTtlbHNlIHRocm93IEVycm9yKFwiT25seSBzdHJpbmcgZGF0YSBpcyBzdXBwb3J0ZWRcIik7ZWxzZSB0aGlzLmZhLnNlbmQoKX07ay5hYm9ydD1mdW5jdGlvbigpe3RoaXMuZmEuYWJvcnQoKX07ay5zZXRSZXF1ZXN0SGVhZGVyPWZ1bmN0aW9uKCl7fTtrLk5kPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXM9MjAwO3RoaXMucmVzcG9uc2VUZXh0PXRoaXMuZmEucmVzcG9uc2VUZXh0O0JjKHRoaXMsNCl9O2suT2M9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz01MDA7dGhpcy5yZXNwb25zZVRleHQ9bnVsbDtCYyh0aGlzLDQpfTtrLlBkPWZ1bmN0aW9uKCl7dGhpcy5PYygpfTtrLk9kPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXM9MjAwO0JjKHRoaXMsMSl9O3ZhciBCYz1mdW5jdGlvbihhLGIpe2EucmVhZHlTdGF0ZT1iO2lmKGEub25yZWFkeXN0YXRlY2hhbmdlKWEub25yZWFkeXN0YXRlY2hhbmdlKCl9O3ZhciBCPWZ1bmN0aW9uKGEsYil7dGhpcy5oPVtdO3RoaXMuZz1iO2Zvcih2YXIgYz0hMCxkPWEubGVuZ3RoLTE7MDw9ZDtkLS0pe3ZhciBlPWFbZF18MDtjJiZlPT1ifHwodGhpcy5oW2RdPWUsYz0hMSl9fSxDYz17fSxEYz1mdW5jdGlvbihhKXtpZigtMTI4PD1hJiYxMjg+YSl7dmFyIGI9Q2NbYV07aWYoYilyZXR1cm4gYn1iPW5ldyBCKFthfDBdLDA+YT8tMTowKTstMTI4PD1hJiYxMjg+YSYmKENjW2FdPWIpO3JldHVybiBifSxFPWZ1bmN0aW9uKGEpe2lmKGlzTmFOKGEpfHwhaXNGaW5pdGUoYSkpcmV0dXJuIEM7aWYoMD5hKXJldHVybiBEKEUoLWEpKTtmb3IodmFyIGI9W10sYz0xLGQ9MDthPj1jO2QrKyliW2RdPWEvY3wwLGMqPTQyOTQ5NjcyOTY7cmV0dXJuIG5ldyBCKGIsMCl9LEVjPWZ1bmN0aW9uKGEsYil7aWYoMD09YS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJudW1iZXIgZm9ybWF0IGVycm9yOiBlbXB0eSBzdHJpbmdcIik7dmFyIGM9Ynx8MTA7aWYoMj5jfHwzNjxjKXRocm93IEVycm9yKFwicmFkaXggb3V0IG9mIHJhbmdlOiBcIitcbmMpO2lmKFwiLVwiPT1hLmNoYXJBdCgwKSlyZXR1cm4gRChFYyhhLnN1YnN0cmluZygxKSxjKSk7aWYoMDw9YS5pbmRleE9mKFwiLVwiKSl0aHJvdyBFcnJvcignbnVtYmVyIGZvcm1hdCBlcnJvcjogaW50ZXJpb3IgXCItXCIgY2hhcmFjdGVyJyk7Zm9yKHZhciBkPUUoTWF0aC5wb3coYyw4KSksZT1DLGY9MDtmPGEubGVuZ3RoO2YrPTgpe3ZhciBnPU1hdGgubWluKDgsYS5sZW5ndGgtZiksaD1wYXJzZUludChhLnN1YnN0cmluZyhmLGYrZyksYyk7OD5nPyhnPUUoTWF0aC5wb3coYyxnKSksZT1lLm11bHRpcGx5KGcpLmFkZChFKGgpKSk6KGU9ZS5tdWx0aXBseShkKSxlPWUuYWRkKEUoaCkpKX1yZXR1cm4gZX0sQz1EYygwKSxGYz1EYygxKSxHYz1EYygxNjc3NzIxNiksSGM9ZnVuY3Rpb24oYSl7aWYoLTE9PWEuZylyZXR1cm4tSGMoRChhKSk7Zm9yKHZhciBiPTAsYz0xLGQ9MDtkPGEuaC5sZW5ndGg7ZCsrKWIrPUljKGEsZCkqYyxjKj00Mjk0OTY3Mjk2O3JldHVybiBifTtcbkIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGEpe2E9YXx8MTA7aWYoMj5hfHwzNjxhKXRocm93IEVycm9yKFwicmFkaXggb3V0IG9mIHJhbmdlOiBcIithKTtpZihGKHRoaXMpKXJldHVyblwiMFwiO2lmKC0xPT10aGlzLmcpcmV0dXJuXCItXCIrRCh0aGlzKS50b1N0cmluZyhhKTtmb3IodmFyIGI9RShNYXRoLnBvdyhhLDYpKSxjPXRoaXMsZD1cIlwiOzspe3ZhciBlPUpjKGMsYiksYz1LYyhjLGUubXVsdGlwbHkoYikpLGY9KCgwPGMuaC5sZW5ndGg/Yy5oWzBdOmMuZyk+Pj4wKS50b1N0cmluZyhhKSxjPWU7aWYoRihjKSlyZXR1cm4gZitkO2Zvcig7Nj5mLmxlbmd0aDspZj1cIjBcIitmO2Q9XCJcIitmK2R9fTtcbnZhciBHPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDA+Yj8wOmI8YS5oLmxlbmd0aD9hLmhbYl06YS5nfSxJYz1mdW5jdGlvbihhLGIpe3ZhciBjPUcoYSxiKTtyZXR1cm4gMDw9Yz9jOjQyOTQ5NjcyOTYrY30sRj1mdW5jdGlvbihhKXtpZigwIT1hLmcpcmV0dXJuITE7Zm9yKHZhciBiPTA7YjxhLmgubGVuZ3RoO2IrKylpZigwIT1hLmhbYl0pcmV0dXJuITE7cmV0dXJuITB9O0IucHJvdG90eXBlLnRiPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZyE9YS5nKXJldHVybiExO2Zvcih2YXIgYj1NYXRoLm1heCh0aGlzLmgubGVuZ3RoLGEuaC5sZW5ndGgpLGM9MDtjPGI7YysrKWlmKEcodGhpcyxjKSE9RyhhLGMpKXJldHVybiExO3JldHVybiEwfTtCLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKGEpe2E9S2ModGhpcyxhKTtyZXR1cm4tMT09YS5nPy0xOkYoYSk/MDoxfTtcbnZhciBEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmgubGVuZ3RoLGM9W10sZD0wO2Q8YjtkKyspY1tkXT1+YS5oW2RdO3JldHVybihuZXcgQihjLH5hLmcpKS5hZGQoRmMpfTtCLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPU1hdGgubWF4KHRoaXMuaC5sZW5ndGgsYS5oLmxlbmd0aCksYz1bXSxkPTAsZT0wO2U8PWI7ZSsrKXt2YXIgZj1kKyhHKHRoaXMsZSkmNjU1MzUpKyhHKGEsZSkmNjU1MzUpLGc9KGY+Pj4xNikrKEcodGhpcyxlKT4+PjE2KSsoRyhhLGUpPj4+MTYpLGQ9Zz4+PjE2LGY9ZiY2NTUzNSxnPWcmNjU1MzU7Y1tlXT1nPDwxNnxmfXJldHVybiBuZXcgQihjLGNbYy5sZW5ndGgtMV0mLTIxNDc0ODM2NDg/LTE6MCl9O3ZhciBLYz1mdW5jdGlvbihhLGIpe3JldHVybiBhLmFkZChEKGIpKX07XG5CLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihhKXtpZihGKHRoaXMpfHxGKGEpKXJldHVybiBDO2lmKC0xPT10aGlzLmcpcmV0dXJuLTE9PWEuZz9EKHRoaXMpLm11bHRpcGx5KEQoYSkpOkQoRCh0aGlzKS5tdWx0aXBseShhKSk7aWYoLTE9PWEuZylyZXR1cm4gRCh0aGlzLm11bHRpcGx5KEQoYSkpKTtpZigwPnRoaXMuY29tcGFyZShHYykmJjA+YS5jb21wYXJlKEdjKSlyZXR1cm4gRShIYyh0aGlzKSpIYyhhKSk7Zm9yKHZhciBiPXRoaXMuaC5sZW5ndGgrYS5oLmxlbmd0aCxjPVtdLGQ9MDtkPDIqYjtkKyspY1tkXT0wO2ZvcihkPTA7ZDx0aGlzLmgubGVuZ3RoO2QrKylmb3IodmFyIGU9MDtlPGEuaC5sZW5ndGg7ZSsrKXt2YXIgZj1HKHRoaXMsZCk+Pj4xNixnPUcodGhpcyxkKSY2NTUzNSxoPUcoYSxlKT4+PjE2LG09RyhhLGUpJjY1NTM1O2NbMipkKzIqZV0rPWcqbTtMYyhjLDIqZCsyKmUpO2NbMipkKzIqZSsxXSs9ZiptO0xjKGMsMipkKzIqZSsxKTtjWzIqZCsyKmUrMV0rPVxuZypoO0xjKGMsMipkKzIqZSsxKTtjWzIqZCsyKmUrMl0rPWYqaDtMYyhjLDIqZCsyKmUrMil9Zm9yKGQ9MDtkPGI7ZCsrKWNbZF09Y1syKmQrMV08PDE2fGNbMipkXTtmb3IoZD1iO2Q8MipiO2QrKyljW2RdPTA7cmV0dXJuIG5ldyBCKGMsMCl9O1xudmFyIExjPWZ1bmN0aW9uKGEsYil7Zm9yKDsoYVtiXSY2NTUzNSkhPWFbYl07KWFbYisxXSs9YVtiXT4+PjE2LGFbYl0mPTY1NTM1fSxKYz1mdW5jdGlvbihhLGIpe2lmKEYoYikpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO2lmKEYoYSkpcmV0dXJuIEM7aWYoLTE9PWEuZylyZXR1cm4tMT09Yi5nP0pjKEQoYSksRChiKSk6RChKYyhEKGEpLGIpKTtpZigtMT09Yi5nKXJldHVybiBEKEpjKGEsRChiKSkpO2lmKDMwPGEuaC5sZW5ndGgpe2lmKC0xPT1hLmd8fC0xPT1iLmcpdGhyb3cgRXJyb3IoXCJzbG93RGl2aWRlXyBvbmx5IHdvcmtzIHdpdGggcG9zaXRpdmUgaW50ZWdlcnMuXCIpO2Zvcih2YXIgYz1GYyxkPWI7MD49ZC5jb21wYXJlKGEpOyljPWMuc2hpZnRMZWZ0KDEpLGQ9ZC5zaGlmdExlZnQoMSk7Zm9yKHZhciBlPU1jKGMsMSksZj1NYyhkLDEpLGcsZD1NYyhkLDIpLGM9TWMoYywyKTshRihkKTspZz1mLmFkZChkKSwwPj1nLmNvbXBhcmUoYSkmJihlPWUuYWRkKGMpLFxuZj1nKSxkPU1jKGQsMSksYz1NYyhjLDEpO3JldHVybiBlfWM9Qztmb3IoZD1hOzA8PWQuY29tcGFyZShiKTspe2U9TWF0aC5tYXgoMSxNYXRoLmZsb29yKEhjKGQpL0hjKGIpKSk7Zj1NYXRoLmNlaWwoTWF0aC5sb2coZSkvTWF0aC5MTjIpO2Y9NDg+PWY/MTpNYXRoLnBvdygyLGYtNDgpO2c9RShlKTtmb3IodmFyIGg9Zy5tdWx0aXBseShiKTstMT09aC5nfHwwPGguY29tcGFyZShkKTspZS09ZixnPUUoZSksaD1nLm11bHRpcGx5KGIpO0YoZykmJihnPUZjKTtjPWMuYWRkKGcpO2Q9S2MoZCxoKX1yZXR1cm4gY30sTmM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9TWF0aC5tYXgoYS5oLmxlbmd0aCxiLmgubGVuZ3RoKSxkPVtdLGU9MDtlPGM7ZSsrKWRbZV09RyhhLGUpfEcoYixlKTtyZXR1cm4gbmV3IEIoZCxhLmd8Yi5nKX07XG5CLnByb3RvdHlwZS5zaGlmdExlZnQ9ZnVuY3Rpb24oYSl7dmFyIGI9YT4+NTthJT0zMjtmb3IodmFyIGM9dGhpcy5oLmxlbmd0aCtiKygwPGE/MTowKSxkPVtdLGU9MDtlPGM7ZSsrKWRbZV09MDxhP0codGhpcyxlLWIpPDxhfEcodGhpcyxlLWItMSk+Pj4zMi1hOkcodGhpcyxlLWIpO3JldHVybiBuZXcgQihkLHRoaXMuZyl9O3ZhciBNYz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iPj41LGQ9YiUzMixlPWEuaC5sZW5ndGgtYyxmPVtdLGc9MDtnPGU7ZysrKWZbZ109MDxkP0coYSxnK2MpPj4+ZHxHKGEsZytjKzEpPDwzMi1kOkcoYSxnK2MpO3JldHVybiBuZXcgQihmLGEuZyl9O3ZhciBPYz1mdW5jdGlvbihhLGIpe3RoaXMuY2I9YTt0aGlzLmVhPWJ9O09jLnByb3RvdHlwZS50Yj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYT09YS5lYSYmdGhpcy5jYi50YihZYShhLmNiKSl9O1xudmFyIFJjPWZ1bmN0aW9uKGEpe3RyeXt2YXIgYjtpZihiPTA9PWEubGFzdEluZGV4T2YoXCJbXCIsMCkpe3ZhciBjPWEubGVuZ3RoLTE7Yj0wPD1jJiZhLmluZGV4T2YoXCJdXCIsYyk9PWN9cmV0dXJuIGI/bmV3IFBjKGEuc3Vic3RyaW5nKDEsYS5sZW5ndGgtMSkpOm5ldyBRYyhhKX1jYXRjaChkKXtyZXR1cm4gbnVsbH19LFFjPWZ1bmN0aW9uKGEpe3ZhciBiPUM7aWYoYSBpbnN0YW5jZW9mIEIpe2lmKDAhPWEuZ3x8MD5hLmNvbXBhcmUoQyl8fDA8YS5jb21wYXJlKFNjKSl0aHJvdyBFcnJvcihcIlRoZSBhZGRyZXNzIGRvZXMgbm90IGxvb2sgbGlrZSBhbiBJUHY0LlwiKTtiPVlhKGEpfWVsc2V7aWYoIVRjLnRlc3QoYSkpdGhyb3cgRXJyb3IoYStcIiBkb2VzIG5vdCBsb29rIGxpa2UgYW4gSVB2NCBhZGRyZXNzLlwiKTt2YXIgYz1hLnNwbGl0KFwiLlwiKTtpZig0IT1jLmxlbmd0aCl0aHJvdyBFcnJvcihhK1wiIGRvZXMgbm90IGxvb2sgbGlrZSBhbiBJUHY0IGFkZHJlc3MuXCIpO2Zvcih2YXIgZD0wO2Q8XG5jLmxlbmd0aDtkKyspe3ZhciBlO2U9Y1tkXTt2YXIgZj1OdW1iZXIoZSk7ZT0wPT1mJiYvXltcXHNcXHhhMF0qJC8udGVzdChlKT9OYU46ZjtpZihpc05hTihlKXx8MD5lfHwyNTU8ZXx8MSE9Y1tkXS5sZW5ndGgmJjA9PWNbZF0ubGFzdEluZGV4T2YoXCIwXCIsMCkpdGhyb3cgRXJyb3IoXCJJbiBcIithK1wiLCBvY3RldCBcIitkK1wiIGlzIG5vdCB2YWxpZFwiKTtlPUUoZSk7Yj1OYyhiLnNoaWZ0TGVmdCg4KSxlKX19T2MuY2FsbCh0aGlzLGIsNCl9O3IoUWMsT2MpO3ZhciBUYz0vXlswLTkuXSokLyxTYz1LYyhGYy5zaGlmdExlZnQoMzIpLEZjKTtRYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLnZhKXJldHVybiB0aGlzLnZhO2Zvcih2YXIgYT1JYyh0aGlzLmNiLDApLGI9W10sYz0zOzA8PWM7Yy0tKWJbY109U3RyaW5nKGEmMjU1KSxhPj4+PTg7cmV0dXJuIHRoaXMudmE9Yi5qb2luKFwiLlwiKX07XG52YXIgUGM9ZnVuY3Rpb24oYSl7dmFyIGI9QztpZihhIGluc3RhbmNlb2YgQil7aWYoMCE9YS5nfHwwPmEuY29tcGFyZShDKXx8MDxhLmNvbXBhcmUoVWMpKXRocm93IEVycm9yKFwiVGhlIGFkZHJlc3MgZG9lcyBub3QgbG9vayBsaWtlIGEgdmFsaWQgSVB2Ni5cIik7Yj1ZYShhKX1lbHNle2lmKCFWYy50ZXN0KGEpKXRocm93IEVycm9yKGErXCIgaXMgbm90IGEgdmFsaWQgSVB2NiBhZGRyZXNzLlwiKTt2YXIgYz1hLnNwbGl0KFwiOlwiKTtpZigtMSE9Y1tjLmxlbmd0aC0xXS5pbmRleE9mKFwiLlwiKSl7YT1JYyhZYSgobmV3IFFjKGNbYy5sZW5ndGgtMV0pKS5jYiksMCk7dmFyIGQ9W107ZC5wdXNoKChhPj4+MTYmNjU1MzUpLnRvU3RyaW5nKDE2KSk7ZC5wdXNoKChhJjY1NTM1KS50b1N0cmluZygxNikpO0phKGMsYy5sZW5ndGgtMSk7UGEoYyxkKTthPWMuam9pbihcIjpcIil9ZD1hLnNwbGl0KFwiOjpcIik7aWYoMjxkLmxlbmd0aHx8MT09ZC5sZW5ndGgmJjghPWMubGVuZ3RoKXRocm93IEVycm9yKGErXG5cIiBpcyBub3QgYSB2YWxpZCBJUHY2IGFkZHJlc3MuXCIpO2lmKDE8ZC5sZW5ndGgpe2M9ZFswXS5zcGxpdChcIjpcIik7ZD1kWzFdLnNwbGl0KFwiOlwiKTsxPT1jLmxlbmd0aCYmXCJcIj09Y1swXSYmKGM9W10pOzE9PWQubGVuZ3RoJiZcIlwiPT1kWzBdJiYoZD1bXSk7dmFyIGU9OC0oYy5sZW5ndGgrZC5sZW5ndGgpO2lmKDE+ZSljPVtdO2Vsc2V7Zm9yKHZhciBmPVtdLGc9MDtnPGU7ZysrKWZbZ109XCIwXCI7Yz1OYShjLGYsZCl9fWlmKDghPWMubGVuZ3RoKXRocm93IEVycm9yKGErXCIgaXMgbm90IGEgdmFsaWQgSVB2NiBhZGRyZXNzXCIpO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspe2U9RWMoY1tkXSwxNik7aWYoMD5lLmNvbXBhcmUoQyl8fDA8ZS5jb21wYXJlKFdjKSl0aHJvdyBFcnJvcihjW2RdK1wiIGluIFwiK2ErXCIgaXMgbm90IGEgdmFsaWQgaGV4dGV0LlwiKTtiPU5jKGIuc2hpZnRMZWZ0KDE2KSxlKX19T2MuY2FsbCh0aGlzLGIsNil9O3IoUGMsT2MpO1xudmFyIFZjPS9eKFthLWZBLUYwLTldKjopezJ9W2EtZkEtRjAtOTouXSokLyxXYz1EYyg2NTUzNSksVWM9S2MoRmMuc2hpZnRMZWZ0KDEyOCksRmMpO1BjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2lmKHRoaXMudmEpcmV0dXJuIHRoaXMudmE7Zm9yKHZhciBhPVtdLGI9MzswPD1iO2ItLSl7dmFyIGM9SWModGhpcy5jYixiKSxkPWMmNjU1MzU7YS5wdXNoKChjPj4+MTYpLnRvU3RyaW5nKDE2KSk7YS5wdXNoKGQudG9TdHJpbmcoMTYpKX1mb3IodmFyIGM9Yj0tMSxlPWQ9MCxmPTA7ZjxhLmxlbmd0aDtmKyspXCIwXCI9PWFbZl0/KGUrKywtMT09YyYmKGM9ZiksZT5kJiYoZD1lLGI9YykpOihjPS0xLGU9MCk7MDxkJiYoYitkPT1hLmxlbmd0aCYmYS5wdXNoKFwiXCIpLGEuc3BsaWNlKGIsZCxcIlwiKSwwPT1iJiYoYT1bXCJcIl0uY29uY2F0KGEpKSk7cmV0dXJuIHRoaXMudmE9YS5qb2luKFwiOlwiKX07IWdiJiYheXx8eSYmOTw9TnVtYmVyKHFiKXx8Z2ImJnooXCIxLjkuMVwiKTt5JiZ6KFwiOVwiKTt2YXIgWWM9ZnVuY3Rpb24oYSxiKXtRYShiLGZ1bmN0aW9uKGIsZCl7XCJzdHlsZVwiPT1kP2Euc3R5bGUuY3NzVGV4dD1iOlwiY2xhc3NcIj09ZD9hLmNsYXNzTmFtZT1iOlwiZm9yXCI9PWQ/YS5odG1sRm9yPWI6WGMuaGFzT3duUHJvcGVydHkoZCk/YS5zZXRBdHRyaWJ1dGUoWGNbZF0sYik6MD09ZC5sYXN0SW5kZXhPZihcImFyaWEtXCIsMCl8fDA9PWQubGFzdEluZGV4T2YoXCJkYXRhLVwiLDApP2Euc2V0QXR0cmlidXRlKGQsYik6YVtkXT1ifSl9LFhjPXtjZWxscGFkZGluZzpcImNlbGxQYWRkaW5nXCIsY2VsbHNwYWNpbmc6XCJjZWxsU3BhY2luZ1wiLGNvbHNwYW46XCJjb2xTcGFuXCIsZnJhbWVib3JkZXI6XCJmcmFtZUJvcmRlclwiLGhlaWdodDpcImhlaWdodFwiLG1heGxlbmd0aDpcIm1heExlbmd0aFwiLG5vbmNlOlwibm9uY2VcIixyb2xlOlwicm9sZVwiLHJvd3NwYW46XCJyb3dTcGFuXCIsdHlwZTpcInR5cGVcIix1c2VtYXA6XCJ1c2VNYXBcIix2YWxpZ246XCJ2QWxpZ25cIix3aWR0aDpcIndpZHRoXCJ9O3ZhciBaYz1mdW5jdGlvbihhLGIsYyl7dGhpcy5hZT1jO3RoaXMuQ2Q9YTt0aGlzLmxlPWI7dGhpcy5GYj0wO3RoaXMuQWI9bnVsbH07WmMucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhOzA8dGhpcy5GYj8odGhpcy5GYi0tLGE9dGhpcy5BYix0aGlzLkFiPWEubmV4dCxhLm5leHQ9bnVsbCk6YT10aGlzLkNkKCk7cmV0dXJuIGF9O1pjLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYSl7dGhpcy5sZShhKTt0aGlzLkZiPHRoaXMuYWUmJih0aGlzLkZiKyssYS5uZXh0PXRoaXMuQWIsdGhpcy5BYj1hKX07dmFyICRjPWZ1bmN0aW9uKGEpe2wuc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGE7fSwwKX0sYWQsYmQ9ZnVuY3Rpb24oKXt2YXIgYT1sLk1lc3NhZ2VDaGFubmVsO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wb3N0TWVzc2FnZSYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXImJiF4KFwiUHJlc3RvXCIpJiYoYT1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJJRlJBTUVcIik7YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2Euc3JjPVwiXCI7ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGEpO3ZhciBiPWEuY29udGVudFdpbmRvdyxhPWIuZG9jdW1lbnQ7YS5vcGVuKCk7YS53cml0ZShcIlwiKTthLmNsb3NlKCk7dmFyIGM9XCJjYWxsSW1tZWRpYXRlXCIrTWF0aC5yYW5kb20oKSxkPVwiZmlsZTpcIj09Yi5sb2NhdGlvbi5wcm90b2NvbD9cIipcIjpiLmxvY2F0aW9uLnByb3RvY29sK1wiLy9cIitiLmxvY2F0aW9uLmhvc3QsXG5hPXEoZnVuY3Rpb24oYSl7aWYoKFwiKlwiPT1kfHxhLm9yaWdpbj09ZCkmJmEuZGF0YT09Yyl0aGlzLnBvcnQxLm9ubWVzc2FnZSgpfSx0aGlzKTtiLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYSwhMSk7dGhpcy5wb3J0MT17fTt0aGlzLnBvcnQyPXtwb3N0TWVzc2FnZTpmdW5jdGlvbigpe2IucG9zdE1lc3NhZ2UoYyxkKX19fSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYheChcIlRyaWRlbnRcIikmJiF4KFwiTVNJRVwiKSl7dmFyIGI9bmV3IGEsYz17fSxkPWM7Yi5wb3J0MS5vbm1lc3NhZ2U9ZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1jLm5leHQpe2M9Yy5uZXh0O3ZhciBhPWMuRmM7Yy5GYz1udWxsO2EoKX19O3JldHVybiBmdW5jdGlvbihhKXtkLm5leHQ9e0ZjOmF9O2Q9ZC5uZXh0O2IucG9ydDIucG9zdE1lc3NhZ2UoMCl9fXJldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiU0NSSVBUXCIpP1xuZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKTtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2Iub25yZWFkeXN0YXRlY2hhbmdlPW51bGw7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2I9bnVsbDthKCk7YT1udWxsfTtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYil9OmZ1bmN0aW9uKGEpe2wuc2V0VGltZW91dChhLDApfX07dmFyIGNkPWZ1bmN0aW9uKCl7dGhpcy5UYj10aGlzLkRhPW51bGx9LGVkPW5ldyBaYyhmdW5jdGlvbigpe3JldHVybiBuZXcgZGR9LGZ1bmN0aW9uKGEpe2EucmVzZXQoKX0sMTAwKTtjZC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZWQuZ2V0KCk7Yy5zZXQoYSxiKTt0aGlzLlRiP3RoaXMuVGIubmV4dD1jOih2KCF0aGlzLkRhKSx0aGlzLkRhPWMpO3RoaXMuVGI9Y307Y2QucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3ZhciBhPW51bGw7dGhpcy5EYSYmKGE9dGhpcy5EYSx0aGlzLkRhPXRoaXMuRGEubmV4dCx0aGlzLkRhfHwodGhpcy5UYj1udWxsKSxhLm5leHQ9bnVsbCk7cmV0dXJuIGF9O3ZhciBkZD1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLnNjb3BlPXRoaXMuZGM9bnVsbH07ZGQucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3RoaXMuZGM9YTt0aGlzLnNjb3BlPWI7dGhpcy5uZXh0PW51bGx9O1xuZGQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuc2NvcGU9dGhpcy5kYz1udWxsfTt2YXIgamQ9ZnVuY3Rpb24oYSxiKXtmZHx8Z2QoKTtoZHx8KGZkKCksaGQ9ITApO2lkLmFkZChhLGIpfSxmZCxnZD1mdW5jdGlvbigpe2lmKGwuUHJvbWlzZSYmbC5Qcm9taXNlLnJlc29sdmUpe3ZhciBhPWwuUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7ZmQ9ZnVuY3Rpb24oKXthLnRoZW4oa2QpfX1lbHNlIGZkPWZ1bmN0aW9uKCl7dmFyIGE9a2Q7IXAobC5zZXRJbW1lZGlhdGUpfHxsLldpbmRvdyYmbC5XaW5kb3cucHJvdG90eXBlJiYheChcIkVkZ2VcIikmJmwuV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PWwuc2V0SW1tZWRpYXRlPyhhZHx8KGFkPWJkKCkpLGFkKGEpKTpsLnNldEltbWVkaWF0ZShhKX19LGhkPSExLGlkPW5ldyBjZCxrZD1mdW5jdGlvbigpe2Zvcih2YXIgYTthPWlkLnJlbW92ZSgpOyl7dHJ5e2EuZGMuY2FsbChhLnNjb3BlKX1jYXRjaChiKXskYyhiKX1lZC5wdXQoYSl9aGQ9ITF9O3ZhciBsZD1mdW5jdGlvbihhKXthLnByb3RvdHlwZS50aGVuPWEucHJvdG90eXBlLnRoZW47YS5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGU9ITB9LG1kPWZ1bmN0aW9uKGEpe2lmKCFhKXJldHVybiExO3RyeXtyZXR1cm4hIWEuJGdvb2dfVGhlbmFibGV9Y2F0Y2goYil7cmV0dXJuITF9fTt2YXIgSD1mdW5jdGlvbihhLGIpe3RoaXMuQT0wO3RoaXMuY2E9dm9pZCAwO3RoaXMuRmE9dGhpcy5YPXRoaXMubD1udWxsO3RoaXMueWI9dGhpcy5jYz0hMTtpZihhIT1iYSl0cnl7dmFyIGM9dGhpczthLmNhbGwoYixmdW5jdGlvbihhKXtuZChjLDIsYSl9LGZ1bmN0aW9uKGEpe2lmKCEoYSBpbnN0YW5jZW9mIG9kKSl0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goYil7fW5kKGMsMyxhKX0pfWNhdGNoKGQpe25kKHRoaXMsMyxkKX19LHBkPWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuY29udGV4dD10aGlzLkxhPXRoaXMud2E9dGhpcy5jaGlsZD1udWxsO3RoaXMuV2E9ITF9O3BkLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuY29udGV4dD10aGlzLkxhPXRoaXMud2E9dGhpcy5jaGlsZD1udWxsO3RoaXMuV2E9ITF9O1xudmFyIHFkPW5ldyBaYyhmdW5jdGlvbigpe3JldHVybiBuZXcgcGR9LGZ1bmN0aW9uKGEpe2EucmVzZXQoKX0sMTAwKSxyZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9cWQuZ2V0KCk7ZC53YT1hO2QuTGE9YjtkLmNvbnRleHQ9YztyZXR1cm4gZH0sST1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgSClyZXR1cm4gYTt2YXIgYj1uZXcgSChiYSk7bmQoYiwyLGEpO3JldHVybiBifSxzZD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEgoZnVuY3Rpb24oYixjKXtjKGEpfSl9LHVkPWZ1bmN0aW9uKGEsYixjKXt0ZChhLGIsYyxudWxsKXx8amQoa2EoYixhKSl9LHZkPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgSChmdW5jdGlvbihiKXt2YXIgYz1hLmxlbmd0aCxkPVtdO2lmKGMpZm9yKHZhciBlPWZ1bmN0aW9uKGEsZSxmKXtjLS07ZFthXT1lP3tMZDohMCx2YWx1ZTpmfTp7TGQ6ITEscmVhc29uOmZ9OzA9PWMmJmIoZCl9LGY9MCxnO2Y8YS5sZW5ndGg7ZisrKWc9YVtmXSx1ZChnLGthKGUsZiwhMCksXG5rYShlLGYsITEpKTtlbHNlIGIoZCl9KX07SC5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YSYmQmEoYSxcIm9wdF9vbkZ1bGZpbGxlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7bnVsbCE9YiYmQmEoYixcIm9wdF9vblJlamVjdGVkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IHBhc3Mgb3B0X2NvbnRleHQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkIG9mIHRoZSB0aGlyZD9cIik7cmV0dXJuIHdkKHRoaXMscChhKT9hOm51bGwscChiKT9iOm51bGwsYyl9O2xkKEgpO3ZhciB5ZD1mdW5jdGlvbihhLGIpe3ZhciBjPXJkKGIsYix2b2lkIDApO2MuV2E9ITA7eGQoYSxjKTtyZXR1cm4gYX07SC5wcm90b3R5cGUuST1mdW5jdGlvbihhLGIpe3JldHVybiB3ZCh0aGlzLG51bGwsYSxiKX07SC5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKGEpezA9PXRoaXMuQSYmamQoZnVuY3Rpb24oKXt2YXIgYj1uZXcgb2QoYSk7emQodGhpcyxiKX0sdGhpcyl9O1xudmFyIHpkPWZ1bmN0aW9uKGEsYil7aWYoMD09YS5BKWlmKGEubCl7dmFyIGM9YS5sO2lmKGMuWCl7Zm9yKHZhciBkPTAsZT1udWxsLGY9bnVsbCxnPWMuWDtnJiYoZy5XYXx8KGQrKyxnLmNoaWxkPT1hJiYoZT1nKSwhKGUmJjE8ZCkpKTtnPWcubmV4dCllfHwoZj1nKTtlJiYoMD09Yy5BJiYxPT1kP3pkKGMsYik6KGY/KGQ9Zix2KGMuWCksdihudWxsIT1kKSxkLm5leHQ9PWMuRmEmJihjLkZhPWQpLGQubmV4dD1kLm5leHQubmV4dCk6QWQoYyksQmQoYyxlLDMsYikpKX1hLmw9bnVsbH1lbHNlIG5kKGEsMyxiKX0seGQ9ZnVuY3Rpb24oYSxiKXthLlh8fDIhPWEuQSYmMyE9YS5BfHxDZChhKTt2KG51bGwhPWIud2EpO2EuRmE/YS5GYS5uZXh0PWI6YS5YPWI7YS5GYT1ifSx3ZD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1yZChudWxsLG51bGwsbnVsbCk7ZS5jaGlsZD1uZXcgSChmdW5jdGlvbihhLGcpe2Uud2E9Yj9mdW5jdGlvbihjKXt0cnl7dmFyIGU9Yi5jYWxsKGQsYyk7YShlKX1jYXRjaChTKXtnKFMpfX06XG5hO2UuTGE9Yz9mdW5jdGlvbihiKXt0cnl7dmFyIGU9Yy5jYWxsKGQsYik7dm9pZCAwPT09ZSYmYiBpbnN0YW5jZW9mIG9kP2coYik6YShlKX1jYXRjaChTKXtnKFMpfX06Z30pO2UuY2hpbGQubD1hO3hkKGEsZSk7cmV0dXJuIGUuY2hpbGR9O0gucHJvdG90eXBlLnZlPWZ1bmN0aW9uKGEpe3YoMT09dGhpcy5BKTt0aGlzLkE9MDtuZCh0aGlzLDIsYSl9O0gucHJvdG90eXBlLndlPWZ1bmN0aW9uKGEpe3YoMT09dGhpcy5BKTt0aGlzLkE9MDtuZCh0aGlzLDMsYSl9O1xudmFyIG5kPWZ1bmN0aW9uKGEsYixjKXswPT1hLkEmJihhPT1jJiYoYj0zLGM9bmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2Fubm90IHJlc29sdmUgdG8gaXRzZWxmXCIpKSxhLkE9MSx0ZChjLGEudmUsYS53ZSxhKXx8KGEuY2E9YyxhLkE9YixhLmw9bnVsbCxDZChhKSwzIT1ifHxjIGluc3RhbmNlb2Ygb2R8fERkKGEsYykpKX0sdGQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSBpbnN0YW5jZW9mIEgpcmV0dXJuIG51bGwhPWImJkJhKGIsXCJvcHRfb25GdWxmaWxsZWQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCIpLG51bGwhPWMmJkJhKGMsXCJvcHRfb25SZWplY3RlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBwYXNzIG9wdF9jb250ZXh0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZCBvZiB0aGUgdGhpcmQ/XCIpLHhkKGEscmQoYnx8YmEsY3x8bnVsbCxkKSksITA7aWYobWQoYSkpcmV0dXJuIGEudGhlbihiLGMsZCksITA7aWYoaGEoYSkpdHJ5e3ZhciBlPWEudGhlbjtpZihwKGUpKXJldHVybiBFZChhLFxuZSxiLGMsZCksITB9Y2F0Y2goZil7cmV0dXJuIGMuY2FsbChkLGYpLCEwfXJldHVybiExfSxFZD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPSExLGc9ZnVuY3Rpb24oYSl7Znx8KGY9ITAsYy5jYWxsKGUsYSkpfSxoPWZ1bmN0aW9uKGEpe2Z8fChmPSEwLGQuY2FsbChlLGEpKX07dHJ5e2IuY2FsbChhLGcsaCl9Y2F0Y2gobSl7aChtKX19LENkPWZ1bmN0aW9uKGEpe2EuY2N8fChhLmNjPSEwLGpkKGEuR2QsYSkpfSxBZD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2EuWCYmKGI9YS5YLGEuWD1iLm5leHQsYi5uZXh0PW51bGwpO2EuWHx8KGEuRmE9bnVsbCk7bnVsbCE9YiYmdihudWxsIT1iLndhKTtyZXR1cm4gYn07SC5wcm90b3R5cGUuR2Q9ZnVuY3Rpb24oKXtmb3IodmFyIGE7YT1BZCh0aGlzKTspQmQodGhpcyxhLHRoaXMuQSx0aGlzLmNhKTt0aGlzLmNjPSExfTtcbnZhciBCZD1mdW5jdGlvbihhLGIsYyxkKXtpZigzPT1jJiZiLkxhJiYhYi5XYSlmb3IoO2EmJmEueWI7YT1hLmwpYS55Yj0hMTtpZihiLmNoaWxkKWIuY2hpbGQubD1udWxsLEZkKGIsYyxkKTtlbHNlIHRyeXtiLldhP2Iud2EuY2FsbChiLmNvbnRleHQpOkZkKGIsYyxkKX1jYXRjaChlKXtHZC5jYWxsKG51bGwsZSl9cWQucHV0KGIpfSxGZD1mdW5jdGlvbihhLGIsYyl7Mj09Yj9hLndhLmNhbGwoYS5jb250ZXh0LGMpOmEuTGEmJmEuTGEuY2FsbChhLmNvbnRleHQsYyl9LERkPWZ1bmN0aW9uKGEsYil7YS55Yj0hMDtqZChmdW5jdGlvbigpe2EueWImJkdkLmNhbGwobnVsbCxiKX0pfSxHZD0kYyxvZD1mdW5jdGlvbihhKXt0LmNhbGwodGhpcyxhKX07cihvZCx0KTtvZC5wcm90b3R5cGUubmFtZT1cImNhbmNlbFwiOy8qXG4gUG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBmcm9tIE1vY2hpS2l0LCByZWNlaXZlZCBieVxuIFRoZSBDbG9zdXJlIEF1dGhvcnMgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBBbGwgb3RoZXIgY29kZSBpcyBDb3B5cmlnaHRcbiAyMDA1LTIwMDkgVGhlIENsb3N1cmUgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiovXG52YXIgSGQ9ZnVuY3Rpb24oYSxiKXt0aGlzLk1iPVtdO3RoaXMuWmM9YTt0aGlzLkhjPWJ8fG51bGw7dGhpcy4kYT10aGlzLklhPSExO3RoaXMuY2E9dm9pZCAwO3RoaXMud2M9dGhpcy5BYz10aGlzLlhiPSExO3RoaXMuUmI9MDt0aGlzLmw9bnVsbDt0aGlzLlliPTB9O0hkLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7aWYodGhpcy5JYSl0aGlzLmNhIGluc3RhbmNlb2YgSGQmJnRoaXMuY2EuY2FuY2VsKCk7ZWxzZXtpZih0aGlzLmwpe3ZhciBiPXRoaXMubDtkZWxldGUgdGhpcy5sO2E/Yi5jYW5jZWwoYSk6KGIuWWItLSwwPj1iLlliJiZiLmNhbmNlbCgpKX10aGlzLlpjP3RoaXMuWmMuY2FsbCh0aGlzLkhjLHRoaXMpOnRoaXMud2M9ITA7dGhpcy5JYXx8SWQodGhpcyxuZXcgSmQpfX07SGQucHJvdG90eXBlLkdjPWZ1bmN0aW9uKGEsYil7dGhpcy5YYj0hMTtLZCh0aGlzLGEsYil9O1xudmFyIEtkPWZ1bmN0aW9uKGEsYixjKXthLklhPSEwO2EuY2E9YzthLiRhPSFiO0xkKGEpfSxOZD1mdW5jdGlvbihhKXtpZihhLklhKXtpZighYS53Yyl0aHJvdyBuZXcgTWQ7YS53Yz0hMX19O0hkLnByb3RvdHlwZS5jYWxsYmFjaz1mdW5jdGlvbihhKXtOZCh0aGlzKTtPZChhKTtLZCh0aGlzLCEwLGEpfTt2YXIgSWQ9ZnVuY3Rpb24oYSxiKXtOZChhKTtPZChiKTtLZChhLCExLGIpfSxPZD1mdW5jdGlvbihhKXt2KCEoYSBpbnN0YW5jZW9mIEhkKSxcIkFuIGV4ZWN1dGlvbiBzZXF1ZW5jZSBtYXkgbm90IGJlIGluaXRpYXRlZCB3aXRoIGEgYmxvY2tpbmcgRGVmZXJyZWQuXCIpfSxRZD1mdW5jdGlvbihhLGIpe1BkKGEsbnVsbCxiLHZvaWQgMCl9LFBkPWZ1bmN0aW9uKGEsYixjLGQpe3YoIWEuQWMsXCJCbG9ja2luZyBEZWZlcnJlZHMgY2FuIG5vdCBiZSByZS11c2VkXCIpO2EuTWIucHVzaChbYixjLGRdKTthLklhJiZMZChhKX07XG5IZC5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPW5ldyBIKGZ1bmN0aW9uKGEsYil7ZD1hO2U9Yn0pO1BkKHRoaXMsZCxmdW5jdGlvbihhKXthIGluc3RhbmNlb2YgSmQ/Zi5jYW5jZWwoKTplKGEpfSk7cmV0dXJuIGYudGhlbihhLGIsYyl9O2xkKEhkKTtcbnZhciBSZD1mdW5jdGlvbihhKXtyZXR1cm4gRmEoYS5NYixmdW5jdGlvbihhKXtyZXR1cm4gcChhWzFdKX0pfSxMZD1mdW5jdGlvbihhKXtpZihhLlJiJiZhLklhJiZSZChhKSl7dmFyIGI9YS5SYixjPVNkW2JdO2MmJihsLmNsZWFyVGltZW91dChjLmFiKSxkZWxldGUgU2RbYl0pO2EuUmI9MH1hLmwmJihhLmwuWWItLSxkZWxldGUgYS5sKTtmb3IodmFyIGI9YS5jYSxkPWM9ITE7YS5NYi5sZW5ndGgmJiFhLlhiOyl7dmFyIGU9YS5NYi5zaGlmdCgpLGY9ZVswXSxnPWVbMV0sZT1lWzJdO2lmKGY9YS4kYT9nOmYpdHJ5e3ZhciBoPWYuY2FsbChlfHxhLkhjLGIpO3ZvaWQgMCE9PWgmJihhLiRhPWEuJGEmJihoPT1ifHxoIGluc3RhbmNlb2YgRXJyb3IpLGEuY2E9Yj1oKTtpZihtZChiKXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGwuUHJvbWlzZSYmYiBpbnN0YW5jZW9mIGwuUHJvbWlzZSlkPSEwLGEuWGI9ITB9Y2F0Y2gobSl7Yj1tLGEuJGE9ITAsUmQoYSl8fChjPSEwKX19YS5jYT1iO2QmJlxuKGg9cShhLkdjLGEsITApLGQ9cShhLkdjLGEsITEpLGIgaW5zdGFuY2VvZiBIZD8oUGQoYixoLGQpLGIuQWM9ITApOmIudGhlbihoLGQpKTtjJiYoYj1uZXcgVGQoYiksU2RbYi5hYl09YixhLlJiPWIuYWIpfSxNZD1mdW5jdGlvbigpe3QuY2FsbCh0aGlzKX07cihNZCx0KTtNZC5wcm90b3R5cGUubWVzc2FnZT1cIkRlZmVycmVkIGhhcyBhbHJlYWR5IGZpcmVkXCI7TWQucHJvdG90eXBlLm5hbWU9XCJBbHJlYWR5Q2FsbGVkRXJyb3JcIjt2YXIgSmQ9ZnVuY3Rpb24oKXt0LmNhbGwodGhpcyl9O3IoSmQsdCk7SmQucHJvdG90eXBlLm1lc3NhZ2U9XCJEZWZlcnJlZCB3YXMgY2FuY2VsZWRcIjtKZC5wcm90b3R5cGUubmFtZT1cIkNhbmNlbGVkRXJyb3JcIjt2YXIgVGQ9ZnVuY3Rpb24oYSl7dGhpcy5hYj1sLnNldFRpbWVvdXQocSh0aGlzLnVlLHRoaXMpLDApO3RoaXMuRD1hfTtcblRkLnByb3RvdHlwZS51ZT1mdW5jdGlvbigpe3YoU2RbdGhpcy5hYl0sXCJDYW5ub3QgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBub3Qgc2NoZWR1bGVkLlwiKTtkZWxldGUgU2RbdGhpcy5hYl07dGhyb3cgdGhpcy5EO307dmFyIFNkPXt9O3ZhciBZZD1mdW5jdGlvbihhKXt2YXIgYj17fSxjPWIuZG9jdW1lbnR8fGRvY3VtZW50LGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKSxlPXtoZDpkLG9iOnZvaWQgMH0sZj1uZXcgSGQoVWQsZSksZz1udWxsLGg9bnVsbCE9Yi50aW1lb3V0P2IudGltZW91dDo1RTM7MDxoJiYoZz13aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1ZkKGQsITApO0lkKGYsbmV3IFdkKDEsXCJUaW1lb3V0IHJlYWNoZWQgZm9yIGxvYWRpbmcgc2NyaXB0IFwiK2EpKX0saCksZS5vYj1nKTtkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2QucmVhZHlTdGF0ZSYmXCJsb2FkZWRcIiE9ZC5yZWFkeVN0YXRlJiZcImNvbXBsZXRlXCIhPWQucmVhZHlTdGF0ZXx8KFZkKGQsYi5CZXx8ITEsZyksZi5jYWxsYmFjayhudWxsKSl9O2Qub25lcnJvcj1mdW5jdGlvbigpe1ZkKGQsITAsZyk7SWQoZixuZXcgV2QoMCxcIkVycm9yIHdoaWxlIGxvYWRpbmcgc2NyaXB0IFwiK2EpKX07ZT1iLmF0dHJpYnV0ZXN8fFxue307JGEoZSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwiLGNoYXJzZXQ6XCJVVEYtOFwiLHNyYzphfSk7WWMoZCxlKTtYZChjKS5hcHBlbmRDaGlsZChkKTtyZXR1cm4gZn0sWGQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkhFQURcIik7cmV0dXJuIGImJjAhPWIubGVuZ3RoP2JbMF06YS5kb2N1bWVudEVsZW1lbnR9LFVkPWZ1bmN0aW9uKCl7aWYodGhpcyYmdGhpcy5oZCl7dmFyIGE9dGhpcy5oZDthJiZcIlNDUklQVFwiPT1hLnRhZ05hbWUmJlZkKGEsITAsdGhpcy5vYil9fSxWZD1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YyYmbC5jbGVhclRpbWVvdXQoYyk7YS5vbmxvYWQ9YmE7YS5vbmVycm9yPWJhO2Eub25yZWFkeXN0YXRlY2hhbmdlPWJhO2ImJndpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSYmYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9LDApfSxXZD1mdW5jdGlvbihhLGIpe3ZhciBjPVwiSnNsb2FkZXIgZXJyb3IgKGNvZGUgI1wiK1xuYStcIilcIjtiJiYoYys9XCI6IFwiK2IpO3QuY2FsbCh0aGlzLGMpO3RoaXMuY29kZT1hfTtyKFdkLHQpO3ZhciBKPWZ1bmN0aW9uKCl7TGIuY2FsbCh0aGlzKTt0aGlzLk89bmV3IFNiKHRoaXMpO3RoaXMueWQ9dGhpczt0aGlzLmxjPW51bGx9O3IoSixMYik7Si5wcm90b3R5cGVbT2JdPSEwO0oucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMsZCl7WWIodGhpcyxhLGIsYyxkKX07Si5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyxkKXtoYyh0aGlzLGEsYixjLGQpfTtcbkoucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24oYSl7WmQodGhpcyk7dmFyIGIsYz10aGlzLmxjO2lmKGMpe2I9W107Zm9yKHZhciBkPTE7YztjPWMubGMpYi5wdXNoKGMpLHYoMUUzPisrZCxcImluZmluaXRlIGxvb3BcIil9Yz10aGlzLnlkO2Q9YS50eXBlfHxhO2lmKG4oYSkpYT1uZXcgTWIoYSxjKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBNYilhLnRhcmdldD1hLnRhcmdldHx8YztlbHNle3ZhciBlPWE7YT1uZXcgTWIoZCxjKTskYShhLGUpfXZhciBlPSEwLGY7aWYoYilmb3IodmFyIGc9Yi5sZW5ndGgtMTshYS5OYSYmMDw9ZztnLS0pZj1hLmN1cnJlbnRUYXJnZXQ9YltnXSxlPSRkKGYsZCwhMCxhKSYmZTthLk5hfHwoZj1hLmN1cnJlbnRUYXJnZXQ9YyxlPSRkKGYsZCwhMCxhKSYmZSxhLk5hfHwoZT0kZChmLGQsITEsYSkmJmUpKTtpZihiKWZvcihnPTA7IWEuTmEmJmc8Yi5sZW5ndGg7ZysrKWY9YS5jdXJyZW50VGFyZ2V0PWJbZ10sZT0kZChmLGQsITEsYSkmJmU7cmV0dXJuIGV9O1xuSi5wcm90b3R5cGUuR2E9ZnVuY3Rpb24oKXtKLnljLkdhLmNhbGwodGhpcyk7aWYodGhpcy5PKXt2YXIgYT10aGlzLk8sYj0wLGM7Zm9yKGMgaW4gYS52KXtmb3IodmFyIGQ9YS52W2NdLGU9MDtlPGQubGVuZ3RoO2UrKykrK2IsUmIoZFtlXSk7ZGVsZXRlIGEudltjXTthLnBiLS19fXRoaXMubGM9bnVsbH07XG52YXIgJGI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtaZChhKTthLk8uYWRkKFN0cmluZyhiKSxjLCExLGQsZSl9LGdjPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5PLmFkZChTdHJpbmcoYiksYywhMCxkLGUpfSwkZD1mdW5jdGlvbihhLGIsYyxkKXtiPWEuTy52W1N0cmluZyhiKV07aWYoIWIpcmV0dXJuITA7Yj1iLmNvbmNhdCgpO2Zvcih2YXIgZT0hMCxmPTA7ZjxiLmxlbmd0aDsrK2Ype3ZhciBnPWJbZl07aWYoZyYmIWcuUGEmJmcucmI9PWMpe3ZhciBoPWcubGlzdGVuZXIsbT1nLnpifHxnLnNyYztnLnFiJiZVYihhLk8sZyk7ZT0hMSE9PWguY2FsbChtLGQpJiZlfX1yZXR1cm4gZSYmMCE9ZC5nZH07Si5wcm90b3R5cGUuZWM9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuTy5lYyhTdHJpbmcoYSksYixjLGQpfTt2YXIgWmQ9ZnVuY3Rpb24oYSl7dihhLk8sXCJFdmVudCB0YXJnZXQgaXMgbm90IGluaXRpYWxpemVkLiBEaWQgeW91IGNhbGwgdGhlIHN1cGVyY2xhc3MgKGdvb2cuZXZlbnRzLkV2ZW50VGFyZ2V0KSBjb25zdHJ1Y3Rvcj9cIil9O3ZhciBhZT1cIlN0b3BJdGVyYXRpb25cImluIGw/bC5TdG9wSXRlcmF0aW9uOnttZXNzYWdlOlwiU3RvcEl0ZXJhdGlvblwiLHN0YWNrOlwiXCJ9LGJlPWZ1bmN0aW9uKCl7fTtiZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3Rocm93IGFlO307YmUucHJvdG90eXBlLlZhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O1xudmFyIGNlPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBiZSlyZXR1cm4gYTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLlZhKXJldHVybiBhLlZhKCExKTtpZihmYShhKSl7dmFyIGI9MCxjPW5ldyBiZTtjLm5leHQ9ZnVuY3Rpb24oKXtmb3IoOzspe2lmKGI+PWEubGVuZ3RoKXRocm93IGFlO2lmKGIgaW4gYSlyZXR1cm4gYVtiKytdO2IrK319O3JldHVybiBjfXRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO30sZGU9ZnVuY3Rpb24oYSxiKXtpZihmYShhKSl0cnl7dyhhLGIsdm9pZCAwKX1jYXRjaChjKXtpZihjIT09YWUpdGhyb3cgYzt9ZWxzZXthPWNlKGEpO3RyeXtmb3IoOzspYi5jYWxsKHZvaWQgMCxhLm5leHQoKSx2b2lkIDAsYSl9Y2F0Y2goYyl7aWYoYyE9PWFlKXRocm93IGM7fX19O3ZhciBlZT1mdW5jdGlvbihhLGIpe3RoaXMuUD17fTt0aGlzLm09W107dGhpcy5lYT10aGlzLmk9MDt2YXIgYz1hcmd1bWVudHMubGVuZ3RoO2lmKDE8Yyl7aWYoYyUyKXRocm93IEVycm9yKFwiVW5ldmVuIG51bWJlciBvZiBhcmd1bWVudHNcIik7Zm9yKHZhciBkPTA7ZDxjO2QrPTIpdGhpcy5zZXQoYXJndW1lbnRzW2RdLGFyZ3VtZW50c1tkKzFdKX1lbHNlIGEmJnRoaXMuYWRkQWxsKGEpfTtrPWVlLnByb3RvdHlwZTtrLndiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaX07ay5KPWZ1bmN0aW9uKCl7ZmUodGhpcyk7Zm9yKHZhciBhPVtdLGI9MDtiPHRoaXMubS5sZW5ndGg7YisrKWEucHVzaCh0aGlzLlBbdGhpcy5tW2JdXSk7cmV0dXJuIGF9O2suWT1mdW5jdGlvbigpe2ZlKHRoaXMpO3JldHVybiB0aGlzLm0uY29uY2F0KCl9O2suWWE9ZnVuY3Rpb24oYSl7cmV0dXJuIGdlKHRoaXMuUCxhKX07XG5rLnRiPWZ1bmN0aW9uKGEsYil7aWYodGhpcz09PWEpcmV0dXJuITA7aWYodGhpcy5pIT1hLndiKCkpcmV0dXJuITE7dmFyIGM9Ynx8aGU7ZmUodGhpcyk7Zm9yKHZhciBkLGU9MDtkPXRoaXMubVtlXTtlKyspaWYoIWModGhpcy5nZXQoZCksYS5nZXQoZCkpKXJldHVybiExO3JldHVybiEwfTt2YXIgaGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWJ9O2VlLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGdlKHRoaXMuUCxhKT8oZGVsZXRlIHRoaXMuUFthXSx0aGlzLmktLSx0aGlzLmVhKyssdGhpcy5tLmxlbmd0aD4yKnRoaXMuaSYmZmUodGhpcyksITApOiExfTtcbnZhciBmZT1mdW5jdGlvbihhKXtpZihhLmkhPWEubS5sZW5ndGgpe2Zvcih2YXIgYj0wLGM9MDtiPGEubS5sZW5ndGg7KXt2YXIgZD1hLm1bYl07Z2UoYS5QLGQpJiYoYS5tW2MrK109ZCk7YisrfWEubS5sZW5ndGg9Y31pZihhLmkhPWEubS5sZW5ndGgpe2Zvcih2YXIgZT17fSxjPWI9MDtiPGEubS5sZW5ndGg7KWQ9YS5tW2JdLGdlKGUsZCl8fChhLm1bYysrXT1kLGVbZF09MSksYisrO2EubS5sZW5ndGg9Y319O2s9ZWUucHJvdG90eXBlO2suZ2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGdlKHRoaXMuUCxhKT90aGlzLlBbYV06Yn07ay5zZXQ9ZnVuY3Rpb24oYSxiKXtnZSh0aGlzLlAsYSl8fCh0aGlzLmkrKyx0aGlzLm0ucHVzaChhKSx0aGlzLmVhKyspO3RoaXMuUFthXT1ifTtcbmsuYWRkQWxsPWZ1bmN0aW9uKGEpe3ZhciBiO2EgaW5zdGFuY2VvZiBlZT8oYj1hLlkoKSxhPWEuSigpKTooYj1TYShhKSxhPVJhKGEpKTtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl0aGlzLnNldChiW2NdLGFbY10pfTtrLmZvckVhY2g9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5ZKCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9dGhpcy5nZXQoZSk7YS5jYWxsKGIsZixlLHRoaXMpfX07ay5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgZWUodGhpcyl9O2suVmE9ZnVuY3Rpb24oYSl7ZmUodGhpcyk7dmFyIGI9MCxjPXRoaXMuZWEsZD10aGlzLGU9bmV3IGJlO2UubmV4dD1mdW5jdGlvbigpe2lmKGMhPWQuZWEpdGhyb3cgRXJyb3IoXCJUaGUgbWFwIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBpdGVyYXRvciB3YXMgY3JlYXRlZFwiKTtpZihiPj1kLm0ubGVuZ3RoKXRocm93IGFlO3ZhciBlPWQubVtiKytdO3JldHVybiBhP2U6ZC5QW2VdfTtyZXR1cm4gZX07XG52YXIgZ2U9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYil9O3ZhciBpZT1mdW5jdGlvbihhKXtpZihhLkomJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuSilyZXR1cm4gYS5KKCk7aWYobihhKSlyZXR1cm4gYS5zcGxpdChcIlwiKTtpZihmYShhKSl7Zm9yKHZhciBiPVtdLGM9YS5sZW5ndGgsZD0wO2Q8YztkKyspYi5wdXNoKGFbZF0pO3JldHVybiBifXJldHVybiBSYShhKX0samU9ZnVuY3Rpb24oYSl7aWYoYS5ZJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLlkpcmV0dXJuIGEuWSgpO2lmKCFhLkp8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEuSil7aWYoZmEoYSl8fG4oYSkpe3ZhciBiPVtdO2E9YS5sZW5ndGg7Zm9yKHZhciBjPTA7YzxhO2MrKyliLnB1c2goYyk7cmV0dXJuIGJ9cmV0dXJuIFNhKGEpfX0sa2U9ZnVuY3Rpb24oYSxiKXtpZihhLmZvckVhY2gmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZm9yRWFjaClhLmZvckVhY2goYix2b2lkIDApO2Vsc2UgaWYoZmEoYSl8fG4oYSkpdyhhLGIsdm9pZCAwKTtlbHNlIGZvcih2YXIgYz1qZShhKSxkPWllKGEpLGU9ZC5sZW5ndGgsXG5mPTA7ZjxlO2YrKyliLmNhbGwodm9pZCAwLGRbZl0sYyYmY1tmXSxhKX07dmFyIGxlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5yZXNldChhLGIsYyxkLGUpfTtsZS5wcm90b3R5cGUuSmM9bnVsbDt2YXIgbWU9MDtsZS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtcIm51bWJlclwiPT10eXBlb2YgZXx8bWUrKztkfHxsYSgpO3RoaXMuZ2I9YTt0aGlzLmRlPWI7ZGVsZXRlIHRoaXMuSmN9O2xlLnByb3RvdHlwZS5rZD1mdW5jdGlvbihhKXt0aGlzLmdiPWF9O3ZhciBuZT1mdW5jdGlvbihhKXt0aGlzLmVlPWE7dGhpcy5QYz10aGlzLlpiPXRoaXMuZ2I9dGhpcy5sPW51bGx9LG9lPWZ1bmN0aW9uKGEsYil7dGhpcy5uYW1lPWE7dGhpcy52YWx1ZT1ifTtvZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfTt2YXIgcGU9bmV3IG9lKFwiU0VWRVJFXCIsMUUzKSxxZT1uZXcgb2UoXCJDT05GSUdcIiw3MDApLHJlPW5ldyBvZShcIkZJTkVcIiw1MDApO25lLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sfTtuZS5wcm90b3R5cGUua2Q9ZnVuY3Rpb24oYSl7dGhpcy5nYj1hfTt2YXIgc2U9ZnVuY3Rpb24oYSl7aWYoYS5nYilyZXR1cm4gYS5nYjtpZihhLmwpcmV0dXJuIHNlKGEubCk7eWEoXCJSb290IGxvZ2dlciBoYXMgbm8gbGV2ZWwgc2V0LlwiKTtyZXR1cm4gbnVsbH07XG5uZS5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKGEsYixjKXtpZihhLnZhbHVlPj1zZSh0aGlzKS52YWx1ZSlmb3IocChiKSYmKGI9YigpKSxhPW5ldyBsZShhLFN0cmluZyhiKSx0aGlzLmVlKSxjJiYoYS5KYz1jKSxjPVwibG9nOlwiK2EuZGUsbC5jb25zb2xlJiYobC5jb25zb2xlLnRpbWVTdGFtcD9sLmNvbnNvbGUudGltZVN0YW1wKGMpOmwuY29uc29sZS5tYXJrVGltZWxpbmUmJmwuY29uc29sZS5tYXJrVGltZWxpbmUoYykpLGwubXNXcml0ZVByb2ZpbGVyTWFyayYmbC5tc1dyaXRlUHJvZmlsZXJNYXJrKGMpLGM9dGhpcztjOyl7Yj1jO3ZhciBkPWE7aWYoYi5QYylmb3IodmFyIGU9MCxmO2Y9Yi5QY1tlXTtlKyspZihkKTtjPWMuZ2V0UGFyZW50KCl9fTtcbnZhciB0ZT17fSx1ZT1udWxsLHZlPWZ1bmN0aW9uKGEpe3VlfHwodWU9bmV3IG5lKFwiXCIpLHRlW1wiXCJdPXVlLHVlLmtkKHFlKSk7dmFyIGI7aWYoIShiPXRlW2FdKSl7Yj1uZXcgbmUoYSk7dmFyIGM9YS5sYXN0SW5kZXhPZihcIi5cIiksZD1hLnN1YnN0cihjKzEpLGM9dmUoYS5zdWJzdHIoMCxjKSk7Yy5aYnx8KGMuWmI9e30pO2MuWmJbZF09YjtiLmw9Yzt0ZVthXT1ifXJldHVybiBifTt2YXIgSz1mdW5jdGlvbihhLGIpe2EmJmEubG9nKHJlLGIsdm9pZCAwKX07dmFyIHdlPWZ1bmN0aW9uKGEsYixjKXtpZihwKGEpKWMmJihhPXEoYSxjKSk7ZWxzZSBpZihhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmhhbmRsZUV2ZW50KWE9cShhLmhhbmRsZUV2ZW50LGEpO2Vsc2UgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpO3JldHVybiAyMTQ3NDgzNjQ3PE51bWJlcihiKT8tMTpsLnNldFRpbWVvdXQoYSxifHwwKX0seGU9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtyZXR1cm4obmV3IEgoZnVuY3Rpb24oYyxkKXtiPXdlKGZ1bmN0aW9uKCl7Yyh2b2lkIDApfSxhKTstMT09YiYmZChFcnJvcihcIkZhaWxlZCB0byBzY2hlZHVsZSB0aW1lci5cIikpfSkpLkkoZnVuY3Rpb24oYSl7bC5jbGVhclRpbWVvdXQoYik7dGhyb3cgYTt9KX07dmFyIHllPS9eKD86KFteOi8/Iy5dKyk6KT8oPzpcXC9cXC8oPzooW14vPyNdKilAKT8oW14vIz9dKj8pKD86OihbMC05XSspKT8oPz1bLyM/XXwkKSk/KFtePyNdKyk/KD86XFw/KFteI10qKSk/KD86IyguKikpPyQvLHplPWZ1bmN0aW9uKGEsYil7aWYoYSlmb3IodmFyIGM9YS5zcGxpdChcIiZcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLmluZGV4T2YoXCI9XCIpLGYsZz1udWxsOzA8PWU/KGY9Y1tkXS5zdWJzdHJpbmcoMCxlKSxnPWNbZF0uc3Vic3RyaW5nKGUrMSkpOmY9Y1tkXTtiKGYsZz9kZWNvZGVVUklDb21wb25lbnQoZy5yZXBsYWNlKC9cXCsvZyxcIiBcIikpOlwiXCIpfX07dmFyIEw9ZnVuY3Rpb24oYSl7Si5jYWxsKHRoaXMpO3RoaXMuaGVhZGVycz1uZXcgZWU7dGhpcy5WYj1hfHxudWxsO3RoaXMuZ2E9ITE7dGhpcy5VYj10aGlzLmE9bnVsbDt0aGlzLmZiPXRoaXMuV2M9dGhpcy5DYj1cIlwiO3RoaXMudWE9dGhpcy5qYz10aGlzLkJiPXRoaXMuYmM9ITE7dGhpcy5TYT0wO3RoaXMuUWI9bnVsbDt0aGlzLmZkPVwiXCI7dGhpcy5TYj10aGlzLmtlPXRoaXMueWU9ITF9O3IoTCxKKTt2YXIgQWU9TC5wcm90b3R5cGUsQmU9dmUoXCJnb29nLm5ldC5YaHJJb1wiKTtBZS5MPUJlO3ZhciBDZT0vXmh0dHBzPyQvaSxEZT1bXCJQT1NUXCIsXCJQVVRcIl07XG5MLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKGEsYixjLGQpe2lmKHRoaXMuYSl0aHJvdyBFcnJvcihcIltnb29nLm5ldC5YaHJJb10gT2JqZWN0IGlzIGFjdGl2ZSB3aXRoIGFub3RoZXIgcmVxdWVzdD1cIit0aGlzLkNiK1wiOyBuZXdVcmk9XCIrYSk7Yj1iP2IudG9VcHBlckNhc2UoKTpcIkdFVFwiO3RoaXMuQ2I9YTt0aGlzLmZiPVwiXCI7dGhpcy5XYz1iO3RoaXMuYmM9ITE7dGhpcy5nYT0hMDt0aGlzLmE9dGhpcy5WYj90aGlzLlZiLiRiKCk6d2MuJGIoKTt0aGlzLlViPXRoaXMuVmI/dmModGhpcy5WYik6dmMod2MpO3RoaXMuYS5vbnJlYWR5c3RhdGVjaGFuZ2U9cSh0aGlzLmFkLHRoaXMpO3RoaXMua2UmJlwib25wcm9ncmVzc1wiaW4gdGhpcy5hJiYodGhpcy5hLm9ucHJvZ3Jlc3M9cShmdW5jdGlvbihhKXt0aGlzLiRjKGEsITApfSx0aGlzKSx0aGlzLmEudXBsb2FkJiYodGhpcy5hLnVwbG9hZC5vbnByb2dyZXNzPXEodGhpcy4kYyx0aGlzKSkpO3RyeXtLKHRoaXMuTCxFZSh0aGlzLFwiT3BlbmluZyBYaHJcIikpLFxudGhpcy5qYz0hMCx0aGlzLmEub3BlbihiLFN0cmluZyhhKSwhMCksdGhpcy5qYz0hMX1jYXRjaChmKXtLKHRoaXMuTCxFZSh0aGlzLFwiRXJyb3Igb3BlbmluZyBYaHI6IFwiK2YubWVzc2FnZSkpO3RoaXMuRCg1LGYpO3JldHVybn1hPWN8fFwiXCI7dmFyIGU9dGhpcy5oZWFkZXJzLmNsb25lKCk7ZCYma2UoZCxmdW5jdGlvbihhLGIpe2Uuc2V0KGIsYSl9KTtkPUhhKGUuWSgpKTtjPWwuRm9ybURhdGEmJmEgaW5zdGFuY2VvZiBsLkZvcm1EYXRhOyFJYShEZSxiKXx8ZHx8Y3x8ZS5zZXQoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04XCIpO2UuZm9yRWFjaChmdW5jdGlvbihhLGIpe3RoaXMuYS5zZXRSZXF1ZXN0SGVhZGVyKGIsYSl9LHRoaXMpO3RoaXMuZmQmJih0aGlzLmEucmVzcG9uc2VUeXBlPXRoaXMuZmQpO1RhKHRoaXMuYSkmJih0aGlzLmEud2l0aENyZWRlbnRpYWxzPXRoaXMueWUpO3RyeXtGZSh0aGlzKSwwPHRoaXMuU2EmJlxuKHRoaXMuU2I9R2UodGhpcy5hKSxLKHRoaXMuTCxFZSh0aGlzLFwiV2lsbCBhYm9ydCBhZnRlciBcIit0aGlzLlNhK1wibXMgaWYgaW5jb21wbGV0ZSwgeGhyMiBcIit0aGlzLlNiKSksdGhpcy5TYj8odGhpcy5hLnRpbWVvdXQ9dGhpcy5TYSx0aGlzLmEub250aW1lb3V0PXEodGhpcy5vYix0aGlzKSk6dGhpcy5RYj13ZSh0aGlzLm9iLHRoaXMuU2EsdGhpcykpLEsodGhpcy5MLEVlKHRoaXMsXCJTZW5kaW5nIHJlcXVlc3RcIikpLHRoaXMuQmI9ITAsdGhpcy5hLnNlbmQoYSksdGhpcy5CYj0hMX1jYXRjaChmKXtLKHRoaXMuTCxFZSh0aGlzLFwiU2VuZCBlcnJvcjogXCIrZi5tZXNzYWdlKSksdGhpcy5EKDUsZil9fTt2YXIgR2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHkmJnooOSkmJmdhKGEudGltZW91dCkmJnZvaWQgMCE9PWEub250aW1lb3V0fSxHYT1mdW5jdGlvbihhKXtyZXR1cm5cImNvbnRlbnQtdHlwZVwiPT1hLnRvTG93ZXJDYXNlKCl9O1xuTC5wcm90b3R5cGUub2I9ZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgYWEmJnRoaXMuYSYmKHRoaXMuZmI9XCJUaW1lZCBvdXQgYWZ0ZXIgXCIrdGhpcy5TYStcIm1zLCBhYm9ydGluZ1wiLEsodGhpcy5MLEVlKHRoaXMsdGhpcy5mYikpLHRoaXMuZGlzcGF0Y2hFdmVudChcInRpbWVvdXRcIiksdGhpcy5hYm9ydCg4KSl9O0wucHJvdG90eXBlLkQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmdhPSExO3RoaXMuYSYmKHRoaXMudWE9ITAsdGhpcy5hLmFib3J0KCksdGhpcy51YT0hMSk7dGhpcy5mYj1iO0hlKHRoaXMpO0llKHRoaXMpfTt2YXIgSGU9ZnVuY3Rpb24oYSl7YS5iY3x8KGEuYmM9ITAsYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksYS5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIikpfTtcbkwucHJvdG90eXBlLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5hJiZ0aGlzLmdhJiYoSyh0aGlzLkwsRWUodGhpcyxcIkFib3J0aW5nXCIpKSx0aGlzLmdhPSExLHRoaXMudWE9ITAsdGhpcy5hLmFib3J0KCksdGhpcy51YT0hMSx0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSx0aGlzLmRpc3BhdGNoRXZlbnQoXCJhYm9ydFwiKSxJZSh0aGlzKSl9O0wucHJvdG90eXBlLkdhPWZ1bmN0aW9uKCl7dGhpcy5hJiYodGhpcy5nYSYmKHRoaXMuZ2E9ITEsdGhpcy51YT0hMCx0aGlzLmEuYWJvcnQoKSx0aGlzLnVhPSExKSxJZSh0aGlzLCEwKSk7TC55Yy5HYS5jYWxsKHRoaXMpfTtMLnByb3RvdHlwZS5hZD1mdW5jdGlvbigpe3RoaXMuaXNEaXNwb3NlZCgpfHwodGhpcy5qY3x8dGhpcy5CYnx8dGhpcy51YT9KZSh0aGlzKTp0aGlzLmllKCkpfTtMLnByb3RvdHlwZS5pZT1mdW5jdGlvbigpe0plKHRoaXMpfTtcbnZhciBKZT1mdW5jdGlvbihhKXtpZihhLmdhJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYWEpaWYoYS5VYlsxXSYmND09S2UoYSkmJjI9PUxlKGEpKUsoYS5MLEVlKGEsXCJMb2NhbCByZXF1ZXN0IGVycm9yIGRldGVjdGVkIGFuZCBpZ25vcmVkXCIpKTtlbHNlIGlmKGEuQmImJjQ9PUtlKGEpKXdlKGEuYWQsMCxhKTtlbHNlIGlmKGEuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIiksND09S2UoYSkpe0soYS5MLEVlKGEsXCJSZXF1ZXN0IGNvbXBsZXRlXCIpKTthLmdhPSExO3RyeXt2YXIgYj1MZShhKSxjO2E6c3dpdGNoKGIpe2Nhc2UgMjAwOmNhc2UgMjAxOmNhc2UgMjAyOmNhc2UgMjA0OmNhc2UgMjA2OmNhc2UgMzA0OmNhc2UgMTIyMzpjPSEwO2JyZWFrIGE7ZGVmYXVsdDpjPSExfXZhciBkO2lmKCEoZD1jKSl7dmFyIGU7aWYoZT0wPT09Yil7dmFyIGY9U3RyaW5nKGEuQ2IpLm1hdGNoKHllKVsxXXx8bnVsbDtpZighZiYmbC5zZWxmJiZsLnNlbGYubG9jYXRpb24pdmFyIGc9bC5zZWxmLmxvY2F0aW9uLnByb3RvY29sLFxuZj1nLnN1YnN0cigwLGcubGVuZ3RoLTEpO2U9IUNlLnRlc3QoZj9mLnRvTG93ZXJDYXNlKCk6XCJcIil9ZD1lfWlmKGQpYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksYS5kaXNwYXRjaEV2ZW50KFwic3VjY2Vzc1wiKTtlbHNle3ZhciBoO3RyeXtoPTI8S2UoYSk/YS5hLnN0YXR1c1RleHQ6XCJcIn1jYXRjaChtKXtLKGEuTCxcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIrbS5tZXNzYWdlKSxoPVwiXCJ9YS5mYj1oK1wiIFtcIitMZShhKStcIl1cIjtIZShhKX19ZmluYWxseXtJZShhKX19fTtMLnByb3RvdHlwZS4kYz1mdW5jdGlvbihhLGIpe3YoXCJwcm9ncmVzc1wiPT09YS50eXBlLFwiZ29vZy5uZXQuRXZlbnRUeXBlLlBST0dSRVNTIGlzIG9mIHRoZSBzYW1lIHR5cGUgYXMgcmF3IFhIUiBwcm9ncmVzcy5cIik7dGhpcy5kaXNwYXRjaEV2ZW50KE1lKGEsXCJwcm9ncmVzc1wiKSk7dGhpcy5kaXNwYXRjaEV2ZW50KE1lKGEsYj9cImRvd25sb2FkcHJvZ3Jlc3NcIjpcInVwbG9hZHByb2dyZXNzXCIpKX07XG52YXIgTWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm57dHlwZTpiLGxlbmd0aENvbXB1dGFibGU6YS5sZW5ndGhDb21wdXRhYmxlLGxvYWRlZDphLmxvYWRlZCx0b3RhbDphLnRvdGFsfX0sSWU9ZnVuY3Rpb24oYSxiKXtpZihhLmEpe0ZlKGEpO3ZhciBjPWEuYSxkPWEuVWJbMF0/YmE6bnVsbDthLmE9bnVsbDthLlViPW51bGw7Ynx8YS5kaXNwYXRjaEV2ZW50KFwicmVhZHlcIik7dHJ5e2Mub25yZWFkeXN0YXRlY2hhbmdlPWR9Y2F0Y2goZSl7KGM9YS5MKSYmYy5sb2cocGUsXCJQcm9ibGVtIGVuY291bnRlcmVkIHJlc2V0dGluZyBvbnJlYWR5c3RhdGVjaGFuZ2U6IFwiK2UubWVzc2FnZSx2b2lkIDApfX19LEZlPWZ1bmN0aW9uKGEpe2EuYSYmYS5TYiYmKGEuYS5vbnRpbWVvdXQ9bnVsbCk7Z2EoYS5RYikmJihsLmNsZWFyVGltZW91dChhLlFiKSxhLlFiPW51bGwpfSxLZT1mdW5jdGlvbihhKXtyZXR1cm4gYS5hP2EuYS5yZWFkeVN0YXRlOjB9LExlPWZ1bmN0aW9uKGEpe3RyeXtyZXR1cm4gMjxLZShhKT9cbmEuYS5zdGF0dXM6LTF9Y2F0Y2goYil7cmV0dXJuLTF9fSxFZT1mdW5jdGlvbihhLGIpe3JldHVybiBiK1wiIFtcIithLldjK1wiIFwiK2EuQ2IrXCIgXCIrTGUoYSkrXCJdXCJ9O3ZhciBOZT1mdW5jdGlvbihhLGIpe3RoaXMuaWE9dGhpcy5DYT10aGlzLm5hPVwiXCI7dGhpcy5NYT1udWxsO3RoaXMudGE9dGhpcy5rYT1cIlwiO3RoaXMuRj10aGlzLiRkPSExO3ZhciBjO2lmKGEgaW5zdGFuY2VvZiBOZSl0aGlzLkY9dm9pZCAwIT09Yj9iOmEuRixPZSh0aGlzLGEubmEpLGM9YS5DYSxNKHRoaXMpLHRoaXMuQ2E9YyxQZSh0aGlzLGEuaWEpLFFlKHRoaXMsYS5NYSksUmUodGhpcyxhLmthKSxTZSh0aGlzLGEuUy5jbG9uZSgpKSxjPWEudGEsTSh0aGlzKSx0aGlzLnRhPWM7ZWxzZSBpZihhJiYoYz1TdHJpbmcoYSkubWF0Y2goeWUpKSl7dGhpcy5GPSEhYjtPZSh0aGlzLGNbMV18fFwiXCIsITApO3ZhciBkPWNbMl18fFwiXCI7TSh0aGlzKTt0aGlzLkNhPVRlKGQpO1BlKHRoaXMsY1szXXx8XCJcIiwhMCk7UWUodGhpcyxjWzRdKTtSZSh0aGlzLGNbNV18fFwiXCIsITApO1NlKHRoaXMsY1s2XXx8XCJcIiwhMCk7Yz1jWzddfHxcIlwiO00odGhpcyk7dGhpcy50YT1UZShjKX1lbHNlIHRoaXMuRj1cbiEhYix0aGlzLlM9bmV3IE4obnVsbCwwLHRoaXMuRil9O05lLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVtdLGI9dGhpcy5uYTtiJiZhLnB1c2goVWUoYixWZSwhMCksXCI6XCIpO3ZhciBjPXRoaXMuaWE7aWYoY3x8XCJmaWxlXCI9PWIpYS5wdXNoKFwiLy9cIiksKGI9dGhpcy5DYSkmJmEucHVzaChVZShiLFZlLCEwKSxcIkBcIiksYS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYykpLnJlcGxhY2UoLyUyNShbMC05YS1mQS1GXXsyfSkvZyxcIiUkMVwiKSksYz10aGlzLk1hLG51bGwhPWMmJmEucHVzaChcIjpcIixTdHJpbmcoYykpO2lmKGM9dGhpcy5rYSl0aGlzLmlhJiZcIi9cIiE9Yy5jaGFyQXQoMCkmJmEucHVzaChcIi9cIiksYS5wdXNoKFVlKGMsXCIvXCI9PWMuY2hhckF0KDApP1dlOlhlLCEwKSk7KGM9dGhpcy5TLnRvU3RyaW5nKCkpJiZhLnB1c2goXCI/XCIsYyk7KGM9dGhpcy50YSkmJmEucHVzaChcIiNcIixVZShjLFllKSk7cmV0dXJuIGEuam9pbihcIlwiKX07XG5OZS5wcm90b3R5cGUucmVzb2x2ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNsb25lKCksYz0hIWEubmE7Yz9PZShiLGEubmEpOmM9ISFhLkNhO2lmKGMpe3ZhciBkPWEuQ2E7TShiKTtiLkNhPWR9ZWxzZSBjPSEhYS5pYTtjP1BlKGIsYS5pYSk6Yz1udWxsIT1hLk1hO2Q9YS5rYTtpZihjKVFlKGIsYS5NYSk7ZWxzZSBpZihjPSEhYS5rYSl7aWYoXCIvXCIhPWQuY2hhckF0KDApKWlmKHRoaXMuaWEmJiF0aGlzLmthKWQ9XCIvXCIrZDtlbHNle3ZhciBlPWIua2EubGFzdEluZGV4T2YoXCIvXCIpOy0xIT1lJiYoZD1iLmthLnN1YnN0cigwLGUrMSkrZCl9ZT1kO2lmKFwiLi5cIj09ZXx8XCIuXCI9PWUpZD1cIlwiO2Vsc2UgaWYodShlLFwiLi9cIil8fHUoZSxcIi8uXCIpKXtmb3IodmFyIGQ9MD09ZS5sYXN0SW5kZXhPZihcIi9cIiwwKSxlPWUuc3BsaXQoXCIvXCIpLGY9W10sZz0wO2c8ZS5sZW5ndGg7KXt2YXIgaD1lW2crK107XCIuXCI9PWg/ZCYmZz09ZS5sZW5ndGgmJmYucHVzaChcIlwiKTpcIi4uXCI9PWg/KCgxPGYubGVuZ3RofHxcbjE9PWYubGVuZ3RoJiZcIlwiIT1mWzBdKSYmZi5wb3AoKSxkJiZnPT1lLmxlbmd0aCYmZi5wdXNoKFwiXCIpKTooZi5wdXNoKGgpLGQ9ITApfWQ9Zi5qb2luKFwiL1wiKX1lbHNlIGQ9ZX1jP1JlKGIsZCk6Yz1cIlwiIT09YS5TLnRvU3RyaW5nKCk7Yz9TZShiLFRlKGEuUy50b1N0cmluZygpKSk6Yz0hIWEudGE7YyYmKGE9YS50YSxNKGIpLGIudGE9YSk7cmV0dXJuIGJ9O05lLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgTmUodGhpcyl9O1xudmFyIE9lPWZ1bmN0aW9uKGEsYixjKXtNKGEpO2EubmE9Yz9UZShiLCEwKTpiO2EubmEmJihhLm5hPWEubmEucmVwbGFjZSgvOiQvLFwiXCIpKX0sUGU9ZnVuY3Rpb24oYSxiLGMpe00oYSk7YS5pYT1jP1RlKGIsITApOmJ9LFFlPWZ1bmN0aW9uKGEsYil7TShhKTtpZihiKXtiPU51bWJlcihiKTtpZihpc05hTihiKXx8MD5iKXRocm93IEVycm9yKFwiQmFkIHBvcnQgbnVtYmVyIFwiK2IpO2EuTWE9Yn1lbHNlIGEuTWE9bnVsbH0sUmU9ZnVuY3Rpb24oYSxiLGMpe00oYSk7YS5rYT1jP1RlKGIsITApOmJ9LFNlPWZ1bmN0aW9uKGEsYixjKXtNKGEpO2IgaW5zdGFuY2VvZiBOPyhhLlM9YixhLlMudmMoYS5GKSk6KGN8fChiPVVlKGIsWmUpKSxhLlM9bmV3IE4oYiwwLGEuRikpfSxPPWZ1bmN0aW9uKGEsYixjKXtNKGEpO2EuUy5zZXQoYixjKX0sTT1mdW5jdGlvbihhKXtpZihhLiRkKXRocm93IEVycm9yKFwiVHJpZWQgdG8gbW9kaWZ5IGEgcmVhZC1vbmx5IFVyaVwiKTt9O1xuTmUucHJvdG90eXBlLnZjPWZ1bmN0aW9uKGEpe3RoaXMuRj1hO3RoaXMuUyYmdGhpcy5TLnZjKGEpO3JldHVybiB0aGlzfTtcbnZhciAkZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBOZShudWxsLHZvaWQgMCk7T2UoYyxcImh0dHBzXCIpO2EmJlBlKGMsYSk7YiYmUmUoYyxiKTtyZXR1cm4gY30sVGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT9iP2RlY29kZVVSSShhLnJlcGxhY2UoLyUyNS9nLFwiJTI1MjVcIikpOmRlY29kZVVSSUNvbXBvbmVudChhKTpcIlwifSxVZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG4oYSk/KGE9ZW5jb2RlVVJJKGEpLnJlcGxhY2UoYixhZiksYyYmKGE9YS5yZXBsYWNlKC8lMjUoWzAtOWEtZkEtRl17Mn0pL2csXCIlJDFcIikpLGEpOm51bGx9LGFmPWZ1bmN0aW9uKGEpe2E9YS5jaGFyQ29kZUF0KDApO3JldHVyblwiJVwiKyhhPj40JjE1KS50b1N0cmluZygxNikrKGEmMTUpLnRvU3RyaW5nKDE2KX0sVmU9L1sjXFwvXFw/QF0vZyxYZT0vW1xcI1xcPzpdL2csV2U9L1tcXCNcXD9dL2csWmU9L1tcXCNcXD9AXS9nLFllPS8jL2csTj1mdW5jdGlvbihhLGIsYyl7dGhpcy5pPXRoaXMuaj1udWxsO3RoaXMuQz1hfHxudWxsO1xudGhpcy5GPSEhY30sYmY9ZnVuY3Rpb24oYSl7YS5qfHwoYS5qPW5ldyBlZSxhLmk9MCxhLkMmJnplKGEuQyxmdW5jdGlvbihiLGMpe2EuYWRkKGRlY29kZVVSSUNvbXBvbmVudChiLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSksYyl9KSl9LGRmPWZ1bmN0aW9uKGEpe3ZhciBiPWplKGEpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiKXRocm93IEVycm9yKFwiS2V5cyBhcmUgdW5kZWZpbmVkXCIpO3ZhciBjPW5ldyBOKG51bGwsMCx2b2lkIDApO2E9aWUoYSk7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF0sZj1hW2RdO2VhKGYpP2NmKGMsZSxmKTpjLmFkZChlLGYpfXJldHVybiBjfTtrPU4ucHJvdG90eXBlO2sud2I9ZnVuY3Rpb24oKXtiZih0aGlzKTtyZXR1cm4gdGhpcy5pfTtcbmsuYWRkPWZ1bmN0aW9uKGEsYil7YmYodGhpcyk7dGhpcy5DPW51bGw7YT10aGlzLnMoYSk7dmFyIGM9dGhpcy5qLmdldChhKTtjfHx0aGlzLmouc2V0KGEsYz1bXSk7Yy5wdXNoKGIpO3RoaXMuaT16YSh0aGlzLmkpKzE7cmV0dXJuIHRoaXN9O2sucmVtb3ZlPWZ1bmN0aW9uKGEpe2JmKHRoaXMpO2E9dGhpcy5zKGEpO3JldHVybiB0aGlzLmouWWEoYSk/KHRoaXMuQz1udWxsLHRoaXMuaT16YSh0aGlzLmkpLXRoaXMuai5nZXQoYSkubGVuZ3RoLHRoaXMuai5yZW1vdmUoYSkpOiExfTtrLllhPWZ1bmN0aW9uKGEpe2JmKHRoaXMpO2E9dGhpcy5zKGEpO3JldHVybiB0aGlzLmouWWEoYSl9O2suWT1mdW5jdGlvbigpe2JmKHRoaXMpO2Zvcih2YXIgYT10aGlzLmouSigpLGI9dGhpcy5qLlkoKSxjPVtdLGQ9MDtkPGIubGVuZ3RoO2QrKylmb3IodmFyIGU9YVtkXSxmPTA7ZjxlLmxlbmd0aDtmKyspYy5wdXNoKGJbZF0pO3JldHVybiBjfTtcbmsuSj1mdW5jdGlvbihhKXtiZih0aGlzKTt2YXIgYj1bXTtpZihuKGEpKXRoaXMuWWEoYSkmJihiPU1hKGIsdGhpcy5qLmdldCh0aGlzLnMoYSkpKSk7ZWxzZXthPXRoaXMuai5KKCk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYj1NYShiLGFbY10pfXJldHVybiBifTtrLnNldD1mdW5jdGlvbihhLGIpe2JmKHRoaXMpO3RoaXMuQz1udWxsO2E9dGhpcy5zKGEpO3RoaXMuWWEoYSkmJih0aGlzLmk9emEodGhpcy5pKS10aGlzLmouZ2V0KGEpLmxlbmd0aCk7dGhpcy5qLnNldChhLFtiXSk7dGhpcy5pPXphKHRoaXMuaSkrMTtyZXR1cm4gdGhpc307ay5nZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hP3RoaXMuSihhKTpbXTtyZXR1cm4gMDxjLmxlbmd0aD9TdHJpbmcoY1swXSk6Yn07dmFyIGNmPWZ1bmN0aW9uKGEsYixjKXthLnJlbW92ZShiKTswPGMubGVuZ3RoJiYoYS5DPW51bGwsYS5qLnNldChhLnMoYiksT2EoYykpLGEuaT16YShhLmkpK2MubGVuZ3RoKX07XG5OLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2lmKHRoaXMuQylyZXR1cm4gdGhpcy5DO2lmKCF0aGlzLmopcmV0dXJuXCJcIjtmb3IodmFyIGE9W10sYj10aGlzLmouWSgpLGM9MDtjPGIubGVuZ3RoO2MrKylmb3IodmFyIGQ9YltjXSxlPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZCkpLGQ9dGhpcy5KKGQpLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGc9ZTtcIlwiIT09ZFtmXSYmKGcrPVwiPVwiK2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZFtmXSkpKTthLnB1c2goZyl9cmV0dXJuIHRoaXMuQz1hLmpvaW4oXCImXCIpfTtOLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBOO2EuQz10aGlzLkM7dGhpcy5qJiYoYS5qPXRoaXMuai5jbG9uZSgpLGEuaT10aGlzLmkpO3JldHVybiBhfTtOLnByb3RvdHlwZS5zPWZ1bmN0aW9uKGEpe2E9U3RyaW5nKGEpO3RoaXMuRiYmKGE9YS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYX07XG5OLnByb3RvdHlwZS52Yz1mdW5jdGlvbihhKXthJiYhdGhpcy5GJiYoYmYodGhpcyksdGhpcy5DPW51bGwsdGhpcy5qLmZvckVhY2goZnVuY3Rpb24oYSxjKXt2YXIgZD1jLnRvTG93ZXJDYXNlKCk7YyE9ZCYmKHRoaXMucmVtb3ZlKGMpLGNmKHRoaXMsZCxhKSl9LHRoaXMpKTt0aGlzLkY9YX07dmFyIGVmPWZ1bmN0aW9uKGEsYil7dmFyIGM9W10sZDtmb3IoZCBpbiBhKWQgaW4gYj90eXBlb2YgYVtkXSE9dHlwZW9mIGJbZF0/Yy5wdXNoKGQpOmVhKGFbZF0pP1ZhKGFbZF0sYltkXSl8fGMucHVzaChkKTpcIm9iamVjdFwiPT10eXBlb2YgYVtkXSYmbnVsbCE9YVtkXSYmbnVsbCE9YltkXT8wPGVmKGFbZF0sYltkXSkubGVuZ3RoJiZjLnB1c2goZCk6YVtkXSE9PWJbZF0mJmMucHVzaChkKTpjLnB1c2goZCk7Zm9yKGQgaW4gYilkIGluIGF8fGMucHVzaChkKTtyZXR1cm4gY30sZmY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsLGQ9TWF0aC5mbG9vcigxRTkqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKSxlPWF8fDUwMCxmPWJ8fDYwMCxnPSh3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0LWYpLzIsaD0od2luZG93LnNjcmVlbi5hdmFpbFdpZHRoLWUpLzIsZT17d2lkdGg6ZSxoZWlnaHQ6Zix0b3A6MDxnP2c6MCxsZWZ0OjA8aD9oOjAsbG9jYXRpb246ITAscmVzaXphYmxlOiEwLHN0YXR1c2JhcjohMCxcbnRvb2xiYXI6ITF9O2QmJihlLnRhcmdldD1kKTtuYXZpZ2F0b3IudXNlckFnZW50JiYtMSE9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveC9cIikmJihjPWN8fFwiaHR0cDovL2xvY2FsaG9zdFwiKTt2YXIgbSxmPWN8fFwiYWJvdXQ6YmxhbmtcIjsoZD1lKXx8KGQ9e30pO2M9d2luZG93O2U9ZiBpbnN0YW5jZW9mIEE/ZjpEYihcInVuZGVmaW5lZFwiIT10eXBlb2YgZi5ocmVmP2YuaHJlZjpTdHJpbmcoZikpO2Y9ZC50YXJnZXR8fGYudGFyZ2V0O2c9W107Zm9yKG0gaW4gZClzd2l0Y2gobSl7Y2FzZSBcIndpZHRoXCI6Y2FzZSBcImhlaWdodFwiOmNhc2UgXCJ0b3BcIjpjYXNlIFwibGVmdFwiOmcucHVzaChtK1wiPVwiK2RbbV0pO2JyZWFrO2Nhc2UgXCJ0YXJnZXRcIjpjYXNlIFwibm9yZWZlcnJlclwiOmJyZWFrO2RlZmF1bHQ6Zy5wdXNoKG0rXCI9XCIrKGRbbV0/MTowKSl9bT1nLmpvaW4oXCIsXCIpOyh4KFwiaVBob25lXCIpJiYheChcImlQb2RcIikmJiF4KFwiaVBhZFwiKXx8eChcImlQYWRcIil8fHgoXCJpUG9kXCIpKSYmXG5jLm5hdmlnYXRvciYmYy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSYmZiYmXCJfc2VsZlwiIT1mPyhtPWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkFcIiksZT1lIGluc3RhbmNlb2YgQT9lOkRiKGUpLG0uaHJlZj1BYihlKSxtLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLGYpLGQubm9yZWZlcnJlciYmbS5zZXRBdHRyaWJ1dGUoXCJyZWxcIixcIm5vcmVmZXJyZXJcIiksZD1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIiksZC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsYywxKSxtLmRpc3BhdGNoRXZlbnQoZCksbT17fSk6ZC5ub3JlZmVycmVyPyhtPWMub3BlbihcIlwiLGYsbSksZD1BYihlKSxtJiYoZmImJnUoZCxcIjtcIikmJihkPVwiJ1wiK2QucmVwbGFjZSgvJy9nLFwiJTI3XCIpK1wiJ1wiKSxtLm9wZW5lcj1udWxsLGM9bmV3IHhiLGMuUGI9XCJiLzEyMDE0NDEyLCBtZXRhIHRhZyB3aXRoIHNhbml0aXplZCBVUkxcIix1YS50ZXN0KGQpJiYoLTEhPWQuaW5kZXhPZihcIiZcIikmJihkPWQucmVwbGFjZShvYSxcblwiJmFtcDtcIikpLC0xIT1kLmluZGV4T2YoXCI8XCIpJiYoZD1kLnJlcGxhY2UocGEsXCImbHQ7XCIpKSwtMSE9ZC5pbmRleE9mKFwiPlwiKSYmKGQ9ZC5yZXBsYWNlKHFhLFwiJmd0O1wiKSksLTEhPWQuaW5kZXhPZignXCInKSYmKGQ9ZC5yZXBsYWNlKHJhLFwiJnF1b3Q7XCIpKSwtMSE9ZC5pbmRleE9mKFwiJ1wiKSYmKGQ9ZC5yZXBsYWNlKHNhLFwiJiMzOTtcIikpLC0xIT1kLmluZGV4T2YoXCJcXHgwMFwiKSYmKGQ9ZC5yZXBsYWNlKHRhLFwiJiMwO1wiKSkpLGQ9JzxNRVRBIEhUVFAtRVFVSVY9XCJyZWZyZXNoXCIgY29udGVudD1cIjA7IHVybD0nK2QrJ1wiPicsQWEoeWIoYyksXCJtdXN0IHByb3ZpZGUganVzdGlmaWNhdGlvblwiKSx2KCEvXltcXHNcXHhhMF0qJC8udGVzdCh5YihjKSksXCJtdXN0IHByb3ZpZGUgbm9uLWVtcHR5IGp1c3RpZmljYXRpb25cIiksbS5kb2N1bWVudC53cml0ZShHYigobmV3IEZiKS5aZChkKSkpLG0uZG9jdW1lbnQuY2xvc2UoKSkpOm09Yy5vcGVuKEFiKGUpLGYsbSk7aWYobSl0cnl7bS5mb2N1cygpfWNhdGNoKFMpe31yZXR1cm4gbX0sXG5nZj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEgoZnVuY3Rpb24oYil7dmFyIGM9ZnVuY3Rpb24oKXt4ZSgyRTMpLnRoZW4oZnVuY3Rpb24oKXtpZighYXx8YS5jbG9zZWQpYigpO2Vsc2UgcmV0dXJuIGMoKX0pfTtyZXR1cm4gYygpfSl9LGhmPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbDtyZXR1cm4obmV3IEgoZnVuY3Rpb24oYil7XCJjb21wbGV0ZVwiPT1sLmRvY3VtZW50LnJlYWR5U3RhdGU/YigpOihhPWZ1bmN0aW9uKCl7YigpfSxmYyh3aW5kb3csXCJsb2FkXCIsYSkpfSkpLkkoZnVuY3Rpb24oYil7aGMod2luZG93LFwibG9hZFwiLGEpO3Rocm93IGI7fSl9LGpmPWZ1bmN0aW9uKCl7dmFyIGE9bmF2aWdhdG9yLnVzZXJBZ2VudCxiPWEudG9Mb3dlckNhc2UoKTtpZih1KGIsXCJvcGVyYS9cIil8fHUoYixcIm9wci9cIil8fHUoYixcIm9waW9zL1wiKSlyZXR1cm5cIk9wZXJhXCI7aWYodShiLFwibXNpZVwiKXx8dShiLFwidHJpZGVudC9cIikpcmV0dXJuXCJJRVwiO2lmKHUoYixcImVkZ2UvXCIpKXJldHVyblwiRWRnZVwiO2lmKHUoYixcblwiZmlyZWZveC9cIikpcmV0dXJuXCJGaXJlZm94XCI7aWYodShiLFwic2lsay9cIikpcmV0dXJuXCJTaWxrXCI7aWYodShiLFwic2FmYXJpL1wiKSYmIXUoYixcImNocm9tZS9cIikpcmV0dXJuXCJTYWZhcmlcIjtpZighdShiLFwiY2hyb21lL1wiKSYmIXUoYixcImNyaW9zL1wiKXx8dShiLFwiZWRnZS9cIikpe2lmKChhPWEubWF0Y2goLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC8pKSYmMj09YS5sZW5ndGgpcmV0dXJuIGFbMV19ZWxzZSByZXR1cm5cIkNocm9tZVwiO3JldHVyblwiT3RoZXJcIn0sa2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIGpmKCkrXCIvSnNDb3JlL1wiK2F9LGxmPWZ1bmN0aW9uKGEpe2E9YS5zcGxpdChcIi5cIik7Zm9yKHZhciBiPWwsYz0wO2M8YS5sZW5ndGgmJlwib2JqZWN0XCI9PXR5cGVvZiBiJiZudWxsIT1iO2MrKyliPWJbYVtjXV07YyE9YS5sZW5ndGgmJihiPXZvaWQgMCk7cmV0dXJuIGJ9O3ZhciBtZjt0cnl7dmFyIG5mPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShuZixcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6MX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShuZixcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Mn0pO21mPTI9PW5mLmFiY2R9Y2F0Y2goYSl7bWY9ITF9XG52YXIgUD1mdW5jdGlvbihhLGIsYyl7bWY/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Y30pOmFbYl09Y30sb2Y9ZnVuY3Rpb24oYSxiKXtpZihiKWZvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJlAoYSxjLGJbY10pfSxwZj1mdW5jdGlvbihhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9LHFmPWZ1bmN0aW9uKGEsYil7aWYoIWJ8fCFiLmxlbmd0aClyZXR1cm4hMDtpZighYSlyZXR1cm4hMTtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YVtiW2NdXTtpZih2b2lkIDA9PT1kfHxudWxsPT09ZHx8XCJcIj09PWQpcmV0dXJuITF9cmV0dXJuITB9O3ZhciByZj17cmQ6e2tiOjk4NSxqYjo3MzUscHJvdmlkZXJJZDpcImZhY2Vib29rLmNvbVwifSxzZDp7a2I6MTA0MCxqYjo2MjAscHJvdmlkZXJJZDpcImdpdGh1Yi5jb21cIn0sdGQ6e2tiOjQ4NSxqYjo2NDAscHJvdmlkZXJJZDpcImdvb2dsZS5jb21cIn0seGQ6e2tiOjQ4NSxqYjo3MDUscHJvdmlkZXJJZDpcInR3aXR0ZXIuY29tXCJ9fSxzZj1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gcmYpaWYocmZbYl0ucHJvdmlkZXJJZD09YSlyZXR1cm4gcmZbYl07cmV0dXJuIG51bGx9O3ZhciBRPWZ1bmN0aW9uKGEsYil7dGhpcy5jb2RlPVwiYXV0aC9cIithO3RoaXMubWVzc2FnZT1ifHx0ZlthXXx8XCJcIn07cihRLEVycm9yKTtRLnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6dGhpcy5jb2RlLGNvZGU6dGhpcy5jb2RlLG1lc3NhZ2U6dGhpcy5tZXNzYWdlfX07XG52YXIgdGY9e1wiYXJndW1lbnQtZXJyb3JcIjpcIlwiLFwiYXBwLW5vdC1hdXRob3JpemVkXCI6XCJUaGlzIGFwcCwgaWRlbnRpZmllZCBieSB0aGUgZG9tYWluIHdoZXJlIGl0J3MgaG9zdGVkLCBpcyBub3QgYXV0aG9yaXplZCB0byB1c2UgRmlyZWJhc2UgQXV0aGVudGljYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQgQVBJIGtleS4gUmV2aWV3IHlvdXIga2V5IGNvbmZpZ3VyYXRpb24gaW4gdGhlIEdvb2dsZSBBUEkgY29uc29sZS5cIixcImNvcnMtdW5zdXBwb3J0ZWRcIjpcIlRoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlwiLFwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiOlwiVGhpcyBjcmVkZW50aWFsIGlzIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGEgZGlmZmVyZW50IHVzZXIgYWNjb3VudC5cIixcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiOlwiVGhlIGN1c3RvbSB0b2tlbiBjb3JyZXNwb25kcyB0byBhIGRpZmZlcmVudCBhdWRpZW5jZS5cIixcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiOlwiVGhpcyBvcGVyYXRpb24gaXMgc2Vuc2l0aXZlIGFuZCByZXF1aXJlcyByZWNlbnQgYXV0aGVudGljYXRpb24uIExvZyBpbiBhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LlwiLFxuXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiOlwiVGhlIGVtYWlsIGFkZHJlc3MgaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciBhY2NvdW50LlwiLFwiZXhwaXJlZC1hY3Rpb24tY29kZVwiOlwiVGhlIGFjdGlvbiBjb2RlIGhhcyBleHBpcmVkLiBcIixcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCI6XCJUaGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgZHVlIHRvIGFub3RoZXIgY29uZmxpY3RpbmcgcG9wdXAgYmVpbmcgb3BlbmVkLlwiLFwiaW50ZXJuYWwtZXJyb3JcIjpcIkFuIGludGVybmFsIGVycm9yIGhhcyBvY2N1cnJlZC5cIixcImludmFsaWQtdXNlci10b2tlblwiOlwiVGhlIHVzZXIncyBjcmVkZW50aWFsIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlIHVzZXIgbXVzdCBzaWduIGluIGFnYWluLlwiLFwiaW52YWxpZC1hdXRoLWV2ZW50XCI6XCJBbiBpbnRlcm5hbCBlcnJvciBoYXMgb2NjdXJyZWQuXCIsXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiOlwiVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uXCIsXG5cImludmFsaWQtZW1haWxcIjpcIlRoZSBlbWFpbCBhZGRyZXNzIGlzIGJhZGx5IGZvcm1hdHRlZC5cIixcImludmFsaWQtYXBpLWtleVwiOlwiWW91ciBBUEkga2V5IGlzIGludmFsaWQsIHBsZWFzZSBjaGVjayB5b3UgaGF2ZSBjb3BpZWQgaXQgY29ycmVjdGx5LlwiLFwiaW52YWxpZC1jcmVkZW50aWFsXCI6XCJUaGUgc3VwcGxpZWQgYXV0aCBjcmVkZW50aWFsIGlzIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC5cIixcImludmFsaWQtb2F1dGgtcHJvdmlkZXJcIjpcIkVtYWlsQXV0aFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvbiBvbmx5IHN1cHBvcnRzIE9BdXRoIHByb3ZpZGVycy5cIixcInVuYXV0aG9yaXplZC1kb21haW5cIjpcIlRoaXMgZG9tYWluIGlzIG5vdCBhdXRob3JpemVkIGZvciBPQXV0aCBvcGVyYXRpb25zIGZvciB5b3VyIEZpcmViYXNlIHByb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXG5cImludmFsaWQtYWN0aW9uLWNvZGVcIjpcIlRoZSBhY3Rpb24gY29kZSBpcyBpbnZhbGlkLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGNvZGUgaXMgbWFsZm9ybWVkLCBleHBpcmVkLCBvciBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIsXCJ3cm9uZy1wYXNzd29yZFwiOlwiVGhlIHBhc3N3b3JkIGlzIGludmFsaWQgb3IgdGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHBhc3N3b3JkLlwiLFwibWlzc2luZy1pZnJhbWUtc3RhcnRcIjpcIkFuIGludGVybmFsIGVycm9yIGhhcyBvY2N1cnJlZC5cIixcImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiOlwiQmUgc3VyZSB0byBpbmNsdWRlIGF1dGhEb21haW4gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKSwgYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXCJhcHAtZGVsZXRlZFwiOlwiVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLlwiLFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiOlwiQW4gYWNjb3VudCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGVtYWlsIGFkZHJlc3MgYnV0IGRpZmZlcmVudCBzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZW1haWwgYWRkcmVzcy5cIixcblwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiOlwiQSBuZXR3b3JrIGVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLlwiLFwibm8tYXV0aC1ldmVudFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwibm8tc3VjaC1wcm92aWRlclwiOlwiVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLlwiLFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCI6XCJUaGlzIG9wZXJhdGlvbiBpcyBub3QgYWxsb3dlZC4gWW91IG11c3QgZW5hYmxlIHRoaXMgc2VydmljZSBpbiB0aGUgY29uc29sZS5cIixcInBvcHVwLWJsb2NrZWRcIjpcIlVuYWJsZSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHBvcHVwLiBJdCBtYXkgaGF2ZSBiZWVuIGJsb2NrZWQgYnkgdGhlIGJyb3dzZXIuXCIsXCJwb3B1cC1jbG9zZWQtYnktdXNlclwiOlwiVGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZyB0aGUgb3BlcmF0aW9uLlwiLFxuXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiOlwiVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXCIsdGltZW91dDpcIlRoZSBvcGVyYXRpb24gaGFzIHRpbWVkIG91dC5cIixcInVzZXItdG9rZW4tZXhwaXJlZFwiOlwiVGhlIHVzZXIncyBjcmVkZW50aWFsIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlIHVzZXIgbXVzdCBzaWduIGluIGFnYWluLlwiLFwidG9vLW1hbnktcmVxdWVzdHNcIjpcIldlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gVHJ5IGFnYWluIGxhdGVyLlwiLFwidXNlci1ub3QtZm91bmRcIjpcIlRoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQuXCIsXCJ1c2VyLWRpc2FibGVkXCI6XCJUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuXCIsXG5cInVzZXItbWlzbWF0Y2hcIjpcIlRoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci5cIixcInVzZXItc2lnbmVkLW91dFwiOlwiXCIsXCJ3ZWFrLXBhc3N3b3JkXCI6XCJUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLlwiLFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIjpcIlRoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlwifTt2YXIgdWY9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnBhPWE7dGhpcy5zYT1ifHxudWxsO3RoaXMuVWE9Y3x8bnVsbDt0aGlzLnVjPWR8fG51bGw7dGhpcy5EPWV8fG51bGw7aWYodGhpcy5VYXx8dGhpcy5EKXtpZih0aGlzLlVhJiZ0aGlzLkQpdGhyb3cgbmV3IFEoXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7aWYodGhpcy5VYSYmIXRoaXMudWMpdGhyb3cgbmV3IFEoXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7fWVsc2UgdGhyb3cgbmV3IFEoXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7fTt1Zi5wcm90b3R5cGUuZmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51Y307dWYucHJvdG90eXBlLmdldEVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRH07dWYucHJvdG90eXBlLk49ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTp0aGlzLnBhLGV2ZW50SWQ6dGhpcy5zYSx1cmxSZXNwb25zZTp0aGlzLlVhLHNlc3Npb25JZDp0aGlzLnVjLGVycm9yOnRoaXMuRCYmdGhpcy5ELk4oKX19O3ZhciB2Zj1mdW5jdGlvbihhKXt0aGlzLmJlPWEuc3ViO2xhKCk7dGhpcy5zYj1hLmVtYWlsfHxudWxsfTt2YXIgd2Y9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9e307aGEoYyk/ZT1jOmImJm4oYykmJm4oZCk/ZT17b2F1dGhUb2tlbjpjLG9hdXRoVG9rZW5TZWNyZXQ6ZH06IWImJm4oYykmJihlPXthY2Nlc3NUb2tlbjpjfSk7aWYoYnx8IWUuaWRUb2tlbiYmIWUuYWNjZXNzVG9rZW4paWYoYiYmZS5vYXV0aFRva2VuJiZlLm9hdXRoVG9rZW5TZWNyZXQpUCh0aGlzLFwiYWNjZXNzVG9rZW5cIixlLm9hdXRoVG9rZW4pLFAodGhpcyxcInNlY3JldFwiLGUub2F1dGhUb2tlblNlY3JldCk7ZWxzZXtpZihiKXRocm93IG5ldyBRKFwiYXJndW1lbnQtZXJyb3JcIixcImNyZWRlbnRpYWwgZmFpbGVkOiBleHBlY3RlZCAyIGFyZ3VtZW50cyAodGhlIE9BdXRoIGFjY2VzcyB0b2tlbiBhbmQgc2VjcmV0KS5cIik7dGhyb3cgbmV3IFEoXCJhcmd1bWVudC1lcnJvclwiLFwiY3JlZGVudGlhbCBmYWlsZWQ6IGV4cGVjdGVkIDEgYXJndW1lbnQgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4pLlwiKTt9ZWxzZSBlLmlkVG9rZW4mJlAodGhpcyxcblwiaWRUb2tlblwiLGUuaWRUb2tlbiksZS5hY2Nlc3NUb2tlbiYmUCh0aGlzLFwiYWNjZXNzVG9rZW5cIixlLmFjY2Vzc1Rva2VuKTtQKHRoaXMsXCJwcm92aWRlclwiLGEpfTt3Zi5wcm90b3R5cGUueGI9ZnVuY3Rpb24oYSl7cmV0dXJuIHhmKGEseWYodGhpcykpfTt3Zi5wcm90b3R5cGUuWGM9ZnVuY3Rpb24oYSxiKXt2YXIgYz15Zih0aGlzKTtjLmlkVG9rZW49YjtyZXR1cm4gUihhLHpmLGMpfTt2YXIgeWY9ZnVuY3Rpb24oYSl7dmFyIGI9e307YS5pZFRva2VuJiYoYi5pZF90b2tlbj1hLmlkVG9rZW4pO2EuYWNjZXNzVG9rZW4mJihiLmFjY2Vzc190b2tlbj1hLmFjY2Vzc1Rva2VuKTthLnNlY3JldCYmKGIub2F1dGhfdG9rZW5fc2VjcmV0PWEuc2VjcmV0KTtiLnByb3ZpZGVySWQ9YS5wcm92aWRlcjtyZXR1cm57cG9zdEJvZHk6ZGYoYikudG9TdHJpbmcoKSxyZXF1ZXN0VXJpOndpbmRvdy5sb2NhdGlvbi5ocmVmfX07XG53Zi5wcm90b3R5cGUuTj1mdW5jdGlvbigpe3ZhciBhPXtwcm92aWRlcjp0aGlzLnByb3ZpZGVyfTt0aGlzLmlkVG9rZW4mJihhLm9hdXRoSWRUb2tlbj10aGlzLmlkVG9rZW4pO3RoaXMuYWNjZXNzVG9rZW4mJihhLm9hdXRoQWNjZXNzVG9rZW49dGhpcy5hY2Nlc3NUb2tlbik7dGhpcy5zZWNyZXQmJihhLm9hdXRoVG9rZW5TZWNyZXQ9dGhpcy5zZWNyZXQpO3JldHVybiBhfTtcbnZhciBBZj1mdW5jdGlvbihhLGIpe3ZhciBjPSEhYixkPWZ1bmN0aW9uKCl7b2YodGhpcyx7cHJvdmlkZXJJZDphLGlzT0F1dGhQcm92aWRlcjohMH0pO3RoaXMudGM9W119O2N8fChkLnByb3RvdHlwZS5hZGRTY29wZT1mdW5jdGlvbihhKXtJYSh0aGlzLnRjLGEpfHx0aGlzLnRjLnB1c2goYSl9KTtkLnByb3RvdHlwZS5NYz1mdW5jdGlvbigpe3JldHVybiBPYSh0aGlzLnRjKX07ZC5jcmVkZW50aWFsPWZ1bmN0aW9uKGIsZCl7cmV0dXJuIG5ldyB3ZihhLGMsYixkKX07b2YoZCx7UFJPVklERVJfSUQ6YX0pO3JldHVybiBkfSxCZj1BZihcImZhY2Vib29rLmNvbVwiKTtCZi5wcm90b3R5cGUuYWRkU2NvcGU9QmYucHJvdG90eXBlLmFkZFNjb3BlfHx2b2lkIDA7dmFyIENmPUFmKFwiZ2l0aHViLmNvbVwiKTtDZi5wcm90b3R5cGUuYWRkU2NvcGU9Q2YucHJvdG90eXBlLmFkZFNjb3BlfHx2b2lkIDA7dmFyIERmPUFmKFwiZ29vZ2xlLmNvbVwiKTtcbkRmLnByb3RvdHlwZS5hZGRTY29wZT1EZi5wcm90b3R5cGUuYWRkU2NvcGV8fHZvaWQgMDtEZi5jcmVkZW50aWFsPWZ1bmN0aW9uKGEsYil7aWYoIWEmJiFiKXRocm93IG5ldyBRKFwiYXJndW1lbnQtZXJyb3JcIixcImNyZWRlbnRpYWwgZmFpbGVkOiBtdXN0IHByb3ZpZGUgdGhlIElEIHRva2VuIGFuZC9vciB0aGUgYWNjZXNzIHRva2VuLlwiKTtyZXR1cm4gbmV3IHdmKFwiZ29vZ2xlLmNvbVwiLCExLGhhKGEpP2E6e2lkVG9rZW46YXx8bnVsbCxhY2Nlc3NUb2tlbjpifHxudWxsfSl9O3ZhciBFZj1BZihcInR3aXR0ZXIuY29tXCIsITApLEZmPWZ1bmN0aW9uKGEsYil7dGhpcy5zYj1hO3RoaXMubWM9YjtQKHRoaXMsXCJwcm92aWRlclwiLFwicGFzc3dvcmRcIil9O0ZmLnByb3RvdHlwZS54Yj1mdW5jdGlvbihhKXtyZXR1cm4gUihhLEdmLHtlbWFpbDp0aGlzLnNiLHBhc3N3b3JkOnRoaXMubWN9KX07XG5GZi5wcm90b3R5cGUuWGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUihhLEhmLHtpZFRva2VuOmIsZW1haWw6dGhpcy5zYixwYXNzd29yZDp0aGlzLm1jfSl9O0ZmLnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7cmV0dXJue2VtYWlsOnRoaXMuc2IscGFzc3dvcmQ6dGhpcy5tY319O3ZhciBJZj1mdW5jdGlvbigpe29mKHRoaXMse3Byb3ZpZGVySWQ6XCJwYXNzd29yZFwiLGlzT0F1dGhQcm92aWRlcjohMX0pfTtvZihJZix7UFJPVklERVJfSUQ6XCJwYXNzd29yZFwifSk7XG52YXIgSmY9e3plOklmLHJkOkJmLHRkOkRmLHNkOkNmLHhkOkVmfSxLZj1mdW5jdGlvbihhKXt2YXIgYj1hJiZhLnByb3ZpZGVySWQ7aWYoIWIpcmV0dXJuIG51bGw7dmFyIGM9YSYmYS5vYXV0aEFjY2Vzc1Rva2VuLGQ9YSYmYS5vYXV0aFRva2VuU2VjcmV0O2E9YSYmYS5vYXV0aElkVG9rZW47Zm9yKHZhciBlIGluIEpmKWlmKEpmW2VdLlBST1ZJREVSX0lEPT1iKXRyeXtyZXR1cm4gSmZbZV0uY3JlZGVudGlhbCh7YWNjZXNzVG9rZW46YyxpZFRva2VuOmEsb2F1dGhUb2tlbjpjLG9hdXRoVG9rZW5TZWNyZXQ6ZH0pfWNhdGNoKGYpe2JyZWFrfXJldHVybiBudWxsfTt2YXIgTGY9ZnVuY3Rpb24oYSxiLGMpe1EuY2FsbCh0aGlzLFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiLGMpO1AodGhpcyxcImVtYWlsXCIsYSk7UCh0aGlzLFwiY3JlZGVudGlhbFwiLGIpfTtyKExmLFEpO0xmLnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7dmFyIGE9e2NvZGU6dGhpcy5jb2RlLG1lc3NhZ2U6dGhpcy5tZXNzYWdlLGVtYWlsOnRoaXMuZW1haWx9LGI9dGhpcy5jcmVkZW50aWFsJiZ0aGlzLmNyZWRlbnRpYWwuTigpO2ImJigkYShhLGIpLGEucHJvdmlkZXJJZD1iLnByb3ZpZGVyLGRlbGV0ZSBhLnByb3ZpZGVyKTtyZXR1cm4gYX07dmFyIFQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudT1hO2E9Ynx8e307dGhpcy5uZT1hLnNlY3VyZVRva2VuRW5kcG9pbnR8fFwiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbS92MS90b2tlblwiO3RoaXMucGU9YS5zZWN1cmVUb2tlblRpbWVvdXR8fDFFNDt0aGlzLm9lPVlhKGEuc2VjdXJlVG9rZW5IZWFkZXJzfHxNZik7dGhpcy5KZD1hLmZpcmViYXNlRW5kcG9pbnR8fFwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vaWRlbnRpdHl0b29sa2l0L3YzL3JlbHlpbmdwYXJ0eS9cIjt0aGlzLktkPWEuZmlyZWJhc2VUaW1lb3V0fHwxRTQ7dGhpcy5MYz1ZYShhLmZpcmViYXNlSGVhZGVyc3x8TmYpO2MmJih0aGlzLkxjW1wiWC1DbGllbnQtVmVyc2lvblwiXT1jKTt0aGlzLkJkPW5ldyB6Y30sT2YsTWY9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0sTmY9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LFFmPWZ1bmN0aW9uKGEsXG5iLGMsZCxlLGYsZyl7IXl8fCFxYnx8OTxxYj9hPXEoYS5yZSxhKTooT2Z8fChPZj1uZXcgSChmdW5jdGlvbihhLGIpe1BmKGEsYil9KSksYT1xKGEucWUsYSkpO2EoYixjLGQsZSxmLGcpfTtcblQucHJvdG90eXBlLnJlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1uZXcgTCh0aGlzLkJkKSxoO2YmJihnLlNhPU1hdGgubWF4KDAsZiksaD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zy5kaXNwYXRjaEV2ZW50KFwidGltZW91dFwiKX0sZikpOyRiKGcsXCJjb21wbGV0ZVwiLGZ1bmN0aW9uKCl7aCYmY2xlYXJUaW1lb3V0KGgpO3ZhciBhPW51bGw7dHJ5e3ZhciBjO2M9dGhpcy5hP25jKHRoaXMuYS5yZXNwb25zZVRleHQpOnZvaWQgMDthPWN8fG51bGx9Y2F0Y2goZCl7YT1udWxsfWImJmIoYSl9KTtnYyhnLFwicmVhZHlcIixmdW5jdGlvbigpe2gmJmNsZWFyVGltZW91dChoKTt0aGlzLnJhfHwodGhpcy5yYT0hMCx0aGlzLkdhKCkpfSk7Z2MoZyxcInRpbWVvdXRcIixmdW5jdGlvbigpe2gmJmNsZWFyVGltZW91dChoKTt0aGlzLnJhfHwodGhpcy5yYT0hMCx0aGlzLkdhKCkpO2ImJmIobnVsbCl9KTtnLnNlbmQoYSxjLGQsZSl9O1xudmFyIFJmPVwiX19mY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpLFBmPWZ1bmN0aW9uKGEsYil7KCh3aW5kb3cuZ2FwaXx8e30pLmNsaWVudHx8e30pLnJlcXVlc3Q/YSgpOihsW1JmXT1mdW5jdGlvbigpeygod2luZG93LmdhcGl8fHt9KS5jbGllbnR8fHt9KS5yZXF1ZXN0P2EoKTpiKEVycm9yKFwiQ09SU19VTlNVUFBPUlRFRFwiKSl9LFFkKFlkKFwiLy9hcGlzLmdvb2dsZS5jb20vanMvY2xpZW50LmpzP29ubG9hZD1cIitSZiksZnVuY3Rpb24oKXtiKEVycm9yKFwiQ09SU19VTlNVUFBPUlRFRFwiKSl9KSl9O1xuVC5wcm90b3R5cGUucWU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzO09mLnRoZW4oZnVuY3Rpb24oKXt3aW5kb3cuZ2FwaS5jbGllbnQuc2V0QXBpS2V5KGYudSk7dmFyIGc9d2luZG93LmdhcGkuYXV0aC5nZXRUb2tlbigpO3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4obnVsbCk7d2luZG93LmdhcGkuY2xpZW50LnJlcXVlc3Qoe3BhdGg6YSxtZXRob2Q6Yyxib2R5OmQsaGVhZGVyczplLGF1dGhUeXBlOlwibm9uZVwiLGNhbGxiYWNrOmZ1bmN0aW9uKGEpe3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4oZyk7YiYmYihhKX19KX0pLkkoZnVuY3Rpb24oYSl7YiYmYih7ZXJyb3I6e21lc3NhZ2U6YSYmYS5tZXNzYWdlfHxcIkNPUlNfVU5TVVBQT1JURURcIn19KX0pfTtcbnZhciBUZj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSChmdW5jdGlvbihjLGQpe1wicmVmcmVzaF90b2tlblwiPT1iLmdyYW50X3R5cGUmJmIucmVmcmVzaF90b2tlbnx8XCJhdXRob3JpemF0aW9uX2NvZGVcIj09Yi5ncmFudF90eXBlJiZiLmNvZGU/UWYoYSxhLm5lK1wiP2tleT1cIitlbmNvZGVVUklDb21wb25lbnQoYS51KSxmdW5jdGlvbihhKXthP2EuZXJyb3I/ZChTZihhKSk6YS5hY2Nlc3NfdG9rZW4mJmEucmVmcmVzaF90b2tlbj9jKGEpOmQobmV3IFEoXCJpbnRlcm5hbC1lcnJvclwiKSk6ZChuZXcgUShcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIikpfSxcIlBPU1RcIixkZihiKS50b1N0cmluZygpLGEub2UsYS5wZSk6ZChuZXcgUShcImludGVybmFsLWVycm9yXCIpKX0pfSxVZj1mdW5jdGlvbihhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpbnVsbCE9PWFbY10mJnZvaWQgMCE9PWFbY10mJihiW2NdPWFbY10pO3JldHVybiBxYyhiKX0sVmY9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLkpkK1xuYitcIj9rZXk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGEudSk7ZSYmKGYrPVwiJmNiPVwiK2xhKCkudG9TdHJpbmcoKSk7cmV0dXJuIG5ldyBIKGZ1bmN0aW9uKGIsZSl7UWYoYSxmLGZ1bmN0aW9uKGEpe2E/YS5lcnJvcj9lKFNmKGEpKTpiKGEpOmUobmV3IFEoXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIpKX0sYyxVZihkKSxhLkxjLGEuS2QpfSl9LFdmPWZ1bmN0aW9uKGEpe2lmKCFtYy50ZXN0KGEuZW1haWwpKXRocm93IG5ldyBRKFwiaW52YWxpZC1lbWFpbFwiKTt9LFhmPWZ1bmN0aW9uKGEpe1wiZW1haWxcImluIGEmJldmKGEpfSxaZj1mdW5jdGlvbihhLGIpe3JldHVybiBSKGEsWWYse2lkZW50aWZpZXI6Yixjb250aW51ZVVyaTp3aW5kb3cubG9jYXRpb24uaHJlZn0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYWxsUHJvdmlkZXJzfHxbXX0pfSxhZz1mdW5jdGlvbihhKXtyZXR1cm4gUihhLCRmLHt9KS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhLmF1dGhvcml6ZWREb21haW5zfHxbXX0pfSxcbmJnPWZ1bmN0aW9uKGEpe2lmKCFhLmlkVG9rZW4pdGhyb3cgbmV3IFEoXCJpbnRlcm5hbC1lcnJvclwiKTt9O1QucHJvdG90eXBlLnNpZ25JbkFub255bW91c2x5PWZ1bmN0aW9uKCl7cmV0dXJuIFIodGhpcyxjZyx7fSl9O1QucHJvdG90eXBlLnVwZGF0ZUVtYWlsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFIodGhpcyxkZyx7aWRUb2tlbjphLGVtYWlsOmJ9KX07VC5wcm90b3R5cGUudXBkYXRlUGFzc3dvcmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUih0aGlzLEhmLHtpZFRva2VuOmEscGFzc3dvcmQ6Yn0pfTt2YXIgZWc9e2Rpc3BsYXlOYW1lOlwiRElTUExBWV9OQU1FXCIscGhvdG9Vcmw6XCJQSE9UT19VUkxcIn07XG5ULnByb3RvdHlwZS51cGRhdGVQcm9maWxlPWZ1bmN0aW9uKGEsYil7dmFyIGM9e2lkVG9rZW46YX0sZD1bXTtRYShlZyxmdW5jdGlvbihhLGYpe3ZhciBnPWJbZl07bnVsbD09PWc/ZC5wdXNoKGEpOmYgaW4gYiYmKGNbZl09Zyl9KTtkLmxlbmd0aCYmKGMuZGVsZXRlQXR0cmlidXRlPWQpO3JldHVybiBSKHRoaXMsZGcsYyl9O1QucHJvdG90eXBlLnNlbmRQYXNzd29yZFJlc2V0RW1haWw9ZnVuY3Rpb24oYSl7cmV0dXJuIFIodGhpcyxmZyx7cmVxdWVzdFR5cGU6XCJQQVNTV09SRF9SRVNFVFwiLGVtYWlsOmF9KX07VC5wcm90b3R5cGUuc2VuZEVtYWlsVmVyaWZpY2F0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiBSKHRoaXMsZ2cse3JlcXVlc3RUeXBlOlwiVkVSSUZZX0VNQUlMXCIsaWRUb2tlbjphfSl9O1xudmFyIGlnPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUihhLGhnLHtpZFRva2VuOmIsZGVsZXRlUHJvdmlkZXI6Y30pfSxqZz1mdW5jdGlvbihhKXtpZighYS5yZXF1ZXN0VXJpfHwhYS5zZXNzaW9uSWQmJiFhLnBvc3RCb2R5KXRocm93IG5ldyBRKFwiaW50ZXJuYWwtZXJyb3JcIik7fSxrZz1mdW5jdGlvbihhKXtpZihhLm5lZWRDb25maXJtYXRpb24pdGhyb3coYSYmYS5lbWFpbD9uZXcgTGYoYS5lbWFpbCxLZihhKSxhLm1lc3NhZ2UpOm51bGwpfHxuZXcgUShcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIik7aWYoIWEuaWRUb2tlbil0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIpO30seGY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUihhLGxnLGIpfSxtZz1mdW5jdGlvbihhKXtpZighYS5vb2JDb2RlKXRocm93IG5ldyBRKFwiaW52YWxpZC1hY3Rpb24tY29kZVwiKTt9O1xuVC5wcm90b3R5cGUuY29uZmlybVBhc3N3b3JkUmVzZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUih0aGlzLG5nLHtvb2JDb2RlOmEsbmV3UGFzc3dvcmQ6Yn0pfTtULnByb3RvdHlwZS5jaGVja0FjdGlvbkNvZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFIodGhpcyxvZyx7b29iQ29kZTphfSl9O1QucHJvdG90eXBlLmFwcGx5QWN0aW9uQ29kZT1mdW5jdGlvbihhKXtyZXR1cm4gUih0aGlzLHBnLHtvb2JDb2RlOmF9KX07XG52YXIgcGc9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIix3Om1nLFJhOlwiZW1haWxcIn0sb2c9e2VuZHBvaW50OlwicmVzZXRQYXNzd29yZFwiLHc6bWcsbGE6ZnVuY3Rpb24oYSl7aWYoIW1jLnRlc3QoYS5lbWFpbCkpdGhyb3cgbmV3IFEoXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxxZz17ZW5kcG9pbnQ6XCJzaWdudXBOZXdVc2VyXCIsdzpmdW5jdGlvbihhKXtXZihhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgUShcIndlYWstcGFzc3dvcmRcIik7fSxsYTpiZyxtYTohMH0sWWY9e2VuZHBvaW50OlwiY3JlYXRlQXV0aFVyaVwifSxyZz17ZW5kcG9pbnQ6XCJkZWxldGVBY2NvdW50XCIsUWE6W1wiaWRUb2tlblwiXX0saGc9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIixRYTpbXCJpZFRva2VuXCIsXCJkZWxldGVQcm92aWRlclwiXSx3OmZ1bmN0aW9uKGEpe2lmKCFlYShhLmRlbGV0ZVByb3ZpZGVyKSl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIpO319LHNnPXtlbmRwb2ludDpcImdldEFjY291bnRJbmZvXCJ9LFxuZ2c9e2VuZHBvaW50OlwiZ2V0T29iQ29uZmlybWF0aW9uQ29kZVwiLFFhOltcImlkVG9rZW5cIixcInJlcXVlc3RUeXBlXCJdLHc6ZnVuY3Rpb24oYSl7aWYoXCJWRVJJRllfRU1BSUxcIiE9YS5yZXF1ZXN0VHlwZSl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIpO30sUmE6XCJlbWFpbFwifSxmZz17ZW5kcG9pbnQ6XCJnZXRPb2JDb25maXJtYXRpb25Db2RlXCIsUWE6W1wicmVxdWVzdFR5cGVcIl0sdzpmdW5jdGlvbihhKXtpZihcIlBBU1NXT1JEX1JFU0VUXCIhPWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IFEoXCJpbnRlcm5hbC1lcnJvclwiKTtXZihhKX0sUmE6XCJlbWFpbFwifSwkZj17QWQ6ITAsZW5kcG9pbnQ6XCJnZXRQcm9qZWN0Q29uZmlnXCIsU2Q6XCJHRVRcIn0sbmc9e2VuZHBvaW50OlwicmVzZXRQYXNzd29yZFwiLHc6bWcsUmE6XCJlbWFpbFwifSxkZz17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLFFhOltcImlkVG9rZW5cIl0sdzpYZixtYTohMH0sSGY9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIixRYTpbXCJpZFRva2VuXCJdLFxudzpmdW5jdGlvbihhKXtYZihhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgUShcIndlYWstcGFzc3dvcmRcIik7fSxsYTpiZyxtYTohMH0sY2c9e2VuZHBvaW50Olwic2lnbnVwTmV3VXNlclwiLGxhOmJnLG1hOiEwfSxsZz17ZW5kcG9pbnQ6XCJ2ZXJpZnlBc3NlcnRpb25cIix3OmpnLGxhOmtnLG1hOiEwfSx6Zj17ZW5kcG9pbnQ6XCJ2ZXJpZnlBc3NlcnRpb25cIix3OmZ1bmN0aW9uKGEpe2pnKGEpO2lmKCFhLmlkVG9rZW4pdGhyb3cgbmV3IFEoXCJpbnRlcm5hbC1lcnJvclwiKTt9LGxhOmtnLG1hOiEwfSx0Zz17ZW5kcG9pbnQ6XCJ2ZXJpZnlDdXN0b21Ub2tlblwiLHc6ZnVuY3Rpb24oYSl7aWYoIWEudG9rZW4pdGhyb3cgbmV3IFEoXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiKTt9LGxhOmJnLG1hOiEwfSxHZj17ZW5kcG9pbnQ6XCJ2ZXJpZnlQYXNzd29yZFwiLHc6ZnVuY3Rpb24oYSl7V2YoYSk7aWYoIWEucGFzc3dvcmQpdGhyb3cgbmV3IFEoXCJ3cm9uZy1wYXNzd29yZFwiKTt9LGxhOmJnLG1hOiEwfSxSPVxuZnVuY3Rpb24oYSxiLGMpe2lmKCFxZihjLGIuUWEpKXJldHVybiBzZChuZXcgUShcImludGVybmFsLWVycm9yXCIpKTt2YXIgZD1iLlNkfHxcIlBPU1RcIixlO3JldHVybiBJKGMpLnRoZW4oYi53KS50aGVuKGZ1bmN0aW9uKCl7Yi5tYSYmKGMucmV0dXJuU2VjdXJlVG9rZW49ITApO3JldHVybiBWZihhLGIuZW5kcG9pbnQsZCxjLGIuQWR8fCExKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGU9YX0pLnRoZW4oYi5sYSkudGhlbihmdW5jdGlvbigpe2lmKCFiLlJhKXJldHVybiBlO2lmKCEoYi5SYSBpbiBlKSl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIpO3JldHVybiBlW2IuUmFdfSl9LFNmPWZ1bmN0aW9uKGEpe3ZhciBiO2I9KGEuZXJyb3ImJmEuZXJyb3IuZXJyb3JzJiZhLmVycm9yLmVycm9yc1swXXx8e30pLnJlYXNvbnx8XCJcIjt2YXIgYz17a2V5SW52YWxpZDpcImludmFsaWQtYXBpLWtleVwiLGlwUmVmZXJlckJsb2NrZWQ6XCJhcHAtbm90LWF1dGhvcml6ZWRcIn07aWYoYj1jW2JdP1xubmV3IFEoY1tiXSk6bnVsbClyZXR1cm4gYjthPWEuZXJyb3ImJmEuZXJyb3IubWVzc2FnZXx8XCJcIjtiPXtJTlZBTElEX0NVU1RPTV9UT0tFTjpcImludmFsaWQtY3VzdG9tLXRva2VuXCIsQ1JFREVOVElBTF9NSVNNQVRDSDpcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiLE1JU1NJTkdfQ1VTVE9NX1RPS0VOOlwiaW50ZXJuYWwtZXJyb3JcIixJTlZBTElEX0lERU5USUZJRVI6XCJpbnZhbGlkLWVtYWlsXCIsTUlTU0lOR19DT05USU5VRV9VUkk6XCJpbnRlcm5hbC1lcnJvclwiLElOVkFMSURfRU1BSUw6XCJpbnZhbGlkLWVtYWlsXCIsSU5WQUxJRF9QQVNTV09SRDpcIndyb25nLXBhc3N3b3JkXCIsVVNFUl9ESVNBQkxFRDpcInVzZXItZGlzYWJsZWRcIixNSVNTSU5HX1BBU1NXT1JEOlwiaW50ZXJuYWwtZXJyb3JcIixFTUFJTF9FWElTVFM6XCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiLFBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEOlwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIsSU5WQUxJRF9JRFBfUkVTUE9OU0U6XCJpbnZhbGlkLWNyZWRlbnRpYWxcIixcbkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEOlwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiLEVNQUlMX05PVF9GT1VORDpcInVzZXItbm90LWZvdW5kXCIsRVhQSVJFRF9PT0JfQ09ERTpcImV4cGlyZWQtYWN0aW9uLWNvZGVcIixJTlZBTElEX09PQl9DT0RFOlwiaW52YWxpZC1hY3Rpb24tY29kZVwiLE1JU1NJTkdfT09CX0NPREU6XCJpbnRlcm5hbC1lcnJvclwiLENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTjpcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiLElOVkFMSURfSURfVE9LRU46XCJpbnZhbGlkLXVzZXItdG9rZW5cIixUT0tFTl9FWFBJUkVEOlwidXNlci10b2tlbi1leHBpcmVkXCIsVVNFUl9OT1RfRk9VTkQ6XCJ1c2VyLXRva2VuLWV4cGlyZWRcIixDT1JTX1VOU1VQUE9SVEVEOlwiY29ycy11bnN1cHBvcnRlZFwifTtpZihiW2FdKXJldHVybiBuZXcgUShiW2FdKTtiPXtUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVI6XCJ0b28tbWFueS1yZXF1ZXN0c1wiLFdFQUtfUEFTU1dPUkQ6XCJ3ZWFrLXBhc3N3b3JkXCIsXG5PUEVSQVRJT05fTk9UX0FMTE9XRUQ6XCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIn07Zm9yKHZhciBkIGluIGIpaWYoMD09PWEuaW5kZXhPZihkKSlyZXR1cm4gbmV3IFEoYltkXSk7cmV0dXJuIG5ldyBRKFwiaW50ZXJuYWwtZXJyb3JcIil9O3ZhciB1Zz1mdW5jdGlvbihhKXt0aGlzLkc9YX07dWcucHJvdG90eXBlLnZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuR307dWcucHJvdG90eXBlLmxkPWZ1bmN0aW9uKGEpe3RoaXMuRy5zdHlsZT1hO3JldHVybiB0aGlzfTt2YXIgdmc9ZnVuY3Rpb24oYSl7dGhpcy5HPWF8fHt9fTt2Zy5wcm90b3R5cGUudmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5HfTt2Zy5wcm90b3R5cGUubGQ9ZnVuY3Rpb24oYSl7dGhpcy5HLnN0eWxlPWE7cmV0dXJuIHRoaXN9O3ZhciB4Zz1mdW5jdGlvbihhKXt0aGlzLnhlPWE7dGhpcy5oYz1udWxsO3RoaXMuaGU9d2codGhpcyl9LHlnLHpnPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyB2ZztiLkcud2hlcmU9ZG9jdW1lbnQuYm9keTtiLkcudXJsPWEueGU7Yi5HLm1lc3NhZ2VIYW5kbGVyc0ZpbHRlcj1sZihcImdhcGkuaWZyYW1lcy5DUk9TU19PUklHSU5fSUZSQU1FU19GSUxURVJcIik7Yi5HLmF0dHJpYnV0ZXM9Yi5HLmF0dHJpYnV0ZXN8fHt9OyhuZXcgdWcoYi5HLmF0dHJpYnV0ZXMpKS5sZCh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi0xMDBweFwiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCJ9KTtiLkcuZG9udGNsZWFyPSEwO3JldHVybiBifSx3Zz1mdW5jdGlvbihhKXtyZXR1cm4gQWcoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBIKGZ1bmN0aW9uKGIpe2xmKFwiZ2FwaS5pZnJhbWVzLmdldENvbnRleHRcIikoKS5vcGVuKHpnKGEpLnZhbHVlKCksZnVuY3Rpb24oYyl7YS5oYz1jO2EuaGMucmVzdHlsZSh7c2V0SGlkZU9uTGVhdmU6ITF9KTtcbmIoKX0pfSl9KX0sQmc9ZnVuY3Rpb24oYSxiKXthLmhlLnRoZW4oZnVuY3Rpb24oKXthLmhjLnJlZ2lzdGVyKFwiYXV0aEV2ZW50XCIsYixsZihcImdhcGkuaWZyYW1lcy5DUk9TU19PUklHSU5fSUZSQU1FU19GSUxURVJcIikpfSl9LENnPVwiX19pZnJhbWVmY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpLEFnPWZ1bmN0aW9uKCl7cmV0dXJuIHlnP3lnOnlnPW5ldyBIKGZ1bmN0aW9uKGEsYil7dmFyIGM9ZnVuY3Rpb24oKXtsZihcImdhcGkubG9hZFwiKShcImdhcGkuaWZyYW1lc1wiLGZ1bmN0aW9uKCl7YSgpfSl9O2xmKFwiZ2FwaS5pZnJhbWVzLklmcmFtZVwiKT9hKCk6bGYoXCJnYXBpLmxvYWRcIik/YygpOihsW0NnXT1mdW5jdGlvbigpe2xmKFwiZ2FwaS5sb2FkXCIpP2MoKTpiKCl9LFFkKFlkKFwiLy9hcGlzLmdvb2dsZS5jb20vanMvYXBpLmpzP29ubG9hZD1cIitDZyksZnVuY3Rpb24oKXtiKCl9KSl9KX07dmFyIEVnPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuaGE9YTt0aGlzLnU9Yjt0aGlzLlc9YztkPXRoaXMucWE9ZHx8bnVsbDthPSRlKGEsXCIvX18vYXV0aC9pZnJhbWVcIik7TyhhLFwiYXBpS2V5XCIsYik7TyhhLFwiYXBwTmFtZVwiLGMpO2QmJk8oYSxcInZcIixkKTt0aGlzLlVkPWEudG9TdHJpbmcoKTt0aGlzLlZkPW5ldyB4Zyh0aGlzLlVkKTt0aGlzLldiPVtdO0RnKHRoaXMpfSxGZz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsbSl7YT0kZShhLFwiL19fL2F1dGgvaGFuZGxlclwiKTtPKGEsXCJhcGlLZXlcIixiKTtPKGEsXCJhcHBOYW1lXCIsYyk7TyhhLFwiYXV0aFR5cGVcIixkKTtPKGEsXCJwcm92aWRlcklkXCIsZSk7ZiYmZi5sZW5ndGgmJk8oYSxcInNjb3Blc1wiLGYuam9pbihcIixcIikpO2cmJk8oYSxcInJlZGlyZWN0VXJsXCIsZyk7aCYmTyhhLFwiZXZlbnRJZFwiLGgpO20mJk8oYSxcInZcIixtKTtyZXR1cm4gYS50b1N0cmluZygpfSxEZz1mdW5jdGlvbihhKXtCZyhhLlZkLGZ1bmN0aW9uKGIpe3ZhciBjPXt9O1xuaWYoYiYmYi5hdXRoRXZlbnQpe3ZhciBkPSExO2I9Yi5hdXRoRXZlbnR8fHt9O2lmKGIudHlwZSl7aWYoYz1iLmVycm9yKXZhciBlPShjPWIuZXJyb3IpJiYoYy5uYW1lfHxjLmNvZGUpLGM9ZT9uZXcgUShlLnN1YnN0cmluZyg1KSxjLm1lc3NhZ2UpOm51bGw7Yj1uZXcgdWYoYi50eXBlLGIuZXZlbnRJZCxiLnVybFJlc3BvbnNlLGIuc2Vzc2lvbklkLGMpfWVsc2UgYj1udWxsO2ZvcihjPTA7YzxhLldiLmxlbmd0aDtjKyspZD1hLldiW2NdKGIpfHxkO2M9e307Yy5zdGF0dXM9ZD9cIkFDS1wiOlwiRVJST1JcIjtyZXR1cm4gSShjKX1jLnN0YXR1cz1cIkVSUk9SXCI7cmV0dXJuIEkoYyl9KX07RWcucHJvdG90eXBlLnpjPWZ1bmN0aW9uKGEpe3RoaXMuV2IucHVzaChhKX07dmFyIEdnPWZ1bmN0aW9uKGEpe3RoaXMuRWI9YX07R2cucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3ZvaWQgMCE9PWI/dGhpcy5FYi5zZXQoYSxxYyhiKSk6dGhpcy5FYi5yZW1vdmUoYSl9O0dnLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI7dHJ5e2I9dGhpcy5FYi5nZXQoYSl9Y2F0Y2goYyl7cmV0dXJufWlmKG51bGwhPT1iKXRyeXtyZXR1cm4gbmMoYil9Y2F0Y2goYyl7dGhyb3dcIlN0b3JhZ2U6IEludmFsaWQgdmFsdWUgd2FzIGVuY291bnRlcmVkXCI7fX07R2cucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXt0aGlzLkViLnJlbW92ZShhKX07dmFyIEhnPWZ1bmN0aW9uKCl7fTt2YXIgSWc9ZnVuY3Rpb24oKXt9O3IoSWcsSGcpO0lnLnByb3RvdHlwZS53Yj1mdW5jdGlvbigpe3ZhciBhPTA7ZGUodGhpcy5WYSghMCksZnVuY3Rpb24oYil7QWEoYik7YSsrfSk7cmV0dXJuIGF9O3ZhciBKZz1mdW5jdGlvbihhKXt0aGlzLkg9YX07cihKZyxJZyk7dmFyIEtnPWZ1bmN0aW9uKGEpe2lmKCFhLkgpcmV0dXJuITE7dHJ5e3JldHVybiBhLkguc2V0SXRlbShcIl9fc2FrXCIsXCIxXCIpLGEuSC5yZW1vdmVJdGVtKFwiX19zYWtcIiksITB9Y2F0Y2goYil7cmV0dXJuITF9fTtrPUpnLnByb3RvdHlwZTtrLnNldD1mdW5jdGlvbihhLGIpe3RyeXt0aGlzLkguc2V0SXRlbShhLGIpfWNhdGNoKGMpe2lmKDA9PXRoaXMuSC5sZW5ndGgpdGhyb3dcIlN0b3JhZ2UgbWVjaGFuaXNtOiBTdG9yYWdlIGRpc2FibGVkXCI7dGhyb3dcIlN0b3JhZ2UgbWVjaGFuaXNtOiBRdW90YSBleGNlZWRlZFwiO319O2suZ2V0PWZ1bmN0aW9uKGEpe2E9dGhpcy5ILmdldEl0ZW0oYSk7aWYoIW4oYSkmJm51bGwhPT1hKXRocm93XCJTdG9yYWdlIG1lY2hhbmlzbTogSW52YWxpZCB2YWx1ZSB3YXMgZW5jb3VudGVyZWRcIjtyZXR1cm4gYX07ay5yZW1vdmU9ZnVuY3Rpb24oYSl7dGhpcy5ILnJlbW92ZUl0ZW0oYSl9O1xuay53Yj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkgubGVuZ3RofTtrLlZhPWZ1bmN0aW9uKGEpe3ZhciBiPTAsYz10aGlzLkgsZD1uZXcgYmU7ZC5uZXh0PWZ1bmN0aW9uKCl7aWYoYj49Yy5sZW5ndGgpdGhyb3cgYWU7dmFyIGQ9QWEoYy5rZXkoYisrKSk7aWYoYSlyZXR1cm4gZDtkPWMuZ2V0SXRlbShkKTtpZighbihkKSl0aHJvd1wiU3RvcmFnZSBtZWNoYW5pc206IEludmFsaWQgdmFsdWUgd2FzIGVuY291bnRlcmVkXCI7cmV0dXJuIGR9O3JldHVybiBkfTtrLmtleT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ILmtleShhKX07dmFyIExnPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbDt0cnl7YT13aW5kb3cubG9jYWxTdG9yYWdlfHxudWxsfWNhdGNoKGIpe310aGlzLkg9YX07cihMZyxKZyk7dmFyIE1nPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbDt0cnl7YT13aW5kb3cuc2Vzc2lvblN0b3JhZ2V8fG51bGx9Y2F0Y2goYil7fXRoaXMuSD1hfTtyKE1nLEpnKTt2YXIgTmc9XCJGaXJzdCBTZWNvbmQgVGhpcmQgRm91cnRoIEZpZnRoIFNpeHRoIFNldmVudGggRWlnaHRoIE5pbnRoXCIuc3BsaXQoXCIgXCIpLFU9ZnVuY3Rpb24oYSxiKXtyZXR1cm57bmFtZTphfHxcIlwiLFU6XCJhIHZhbGlkIHN0cmluZ1wiLG9wdGlvbmFsOiEhYixWOm59fSxPZz1mdW5jdGlvbihhKXtyZXR1cm57bmFtZTphfHxcIlwiLFU6XCJhIHZhbGlkIG9iamVjdFwiLG9wdGlvbmFsOiExLFY6aGF9fSxQZz1mdW5jdGlvbihhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsVTpcImEgZnVuY3Rpb25cIixvcHRpb25hbDohIWIsVjpwfX0sUWc9ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpcIlwiLFU6XCJudWxsXCIsb3B0aW9uYWw6ITEsVjpkYX19LFJnPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJjcmVkZW50aWFsXCIsVTpcImEgdmFsaWQgY3JlZGVudGlhbFwiLG9wdGlvbmFsOiExLFY6ZnVuY3Rpb24oYSl7cmV0dXJuISghYXx8IWEueGIpfX19LFNnPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJhdXRoUHJvdmlkZXJcIixVOlwiYSB2YWxpZCBBdXRoIHByb3ZpZGVyXCIsXG5vcHRpb25hbDohMSxWOmZ1bmN0aW9uKGEpe3JldHVybiEhKGEmJmEucHJvdmlkZXJJZCYmYS5oYXNPd25Qcm9wZXJ0eSYmYS5oYXNPd25Qcm9wZXJ0eShcImlzT0F1dGhQcm92aWRlclwiKSl9fX0sVGc9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJue25hbWU6Y3x8XCJcIixVOmEuVStcIiBvciBcIitiLlUsb3B0aW9uYWw6ISFkLFY6ZnVuY3Rpb24oYyl7cmV0dXJuIGEuVihjKXx8Yi5WKGMpfX19O3ZhciBWZz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBiKXt2YXIgZD1iW2NdLm5hbWU7YVtkXT1VZyhkLGFbY10sYltjXS5iKX19LFY9ZnVuY3Rpb24oYSxiLGMsZCl7YVtiXT1VZyhiLGMsZCl9LFVnPWZ1bmN0aW9uKGEsYixjKXtpZighYylyZXR1cm4gYjt2YXIgZD1XZyhhKTthPWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxlO2E6e2U9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7dmFyIGg7aD0wO2Zvcih2YXIgbT0hMSxTPTA7UzxjLmxlbmd0aDtTKyspaWYoY1tTXS5vcHRpb25hbCltPSEwO2Vsc2V7aWYobSl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIsXCJBcmd1bWVudCB2YWxpZGF0b3IgZW5jb3VudGVyZWQgYSByZXF1aXJlZCBhcmd1bWVudCBhZnRlciBhbiBvcHRpb25hbCBhcmd1bWVudC5cIik7aCsrfW09Yy5sZW5ndGg7aWYoZS5sZW5ndGg8aHx8bTxlLmxlbmd0aCllPVwiRXhwZWN0ZWQgXCIrKGg9PW0/MT09XG5oP1wiMSBhcmd1bWVudFwiOmgrXCIgYXJndW1lbnRzXCI6aCtcIi1cIittK1wiIGFyZ3VtZW50c1wiKStcIiBidXQgZ290IFwiK2UubGVuZ3RoK1wiLlwiO2Vsc2V7Zm9yKGg9MDtoPGUubGVuZ3RoO2grKylpZihtPWNbaF0ub3B0aW9uYWwmJnZvaWQgMD09PWVbaF0sIWNbaF0uVihlW2hdKSYmIW0pe2U9Y1toXTtpZigwPmh8fGg+PU5nLmxlbmd0aCl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIsXCJBcmd1bWVudCB2YWxpZGF0b3IgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7ZT1OZ1toXStcIiBhcmd1bWVudCBcIisoZS5uYW1lPydcIicrZS5uYW1lKydcIiAnOlwiXCIpK1wibXVzdCBiZSBcIitlLlUrXCIuXCI7YnJlYWsgYX1lPW51bGx9fWlmKGUpdGhyb3cgbmV3IFEoXCJhcmd1bWVudC1lcnJvclwiLGQrXCIgZmFpbGVkOiBcIitlKTtyZXR1cm4gYi5hcHBseSh0aGlzLGEpfTtmb3IodmFyIGUgaW4gYilhW2VdPWJbZV07Zm9yKGUgaW4gYi5wcm90b3R5cGUpYS5wcm90b3R5cGVbZV09XG5iLnByb3RvdHlwZVtlXTtyZXR1cm4gYX0sV2c9ZnVuY3Rpb24oYSl7YT1hLnNwbGl0KFwiLlwiKTtyZXR1cm4gYVthLmxlbmd0aC0xXX07dmFyICRnPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0odGhpcy5xYT1maXJlYmFzZS5TREtfVkVSU0lPTnx8bnVsbCk/a2YodGhpcy5xYSk6bnVsbDt0aGlzLmM9bmV3IFQoYixudWxsLGQpO3RoaXMuYmQ9WGcodGhpcy5jKTt0aGlzLmhhPWE7dGhpcy51PWI7dGhpcy5XPWM7dGhpcy5uYj1bXTt0aGlzLlRjPSExO3RoaXMuemQ9cSh0aGlzLk1kLHRoaXMpO3RoaXMubGI9bmV3IFlnO3RoaXMuZGQ9bmV3IFpnO3RoaXMuVGE9e307dGhpcy5UYS51bmtub3duPXRoaXMubGI7dGhpcy5UYS5zaWduSW5WaWFSZWRpcmVjdD10aGlzLmxiO3RoaXMuVGEubGlua1ZpYVJlZGlyZWN0PXRoaXMubGI7dGhpcy5UYS5zaWduSW5WaWFQb3B1cD10aGlzLmRkO3RoaXMuVGEubGlua1ZpYVBvcHVwPXRoaXMuZGR9LFhnPWZ1bmN0aW9uKGEpe3ZhciBiPXdpbmRvdy5sb2NhdGlvbi5ocmVmO3JldHVybiBhZyhhKS50aGVuKGZ1bmN0aW9uKGEpe2E6e2Zvcih2YXIgZD0oYiBpbnN0YW5jZW9mIE5lP2IuY2xvbmUoKTpcbm5ldyBOZShiLHZvaWQgMCkpLmlhLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY7dmFyIGc9YVtlXTtmPWQ7dmFyIGg9UmMoZyk7aD9mPShmPVJjKGYpKT9oLnRiKGYpOiExOihoPWcuc3BsaXQoXCIuXCIpLmpvaW4oXCJcXFxcLlwiKSxmPShuZXcgUmVnRXhwKFwiXiguKy5cIitoK1wifFwiK2grXCIpJFwiLFwiaVwiKSkudGVzdChmKSk7aWYoZil7YT0hMDticmVhayBhfX1hPSExfWlmKCFhKXRocm93IG5ldyBRKFwidW5hdXRob3JpemVkLWRvbWFpblwiKTt9KX0sYWg9ZnVuY3Rpb24oYSl7YS5UYz0hMDtoZigpLnRoZW4oZnVuY3Rpb24oKXthLlRkPW5ldyBFZyhhLmhhLGEudSxhLlcsYS5xYSk7YS5UZC56YyhhLnpkKX0pfTskZy5wcm90b3R5cGUuc3Vic2NyaWJlPWZ1bmN0aW9uKGEpe0lhKHRoaXMubmIsYSl8fHRoaXMubmIucHVzaChhKTt0aGlzLlRjfHxhaCh0aGlzKX07JGcucHJvdG90eXBlLnVuc3Vic2NyaWJlPWZ1bmN0aW9uKGEpe0xhKHRoaXMubmIsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07XG4kZy5wcm90b3R5cGUuTWQ9ZnVuY3Rpb24oYSl7aWYoIWEpdGhyb3cgbmV3IFEoXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7Zm9yKHZhciBiPSExLGM9MDtjPHRoaXMubmIubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5uYltjXTtpZihkLkVjKGEucGEsYS5zYSkpeyhiPXRoaXMuVGFbYS5wYV0pJiZiLmVkKGEsZCk7Yj0hMDticmVha319YT10aGlzLmxiO2EucWN8fChhLnFjPSEwLGJoKGEsITEsbnVsbCxudWxsKSk7cmV0dXJuIGJ9OyRnLnByb3RvdHlwZS5nZXRSZWRpcmVjdFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxiLmdldFJlZGlyZWN0UmVzdWx0KCl9O1xudmFyIGRoPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIGI/YS5iZC50aGVuKGZ1bmN0aW9uKCl7Y2goZCk7dmFyIGY9RmcoYS5oYSxhLnUsYS5XLGMsZC5wcm92aWRlcklkLGQuTWMoKSxudWxsLGUsYS5xYSk7SGIoKGJ8fHdpbmRvdykubG9jYXRpb24sZik7cmV0dXJuIGJ9KTpzZChuZXcgUShcInBvcHVwLWJsb2NrZWRcIikpfSxlaD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYS5iZC50aGVuKGZ1bmN0aW9uKCl7Y2goYyk7dmFyIGU9RmcoYS5oYSxhLnUsYS5XLGIsYy5wcm92aWRlcklkLGMuTWMoKSx3aW5kb3cubG9jYXRpb24uaHJlZixkLGEucWEpO0hiKHdpbmRvdy5sb2NhdGlvbixlKX0pfSxmaD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgUShcInBvcHVwLWNsb3NlZC1ieS11c2VyXCIpO3JldHVybiBnZihjKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHhlKDNFNCkudGhlbihmdW5jdGlvbigpe2EuQmEoYixudWxsLGUsZCl9KX0pfSxjaD1mdW5jdGlvbihhKXtpZighYS5pc09BdXRoUHJvdmlkZXIpdGhyb3cgbmV3IFEoXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIpO1xufSxnaD17fSxoaD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YitcIjpcIitjO2doW2RdfHwoZ2hbZF09bmV3ICRnKGEsYixjKSk7cmV0dXJuIGdoW2RdfSxZZz1mdW5jdGlvbigpe3RoaXMucmM9dGhpcy5LYj10aGlzLk9hPXRoaXMuVD1udWxsO3RoaXMucWM9ITF9O1lnLnByb3RvdHlwZS5lZD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBzZChuZXcgUShcImludmFsaWQtYXV0aC1ldmVudFwiKSk7dGhpcy5xYz0hMDt2YXIgYz1hLnBhLGQ9YS5zYTtcInVua25vd25cIj09Yz8odGhpcy5UfHxiaCh0aGlzLCExLG51bGwsbnVsbCksYz1JKCkpOmM9YS5EP3RoaXMub2MoYSxiKTpiLlphKGMsZCk/dGhpcy5wYyhhLGIpOnNkKG5ldyBRKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpKTtyZXR1cm4gY307WWcucHJvdG90eXBlLm9jPWZ1bmN0aW9uKGEpe3RoaXMuVHx8YmgodGhpcywhMCxudWxsLGEuZ2V0RXJyb3IoKSk7cmV0dXJuIEkoKX07XG5ZZy5wcm90b3R5cGUucGM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9YS5wYSxlPWIuWmEoZCxhLnNhKSxmPWEuVWEsZz1hLmZjKCksaD1cInNpZ25JblZpYVJlZGlyZWN0XCI9PWR8fFwibGlua1ZpYVJlZGlyZWN0XCI9PWQ7cmV0dXJuIGUoZixnKS50aGVuKGZ1bmN0aW9uKGEpe2MuVHx8YmgoYyxoLGEsbnVsbCl9KS5JKGZ1bmN0aW9uKGEpe2MuVHx8YmgoYyxoLG51bGwsYSl9KX07dmFyIGJoPWZ1bmN0aW9uKGEsYixjLGQpe2I/ZD8oYS5UPWZ1bmN0aW9uKCl7cmV0dXJuIHNkKGQpfSxhLktiJiZhLktiKGQpKTooYS5UPWZ1bmN0aW9uKCl7cmV0dXJuIEkoYyl9LGEuT2EmJmEuT2EoYykpOihhLlQ9ZnVuY3Rpb24oKXtyZXR1cm4gSSh7dXNlcjpudWxsfSl9LGEuT2EmJmEuT2Eoe3VzZXI6bnVsbH0pKTthLk9hPW51bGw7YS5LYj1udWxsfTtcbllnLnByb3RvdHlwZS5nZXRSZWRpcmVjdFJlc3VsdD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5DY3x8KHRoaXMuQ2M9bmV3IEgoZnVuY3Rpb24oYixjKXthLlQ/YS5UKCkudGhlbihiLGMpOihhLk9hPWIsYS5LYj1jLGloKGEpKX0pKTtyZXR1cm4gdGhpcy5DY307dmFyIGloPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBRKFwidGltZW91dFwiKTthLnJjJiZhLnJjLmNhbmNlbCgpO2EucmM9eGUoM0U0KS50aGVuKGZ1bmN0aW9uKCl7YS5UfHxiaChhLCEwLG51bGwsYil9KX0sWmc9ZnVuY3Rpb24oKXt9O1pnLnByb3RvdHlwZS5lZD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBzZChuZXcgUShcImludmFsaWQtYXV0aC1ldmVudFwiKSk7dmFyIGM9YS5wYSxkPWEuc2E7cmV0dXJuIGEuRD90aGlzLm9jKGEsYik6Yi5aYShjLGQpP3RoaXMucGMoYSxiKTpzZChuZXcgUShcImludmFsaWQtYXV0aC1ldmVudFwiKSl9O1xuWmcucHJvdG90eXBlLm9jPWZ1bmN0aW9uKGEsYil7Yi5CYShhLnBhLG51bGwsYS5nZXRFcnJvcigpLGEuc2EpO3JldHVybiBJKCl9O1pnLnByb3RvdHlwZS5wYz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuc2EsZD1hLnBhLGU9Yi5aYShkLGMpLGY9YS5VYSxnPWEuZmMoKTtyZXR1cm4gZShmLGcpLnRoZW4oZnVuY3Rpb24oYSl7Yi5CYShkLGEsbnVsbCxjKX0pLkkoZnVuY3Rpb24oYSl7Yi5CYShkLG51bGwsYSxjKX0pfTt2YXIgamg9ZnVuY3Rpb24oYSl7dGhpcy5jPWE7dGhpcy5FYT10aGlzLmJhPW51bGw7dGhpcy5IYT0wfTtqaC5wcm90b3R5cGUuTj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6dGhpcy5jLnUscmVmcmVzaFRva2VuOnRoaXMuYmEsYWNjZXNzVG9rZW46dGhpcy5FYSxleHBpcmF0aW9uVGltZTp0aGlzLkhhfX07dmFyIGxoPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5pZFRva2VuLGQ9Yi5yZWZyZXNoVG9rZW4sZT1raChiLmV4cGlyZXNJbik7YS5FYT1jO2EuSGE9ZTthLmJhPWR9LGtoPWZ1bmN0aW9uKGEpe3JldHVybiBsYSgpKzFFMypwYXJzZUludChhLDEwKX0sbWg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVGYoYS5jLGIpLnRoZW4oZnVuY3Rpb24oYil7YS5FYT1iLmFjY2Vzc190b2tlbjthLkhhPWtoKGIuZXhwaXJlc19pbik7YS5iYT1iLnJlZnJlc2hfdG9rZW47cmV0dXJue2FjY2Vzc1Rva2VuOmEuRWEsZXhwaXJhdGlvblRpbWU6YS5IYSxyZWZyZXNoVG9rZW46YS5iYX19KX07XG5qaC5wcm90b3R5cGUuZ2V0VG9rZW49ZnVuY3Rpb24oYSl7cmV0dXJuIGF8fCF0aGlzLkVhfHxsYSgpPnRoaXMuSGEtM0U0P3RoaXMuYmE/bWgodGhpcyx7Z3JhbnRfdHlwZTpcInJlZnJlc2hfdG9rZW5cIixyZWZyZXNoX3Rva2VuOnRoaXMuYmF9KTpJKG51bGwpOkkoe2FjY2Vzc1Rva2VuOnRoaXMuRWEsZXhwaXJhdGlvblRpbWU6dGhpcy5IYSxyZWZyZXNoVG9rZW46dGhpcy5iYX0pfTt2YXIgbmg9ZnVuY3Rpb24oYSxiLGMsZCxlKXtvZih0aGlzLHt1aWQ6YSxkaXNwbGF5TmFtZTpkfHxudWxsLHBob3RvVVJMOmV8fG51bGwsZW1haWw6Y3x8bnVsbCxwcm92aWRlcklkOmJ9KX0sb2g9ZnVuY3Rpb24oYSxiKXtNYi5jYWxsKHRoaXMsYSk7Zm9yKHZhciBjIGluIGIpdGhpc1tjXT1iW2NdfTtyKG9oLE1iKTtcbnZhciBXPWZ1bmN0aW9uKGEsYixjKXt0aGlzLk09W107dGhpcy51PWEuYXBpS2V5O3RoaXMuVz1hLmFwcE5hbWU7dGhpcy5oYT1hLmF1dGhEb21haW58fG51bGw7YT1maXJlYmFzZS5TREtfVkVSU0lPTj9rZihmaXJlYmFzZS5TREtfVkVSU0lPTik6bnVsbDt0aGlzLmM9bmV3IFQodGhpcy51LG51bGwsYSk7dGhpcy5vYT1uZXcgamgodGhpcy5jKTtwaCh0aGlzLGIuaWRUb2tlbik7bGgodGhpcy5vYSxiKTtQKHRoaXMsXCJyZWZyZXNoVG9rZW5cIix0aGlzLm9hLmJhKTtxaCh0aGlzLGN8fHt9KTtKLmNhbGwodGhpcyk7dGhpcy5IYj0hMTt0aGlzLmhhJiYodGhpcy5vPWhoKHRoaXMuaGEsdGhpcy51LHRoaXMuVykpO3RoaXMuTmI9W119O3IoVyxKKTtcbnZhciBwaD1mdW5jdGlvbihhLGIpe2EuVmM9YjtQKGEsXCJfbGF0XCIsYil9LHJoPWZ1bmN0aW9uKGEsYil7TGEoYS5OYixmdW5jdGlvbihhKXtyZXR1cm4gYT09Yn0pfSxzaD1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz0wO2M8YS5OYi5sZW5ndGg7YysrKWIucHVzaChhLk5iW2NdKGEpKTtyZXR1cm4gdmQoYikudGhlbihmdW5jdGlvbigpe3JldHVybiBhfSl9LHRoPWZ1bmN0aW9uKGEpe2EubyYmIWEuSGImJihhLkhiPSEwLGEuby5zdWJzY3JpYmUoYSkpfSxxaD1mdW5jdGlvbihhLGIpe29mKGEse3VpZDpiLnVpZCxkaXNwbGF5TmFtZTpiLmRpc3BsYXlOYW1lfHxudWxsLHBob3RvVVJMOmIucGhvdG9VUkx8fG51bGwsZW1haWw6Yi5lbWFpbHx8bnVsbCxlbWFpbFZlcmlmaWVkOmIuZW1haWxWZXJpZmllZHx8ITEsaXNBbm9ueW1vdXM6Yi5pc0Fub255bW91c3x8ITEscHJvdmlkZXJEYXRhOltdfSl9O1AoVy5wcm90b3R5cGUsXCJwcm92aWRlcklkXCIsXCJmaXJlYmFzZVwiKTtcbnZhciB1aD1mdW5jdGlvbigpe30sdmg9ZnVuY3Rpb24oYSl7cmV0dXJuIEkoKS50aGVuKGZ1bmN0aW9uKCl7aWYoYS5FZCl0aHJvdyBuZXcgUShcImFwcC1kZWxldGVkXCIpO30pfSx3aD1mdW5jdGlvbihhKXtyZXR1cm4gRWEoYS5wcm92aWRlckRhdGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEucHJvdmlkZXJJZH0pfSx5aD1mdW5jdGlvbihhLGIpe2ImJih4aChhLGIucHJvdmlkZXJJZCksYS5wcm92aWRlckRhdGEucHVzaChiKSl9LHhoPWZ1bmN0aW9uKGEsYil7TGEoYS5wcm92aWRlckRhdGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEucHJvdmlkZXJJZD09Yn0pfSx6aD1mdW5jdGlvbihhLGIsYyl7KFwidWlkXCIhPWJ8fGMpJiZhLmhhc093blByb3BlcnR5KGIpJiZQKGEsYixjKX07XG5XLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7YiE9YSYmKG9mKHRoaXMse3VpZDphLnVpZCxkaXNwbGF5TmFtZTphLmRpc3BsYXlOYW1lLHBob3RvVVJMOmEucGhvdG9VUkwsZW1haWw6YS5lbWFpbCxlbWFpbFZlcmlmaWVkOmEuZW1haWxWZXJpZmllZCxpc0Fub255bW91czphLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXX0pLHcoYS5wcm92aWRlckRhdGEsZnVuY3Rpb24oYSl7eWgoYixhKX0pLHRoaXMub2E9YS5vYSxQKHRoaXMsXCJyZWZyZXNoVG9rZW5cIix0aGlzLm9hLmJhKSl9O1cucHJvdG90eXBlLnJlbG9hZD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHZoKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gQWgoYSkudGhlbihmdW5jdGlvbigpe3JldHVybiBzaChhKX0pLnRoZW4odWgpfSl9O1xudmFyIEFoPWZ1bmN0aW9uKGEpe3JldHVybiBhLmdldFRva2VuKCkudGhlbihmdW5jdGlvbihiKXt2YXIgYz1hLmlzQW5vbnltb3VzO3JldHVybiBCaChhLGIpLnRoZW4oZnVuY3Rpb24oKXtjfHx6aChhLFwiaXNBbm9ueW1vdXNcIiwhMSk7cmV0dXJuIGJ9KS5JKGZ1bmN0aW9uKGIpe1wiYXV0aC91c2VyLXRva2VuLWV4cGlyZWRcIj09Yi5jb2RlJiYoYS5kaXNwYXRjaEV2ZW50KG5ldyBvaChcInVzZXJEZWxldGVkXCIpKSxDaChhKSk7dGhyb3cgYjt9KX0pfTtXLnByb3RvdHlwZS5nZXRUb2tlbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiB2aCh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGIub2EuZ2V0VG9rZW4oYSl9KS50aGVuKGZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBRKFwiaW50ZXJuYWwtZXJyb3JcIik7YS5hY2Nlc3NUb2tlbiE9Yi5WYyYmKHBoKGIsYS5hY2Nlc3NUb2tlbiksYi5qYSgpKTt6aChiLFwicmVmcmVzaFRva2VuXCIsYS5yZWZyZXNoVG9rZW4pO3JldHVybiBhLmFjY2Vzc1Rva2VufSl9O1xudmFyIERoPWZ1bmN0aW9uKGEsYil7Yi5pZFRva2VuJiZhLlZjIT1iLmlkVG9rZW4mJihsaChhLm9hLGIpLGEuamEoKSxwaChhLGIuaWRUb2tlbikpfTtXLnByb3RvdHlwZS5qYT1mdW5jdGlvbigpe3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgb2goXCJ0b2tlbkNoYW5nZWRcIikpfTt2YXIgQmg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUihhLmMsc2cse2lkVG9rZW46Yn0pLnRoZW4ocShhLmplLGEpKX07XG5XLnByb3RvdHlwZS5qZT1mdW5jdGlvbihhKXthPWEudXNlcnM7aWYoIWF8fCFhLmxlbmd0aCl0aHJvdyBuZXcgUShcImludGVybmFsLWVycm9yXCIpO2E9YVswXTtxaCh0aGlzLHt1aWQ6YS5sb2NhbElkLGRpc3BsYXlOYW1lOmEuZGlzcGxheU5hbWUscGhvdG9VUkw6YS5waG90b1VybCxlbWFpbDphLmVtYWlsLGVtYWlsVmVyaWZpZWQ6ISFhLmVtYWlsVmVyaWZpZWR9KTtmb3IodmFyIGI9RWgoYSksYz0wO2M8Yi5sZW5ndGg7YysrKXloKHRoaXMsYltjXSk7emgodGhpcyxcImlzQW5vbnltb3VzXCIsISh0aGlzLmVtYWlsJiZhLnBhc3N3b3JkSGFzaCkmJiEodGhpcy5wcm92aWRlckRhdGEmJnRoaXMucHJvdmlkZXJEYXRhLmxlbmd0aCkpfTtcbnZhciBFaD1mdW5jdGlvbihhKXtyZXR1cm4oYT1hLnByb3ZpZGVyVXNlckluZm8pJiZhLmxlbmd0aD9FYShhLGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbmgoYS5yYXdJZCxhLnByb3ZpZGVySWQsYS5lbWFpbCxhLmRpc3BsYXlOYW1lLGEucGhvdG9VcmwpfSk6W119O1cucHJvdG90eXBlLnJlYXV0aGVudGljYXRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuZihhLnhiKHRoaXMuYykudGhlbihmdW5jdGlvbihhKXt2YXIgZDthOnt2YXIgZT1hLmlkVG9rZW4uc3BsaXQoXCIuXCIpO2lmKDM9PWUubGVuZ3RoKXtmb3IodmFyIGU9ZVsxXSxmPSg0LWUubGVuZ3RoJTQpJTQsZz0wO2c8ZjtnKyspZSs9XCIuXCI7dHJ5e3ZhciBoPW5jKHViKGUpKTtpZihoLnN1YiYmaC5pc3MmJmguYXVkJiZoLmV4cCl7ZD1uZXcgdmYoaCk7YnJlYWsgYX19Y2F0Y2gobSl7fX1kPW51bGx9aWYoIWR8fGIudWlkIT1kLmJlKXRocm93IG5ldyBRKFwidXNlci1taXNtYXRjaFwiKTtEaChiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtcbnZhciBGaD1mdW5jdGlvbihhLGIpe3JldHVybiBBaChhKS50aGVuKGZ1bmN0aW9uKCl7aWYoSWEod2goYSksYikpcmV0dXJuIHNoKGEpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBuZXcgUShcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCIpO30pfSl9O2s9Vy5wcm90b3R5cGU7ay5saW5rPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuZihGaCh0aGlzLGEucHJvdmlkZXIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5nZXRUb2tlbigpfSkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYS5YYyhiLmMsYyl9KS50aGVuKHEodGhpcy5LYyx0aGlzKSkpfTtrLktjPWZ1bmN0aW9uKGEpe0RoKHRoaXMsYSk7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KX07XG5rLnVwZGF0ZUVtYWlsPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuZih0aGlzLmdldFRva2VuKCkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYi5jLnVwZGF0ZUVtYWlsKGMsYSl9KS50aGVuKGZ1bmN0aW9uKGEpe0RoKGIsYSk7cmV0dXJuIGIucmVsb2FkKCl9KSl9O2sudXBkYXRlUGFzc3dvcmQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5mKHRoaXMuZ2V0VG9rZW4oKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMudXBkYXRlUGFzc3dvcmQoYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7RGgoYixhKTtyZXR1cm4gYi5yZWxvYWQoKX0pKX07XG5rLnVwZGF0ZVByb2ZpbGU9ZnVuY3Rpb24oYSl7aWYodm9pZCAwPT09YS5kaXNwbGF5TmFtZSYmdm9pZCAwPT09YS5waG90b1VSTClyZXR1cm4gdmgodGhpcyk7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5mKHRoaXMuZ2V0VG9rZW4oKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMudXBkYXRlUHJvZmlsZShjLHtkaXNwbGF5TmFtZTphLmRpc3BsYXlOYW1lLHBob3RvVXJsOmEucGhvdG9VUkx9KX0pLnRoZW4oZnVuY3Rpb24oYSl7RGgoYixhKTt6aChiLFwiZGlzcGxheU5hbWVcIixhLmRpc3BsYXlOYW1lfHxudWxsKTt6aChiLFwicGhvdG9VUkxcIixhLnBob3RvVXJsfHxudWxsKTtyZXR1cm4gc2goYil9KS50aGVuKHVoKSl9O1xuay51bmxpbms9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5mKEFoKHRoaXMpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIElhKHdoKGIpLGEpP2lnKGIuYyxjLFthXSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz17fTt3KGEucHJvdmlkZXJVc2VySW5mb3x8W10sZnVuY3Rpb24oYSl7Y1thLnByb3ZpZGVySWRdPSEwfSk7dyh3aChiKSxmdW5jdGlvbihhKXtjW2FdfHx4aChiLGEpfSk7cmV0dXJuIHNoKGIpfSk6c2goYikudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBRKFwibm8tc3VjaC1wcm92aWRlclwiKTt9KX0pKX07a1tcImRlbGV0ZVwiXT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuZih0aGlzLmdldFRva2VuKCkudGhlbihmdW5jdGlvbihiKXtyZXR1cm4gUihhLmMscmcse2lkVG9rZW46Yn0pfSkudGhlbihmdW5jdGlvbigpe2EuZGlzcGF0Y2hFdmVudChuZXcgb2goXCJ1c2VyRGVsZXRlZFwiKSl9KSkudGhlbihmdW5jdGlvbigpe0NoKGEpfSl9O1xuay5FYz1mdW5jdGlvbihhLGIpe3JldHVyblwibGlua1ZpYVBvcHVwXCI9PWEmJih0aGlzLiR8fG51bGwpPT1iJiZ0aGlzLlJ8fFwibGlua1ZpYVJlZGlyZWN0XCI9PWEmJih0aGlzLkpifHxudWxsKT09Yj8hMDohMX07ay5CYT1mdW5jdGlvbihhLGIsYyxkKXtcImxpbmtWaWFQb3B1cFwiPT1hJiZkPT0odGhpcy4kfHxudWxsKSYmKGMmJnRoaXMueGE/dGhpcy54YShjKTpiJiYhYyYmdGhpcy5SJiZ0aGlzLlIoYiksdGhpcy55YSYmKHRoaXMueWEuY2FuY2VsKCksdGhpcy55YT1udWxsKSxkZWxldGUgdGhpcy5SLGRlbGV0ZSB0aGlzLnhhKX07ay5aYT1mdW5jdGlvbihhLGIpe3JldHVyblwibGlua1ZpYVBvcHVwXCI9PWEmJmI9PSh0aGlzLiR8fG51bGwpfHxcImxpbmtWaWFSZWRpcmVjdFwiPT1hJiYodGhpcy5KYnx8bnVsbCk9PWI/cSh0aGlzLkhkLHRoaXMpOm51bGx9O2sudmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51aWQrXCI6OjpcIitNYXRoLmZsb29yKDFFOSpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpfTtcbmsubGlua1dpdGhQb3B1cD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9c2YoYS5wcm92aWRlcklkKSxkPWZmKGMmJmMua2IsYyYmYy5qYiksZT10aGlzLnZiKCksYz1GaCh0aGlzLGEucHJvdmlkZXJJZCkudGhlbihmdW5jdGlvbigpe3JldHVybiBzaChiKX0pLnRoZW4oZnVuY3Rpb24oKXtiLkphKCk7cmV0dXJuIGIuZ2V0VG9rZW4oKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZGgoYi5vLGQsXCJsaW5rVmlhUG9wdXBcIixhLGUpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gbmV3IEgoZnVuY3Rpb24oYyxkKXtiLkJhKFwibGlua1ZpYVBvcHVwXCIsbnVsbCxuZXcgUShcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIpLGIuJHx8bnVsbCk7Yi5SPWM7Yi54YT1kO2IuJD1lO2IueWE9ZmgoYixcImxpbmtWaWFQb3B1cFwiLGEsZSl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZCYmKGR8fHdpbmRvdykuY2xvc2UoKTtyZXR1cm4gYX0pLkkoZnVuY3Rpb24oYSl7ZCYmKGR8fHdpbmRvdykuY2xvc2UoKTt0aHJvdyBhO1xufSk7cmV0dXJuIHRoaXMuZihjKX07ay5saW5rV2l0aFJlZGlyZWN0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsLGQ9dGhpcy52YigpLGU9RmgodGhpcyxhLnByb3ZpZGVySWQpLnRoZW4oZnVuY3Rpb24oKXtiLkphKCk7cmV0dXJuIGIuZ2V0VG9rZW4oKX0pLnRoZW4oZnVuY3Rpb24oKXtiLkpiPWQ7cmV0dXJuIHNoKGIpfSkudGhlbihmdW5jdGlvbihhKXtiLnphJiYoYT1iLnUrXCI6XCIrYi5XLGE9R2goYi56YSxIaCxiLk4oKSxhKSk7cmV0dXJuIGF9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGVoKGIubyxcImxpbmtWaWFSZWRpcmVjdFwiLGEsZCl9KS5JKGZ1bmN0aW9uKGEpe2M9YTtpZihiLnphKXJldHVybiBJaChiLnphLEhoLGIudStcIjpcIitiLlcpO3Rocm93IGM7fSkudGhlbihmdW5jdGlvbigpe2lmKGMpdGhyb3cgYzt9KTtyZXR1cm4gdGhpcy5mKGUpfTtcbmsuSmE9ZnVuY3Rpb24oKXtpZih0aGlzLm8mJnRoaXMuSGIpcmV0dXJuIHRoaXMubztpZih0aGlzLm8mJiF0aGlzLkhiKXRocm93IG5ldyBRKFwiaW50ZXJuYWwtZXJyb3JcIik7dGhyb3cgbmV3IFEoXCJhdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWRcIik7fTtrLkhkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPW51bGwsZT10aGlzLmdldFRva2VuKCkudGhlbihmdW5jdGlvbihkKXtyZXR1cm4gUihjLmMsemYse3JlcXVlc3RVcmk6YSxzZXNzaW9uSWQ6YixpZFRva2VuOmR9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZD1LZihhKTtyZXR1cm4gYy5LYyhhKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJue3VzZXI6YSxjcmVkZW50aWFsOmR9fSk7cmV0dXJuIHRoaXMuZihlKX07XG5rLnNlbmRFbWFpbFZlcmlmaWNhdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuZih0aGlzLmdldFRva2VuKCkudGhlbihmdW5jdGlvbihiKXtyZXR1cm4gYS5jLnNlbmRFbWFpbFZlcmlmaWNhdGlvbihiKX0pLnRoZW4oZnVuY3Rpb24oYil7aWYoYS5lbWFpbCE9YilyZXR1cm4gYS5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXt9KSl9O3ZhciBDaD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEuTS5sZW5ndGg7YisrKWEuTVtiXS5jYW5jZWwoXCJhcHAtZGVsZXRlZFwiKTthLk09W107YS5FZD0hMDtQKGEsXCJyZWZyZXNoVG9rZW5cIixudWxsKTthLm8mJmEuby51bnN1YnNjcmliZShhKX07Vy5wcm90b3R5cGUuZj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuTS5wdXNoKGEpO3lkKGEsZnVuY3Rpb24oKXtLYShiLk0sYSl9KTtyZXR1cm4gYX07XG5XLnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7dmFyIGE9e3VpZDp0aGlzLnVpZCxkaXNwbGF5TmFtZTp0aGlzLmRpc3BsYXlOYW1lLHBob3RvVVJMOnRoaXMucGhvdG9VUkwsZW1haWw6dGhpcy5lbWFpbCxlbWFpbFZlcmlmaWVkOnRoaXMuZW1haWxWZXJpZmllZCxpc0Fub255bW91czp0aGlzLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXSxhcGlLZXk6dGhpcy51LGFwcE5hbWU6dGhpcy5XLGF1dGhEb21haW46dGhpcy5oYSxzdHNUb2tlbk1hbmFnZXI6dGhpcy5vYS5OKCkscmVkaXJlY3RFdmVudElkOnRoaXMuSmJ8fG51bGx9O3codGhpcy5wcm92aWRlckRhdGEsZnVuY3Rpb24oYil7YS5wcm92aWRlckRhdGEucHVzaChwZihiKSl9KTtyZXR1cm4gYX07XG52YXIgSmg9ZnVuY3Rpb24oYSl7aWYoIWEuYXBpS2V5KXJldHVybiBudWxsO3ZhciBiPXthcGlLZXk6YS5hcGlLZXksYXV0aERvbWFpbjphLmF1dGhEb21haW4sYXBwTmFtZTphLmFwcE5hbWV9LGM9e307aWYoYS5zdHNUb2tlbk1hbmFnZXImJmEuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuJiZhLnN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW4mJmEuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lKWMuaWRUb2tlbj1hLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbixjLnJlZnJlc2hUb2tlbj1hLnN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW4sYy5leHBpcmVzSW49KGEuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lLWxhKCkpLzFFMztlbHNlIHJldHVybiBudWxsO3ZhciBkPW5ldyBXKGIsYyxhKTthLnByb3ZpZGVyRGF0YSYmdyhhLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtpZihhKXt2YXIgYj17fTtvZihiLGEpO3loKGQsYil9fSk7YS5yZWRpcmVjdEV2ZW50SWQmJlxuKGQuSmI9YS5yZWRpcmVjdEV2ZW50SWQpO3JldHVybiBkfSxLaD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bmV3IFcoYSxiKTtjJiYoZC56YT1jKTtyZXR1cm4gZC5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGR9KX07dmFyIExoLE1oPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLkRkPWE7dGhpcy5rYz1iO3RoaXMuYWM9Yzt0aGlzLnFkPWQ7dGhpcy5lYT1lO3RoaXMuRGI9e307dGhpcy5tYj1bXTt0aGlzLmliPTA7dGhpcy5XZD1mfHxsLmluZGV4ZWREQn0sTmg9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBIKGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5XZC5vcGVuKGEuRGQsYS5lYSk7ZC5vbmVycm9yPWZ1bmN0aW9uKGEpe2MoRXJyb3IoYS50YXJnZXQuZXJyb3JDb2RlKSl9O2Qub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKGIpe2I9Yi50YXJnZXQucmVzdWx0O3RyeXtiLmNyZWF0ZU9iamVjdFN0b3JlKGEua2Mse2tleVBhdGg6YS5hY30pfWNhdGNoKGQpe2MoZCl9fTtkLm9uc3VjY2Vzcz1mdW5jdGlvbihhKXtiKGEudGFyZ2V0LnJlc3VsdCl9fSl9LE9oPWZ1bmN0aW9uKGEpe2EuU2N8fChhLlNjPU5oKGEpKTtyZXR1cm4gYS5TY30sUGg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5vYmplY3RTdG9yZShhLmtjKX0sXG5RaD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGIudHJhbnNhY3Rpb24oW2Eua2NdLGM/XCJyZWFkd3JpdGVcIjpcInJlYWRvbmx5XCIpfSxSaD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEgoZnVuY3Rpb24oYixjKXthLm9uc3VjY2Vzcz1mdW5jdGlvbihhKXthJiZhLnRhcmdldD9iKGEudGFyZ2V0LnJlc3VsdCk6YigpfTthLm9uZXJyb3I9ZnVuY3Rpb24oYSl7YyhFcnJvcihhLnRhcmdldC5lcnJvckNvZGUpKX19KX07XG5NaC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7dmFyIGM9ITEsZCxlPXRoaXM7cmV0dXJuIHlkKE9oKHRoaXMpLnRoZW4oZnVuY3Rpb24oYil7ZD1iO2I9UGgoZSxRaChlLGQsITApKTtyZXR1cm4gUmgoYi5nZXQoYSkpfSkudGhlbihmdW5jdGlvbihmKXt2YXIgZz1QaChlLFFoKGUsZCwhMCkpO2lmKGYpcmV0dXJuIGYudmFsdWU9YixSaChnLnB1dChmKSk7ZS5pYisrO2M9ITA7Zj17fTtmW2UuYWNdPWE7ZltlLnFkXT1iO3JldHVybiBSaChnLmFkZChmKSl9KS50aGVuKGZ1bmN0aW9uKCl7ZS5EYlthXT1ifSksZnVuY3Rpb24oKXtjJiZlLmliLS19KX07TWgucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBPaCh0aGlzKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBSaChQaChiLFFoKGIsYywhMSkpLmdldChhKSl9KX07XG5NaC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPSExLGM9dGhpcztyZXR1cm4geWQoT2godGhpcykudGhlbihmdW5jdGlvbihkKXtiPSEwO2MuaWIrKztyZXR1cm4gUmgoUGgoYyxRaChjLGQsITApKVtcImRlbGV0ZVwiXShhKSl9KS50aGVuKGZ1bmN0aW9uKCl7ZGVsZXRlIGMuRGJbYV19KSxmdW5jdGlvbigpe2ImJmMuaWItLX0pfTtcbk1oLnByb3RvdHlwZS50ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIE9oKHRoaXMpLnRoZW4oZnVuY3Rpb24oYil7dmFyIGM9UGgoYSxRaChhLGIsITEpKTtyZXR1cm4gYy5nZXRBbGw/UmgoYy5nZXRBbGwoKSk6bmV3IEgoZnVuY3Rpb24oYSxiKXt2YXIgZj1bXSxnPWMub3BlbkN1cnNvcigpO2cub25zdWNjZXNzPWZ1bmN0aW9uKGIpeyhiPWIudGFyZ2V0LnJlc3VsdCk/KGYucHVzaChiLnZhbHVlKSxiW1wiY29udGludWVcIl0oKSk6YShmKX07Zy5vbmVycm9yPWZ1bmN0aW9uKGEpe2IoRXJyb3IoYS50YXJnZXQuZXJyb3JDb2RlKSl9fSl9KS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjPXt9LGQ9W107aWYoMD09YS5pYil7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyljW2JbZF1bYS5hY11dPWJbZF1bYS5xZF07ZD1lZihhLkRiLGMpO2EuRGI9Y31yZXR1cm4gZH0pfTtcbnZhciBTaD1mdW5jdGlvbihhLGIpe0xhKGEubWIsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PWJ9KTswPT1hLm1iLmxlbmd0aCYmYS5PYigpfTtNaC5wcm90b3R5cGUueGM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuT2IoKTt2YXIgYj1mdW5jdGlvbigpe2EubmM9eGUoMUUzKS50aGVuKHEoYS50ZSxhKSkudGhlbihmdW5jdGlvbihiKXswPGIubGVuZ3RoJiZ3KGEubWIsZnVuY3Rpb24oYSl7YShiKX0pfSkudGhlbihiKS5JKGZ1bmN0aW9uKGEpe1wiU1RPUF9FVkVOVFwiIT1hLm1lc3NhZ2UmJmIoKX0pO3JldHVybiBhLm5jfTtiKCl9O01oLnByb3RvdHlwZS5PYj1mdW5jdGlvbigpe3RoaXMubmMmJnRoaXMubmMuY2FuY2VsKFwiU1RPUF9FVkVOVFwiKX07dmFyIEhoPXtuYW1lOlwicmVkaXJlY3RVc2VyXCIsWjohMX0sVGg9e25hbWU6XCJzZXNzaW9uSWRcIixaOiExfSxVaD17bmFtZTpcImF1dGhFdmVudFwiLFo6ITB9LFZoPXtuYW1lOlwiYXV0aFVzZXJcIixaOiEwfSxXaD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuZmU9YTt0aGlzLmpkPWI7dGhpcy5oYj1kO3RoaXMubWU9ZTtpZighS2cobmV3IExnKXx8IUtnKG5ldyBNZykpdGhyb3cgbmV3IFEoXCJ3ZWItc3RvcmFnZS11bnN1cHBvcnRlZFwiKTt0aGlzLks9e307dGhpcy5iYj1jO3RoaXMuWWM9cSh0aGlzLmNlLHRoaXMpO3RoaXMuUmM9cSh0aGlzLlhkLHRoaXMpfSxYaCxZaD1mdW5jdGlvbigpe2lmKCFYaCl7TGh8fChMaD1uZXcgTWgoXCJmaXJlYmFzZUxvY2FsU3RvcmFnZURiXCIsXCJmaXJlYmFzZUxvY2FsU3RvcmFnZVwiLFwiZmJhc2Vfa2V5XCIsXCJ2YWx1ZVwiLDEpKTt2YXIgYT1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7WGg9bmV3IFdoKFwiZmlyZWJhc2VcIixcIjpcIixMaCx5JiYhIXFiJiZcbjExPT1xYnx8L0VkZ2VcXC9cXGQrLy50ZXN0KGFiKSwtMSE9YS5pbmRleE9mKFwic2FmYXJpXCIpJiYtMT09YS5pbmRleE9mKFwiY2hyb21lXCIpJiZ3aW5kb3chPXdpbmRvdy50b3A/ITA6ITEpfXJldHVybiBYaH0sWmg9ZnVuY3Rpb24oYSxiKXt2YXIgYztiPyhhLmNkfHwoYz1uZXcgTGcsYz1LZyhjKT9jOm51bGwsYS5jZD1uZXcgR2coYykpLGM9YS5jZCk6KGEubWR8fChjPW5ldyBNZyxjPUtnKGMpP2M6bnVsbCxhLm1kPW5ldyBHZyhjKSksYz1hLm1kKTtyZXR1cm4gY307V2gucHJvdG90eXBlLnM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5mZSt0aGlzLmpkK2EubmFtZSsoYj90aGlzLmpkK2I6XCJcIil9O1xudmFyICRoPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5oYiYmYi5aP2EuYmIuZ2V0KGEucyhiLGMpKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhJiZhLnZhbHVlfSk6SShaaChhLGIuWikuZ2V0KGEucyhiLGMpKSl9LEloPWZ1bmN0aW9uKGEsYixjKXtpZihhLmhiJiZiLlopcmV0dXJuIGEuYmIucmVtb3ZlKGEucyhiLGMpKTtaaChhLGIuWikucmVtb3ZlKGEucyhiLGMpKTtyZXR1cm4gSSgpfSxHaD1mdW5jdGlvbihhLGIsYyxkKXtpZihhLmhiJiZiLlopcmV0dXJuIGEuYmIuc2V0KGEucyhiLGQpLGMpO1poKGEsYi5aKS5zZXQoYS5zKGIsZCksYyk7cmV0dXJuIEkoKX07V2gucHJvdG90eXBlLmZjPWZ1bmN0aW9uKGEpe3JldHVybiAkaCh0aGlzLFRoLGEpfTtXaC5wcm90b3R5cGUuemM9ZnVuY3Rpb24oYSxiKXthaSh0aGlzLHRoaXMucyhVaCxhKSxiKX07XG52YXIgYmk9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiAkaChhLFZoLGIpLnRoZW4oZnVuY3Rpb24oYSl7YSYmYyYmKGEuYXV0aERvbWFpbj1jKTtyZXR1cm4gSmgoYXx8e30pfSl9LGNpPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gJGgoYSxIaCxiKS50aGVuKGZ1bmN0aW9uKGEpe2EmJmMmJihhLmF1dGhEb21haW49Yyk7cmV0dXJuIEpoKGF8fHt9KX0pfSxhaT1mdW5jdGlvbihhLGIsYyl7VWEoYS5LKSYmYS54YygpO2EuS1tiXXx8KGEuS1tiXT1bXSk7YS5LW2JdLnB1c2goYyl9LGRpPWZ1bmN0aW9uKGEsYixjKXthLktbYl0mJihMYShhLktbYl0sZnVuY3Rpb24oYSl7cmV0dXJuIGE9PWN9KSwwPT1hLktbYl0ubGVuZ3RoJiZkZWxldGUgYS5LW2JdKTtVYShhLkspJiZhLk9iKCl9O2s9V2gucHJvdG90eXBlO1xuay54Yz1mdW5jdGlvbigpe2lmKHRoaXMuaGIpe3ZhciBhPXRoaXMuYmIsYj10aGlzLlJjOzA9PWEubWIubGVuZ3RoJiZhLnhjKCk7YS5tYi5wdXNoKGIpfWVsc2UgWWIod2luZG93LFwic3RvcmFnZVwiLHRoaXMuWWMpfTtrLk9iPWZ1bmN0aW9uKCl7dGhpcy5oYj9TaCh0aGlzLmJiLHRoaXMuUmMpOmhjKHdpbmRvdyxcInN0b3JhZ2VcIix0aGlzLlljKX07ay5jZT1mdW5jdGlvbihhKXt2YXIgYj1hLnViLmtleTtpZih0aGlzLm1lKXt2YXIgYz13aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oYik7YT1hLnViLm5ld1ZhbHVlO2EhPWMmJihhP3dpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShiLGEpOmF8fHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiKSl9dGhpcy5EYyhiKX07ay5YZD1mdW5jdGlvbihhKXt3KGEscSh0aGlzLkRjLHRoaXMpKX07ay5EYz1mdW5jdGlvbihhKXt0aGlzLktbYV0mJncodGhpcy5LW2FdLGZ1bmN0aW9uKGEpe2EoKX0pfTt2YXIgWT1mdW5jdGlvbihhKXt0aGlzLkljPSExO1AodGhpcyxcImFwcFwiLGEpO2lmKFgodGhpcykub3B0aW9ucyYmWCh0aGlzKS5vcHRpb25zLmFwaUtleSlhPWZpcmViYXNlLlNES19WRVJTSU9OP2tmKGZpcmViYXNlLlNES19WRVJTSU9OKTpudWxsLHRoaXMuYz1uZXcgVChYKHRoaXMpLm9wdGlvbnMmJlgodGhpcykub3B0aW9ucy5hcGlLZXksbnVsbCxhKTtlbHNlIHRocm93IG5ldyBRKFwiaW52YWxpZC1hcGkta2V5XCIpO3RoaXMuTT1bXTt0aGlzLlhhPVtdO3RoaXMuZ2U9ZmlyZWJhc2UuSU5URVJOQUwuY3JlYXRlU3Vic2NyaWJlKHEodGhpcy5ZZCx0aGlzKSk7ZWkodGhpcyxudWxsKTt0aGlzLkFhPXRoaXMuZGE9bnVsbDt0cnl7dGhpcy5kYT1ZaCgpLHRoaXMuQWE9WWgoKSx0aGlzLkI9ZmkodGhpcyl9Y2F0Y2goYil7dGhpcy5CPXNkKGIpfXRoaXMuZWI9ITE7dGhpcy5OYz1xKHRoaXMuc2UsdGhpcyk7dGhpcy5vZD1xKHRoaXMuS2EsdGhpcyk7dGhpcy5wZD1xKHRoaXMuUmQsdGhpcyk7XG50aGlzLm5kPXEodGhpcy5RZCx0aGlzKTtnaSh0aGlzKTt0aGlzLklOVEVSTkFMPXt9O3RoaXMuSU5URVJOQUxbXCJkZWxldGVcIl09cSh0aGlzW1wiZGVsZXRlXCJdLHRoaXMpfTtZLnByb3RvdHlwZS5KYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkZkfHxzZChuZXcgUShcImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiKSl9O3ZhciBnaT1mdW5jdGlvbihhKXt2YXIgYj1YKGEpLm9wdGlvbnMuYXV0aERvbWFpbixjPVgoYSkub3B0aW9ucy5hcGlLZXk7YiYmKGEuRmQ9YS5CLnRoZW4oZnVuY3Rpb24oKXthLm89aGgoYixjLFgoYSkubmFtZSk7YS5vLnN1YnNjcmliZShhKTtaKGEpJiZ0aChaKGEpKTthLnNjJiYodGgoYS5zYyksYS5zYz1udWxsKTtyZXR1cm4gYS5vfSkpfTtrPVkucHJvdG90eXBlO1xuay5FYz1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIFwidW5rbm93blwiOmNhc2UgXCJzaWduSW5WaWFSZWRpcmVjdFwiOnJldHVybiEwO2Nhc2UgXCJzaWduSW5WaWFQb3B1cFwiOnJldHVybiB0aGlzLiQ9PWImJiEhdGhpcy5SO2RlZmF1bHQ6cmV0dXJuITF9fTtrLkJhPWZ1bmN0aW9uKGEsYixjLGQpe1wic2lnbkluVmlhUG9wdXBcIj09YSYmdGhpcy4kPT1kJiYoYyYmdGhpcy54YT90aGlzLnhhKGMpOmImJiFjJiZ0aGlzLlImJnRoaXMuUihiKSx0aGlzLnlhJiYodGhpcy55YS5jYW5jZWwoKSx0aGlzLnlhPW51bGwpLGRlbGV0ZSB0aGlzLlIsZGVsZXRlIHRoaXMueGEpfTtrLlphPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJzaWduSW5WaWFSZWRpcmVjdFwiPT1hfHxcInNpZ25JblZpYVBvcHVwXCI9PWEmJnRoaXMuJD09YiYmdGhpcy5SP3EodGhpcy5JZCx0aGlzKTpudWxsfTtcbmsuSWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9bnVsbCxlPXhmKGMuYyx7cmVxdWVzdFVyaTphLHNlc3Npb25JZDpifSkudGhlbihmdW5jdGlvbihhKXtkPUtmKGEpO3JldHVybiBhfSksZj1jLkIudGhlbihmdW5jdGlvbigpe3JldHVybiBlfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gaGkoYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm57dXNlcjpaKGMpLGNyZWRlbnRpYWw6ZH19KTtyZXR1cm4gdGhpcy5mKGYpfTtrLnZiPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IoMUU5Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCl9O1xuay5zaWduSW5XaXRoUG9wdXA9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXNmKGEucHJvdmlkZXJJZCksZD1mZihjJiZjLmtiLGMmJmMuamIpLGU9dGhpcy52YigpLGM9dGhpcy5KYSgpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGRoKGIsZCxcInNpZ25JblZpYVBvcHVwXCIsYSxlKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBIKGZ1bmN0aW9uKGMsZCl7Yi5CYShcInNpZ25JblZpYVBvcHVwXCIsbnVsbCxuZXcgUShcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIpLGIuJCk7Yi5SPWM7Yi54YT1kO2IuJD1lO2IueWE9ZmgoYixcInNpZ25JblZpYVBvcHVwXCIsYSxlKX0pfSkudGhlbihmdW5jdGlvbihhKXtkJiYoZHx8d2luZG93KS5jbG9zZSgpO3JldHVybiBhfSkuSShmdW5jdGlvbihhKXtkJiYoZHx8d2luZG93KS5jbG9zZSgpO3Rocm93IGE7fSk7cmV0dXJuIHRoaXMuZihjKX07XG5rLnNpZ25JbldpdGhSZWRpcmVjdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5KYSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZWgoYi5vLFwic2lnbkluVmlhUmVkaXJlY3RcIixhKX0pO3JldHVybiB0aGlzLmYoYyl9O2suZ2V0UmVkaXJlY3RSZXN1bHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5KYSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5vLmdldFJlZGlyZWN0UmVzdWx0KCl9KTtyZXR1cm4gdGhpcy5mKGIpfTtcbnZhciBoaT1mdW5jdGlvbihhLGIpe3ZhciBjPXt9O2MuYXBpS2V5PVgoYSkub3B0aW9ucy5hcGlLZXk7Yy5hdXRoRG9tYWluPVgoYSkub3B0aW9ucy5hdXRoRG9tYWluO2MuYXBwTmFtZT1YKGEpLm5hbWU7cmV0dXJuIGEuQi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEtoKGMsYixhLkFhKX0pLnRoZW4oZnVuY3Rpb24oYil7aWYoWihhKSYmYi51aWQ9PVooYSkudWlkKXJldHVybiBaKGEpLmNvcHkoYiksYS5LYShiKTtlaShhLGIpO3RoKGIpO3JldHVybiBhLkthKGIpfSkudGhlbihmdW5jdGlvbigpe2EuamEoKX0pfSxlaT1mdW5jdGlvbihhLGIpe1ooYSkmJihyaChaKGEpLGEub2QpLGhjKFooYSksXCJ0b2tlbkNoYW5nZWRcIixhLnBkKSxoYyhaKGEpLFwidXNlckRlbGV0ZWRcIixhLm5kKSk7YiYmKGIuTmIucHVzaChhLm9kKSxZYihiLFwidG9rZW5DaGFuZ2VkXCIsYS5wZCksWWIoYixcInVzZXJEZWxldGVkXCIsYS5uZCkpO1AoYSxcImN1cnJlbnRVc2VyXCIsYil9O1xuWS5wcm90b3R5cGUuc2lnbk91dD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLkIudGhlbihmdW5jdGlvbigpe2lmKCFaKGEpKXJldHVybiBJKCk7ZWkoYSxudWxsKTtyZXR1cm4gSWgoYS5kYSxWaCxpaShhKSkudGhlbihmdW5jdGlvbigpe2EuamEoKX0pfSk7cmV0dXJuIHRoaXMuZihiKX07XG52YXIgamk9ZnVuY3Rpb24oYSl7dmFyIGI9aWkoYSksYz1jaShhLkFhLGIsWChhKS5vcHRpb25zLmF1dGhEb21haW4pLnRoZW4oZnVuY3Rpb24oYyl7aWYoYS5zYz1jKWMuemE9YS5BYTtyZXR1cm4gSWgoYS5BYSxIaCxiKX0pO3JldHVybiBhLmYoYyl9LGZpPWZ1bmN0aW9uKGEpe3ZhciBiPWlpKGEpLGM9WChhKS5vcHRpb25zLmF1dGhEb21haW4sZD15ZChqaShhKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGJpKGEuZGEsYixjKX0pLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGM/KGMuemE9YS5BYSxjLnJlbG9hZCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gY30pLkkoZnVuY3Rpb24oZCl7cmV0dXJuXCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09ZC5jb2RlP2M6SWgoYS5kYSxWaCxiKX0pKTpudWxsfSkudGhlbihmdW5jdGlvbihiKXtlaShhLGJ8fG51bGwpO2EuZWI9ITA7YS5qYSgpfSksZnVuY3Rpb24oKXtpZighYS5JYyl7YS5lYj0hMDt2YXIgYz1hLmRhO2FpKGMsYy5zKFZoLFxuYiksYS5OYyl9fSk7cmV0dXJuIGEuZihkKX07WS5wcm90b3R5cGUuc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBiaSh0aGlzLmRhLGlpKHRoaXMpLFgodGhpcykub3B0aW9ucy5hdXRoRG9tYWluKS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjO2lmKGM9WihhKSYmYil7Yz1aKGEpLnVpZDt2YXIgZD1iLnVpZDtjPXZvaWQgMD09PWN8fG51bGw9PT1jfHxcIlwiPT09Y3x8dm9pZCAwPT09ZHx8bnVsbD09PWR8fFwiXCI9PT1kPyExOmM9PWR9aWYoYylyZXR1cm4gWihhKS5jb3B5KGIpLFooYSkuZ2V0VG9rZW4oKTtlaShhLGIpO2ImJih0aChiKSxiLnphPWEuQWEpO2Euby5zdWJzY3JpYmUoYSk7YS5qYSgpfSl9O1kucHJvdG90eXBlLkthPWZ1bmN0aW9uKGEpe3ZhciBiPWlpKHRoaXMpO3JldHVybiBHaCh0aGlzLmRhLFZoLGEuTigpLGIpfTtZLnByb3RvdHlwZS5SZD1mdW5jdGlvbigpe3RoaXMuZWI9ITA7dGhpcy5qYSgpO3RoaXMuS2EoWih0aGlzKSl9O1kucHJvdG90eXBlLlFkPWZ1bmN0aW9uKCl7dGhpcy5zaWduT3V0KCl9O1xudmFyIGtpPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZihiLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGhpKGEsYil9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFooYSl9KSl9O2s9WS5wcm90b3R5cGU7ay5ZZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuYWRkQXV0aFRva2VuTGlzdGVuZXIoZnVuY3Rpb24oKXthLm5leHQoWihiKSl9KX07ay5vbkF1dGhTdGF0ZUNoYW5nZWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXM7dGhpcy5lYiYmZmlyZWJhc2UuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3AoYSk/YShaKGQpKTpwKGEubmV4dCkmJmEubmV4dChaKGQpKX0pO3JldHVybiB0aGlzLmdlKGEsYixjKX07ay5nZXRUb2tlbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5CLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gWihiKT9aKGIpLmdldFRva2VuKGEpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJue2FjY2Vzc1Rva2VuOmF9fSk6bnVsbH0pO3JldHVybiB0aGlzLmYoYyl9O1xuay5zaWduSW5XaXRoQ3VzdG9tVG9rZW49ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5CLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4ga2koYixSKGIuYyx0Zyx7dG9rZW46YX0pKX0pLnRoZW4oZnVuY3Rpb24oYSl7emgoYSxcImlzQW5vbnltb3VzXCIsITEpO3JldHVybiBiLkthKGEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBaKGIpfSl9O2suc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3JldHVybiB0aGlzLkIudGhlbihmdW5jdGlvbigpe3JldHVybiBraShjLFIoYy5jLEdmLHtlbWFpbDphLHBhc3N3b3JkOmJ9KSl9KX07ay5jcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3JldHVybiB0aGlzLkIudGhlbihmdW5jdGlvbigpe3JldHVybiBraShjLFIoYy5jLHFnLHtlbWFpbDphLHBhc3N3b3JkOmJ9KSl9KX07XG5rLnNpZ25JbldpdGhDcmVkZW50aWFsPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuQi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGtpKGIsYS54YihiLmMpKX0pfTtrLnNpZ25JbkFub255bW91c2x5PWZ1bmN0aW9uKCl7dmFyIGE9Wih0aGlzKSxiPXRoaXM7cmV0dXJuIGEmJmEuaXNBbm9ueW1vdXM/SShhKTp0aGlzLkIudGhlbihmdW5jdGlvbigpe3JldHVybiBraShiLGIuYy5zaWduSW5Bbm9ueW1vdXNseSgpKX0pLnRoZW4oZnVuY3Rpb24oYSl7emgoYSxcImlzQW5vbnltb3VzXCIsITApO3JldHVybiBiLkthKGEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBaKGIpfSl9O3ZhciBpaT1mdW5jdGlvbihhKXtyZXR1cm4gWChhKS5vcHRpb25zLmFwaUtleStcIjpcIitYKGEpLm5hbWV9LFg9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXBwfSxaPWZ1bmN0aW9uKGEpe3JldHVybiBhLmN1cnJlbnRVc2VyfTtrPVkucHJvdG90eXBlO1xuay5qYT1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5YYS5sZW5ndGg7YSsrKWlmKHRoaXMuWGFbYV0pdGhpcy5YYVthXShaKHRoaXMpJiZaKHRoaXMpLl9sYXR8fG51bGwpfTtrLmFkZEF1dGhUb2tlbkxpc3RlbmVyPWZ1bmN0aW9uKGEpe3RoaXMuWGEucHVzaChhKTt2YXIgYj10aGlzO3RoaXMuZWImJnRoaXMuQi50aGVuKGZ1bmN0aW9uKCl7YShaKGIpJiZaKGIpLl9sYXR8fG51bGwpfSl9O2sucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI9ZnVuY3Rpb24oYSl7TGEodGhpcy5YYSxmdW5jdGlvbihiKXtyZXR1cm4gYj09YX0pfTtrW1wiZGVsZXRlXCJdPWZ1bmN0aW9uKCl7dGhpcy5JYz0hMDtmb3IodmFyIGE9MDthPHRoaXMuTS5sZW5ndGg7YSsrKXRoaXMuTVthXS5jYW5jZWwoXCJhcHAtZGVsZXRlZFwiKTt0aGlzLk09W107dGhpcy5kYSYmKGE9dGhpcy5kYSxkaShhLGEucyhWaCxpaSh0aGlzKSksdGhpcy5OYykpO3RoaXMubyYmdGhpcy5vLnVuc3Vic2NyaWJlKHRoaXMpfTtcbmsuZj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuTS5wdXNoKGEpO3lkKGEsZnVuY3Rpb24oKXtLYShiLk0sYSl9KTtyZXR1cm4gYX07ay5mZXRjaFByb3ZpZGVyc0ZvckVtYWlsPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmYoWmYodGhpcy5jLGEpKX07ay52ZXJpZnlQYXNzd29yZFJlc2V0Q29kZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jaGVja0FjdGlvbkNvZGUoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS5kYXRhLmVtYWlsfSl9O2suY29uZmlybVBhc3N3b3JkUmVzZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5mKHRoaXMuYy5jb25maXJtUGFzc3dvcmRSZXNldChhLGIpLnRoZW4oZnVuY3Rpb24oKXt9KSl9O2suY2hlY2tBY3Rpb25Db2RlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmYodGhpcy5jLmNoZWNrQWN0aW9uQ29kZShhKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybntkYXRhOntlbWFpbDphLmVtYWlsfX19KSl9O2suYXBwbHlBY3Rpb25Db2RlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmYodGhpcy5jLmFwcGx5QWN0aW9uQ29kZShhKS50aGVuKGZ1bmN0aW9uKCl7fSkpfTtcbmsuc2VuZFBhc3N3b3JkUmVzZXRFbWFpbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5mKHRoaXMuYy5zZW5kUGFzc3dvcmRSZXNldEVtYWlsKGEpLnRoZW4oZnVuY3Rpb24oKXt9KSl9O1ZnKFkucHJvdG90eXBlLHthcHBseUFjdGlvbkNvZGU6e25hbWU6XCJhcHBseUFjdGlvbkNvZGVcIixiOltVKFwiY29kZVwiKV19LGNoZWNrQWN0aW9uQ29kZTp7bmFtZTpcImNoZWNrQWN0aW9uQ29kZVwiLGI6W1UoXCJjb2RlXCIpXX0sY29uZmlybVBhc3N3b3JkUmVzZXQ6e25hbWU6XCJjb25maXJtUGFzc3dvcmRSZXNldFwiLGI6W1UoXCJjb2RlXCIpLFUoXCJuZXdQYXNzd29yZFwiKV19LGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZDp7bmFtZTpcImNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZFwiLGI6W1UoXCJlbWFpbFwiKSxVKFwicGFzc3dvcmRcIildfSxmZXRjaFByb3ZpZGVyc0ZvckVtYWlsOntuYW1lOlwiZmV0Y2hQcm92aWRlcnNGb3JFbWFpbFwiLGI6W1UoXCJlbWFpbFwiKV19LGdldFJlZGlyZWN0UmVzdWx0OntuYW1lOlwiZ2V0UmVkaXJlY3RSZXN1bHRcIixiOltdfSxvbkF1dGhTdGF0ZUNoYW5nZWQ6e25hbWU6XCJvbkF1dGhTdGF0ZUNoYW5nZWRcIixiOltUZyhPZygpLFBnKCksXCJuZXh0T3JPYnNlcnZlclwiKSxcblBnKFwib3B0X2Vycm9yXCIsITApLFBnKFwib3B0X2NvbXBsZXRlZFwiLCEwKV19LHNlbmRQYXNzd29yZFJlc2V0RW1haWw6e25hbWU6XCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsXCIsYjpbVShcImVtYWlsXCIpXX0sc2lnbkluQW5vbnltb3VzbHk6e25hbWU6XCJzaWduSW5Bbm9ueW1vdXNseVwiLGI6W119LHNpZ25JbldpdGhDcmVkZW50aWFsOntuYW1lOlwic2lnbkluV2l0aENyZWRlbnRpYWxcIixiOltSZygpXX0sc2lnbkluV2l0aEN1c3RvbVRva2VuOntuYW1lOlwic2lnbkluV2l0aEN1c3RvbVRva2VuXCIsYjpbVShcInRva2VuXCIpXX0sc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQ6e25hbWU6XCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZFwiLGI6W1UoXCJlbWFpbFwiKSxVKFwicGFzc3dvcmRcIildfSxzaWduSW5XaXRoUG9wdXA6e25hbWU6XCJzaWduSW5XaXRoUG9wdXBcIixiOltTZygpXX0sc2lnbkluV2l0aFJlZGlyZWN0OntuYW1lOlwic2lnbkluV2l0aFJlZGlyZWN0XCIsYjpbU2coKV19LHNpZ25PdXQ6e25hbWU6XCJzaWduT3V0XCIsXG5iOltdfSx2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZTp7bmFtZTpcInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlXCIsYjpbVShcImNvZGVcIildfX0pO1xuVmcoVy5wcm90b3R5cGUse1wiZGVsZXRlXCI6e25hbWU6XCJkZWxldGVcIixiOltdfSxnZXRUb2tlbjp7bmFtZTpcImdldFRva2VuXCIsYjpbe25hbWU6XCJvcHRfZm9yY2VSZWZyZXNoXCIsVTpcImEgYm9vbGVhblwiLG9wdGlvbmFsOiEwLFY6ZnVuY3Rpb24oYSl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBhfX1dfSxsaW5rOntuYW1lOlwibGlua1wiLGI6W1JnKCldfSxsaW5rV2l0aFBvcHVwOntuYW1lOlwibGlua1dpdGhQb3B1cFwiLGI6W1NnKCldfSxsaW5rV2l0aFJlZGlyZWN0OntuYW1lOlwibGlua1dpdGhSZWRpcmVjdFwiLGI6W1NnKCldfSxyZWF1dGhlbnRpY2F0ZTp7bmFtZTpcInJlYXV0aGVudGljYXRlXCIsYjpbUmcoKV19LHJlbG9hZDp7bmFtZTpcInJlbG9hZFwiLGI6W119LHNlbmRFbWFpbFZlcmlmaWNhdGlvbjp7bmFtZTpcInNlbmRFbWFpbFZlcmlmaWNhdGlvblwiLGI6W119LHVubGluazp7bmFtZTpcInVubGlua1wiLGI6W1UoXCJwcm92aWRlclwiKV19LHVwZGF0ZUVtYWlsOntuYW1lOlwidXBkYXRlRW1haWxcIixcbmI6W1UoXCJlbWFpbFwiKV19LHVwZGF0ZVBhc3N3b3JkOntuYW1lOlwidXBkYXRlUGFzc3dvcmRcIixiOltVKFwicGFzc3dvcmRcIildfSx1cGRhdGVQcm9maWxlOntuYW1lOlwidXBkYXRlUHJvZmlsZVwiLGI6W09nKFwicHJvZmlsZVwiKV19fSk7VmcoSC5wcm90b3R5cGUse0k6e25hbWU6XCJjYXRjaFwifSx0aGVuOntuYW1lOlwidGhlblwifX0pO1YoSWYsXCJjcmVkZW50aWFsXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEZmKGEsYil9LFtVKFwiZW1haWxcIiksVShcInBhc3N3b3JkXCIpXSk7VmcoQmYucHJvdG90eXBlLHthZGRTY29wZTp7bmFtZTpcImFkZFNjb3BlXCIsYjpbVShcInNjb3BlXCIpXX19KTtWKEJmLFwiY3JlZGVudGlhbFwiLEJmLmNyZWRlbnRpYWwsW1RnKFUoKSxPZygpLFwidG9rZW5cIildKTtWZyhDZi5wcm90b3R5cGUse2FkZFNjb3BlOntuYW1lOlwiYWRkU2NvcGVcIixiOltVKFwic2NvcGVcIildfX0pO1YoQ2YsXCJjcmVkZW50aWFsXCIsQ2YuY3JlZGVudGlhbCxbVGcoVSgpLE9nKCksXCJ0b2tlblwiKV0pO1xuVmcoRGYucHJvdG90eXBlLHthZGRTY29wZTp7bmFtZTpcImFkZFNjb3BlXCIsYjpbVShcInNjb3BlXCIpXX19KTtWKERmLFwiY3JlZGVudGlhbFwiLERmLmNyZWRlbnRpYWwsW1RnKFUoKSxUZyhPZygpLFFnKCkpLFwiaWRUb2tlblwiKSxUZyhVKCksUWcoKSxcImFjY2Vzc1Rva2VuXCIsITApXSk7VihFZixcImNyZWRlbnRpYWxcIixFZi5jcmVkZW50aWFsLFtUZyhVKCksT2coKSxcInRva2VuXCIpLFUoXCJzZWNyZXRcIiwhMCldKTtcbihmdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZmlyZWJhc2UmJmZpcmViYXNlLklOVEVSTkFMJiZmaXJlYmFzZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2Upe3ZhciBhPXtBdXRoOlksRXJyb3I6UX07VihhLFwiRW1haWxBdXRoUHJvdmlkZXJcIixJZixbXSk7VihhLFwiRmFjZWJvb2tBdXRoUHJvdmlkZXJcIixCZixbXSk7VihhLFwiR2l0aHViQXV0aFByb3ZpZGVyXCIsQ2YsW10pO1YoYSxcIkdvb2dsZUF1dGhQcm92aWRlclwiLERmLFtdKTtWKGEsXCJUd2l0dGVyQXV0aFByb3ZpZGVyXCIsRWYsW10pO2ZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZShcImF1dGhcIixmdW5jdGlvbihhLGMpe3ZhciBkPW5ldyBZKGEpO2Moe0lOVEVSTkFMOntnZXRUb2tlbjpxKGQuZ2V0VG9rZW4sZCksYWRkQXV0aFRva2VuTGlzdGVuZXI6cShkLmFkZEF1dGhUb2tlbkxpc3RlbmVyLGQpLHJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyOnEoZC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcixkKX19KTtyZXR1cm4gZH0sXG5hKTtmaXJlYmFzZS5JTlRFUk5BTC5yZWdpc3RlckFwcEhvb2soZnVuY3Rpb24oYSxjKXtcImNyZWF0ZVwiPT09YSYmYy5hdXRoKCl9KTtmaXJlYmFzZS5JTlRFUk5BTC5leHRlbmROYW1lc3BhY2Uoe1VzZXI6V30pfWVsc2UgdGhyb3cgRXJyb3IoXCJDYW5ub3QgZmluZCB0aGUgZmlyZWJhc2UgbmFtZXNwYWNlOyBiZSBzdXJlIHRvIGluY2x1ZGUgZmlyZWJhc2UtYXBwLmpzIGJlZm9yZSB0aGlzIGxpYnJhcnkuXCIpO30pKCk7fSkoKTtcbihmdW5jdGlvbigpIHt2YXIgZyxuPXRoaXM7ZnVuY3Rpb24gcChhKXtyZXR1cm4gdm9pZCAwIT09YX1mdW5jdGlvbiBhYSgpe31mdW5jdGlvbiBiYShhKXthLldiPWZ1bmN0aW9uKCl7cmV0dXJuIGEuJGU/YS4kZTphLiRlPW5ldyBhfX1cbmZ1bmN0aW9uIGNhKGEpe3ZhciBiPXR5cGVvZiBhO2lmKFwib2JqZWN0XCI9PWIpaWYoYSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5KXJldHVyblwiYXJyYXlcIjtpZihhIGluc3RhbmNlb2YgT2JqZWN0KXJldHVybiBiO3ZhciBjPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtpZihcIltvYmplY3QgV2luZG93XVwiPT1jKXJldHVyblwib2JqZWN0XCI7aWYoXCJbb2JqZWN0IEFycmF5XVwiPT1jfHxcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGgmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnNwbGljZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwic3BsaWNlXCIpKXJldHVyblwiYXJyYXlcIjtpZihcIltvYmplY3QgRnVuY3Rpb25dXCI9PWN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNhbGwmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpcmV0dXJuXCJmdW5jdGlvblwifWVsc2UgcmV0dXJuXCJudWxsXCI7XG5lbHNlIGlmKFwiZnVuY3Rpb25cIj09YiYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGEuY2FsbClyZXR1cm5cIm9iamVjdFwiO3JldHVybiBifWZ1bmN0aW9uIGRhKGEpe3JldHVyblwiYXJyYXlcIj09Y2EoYSl9ZnVuY3Rpb24gZWEoYSl7dmFyIGI9Y2EoYSk7cmV0dXJuXCJhcnJheVwiPT1ifHxcIm9iamVjdFwiPT1iJiZcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGh9ZnVuY3Rpb24gcShhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYX1mdW5jdGlvbiBmYShhKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYX1mdW5jdGlvbiBnYShhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PWNhKGEpfWZ1bmN0aW9uIGhhKGEpe3ZhciBiPXR5cGVvZiBhO3JldHVyblwib2JqZWN0XCI9PWImJm51bGwhPWF8fFwiZnVuY3Rpb25cIj09Yn1mdW5jdGlvbiBpYShhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIGphKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYyxkKTtyZXR1cm4gYS5hcHBseShiLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHIoYSxiLGMpe3I9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9pYTpqYTtyZXR1cm4gci5hcHBseShudWxsLGFyZ3VtZW50cyl9XG5mdW5jdGlvbiBrYShhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5FZz1iLnByb3RvdHlwZTthLnByb3RvdHlwZT1uZXcgYzthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuQmc9ZnVuY3Rpb24oYSxjLGYpe2Zvcih2YXIgaD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLGs9MjtrPGFyZ3VtZW50cy5sZW5ndGg7aysrKWhbay0yXT1hcmd1bWVudHNba107cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsaCl9fTtmdW5jdGlvbiBsYSgpe3RoaXMuWWE9LTF9O2Z1bmN0aW9uIG1hKCl7dGhpcy5ZYT0tMTt0aGlzLllhPTY0O3RoaXMuTj1bXTt0aGlzLldkPVtdO3RoaXMuSGY9W107dGhpcy56ZD1bXTt0aGlzLnpkWzBdPTEyODtmb3IodmFyIGE9MTthPHRoaXMuWWE7KythKXRoaXMuemRbYV09MDt0aGlzLlBkPXRoaXMuYWM9MDt0aGlzLnJlc2V0KCl9a2EobWEsbGEpO21hLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuTlswXT0xNzMyNTg0MTkzO3RoaXMuTlsxXT00MDIzMjMzNDE3O3RoaXMuTlsyXT0yNTYyMzgzMTAyO3RoaXMuTlszXT0yNzE3MzM4Nzg7dGhpcy5OWzRdPTMyODUzNzc1MjA7dGhpcy5QZD10aGlzLmFjPTB9O1xuZnVuY3Rpb24gbmEoYSxiLGMpe2N8fChjPTApO3ZhciBkPWEuSGY7aWYocShiKSlmb3IodmFyIGU9MDsxNj5lO2UrKylkW2VdPWIuY2hhckNvZGVBdChjKTw8MjR8Yi5jaGFyQ29kZUF0KGMrMSk8PDE2fGIuY2hhckNvZGVBdChjKzIpPDw4fGIuY2hhckNvZGVBdChjKzMpLGMrPTQ7ZWxzZSBmb3IoZT0wOzE2PmU7ZSsrKWRbZV09YltjXTw8MjR8YltjKzFdPDwxNnxiW2MrMl08PDh8YltjKzNdLGMrPTQ7Zm9yKGU9MTY7ODA+ZTtlKyspe3ZhciBmPWRbZS0zXV5kW2UtOF1eZFtlLTE0XV5kW2UtMTZdO2RbZV09KGY8PDF8Zj4+PjMxKSY0Mjk0OTY3Mjk1fWI9YS5OWzBdO2M9YS5OWzFdO2Zvcih2YXIgaD1hLk5bMl0saz1hLk5bM10sbT1hLk5bNF0sbCxlPTA7ODA+ZTtlKyspNDA+ZT8yMD5lPyhmPWteYyYoaF5rKSxsPTE1MTg1MDAyNDkpOihmPWNeaF5rLGw9MTg1OTc3NTM5Myk6NjA+ZT8oZj1jJmh8ayYoY3xoKSxsPTI0MDA5NTk3MDgpOihmPWNeaF5rLGw9MzM5NTQ2OTc4MiksZj0oYjw8XG41fGI+Pj4yNykrZittK2wrZFtlXSY0Mjk0OTY3Mjk1LG09ayxrPWgsaD0oYzw8MzB8Yz4+PjIpJjQyOTQ5NjcyOTUsYz1iLGI9ZjthLk5bMF09YS5OWzBdK2ImNDI5NDk2NzI5NTthLk5bMV09YS5OWzFdK2MmNDI5NDk2NzI5NTthLk5bMl09YS5OWzJdK2gmNDI5NDk2NzI5NTthLk5bM109YS5OWzNdK2smNDI5NDk2NzI5NTthLk5bNF09YS5OWzRdK20mNDI5NDk2NzI5NX1cbm1hLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXtwKGIpfHwoYj1hLmxlbmd0aCk7Zm9yKHZhciBjPWItdGhpcy5ZYSxkPTAsZT10aGlzLldkLGY9dGhpcy5hYztkPGI7KXtpZigwPT1mKWZvcig7ZDw9YzspbmEodGhpcyxhLGQpLGQrPXRoaXMuWWE7aWYocShhKSlmb3IoO2Q8Yjspe2lmKGVbZl09YS5jaGFyQ29kZUF0KGQpLCsrZiwrK2QsZj09dGhpcy5ZYSl7bmEodGhpcyxlKTtmPTA7YnJlYWt9fWVsc2UgZm9yKDtkPGI7KWlmKGVbZl09YVtkXSwrK2YsKytkLGY9PXRoaXMuWWEpe25hKHRoaXMsZSk7Zj0wO2JyZWFrfX10aGlzLmFjPWY7dGhpcy5QZCs9Yn19O2Z1bmN0aW9uIHQoYSxiKXtmb3IodmFyIGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKX1mdW5jdGlvbiBvYShhLGIpe3ZhciBjPXt9LGQ7Zm9yKGQgaW4gYSljW2RdPWIuY2FsbCh2b2lkIDAsYVtkXSxkLGEpO3JldHVybiBjfWZ1bmN0aW9uIHBhKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHFhKGEpe3ZhciBiPTAsYztmb3IoYyBpbiBhKWIrKztyZXR1cm4gYn1mdW5jdGlvbiByYShhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4gYn1mdW5jdGlvbiBzYShhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1hW2RdO3JldHVybiBifWZ1bmN0aW9uIHRhKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWQ7cmV0dXJuIGJ9ZnVuY3Rpb24gdWEoYSxiKXtmb3IodmFyIGMgaW4gYSlpZihhW2NdPT1iKXJldHVybiEwO3JldHVybiExfVxuZnVuY3Rpb24gdmEoYSxiLGMpe2Zvcih2YXIgZCBpbiBhKWlmKGIuY2FsbChjLGFbZF0sZCxhKSlyZXR1cm4gZH1mdW5jdGlvbiB3YShhLGIpe3ZhciBjPXZhKGEsYix2b2lkIDApO3JldHVybiBjJiZhW2NdfWZ1bmN0aW9uIHhhKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHlhKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9O2Z1bmN0aW9uIHphKGEpe2E9U3RyaW5nKGEpO2lmKC9eXFxzKiQvLnRlc3QoYSk/MDovXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZyxcIlwiKSkpdHJ5e3JldHVybiBldmFsKFwiKFwiK2ErXCIpXCIpfWNhdGNoKGIpe310aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBzdHJpbmc6IFwiK2EpO31mdW5jdGlvbiBBYSgpe3RoaXMuRmQ9dm9pZCAwfVxuZnVuY3Rpb24gQmEoYSxiLGMpe3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcInN0cmluZ1wiOkNhKGIsYyk7YnJlYWs7Y2FzZSBcIm51bWJlclwiOmMucHVzaChpc0Zpbml0ZShiKSYmIWlzTmFOKGIpP2I6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKGIpO2JyZWFrO2Nhc2UgXCJ1bmRlZmluZWRcIjpjLnB1c2goXCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjppZihudWxsPT1iKXtjLnB1c2goXCJudWxsXCIpO2JyZWFrfWlmKGRhKGIpKXt2YXIgZD1iLmxlbmd0aDtjLnB1c2goXCJbXCIpO2Zvcih2YXIgZT1cIlwiLGY9MDtmPGQ7ZisrKWMucHVzaChlKSxlPWJbZl0sQmEoYSxhLkZkP2EuRmQuY2FsbChiLFN0cmluZyhmKSxlKTplLGMpLGU9XCIsXCI7Yy5wdXNoKFwiXVwiKTticmVha31jLnB1c2goXCJ7XCIpO2Q9XCJcIjtmb3IoZiBpbiBiKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLGYpJiYoZT1iW2ZdLFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihjLnB1c2goZCksQ2EoZixjKSxcbmMucHVzaChcIjpcIiksQmEoYSxhLkZkP2EuRmQuY2FsbChiLGYsZSk6ZSxjKSxkPVwiLFwiKSk7Yy5wdXNoKFwifVwiKTticmVhaztjYXNlIFwiZnVuY3Rpb25cIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX12YXIgRGE9eydcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFwiL1wiOlwiXFxcXC9cIixcIlxcYlwiOlwiXFxcXGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcclwiOlwiXFxcXHJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sRWE9L1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpPy9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2c6L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBDYShhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShFYSxmdW5jdGlvbihhKXtpZihhIGluIERhKXJldHVybiBEYVthXTt2YXIgYj1hLmNoYXJDb2RlQXQoMCksZT1cIlxcXFx1XCI7MTY+Yj9lKz1cIjAwMFwiOjI1Nj5iP2UrPVwiMDBcIjo0MDk2PmImJihlKz1cIjBcIik7cmV0dXJuIERhW2FdPWUrYi50b1N0cmluZygxNil9KSwnXCInKX07dmFyIHY7YTp7dmFyIEZhPW4ubmF2aWdhdG9yO2lmKEZhKXt2YXIgR2E9RmEudXNlckFnZW50O2lmKEdhKXt2PUdhO2JyZWFrIGF9fXY9XCJcIn07ZnVuY3Rpb24gSGEoYSl7aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxIYSk7ZWxzZXt2YXIgYj1FcnJvcigpLnN0YWNrO2ImJih0aGlzLnN0YWNrPWIpfWEmJih0aGlzLm1lc3NhZ2U9U3RyaW5nKGEpKX1rYShIYSxFcnJvcik7SGEucHJvdG90eXBlLm5hbWU9XCJDdXN0b21FcnJvclwiO3ZhciB3PUFycmF5LnByb3RvdHlwZSxJYT13LmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmluZGV4T2YuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtjPW51bGw9PWM/MDowPmM/TWF0aC5tYXgoMCxhLmxlbmd0aCtjKTpjO2lmKHEoYSkpcmV0dXJuIHEoYikmJjE9PWIubGVuZ3RoP2EuaW5kZXhPZihiLGMpOi0xO2Zvcig7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSmE9dy5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt3LmZvckVhY2guY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1xKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKX0sS2E9dy5maWx0ZXI/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmZpbHRlci5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxoPXEoYSk/XG5hLnNwbGl0KFwiXCIpOmEsaz0wO2s8ZDtrKyspaWYoayBpbiBoKXt2YXIgbT1oW2tdO2IuY2FsbChjLG0sayxhKSYmKGVbZisrXT1tKX1yZXR1cm4gZX0sTGE9dy5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3Lm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9cShhKT9hLnNwbGl0KFwiXCIpOmEsaD0wO2g8ZDtoKyspaCBpbiBmJiYoZVtoXT1iLmNhbGwoYyxmW2hdLGgsYSkpO3JldHVybiBlfSxNYT13LnJlZHVjZT9mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9W10sZj0xLGg9YXJndW1lbnRzLmxlbmd0aDtmPGg7ZisrKWUucHVzaChhcmd1bWVudHNbZl0pO2QmJihlWzBdPXIoYixkKSk7cmV0dXJuIHcucmVkdWNlLmFwcGx5KGEsZSl9OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWM7SmEoYSxmdW5jdGlvbihjLGgpe2U9Yi5jYWxsKGQsZSxjLGgsYSl9KTtyZXR1cm4gZX0sTmE9dy5ldmVyeT9mdW5jdGlvbihhLGIsXG5jKXtyZXR1cm4gdy5ldmVyeS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXEoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmIWIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMTtyZXR1cm4hMH07ZnVuY3Rpb24gT2EoYSxiKXt2YXIgYz1QYShhLGIsdm9pZCAwKTtyZXR1cm4gMD5jP251bGw6cShhKT9hLmNoYXJBdChjKTphW2NdfWZ1bmN0aW9uIFBhKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1xKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4gZjtyZXR1cm4tMX1mdW5jdGlvbiBRYShhLGIpe3ZhciBjPUlhKGEsYik7MDw9YyYmdy5zcGxpY2UuY2FsbChhLGMsMSl9ZnVuY3Rpb24gUmEoYSxiLGMpe3JldHVybiAyPj1hcmd1bWVudHMubGVuZ3RoP3cuc2xpY2UuY2FsbChhLGIpOncuc2xpY2UuY2FsbChhLGIsYyl9XG5mdW5jdGlvbiBTYShhLGIpe2Euc29ydChifHxUYSl9ZnVuY3Rpb24gVGEoYSxiKXtyZXR1cm4gYT5iPzE6YTxiPy0xOjB9O3ZhciBVYT0tMSE9di5pbmRleE9mKFwiT3BlcmFcIil8fC0xIT12LmluZGV4T2YoXCJPUFJcIiksVmE9LTEhPXYuaW5kZXhPZihcIlRyaWRlbnRcIil8fC0xIT12LmluZGV4T2YoXCJNU0lFXCIpLFdhPS0xIT12LmluZGV4T2YoXCJHZWNrb1wiKSYmLTE9PXYudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhKC0xIT12LmluZGV4T2YoXCJUcmlkZW50XCIpfHwtMSE9di5pbmRleE9mKFwiTVNJRVwiKSksWGE9LTEhPXYudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpO1xuKGZ1bmN0aW9uKCl7dmFyIGE9XCJcIixiO2lmKFVhJiZuLm9wZXJhKXJldHVybiBhPW4ub3BlcmEudmVyc2lvbixnYShhKT9hKCk6YTtXYT9iPS9ydlxcOihbXlxcKTtdKykoXFwpfDspLzpWYT9iPS9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS86WGEmJihiPS9XZWJLaXRcXC8oXFxTKykvKTtiJiYoYT0oYT1iLmV4ZWModikpP2FbMV06XCJcIik7cmV0dXJuIFZhJiYoYj0oYj1uLmRvY3VtZW50KT9iLmRvY3VtZW50TW9kZTp2b2lkIDAsYj5wYXJzZUZsb2F0KGEpKT9TdHJpbmcoYik6YX0pKCk7dmFyIFlhPW51bGwsWmE9bnVsbCwkYT1udWxsO2Z1bmN0aW9uIGFiKGEsYil7aWYoIWVhKGEpKXRocm93IEVycm9yKFwiZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyXCIpO2JiKCk7Zm9yKHZhciBjPWI/WmE6WWEsZD1bXSxlPTA7ZTxhLmxlbmd0aDtlKz0zKXt2YXIgZj1hW2VdLGg9ZSsxPGEubGVuZ3RoLGs9aD9hW2UrMV06MCxtPWUrMjxhLmxlbmd0aCxsPW0/YVtlKzJdOjAsdT1mPj4yLGY9KGYmMyk8PDR8az4+NCxrPShrJjE1KTw8MnxsPj42LGw9bCY2MzttfHwobD02NCxofHwoaz02NCkpO2QucHVzaChjW3VdLGNbZl0sY1trXSxjW2xdKX1yZXR1cm4gZC5qb2luKFwiXCIpfVxuZnVuY3Rpb24gYmIoKXtpZighWWEpe1lhPXt9O1phPXt9OyRhPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKVlhW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksWmFbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fLlwiLmNoYXJBdChhKSwkYVtaYVthXV09YSw2Mjw9YSYmKCRhW1wiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSldPWEpfX07ZnVuY3Rpb24gY2IoYSl7bi5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYTt9LDApfXZhciBkYjtcbmZ1bmN0aW9uIGViKCl7dmFyIGE9bi5NZXNzYWdlQ2hhbm5lbDtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucG9zdE1lc3NhZ2UmJndpbmRvdy5hZGRFdmVudExpc3RlbmVyJiYtMT09di5pbmRleE9mKFwiUHJlc3RvXCIpJiYoYT1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2Euc3JjPVwiXCI7ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGEpO3ZhciBiPWEuY29udGVudFdpbmRvdyxhPWIuZG9jdW1lbnQ7YS5vcGVuKCk7YS53cml0ZShcIlwiKTthLmNsb3NlKCk7dmFyIGM9XCJjYWxsSW1tZWRpYXRlXCIrTWF0aC5yYW5kb20oKSxkPVwiZmlsZTpcIj09Yi5sb2NhdGlvbi5wcm90b2NvbD9cIipcIjpiLmxvY2F0aW9uLnByb3RvY29sK1wiLy9cIitiLmxvY2F0aW9uLmhvc3QsYT1yKGZ1bmN0aW9uKGEpe2lmKChcIipcIj09ZHx8YS5vcmlnaW49PVxuZCkmJmEuZGF0YT09Yyl0aGlzLnBvcnQxLm9ubWVzc2FnZSgpfSx0aGlzKTtiLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYSwhMSk7dGhpcy5wb3J0MT17fTt0aGlzLnBvcnQyPXtwb3N0TWVzc2FnZTpmdW5jdGlvbigpe2IucG9zdE1lc3NhZ2UoYyxkKX19fSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYtMT09di5pbmRleE9mKFwiVHJpZGVudFwiKSYmLTE9PXYuaW5kZXhPZihcIk1TSUVcIikpe3ZhciBiPW5ldyBhLGM9e30sZD1jO2IucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKCl7aWYocChjLm5leHQpKXtjPWMubmV4dDt2YXIgYT1jLktlO2MuS2U9bnVsbDthKCl9fTtyZXR1cm4gZnVuY3Rpb24oYSl7ZC5uZXh0PXtLZTphfTtkPWQubmV4dDtiLnBvcnQyLnBvc3RNZXNzYWdlKDApfX1yZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT9mdW5jdGlvbihhKXt2YXIgYj1cbmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPW51bGw7YSgpO2E9bnVsbH07ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXtuLnNldFRpbWVvdXQoYSwwKX19O2Z1bmN0aW9uIGZiKGEsYil7Z2J8fGhiKCk7aWJ8fChnYigpLGliPSEwKTtqYi5wdXNoKG5ldyBrYihhLGIpKX12YXIgZ2I7ZnVuY3Rpb24gaGIoKXtpZihuLlByb21pc2UmJm4uUHJvbWlzZS5yZXNvbHZlKXt2YXIgYT1uLlByb21pc2UucmVzb2x2ZSgpO2diPWZ1bmN0aW9uKCl7YS50aGVuKGxiKX19ZWxzZSBnYj1mdW5jdGlvbigpe3ZhciBhPWxiOyFnYShuLnNldEltbWVkaWF0ZSl8fG4uV2luZG93JiZuLldpbmRvdy5wcm90b3R5cGUmJm4uV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PW4uc2V0SW1tZWRpYXRlPyhkYnx8KGRiPWViKCkpLGRiKGEpKTpuLnNldEltbWVkaWF0ZShhKX19dmFyIGliPSExLGpiPVtdO1tdLnB1c2goZnVuY3Rpb24oKXtpYj0hMTtqYj1bXX0pO1xuZnVuY3Rpb24gbGIoKXtmb3IoO2piLmxlbmd0aDspe3ZhciBhPWpiO2piPVtdO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3RyeXtjLlVmLmNhbGwoYy5zY29wZSl9Y2F0Y2goZCl7Y2IoZCl9fX1pYj0hMX1mdW5jdGlvbiBrYihhLGIpe3RoaXMuVWY9YTt0aGlzLnNjb3BlPWJ9O2Z1bmN0aW9uIG1iKGEsYil7dGhpcy5MPW5iO3RoaXMuc2Y9dm9pZCAwO3RoaXMuQ2E9dGhpcy5IYT1udWxsO3RoaXMuamQ9dGhpcy5iZT0hMTtpZihhPT1vYilwYih0aGlzLHFiLGIpO2Vsc2UgdHJ5e3ZhciBjPXRoaXM7YS5jYWxsKGIsZnVuY3Rpb24oYSl7cGIoYyxxYixhKX0sZnVuY3Rpb24oYSl7aWYoIShhIGluc3RhbmNlb2YgcmIpKXRyeXtpZihhIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgYTt0aHJvdyBFcnJvcihcIlByb21pc2UgcmVqZWN0ZWQuXCIpO31jYXRjaChiKXt9cGIoYyxzYixhKX0pfWNhdGNoKGQpe3BiKHRoaXMsc2IsZCl9fXZhciBuYj0wLHFiPTIsc2I9MztmdW5jdGlvbiBvYigpe31tYi5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRiKHRoaXMsZ2EoYSk/YTpudWxsLGdhKGIpP2I6bnVsbCxjKX07bWIucHJvdG90eXBlLnRoZW49bWIucHJvdG90eXBlLnRoZW47bWIucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlPSEwO2c9bWIucHJvdG90eXBlO1xuZy54Zz1mdW5jdGlvbihhLGIpe3JldHVybiB0Yih0aGlzLG51bGwsYSxiKX07Zy5jYW5jZWw9ZnVuY3Rpb24oYSl7dGhpcy5MPT1uYiYmZmIoZnVuY3Rpb24oKXt2YXIgYj1uZXcgcmIoYSk7dWIodGhpcyxiKX0sdGhpcyl9O2Z1bmN0aW9uIHViKGEsYil7aWYoYS5MPT1uYilpZihhLkhhKXt2YXIgYz1hLkhhO2lmKGMuQ2Epe2Zvcih2YXIgZD0wLGU9LTEsZj0wLGg7aD1jLkNhW2ZdO2YrKylpZihoPWgubSlpZihkKyssaD09YSYmKGU9ZiksMDw9ZSYmMTxkKWJyZWFrOzA8PWUmJihjLkw9PW5iJiYxPT1kP3ViKGMsYik6KGQ9Yy5DYS5zcGxpY2UoZSwxKVswXSx2YihjLGQsc2IsYikpKX1hLkhhPW51bGx9ZWxzZSBwYihhLHNiLGIpfWZ1bmN0aW9uIHdiKGEsYil7YS5DYSYmYS5DYS5sZW5ndGh8fGEuTCE9cWImJmEuTCE9c2J8fHhiKGEpO2EuQ2F8fChhLkNhPVtdKTthLkNhLnB1c2goYil9XG5mdW5jdGlvbiB0YihhLGIsYyxkKXt2YXIgZT17bTpudWxsLGZmOm51bGwsaGY6bnVsbH07ZS5tPW5ldyBtYihmdW5jdGlvbihhLGgpe2UuZmY9Yj9mdW5jdGlvbihjKXt0cnl7dmFyIGU9Yi5jYWxsKGQsYyk7YShlKX1jYXRjaChsKXtoKGwpfX06YTtlLmhmPWM/ZnVuY3Rpb24oYil7dHJ5e3ZhciBlPWMuY2FsbChkLGIpOyFwKGUpJiZiIGluc3RhbmNlb2YgcmI/aChiKTphKGUpfWNhdGNoKGwpe2gobCl9fTpofSk7ZS5tLkhhPWE7d2IoYSxlKTtyZXR1cm4gZS5tfWcuQWY9ZnVuY3Rpb24oYSl7dGhpcy5MPW5iO3BiKHRoaXMscWIsYSl9O2cuQmY9ZnVuY3Rpb24oYSl7dGhpcy5MPW5iO3BiKHRoaXMsc2IsYSl9O1xuZnVuY3Rpb24gcGIoYSxiLGMpe2lmKGEuTD09bmIpe2lmKGE9PWMpYj1zYixjPW5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZlwiKTtlbHNle3ZhciBkO2lmKGMpdHJ5e2Q9ISFjLiRnb29nX1RoZW5hYmxlfWNhdGNoKGUpe2Q9ITF9ZWxzZSBkPSExO2lmKGQpe2EuTD0xO2MudGhlbihhLkFmLGEuQmYsYSk7cmV0dXJufWlmKGhhKGMpKXRyeXt2YXIgZj1jLnRoZW47aWYoZ2EoZikpe3liKGEsYyxmKTtyZXR1cm59fWNhdGNoKGgpe2I9c2IsYz1ofX1hLnNmPWM7YS5MPWI7YS5IYT1udWxsO3hiKGEpO2IhPXNifHxjIGluc3RhbmNlb2YgcmJ8fHpiKGEsYyl9fWZ1bmN0aW9uIHliKGEsYixjKXtmdW5jdGlvbiBkKGIpe2Z8fChmPSEwLGEuQmYoYikpfWZ1bmN0aW9uIGUoYil7Znx8KGY9ITAsYS5BZihiKSl9YS5MPTE7dmFyIGY9ITE7dHJ5e2MuY2FsbChiLGUsZCl9Y2F0Y2goaCl7ZChoKX19XG5mdW5jdGlvbiB4YihhKXthLmJlfHwoYS5iZT0hMCxmYihhLlNmLGEpKX1nLlNmPWZ1bmN0aW9uKCl7Zm9yKDt0aGlzLkNhJiZ0aGlzLkNhLmxlbmd0aDspe3ZhciBhPXRoaXMuQ2E7dGhpcy5DYT1udWxsO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXZiKHRoaXMsYVtiXSx0aGlzLkwsdGhpcy5zZil9dGhpcy5iZT0hMX07ZnVuY3Rpb24gdmIoYSxiLGMsZCl7aWYoYz09cWIpYi5mZihkKTtlbHNle2lmKGIubSlmb3IoO2EmJmEuamQ7YT1hLkhhKWEuamQ9ITE7Yi5oZihkKX19ZnVuY3Rpb24gemIoYSxiKXthLmpkPSEwO2ZiKGZ1bmN0aW9uKCl7YS5qZCYmQWIuY2FsbChudWxsLGIpfSl9dmFyIEFiPWNiO2Z1bmN0aW9uIHJiKGEpe0hhLmNhbGwodGhpcyxhKX1rYShyYixIYSk7cmIucHJvdG90eXBlLm5hbWU9XCJjYW5jZWxcIjtmdW5jdGlvbiBCYihhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX1mdW5jdGlvbiB4KGEsYil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYikpcmV0dXJuIGFbYl19ZnVuY3Rpb24gQ2IoYSxiKXtmb3IodmFyIGMgaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSYmYihjLGFbY10pfTtmdW5jdGlvbiB5KGEsYixjLGQpe3ZhciBlO2Q8Yj9lPVwiYXQgbGVhc3QgXCIrYjpkPmMmJihlPTA9PT1jP1wibm9uZVwiOlwibm8gbW9yZSB0aGFuIFwiK2MpO2lmKGUpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCBcIitkKygxPT09ZD9cIiBhcmd1bWVudC5cIjpcIiBhcmd1bWVudHMuXCIpK1wiIEV4cGVjdHMgXCIrZStcIi5cIik7fWZ1bmN0aW9uIERiKGEsYixjKXt2YXIgZD1cIlwiO3N3aXRjaChiKXtjYXNlIDE6ZD1jP1wiZmlyc3RcIjpcIkZpcnN0XCI7YnJlYWs7Y2FzZSAyOmQ9Yz9cInNlY29uZFwiOlwiU2Vjb25kXCI7YnJlYWs7Y2FzZSAzOmQ9Yz9cInRoaXJkXCI6XCJUaGlyZFwiO2JyZWFrO2Nhc2UgNDpkPWM/XCJmb3VydGhcIjpcIkZvdXJ0aFwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJlcnJvclByZWZpeCBjYWxsZWQgd2l0aCBhcmd1bWVudE51bWJlciA+IDQuICBOZWVkIHRvIHVwZGF0ZSBpdD9cIik7fXJldHVybiBhPWErXCIgZmFpbGVkOiBcIisoZCtcIiBhcmd1bWVudCBcIil9XG5mdW5jdGlvbiBBKGEsYixjLGQpe2lmKCghZHx8cChjKSkmJiFnYShjKSl0aHJvdyBFcnJvcihEYihhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uXCIpO31mdW5jdGlvbiBFYihhLGIsYyl7aWYocChjKSYmKCFoYShjKXx8bnVsbD09PWMpKXRocm93IEVycm9yKERiKGEsYiwhMCkrXCJtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuXCIpO307ZnVuY3Rpb24gRmIoYSl7dmFyIGI9W107Q2IoYSxmdW5jdGlvbihhLGQpe2RhKGQpP0phKGQsZnVuY3Rpb24oZCl7Yi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZCkpfSk6Yi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZCkpfSk7cmV0dXJuIGIubGVuZ3RoP1wiJlwiK2Iuam9pbihcIiZcIik6XCJcIn07dmFyIEdiPW4uUHJvbWlzZXx8bWI7bWIucHJvdG90eXBlW1wiY2F0Y2hcIl09bWIucHJvdG90eXBlLnhnO2Z1bmN0aW9uIEhiKCl7dmFyIGE9dGhpczt0aGlzLnJlamVjdD10aGlzLnJlc29sdmU9bnVsbDt0aGlzLnJhPW5ldyBHYihmdW5jdGlvbihiLGMpe2EucmVzb2x2ZT1iO2EucmVqZWN0PWN9KX1mdW5jdGlvbiBJYihhLGIpe3JldHVybiBmdW5jdGlvbihjLGQpe2M/YS5yZWplY3QoYyk6YS5yZXNvbHZlKGQpO2dhKGIpJiYoSmIoYS5yYSksMT09PWIubGVuZ3RoP2IoYyk6YihjLGQpKX19ZnVuY3Rpb24gSmIoYSl7YS50aGVuKHZvaWQgMCxhYSl9O2Z1bmN0aW9uIEtiKGEsYil7aWYoIWEpdGhyb3cgTGIoYik7fWZ1bmN0aW9uIExiKGEpe3JldHVybiBFcnJvcihcIkZpcmViYXNlIERhdGFiYXNlIChcIitmaXJlYmFzZS5TREtfVkVSU0lPTitcIikgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogXCIrYSl9O2Z1bmN0aW9uIE1iKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hLmNoYXJDb2RlQXQoZCk7NTUyOTY8PWUmJjU2MzE5Pj1lJiYoZS09NTUyOTYsZCsrLEtiKGQ8YS5sZW5ndGgsXCJTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS5cIiksZT02NTUzNisoZTw8MTApKyhhLmNoYXJDb2RlQXQoZCktNTYzMjApKTsxMjg+ZT9iW2MrK109ZTooMjA0OD5lP2JbYysrXT1lPj42fDE5MjooNjU1MzY+ZT9iW2MrK109ZT4+MTJ8MjI0OihiW2MrK109ZT4+MTh8MjQwLGJbYysrXT1lPj4xMiY2M3wxMjgpLGJbYysrXT1lPj42JjYzfDEyOCksYltjKytdPWUmNjN8MTI4KX1yZXR1cm4gYn1mdW5jdGlvbiBOYihhKXtmb3IodmFyIGI9MCxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWEuY2hhckNvZGVBdChjKTsxMjg+ZD9iKys6MjA0OD5kP2IrPTI6NTUyOTY8PWQmJjU2MzE5Pj1kPyhiKz00LGMrKyk6Yis9M31yZXR1cm4gYn07ZnVuY3Rpb24gT2IoYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZwKEpTT04ucGFyc2UpP0pTT04ucGFyc2UoYSk6emEoYSl9ZnVuY3Rpb24gQihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIEpTT04mJnAoSlNPTi5zdHJpbmdpZnkpKWE9SlNPTi5zdHJpbmdpZnkoYSk7ZWxzZXt2YXIgYj1bXTtCYShuZXcgQWEsYSxiKTthPWIuam9pbihcIlwiKX1yZXR1cm4gYX07ZnVuY3Rpb24gUGIoYSxiKXt0aGlzLmNvbW1pdHRlZD1hO3RoaXMuc25hcHNob3Q9Yn07ZnVuY3Rpb24gUWIoYSl7dGhpcy5zZT1hO3RoaXMuQmQ9W107dGhpcy5SYj0wO3RoaXMuWWQ9LTE7dGhpcy5HYj1udWxsfWZ1bmN0aW9uIFJiKGEsYixjKXthLllkPWI7YS5HYj1jO2EuWWQ8YS5SYiYmKGEuR2IoKSxhLkdiPW51bGwpfWZ1bmN0aW9uIFNiKGEsYixjKXtmb3IoYS5CZFtiXT1jO2EuQmRbYS5SYl07KXt2YXIgZD1hLkJkW2EuUmJdO2RlbGV0ZSBhLkJkW2EuUmJdO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGRbZV0pe3ZhciBmPWE7VGIoZnVuY3Rpb24oKXtmLnNlKGRbZV0pfSl9aWYoYS5SYj09PWEuWWQpe2EuR2ImJihjbGVhclRpbWVvdXQoYS5HYiksYS5HYigpLGEuR2I9bnVsbCk7YnJlYWt9YS5SYisrfX07ZnVuY3Rpb24gVWIoKXt0aGlzLnFjPXt9fVViLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtudWxsPT1iP2RlbGV0ZSB0aGlzLnFjW2FdOnRoaXMucWNbYV09Yn07VWIucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gQmIodGhpcy5xYyxhKT90aGlzLnFjW2FdOm51bGx9O1ViLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMucWNbYV19O1ViLnByb3RvdHlwZS5hZj0hMDtmdW5jdGlvbiBWYihhKXt0aGlzLnZjPWE7dGhpcy5DZD1cImZpcmViYXNlOlwifWc9VmIucHJvdG90eXBlO2cuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj90aGlzLnZjLnJlbW92ZUl0ZW0odGhpcy5DZCthKTp0aGlzLnZjLnNldEl0ZW0odGhpcy5DZCthLEIoYikpfTtnLmdldD1mdW5jdGlvbihhKXthPXRoaXMudmMuZ2V0SXRlbSh0aGlzLkNkK2EpO3JldHVybiBudWxsPT1hP251bGw6T2IoYSl9O2cucmVtb3ZlPWZ1bmN0aW9uKGEpe3RoaXMudmMucmVtb3ZlSXRlbSh0aGlzLkNkK2EpfTtnLmFmPSExO2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52Yy50b1N0cmluZygpfTtmdW5jdGlvbiBXYihhKXt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93W2FdKXt2YXIgYj13aW5kb3dbYV07Yi5zZXRJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIixcImNhY2hlXCIpO2IucmVtb3ZlSXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIpO3JldHVybiBuZXcgVmIoYil9fWNhdGNoKGMpe31yZXR1cm4gbmV3IFVifXZhciBYYj1XYihcImxvY2FsU3RvcmFnZVwiKSxZYj1XYihcInNlc3Npb25TdG9yYWdlXCIpO2Z1bmN0aW9uIFpiKGEsYixjKXt0aGlzLnR5cGU9JGI7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLkphPWN9WmIucHJvdG90eXBlLk5jPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBaYih0aGlzLnNvdXJjZSxDLHRoaXMuSmEuUihhKSk6bmV3IFpiKHRoaXMuc291cmNlLEQodGhpcy5wYXRoKSx0aGlzLkphKX07WmIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG92ZXJ3cml0ZTogXCIrdGhpcy5KYS50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBhYyhhLGIpe3RoaXMudHlwZT1iYzt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1ifWFjLnByb3RvdHlwZS5OYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBhYyh0aGlzLnNvdXJjZSxDKTpuZXcgYWModGhpcy5zb3VyY2UsRCh0aGlzLnBhdGgpKX07YWMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGxpc3Rlbl9jb21wbGV0ZSlcIn07ZnVuY3Rpb24gY2MoYSl7dGhpcy5HZT1hfWNjLnByb3RvdHlwZS5nZXRUb2tlbj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5HZS5JTlRFUk5BTC5nZXRUb2tlbihhKS50aGVuKG51bGwsZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwiYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWRcIj09PWEuY29kZT8oRShcIkdvdCBhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCBlcnJvci4gIFRyZWF0aW5nIGFzIG51bGwgdG9rZW4uXCIpLG51bGwpOlByb21pc2UucmVqZWN0KGEpfSl9O2Z1bmN0aW9uIGRjKGEsYil7YS5HZS5JTlRFUk5BTC5hZGRBdXRoVG9rZW5MaXN0ZW5lcihiKX07ZnVuY3Rpb24gZWMoKXt0aGlzLkpkPUZ9ZWMucHJvdG90eXBlLmo9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuSmQuUShhKX07ZWMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuSmQudG9TdHJpbmcoKX07ZnVuY3Rpb24gZmMoYSxiLGMsZCxlKXt0aGlzLmhvc3Q9YS50b0xvd2VyQ2FzZSgpO3RoaXMuZG9tYWluPXRoaXMuaG9zdC5zdWJzdHIodGhpcy5ob3N0LmluZGV4T2YoXCIuXCIpKzEpO3RoaXMuU2M9Yjt0aGlzLm9lPWM7dGhpcy56Zz1kO3RoaXMubGY9ZXx8XCJcIjt0aGlzLmJiPVhiLmdldChcImhvc3Q6XCIrYSl8fHRoaXMuaG9zdH1mdW5jdGlvbiBnYyhhLGIpe2IhPT1hLmJiJiYoYS5iYj1iLFwicy1cIj09PWEuYmIuc3Vic3RyKDAsMikmJlhiLnNldChcImhvc3Q6XCIrYS5ob3N0LGEuYmIpKX1cbmZ1bmN0aW9uIGhjKGEsYixjKXtIKFwic3RyaW5nXCI9PT10eXBlb2YgYixcInR5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nXCIpO0goXCJvYmplY3RcIj09PXR5cGVvZiBjLFwidHlwZW9mIHBhcmFtcyBtdXN0ID09IG9iamVjdFwiKTtpZihcIndlYnNvY2tldFwiPT09YiliPShhLlNjP1wid3NzOi8vXCI6XCJ3czovL1wiKSthLmJiK1wiLy53cz9cIjtlbHNlIGlmKFwibG9uZ19wb2xsaW5nXCI9PT1iKWI9KGEuU2M/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSthLmJiK1wiLy5scD9cIjtlbHNlIHRocm93IEVycm9yKFwiVW5rbm93biBjb25uZWN0aW9uIHR5cGU6IFwiK2IpO2EuaG9zdCE9PWEuYmImJihjLm5zPWEub2UpO3ZhciBkPVtdO3QoYyxmdW5jdGlvbihhLGIpe2QucHVzaChiK1wiPVwiK2EpfSk7cmV0dXJuIGIrZC5qb2luKFwiJlwiKX1cbmZjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPSh0aGlzLlNjP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5ob3N0O3RoaXMubGYmJihhKz1cIjxcIit0aGlzLmxmK1wiPlwiKTtyZXR1cm4gYX07ZnVuY3Rpb24gaWMoYSxiKXt0aGlzLnhmPXt9O3RoaXMuVmM9bmV3IGpjKGEpO3RoaXMudmE9Yjt2YXIgYz0xRTQrMkU0Kk1hdGgucmFuZG9tKCk7c2V0VGltZW91dChyKHRoaXMucGYsdGhpcyksTWF0aC5mbG9vcihjKSl9aWMucHJvdG90eXBlLnBmPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5WYy5nZXQoKSxiPXt9LGM9ITEsZDtmb3IoZCBpbiBhKTA8YVtkXSYmQmIodGhpcy54ZixkKSYmKGJbZF09YVtkXSxjPSEwKTtjJiZ0aGlzLnZhLnhlKGIpO3NldFRpbWVvdXQocih0aGlzLnBmLHRoaXMpLE1hdGguZmxvb3IoNkU1Kk1hdGgucmFuZG9tKCkpKX07ZnVuY3Rpb24ga2MoKXt0aGlzLnVjPXt9fWZ1bmN0aW9uIGxjKGEsYixjKXtwKGMpfHwoYz0xKTtCYihhLnVjLGIpfHwoYS51Y1tiXT0wKTthLnVjW2JdKz1jfWtjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4geWEodGhpcy51Yyl9O2Z1bmN0aW9uIGpjKGEpe3RoaXMuTGY9YTt0aGlzLnJkPW51bGx9amMucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuTGYuZ2V0KCksYj15YShhKTtpZih0aGlzLnJkKWZvcih2YXIgYyBpbiB0aGlzLnJkKWJbY10tPXRoaXMucmRbY107dGhpcy5yZD1hO3JldHVybiBifTt2YXIgbWM9e30sbmM9e307ZnVuY3Rpb24gb2MoYSl7YT1hLnRvU3RyaW5nKCk7bWNbYV18fChtY1thXT1uZXcga2MpO3JldHVybiBtY1thXX1mdW5jdGlvbiBwYyhhLGIpe3ZhciBjPWEudG9TdHJpbmcoKTtuY1tjXXx8KG5jW2NdPWIoKSk7cmV0dXJuIG5jW2NdfTtmdW5jdGlvbiBxYygpe3RoaXMud2I9W119ZnVuY3Rpb24gcmMoYSxiKXtmb3IodmFyIGM9bnVsbCxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF0sZj1lLlpiKCk7bnVsbD09PWN8fGYuY2EoYy5aYigpKXx8KGEud2IucHVzaChjKSxjPW51bGwpO251bGw9PT1jJiYoYz1uZXcgc2MoZikpO2MuYWRkKGUpfWMmJmEud2IucHVzaChjKX1mdW5jdGlvbiB0YyhhLGIsYyl7cmMoYSxjKTt1YyhhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNhKGIpfSl9ZnVuY3Rpb24gdmMoYSxiLGMpe3JjKGEsYyk7dWMoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5jb250YWlucyhiKXx8Yi5jb250YWlucyhhKX0pfVxuZnVuY3Rpb24gdWMoYSxiKXtmb3IodmFyIGM9ITAsZD0wO2Q8YS53Yi5sZW5ndGg7ZCsrKXt2YXIgZT1hLndiW2RdO2lmKGUpaWYoZT1lLlpiKCksYihlKSl7Zm9yKHZhciBlPWEud2JbZF0sZj0wO2Y8ZS5oZC5sZW5ndGg7ZisrKXt2YXIgaD1lLmhkW2ZdO2lmKG51bGwhPT1oKXtlLmhkW2ZdPW51bGw7dmFyIGs9aC5VYigpO3djJiZFKFwiZXZlbnQ6IFwiK2gudG9TdHJpbmcoKSk7VGIoayl9fWEud2JbZF09bnVsbH1lbHNlIGM9ITF9YyYmKGEud2I9W10pfWZ1bmN0aW9uIHNjKGEpe3RoaXMucWE9YTt0aGlzLmhkPVtdfXNjLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5oZC5wdXNoKGEpfTtzYy5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xYX07ZnVuY3Rpb24geGMoYSxiLGMsZCl7dGhpcy5hZT1iO3RoaXMuTWQ9Yzt0aGlzLkRkPWQ7dGhpcy5nZD1hfXhjLnByb3RvdHlwZS5aYj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuTWQueGIoKTtyZXR1cm5cInZhbHVlXCI9PT10aGlzLmdkP2EucGF0aDphLmdldFBhcmVudCgpLnBhdGh9O3hjLnByb3RvdHlwZS5nZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdkfTt4Yy5wcm90b3R5cGUuVWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZS5VYih0aGlzKX07eGMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWmIoKS50b1N0cmluZygpK1wiOlwiK3RoaXMuZ2QrXCI6XCIrQih0aGlzLk1kLlNlKCkpfTtmdW5jdGlvbiB5YyhhLGIsYyl7dGhpcy5hZT1hO3RoaXMuZXJyb3I9Yjt0aGlzLnBhdGg9Y315Yy5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRofTt5Yy5wcm90b3R5cGUuZ2U9ZnVuY3Rpb24oKXtyZXR1cm5cImNhbmNlbFwifTtcbnljLnByb3RvdHlwZS5VYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFlLlViKHRoaXMpfTt5Yy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkrXCI6Y2FuY2VsXCJ9O2Z1bmN0aW9uIHpjKCl7fXpjLnByb3RvdHlwZS5WZT1mdW5jdGlvbigpe3JldHVybiBudWxsfTt6Yy5wcm90b3R5cGUuZmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07dmFyIEFjPW5ldyB6YztmdW5jdGlvbiBCYyhhLGIsYyl7dGhpcy5FZj1hO3RoaXMuTmE9Yjt0aGlzLnlkPWN9QmMucHJvdG90eXBlLlZlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuTmEuTztpZihDYyhiLGEpKXJldHVybiBiLmooKS5SKGEpO2I9bnVsbCE9dGhpcy55ZD9uZXcgRGModGhpcy55ZCwhMCwhMSk6dGhpcy5OYS51KCk7cmV0dXJuIHRoaXMuRWYucmMoYSxiKX07QmMucHJvdG90eXBlLmZlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsIT10aGlzLnlkP3RoaXMueWQ6RWModGhpcy5OYSk7YT10aGlzLkVmLlhkKGQsYiwxLGMsYSk7cmV0dXJuIDA9PT1hLmxlbmd0aD9udWxsOmFbMF19O2Z1bmN0aW9uIEkoYSxiLGMsZCl7dGhpcy50eXBlPWE7dGhpcy5NYT1iO3RoaXMuWmE9Yzt0aGlzLnBlPWQ7dGhpcy5EZD12b2lkIDB9ZnVuY3Rpb24gRmMoYSl7cmV0dXJuIG5ldyBJKEdjLGEpfXZhciBHYz1cInZhbHVlXCI7ZnVuY3Rpb24gRGMoYSxiLGMpe3RoaXMuQT1hO3RoaXMuZWE9Yjt0aGlzLlRiPWN9ZnVuY3Rpb24gSGMoYSl7cmV0dXJuIGEuZWF9ZnVuY3Rpb24gSWMoYSl7cmV0dXJuIGEuVGJ9ZnVuY3Rpb24gSmMoYSxiKXtyZXR1cm4gYi5lKCk/YS5lYSYmIWEuVGI6Q2MoYSxKKGIpKX1mdW5jdGlvbiBDYyhhLGIpe3JldHVybiBhLmVhJiYhYS5UYnx8YS5BLkZhKGIpfURjLnByb3RvdHlwZS5qPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQX07ZnVuY3Rpb24gS2MoYSxiKXtyZXR1cm4gTGMoYS5uYW1lLGIubmFtZSl9ZnVuY3Rpb24gTWMoYSxiKXtyZXR1cm4gTGMoYSxiKX07ZnVuY3Rpb24gSyhhLGIpe3RoaXMubmFtZT1hO3RoaXMuUz1ifWZ1bmN0aW9uIE5jKGEsYil7cmV0dXJuIG5ldyBLKGEsYil9O2Z1bmN0aW9uIE9jKGEsYil7cmV0dXJuIGEmJlwib2JqZWN0XCI9PT10eXBlb2YgYT8oSChcIi5zdlwiaW4gYSxcIlVuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzXCIpLGJbYVtcIi5zdlwiXV0pOmF9ZnVuY3Rpb24gUGMoYSxiKXt2YXIgYz1uZXcgUWM7UmMoYSxuZXcgTChcIlwiKSxmdW5jdGlvbihhLGUpe1NjKGMsYSxUYyhlLGIpKX0pO3JldHVybiBjfWZ1bmN0aW9uIFRjKGEsYil7dmFyIGM9YS5DKCkuSCgpLGM9T2MoYyxiKSxkO2lmKGEuSigpKXt2YXIgZT1PYyhhLkVhKCksYik7cmV0dXJuIGUhPT1hLkVhKCl8fGMhPT1hLkMoKS5IKCk/bmV3IFVjKGUsTShjKSk6YX1kPWE7YyE9PWEuQygpLkgoKSYmKGQ9ZC5nYShuZXcgVWMoYykpKTthLlAoTixmdW5jdGlvbihhLGMpe3ZhciBlPVRjKGMsYik7ZSE9PWMmJihkPWQuVShhLGUpKX0pO3JldHVybiBkfTt2YXIgVmM9ZnVuY3Rpb24oKXt2YXIgYT0xO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhKyt9fSgpLEg9S2IsV2M9TGI7XG5mdW5jdGlvbiBYYyhhKXt0cnl7dmFyIGI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhdG9iKWI9YXRvYihhKTtlbHNle2JiKCk7Zm9yKHZhciBjPSRhLGQ9W10sZT0wO2U8YS5sZW5ndGg7KXt2YXIgZj1jW2EuY2hhckF0KGUrKyldLGg9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTowOysrZTt2YXIgaz1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTt2YXIgbT1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTtpZihudWxsPT1mfHxudWxsPT1ofHxudWxsPT1rfHxudWxsPT1tKXRocm93IEVycm9yKCk7ZC5wdXNoKGY8PDJ8aD4+NCk7NjQhPWsmJihkLnB1c2goaDw8NCYyNDB8az4+MiksNjQhPW0mJmQucHVzaChrPDw2JjE5MnxtKSl9aWYoODE5Mj5kLmxlbmd0aCliPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxkKTtlbHNle2E9XCJcIjtmb3IoYz0wO2M8ZC5sZW5ndGg7Yys9ODE5MilhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsUmEoZCxjLFxuYys4MTkyKSk7Yj1hfX1yZXR1cm4gYn1jYXRjaChsKXtFKFwiYmFzZTY0RGVjb2RlIGZhaWxlZDogXCIsbCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gWWMoYSl7dmFyIGI9TWIoYSk7YT1uZXcgbWE7YS51cGRhdGUoYik7dmFyIGI9W10sYz04KmEuUGQ7NTY+YS5hYz9hLnVwZGF0ZShhLnpkLDU2LWEuYWMpOmEudXBkYXRlKGEuemQsYS5ZYS0oYS5hYy01NikpO2Zvcih2YXIgZD1hLllhLTE7NTY8PWQ7ZC0tKWEuV2RbZF09YyYyNTUsYy89MjU2O25hKGEsYS5XZCk7Zm9yKGQ9Yz0wOzU+ZDtkKyspZm9yKHZhciBlPTI0OzA8PWU7ZS09OCliW2NdPWEuTltkXT4+ZSYyNTUsKytjO3JldHVybiBhYihiKX1cbmZ1bmN0aW9uIFpjKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWI9ZWEoYXJndW1lbnRzW2NdKT9iK1pjLmFwcGx5KG51bGwsYXJndW1lbnRzW2NdKTpcIm9iamVjdFwiPT09dHlwZW9mIGFyZ3VtZW50c1tjXT9iK0IoYXJndW1lbnRzW2NdKTpiK2FyZ3VtZW50c1tjXSxiKz1cIiBcIjtyZXR1cm4gYn12YXIgd2M9bnVsbCwkYz0hMDtcbmZ1bmN0aW9uIGFkKGEsYil7S2IoIWJ8fCEwPT09YXx8ITE9PT1hLFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpOyEwPT09YT8oXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnNvbGUubG9nP3djPXIoY29uc29sZS5sb2csY29uc29sZSk6XCJvYmplY3RcIj09PXR5cGVvZiBjb25zb2xlLmxvZyYmKHdjPWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKGEpfSkpLGImJlliLnNldChcImxvZ2dpbmdfZW5hYmxlZFwiLCEwKSk6Z2EoYSk/d2M9YTood2M9bnVsbCxZYi5yZW1vdmUoXCJsb2dnaW5nX2VuYWJsZWRcIikpfWZ1bmN0aW9uIEUoYSl7ITA9PT0kYyYmKCRjPSExLG51bGw9PT13YyYmITA9PT1ZYi5nZXQoXCJsb2dnaW5nX2VuYWJsZWRcIikmJmFkKCEwKSk7aWYod2Mpe3ZhciBiPVpjLmFwcGx5KG51bGwsYXJndW1lbnRzKTt3YyhiKX19XG5mdW5jdGlvbiBiZChhKXtyZXR1cm4gZnVuY3Rpb24oKXtFKGEsYXJndW1lbnRzKX19ZnVuY3Rpb24gY2QoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiBcIitaYy5hcHBseShudWxsLGFyZ3VtZW50cyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlLmVycm9yP2NvbnNvbGUuZXJyb3IoYik6Y29uc29sZS5sb2coYil9fWZ1bmN0aW9uIGRkKGEpe3ZhciBiPVpjLmFwcGx5KG51bGwsYXJndW1lbnRzKTt0aHJvdyBFcnJvcihcIkZJUkVCQVNFIEZBVEFMIEVSUk9SOiBcIitiKTt9ZnVuY3Rpb24gTyhhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBiPVwiRklSRUJBU0UgV0FSTklORzogXCIrWmMuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS53YXJuP2NvbnNvbGUud2FybihiKTpjb25zb2xlLmxvZyhiKX19XG5mdW5jdGlvbiBlZChhKXt2YXIgYixjLGQsZSxmLGg9YTtmPWM9YT1iPVwiXCI7ZD0hMDtlPVwiaHR0cHNcIjtpZihxKGgpKXt2YXIgaz1oLmluZGV4T2YoXCIvL1wiKTswPD1rJiYoZT1oLnN1YnN0cmluZygwLGstMSksaD1oLnN1YnN0cmluZyhrKzIpKTtrPWguaW5kZXhPZihcIi9cIik7LTE9PT1rJiYoaz1oLmxlbmd0aCk7Yj1oLnN1YnN0cmluZygwLGspO2Y9XCJcIjtoPWguc3Vic3RyaW5nKGspLnNwbGl0KFwiL1wiKTtmb3Ioaz0wO2s8aC5sZW5ndGg7aysrKWlmKDA8aFtrXS5sZW5ndGgpe3ZhciBtPWhba107dHJ5e209ZGVjb2RlVVJJQ29tcG9uZW50KG0ucmVwbGFjZSgvXFwrL2csXCIgXCIpKX1jYXRjaChsKXt9Zis9XCIvXCIrbX1oPWIuc3BsaXQoXCIuXCIpOzM9PT1oLmxlbmd0aD8oYT1oWzFdLGM9aFswXS50b0xvd2VyQ2FzZSgpKToyPT09aC5sZW5ndGgmJihhPWhbMF0pO2s9Yi5pbmRleE9mKFwiOlwiKTswPD1rJiYoZD1cImh0dHBzXCI9PT1lfHxcIndzc1wiPT09ZSl9XCJmaXJlYmFzZVwiPT09YSYmZGQoYitcIiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkXCIpO1xuYyYmXCJ1bmRlZmluZWRcIiE9Y3x8ZGQoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2R8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmTyhcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO3JldHVybntrYzpuZXcgZmMoYixkLGMsXCJ3c1wiPT09ZXx8XCJ3c3NcIj09PWUpLHBhdGg6bmV3IEwoZil9fWZ1bmN0aW9uIGZkKGEpe3JldHVybiBmYShhKSYmKGEhPWF8fGE9PU51bWJlci5QT1NJVElWRV9JTkZJTklUWXx8YT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKX1cbmZ1bmN0aW9uIGdkKGEpe2lmKFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUpYSgpO2Vsc2V7dmFyIGI9ITEsYz1mdW5jdGlvbigpe2RvY3VtZW50LmJvZHk/Ynx8KGI9ITAsYSgpKTpzZXRUaW1lb3V0KGMsTWF0aC5mbG9vcigxMCkpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGMsITEpKTpkb2N1bWVudC5hdHRhY2hFdmVudCYmKGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZjKCl9KSx3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixjKSl9fVxuZnVuY3Rpb24gTGMoYSxiKXtpZihhPT09YilyZXR1cm4gMDtpZihcIltNSU5fTkFNRV1cIj09PWF8fFwiW01BWF9OQU1FXVwiPT09YilyZXR1cm4tMTtpZihcIltNSU5fTkFNRV1cIj09PWJ8fFwiW01BWF9OQU1FXVwiPT09YSlyZXR1cm4gMTt2YXIgYz1oZChhKSxkPWhkKGIpO3JldHVybiBudWxsIT09Yz9udWxsIT09ZD8wPT1jLWQ/YS5sZW5ndGgtYi5sZW5ndGg6Yy1kOi0xOm51bGwhPT1kPzE6YTxiPy0xOjF9ZnVuY3Rpb24gaWQoYSxiKXtpZihiJiZhIGluIGIpcmV0dXJuIGJbYV07dGhyb3cgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGtleSAoXCIrYStcIikgaW4gb2JqZWN0OiBcIitCKGIpKTt9XG5mdW5jdGlvbiBqZChhKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiBCKGEpO3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSliLnB1c2goYyk7Yi5zb3J0KCk7Yz1cIntcIjtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKykwIT09ZCYmKGMrPVwiLFwiKSxjKz1CKGJbZF0pLGMrPVwiOlwiLGMrPWpkKGFbYltkXV0pO3JldHVybiBjK1wifVwifWZ1bmN0aW9uIGtkKGEsYil7aWYoYS5sZW5ndGg8PWIpcmV0dXJuW2FdO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKz1iKWQrYj5hP2MucHVzaChhLnN1YnN0cmluZyhkLGEubGVuZ3RoKSk6Yy5wdXNoKGEuc3Vic3RyaW5nKGQsZCtiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gbGQoYSxiKXtpZihkYShhKSlmb3IodmFyIGM9MDtjPGEubGVuZ3RoOysrYyliKGMsYVtjXSk7ZWxzZSB0KGEsYil9XG5mdW5jdGlvbiBtZChhKXtIKCFmZChhKSxcIkludmFsaWQgSlNPTiBudW1iZXJcIik7dmFyIGIsYyxkLGU7MD09PWE/KGQ9Yz0wLGI9LUluZmluaXR5PT09MS9hPzE6MCk6KGI9MD5hLGE9TWF0aC5hYnMoYSksYT49TWF0aC5wb3coMiwtMTAyMik/KGQ9TWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLkxOMiksMTAyMyksYz1kKzEwMjMsZD1NYXRoLnJvdW5kKGEqTWF0aC5wb3coMiw1Mi1kKS1NYXRoLnBvdygyLDUyKSkpOihjPTAsZD1NYXRoLnJvdW5kKGEvTWF0aC5wb3coMiwtMTA3NCkpKSk7ZT1bXTtmb3IoYT01MjthOy0tYSllLnB1c2goZCUyPzE6MCksZD1NYXRoLmZsb29yKGQvMik7Zm9yKGE9MTE7YTstLWEpZS5wdXNoKGMlMj8xOjApLGM9TWF0aC5mbG9vcihjLzIpO2UucHVzaChiPzE6MCk7ZS5yZXZlcnNlKCk7Yj1lLmpvaW4oXCJcIik7Yz1cIlwiO2ZvcihhPTA7NjQ+YTthKz04KWQ9cGFyc2VJbnQoYi5zdWJzdHIoYSw4KSwyKS50b1N0cmluZygxNiksMT09PWQubGVuZ3RoJiZcbihkPVwiMFwiK2QpLGMrPWQ7cmV0dXJuIGMudG9Mb3dlckNhc2UoKX12YXIgbmQ9L14tP1xcZHsxLDEwfSQvO2Z1bmN0aW9uIGhkKGEpe3JldHVybiBuZC50ZXN0KGEpJiYoYT1OdW1iZXIoYSksLTIxNDc0ODM2NDg8PWEmJjIxNDc0ODM2NDc+PWEpP2E6bnVsbH1mdW5jdGlvbiBUYihhKXt0cnl7YSgpfWNhdGNoKGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtPKFwiRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay5cIixiLnN0YWNrfHxcIlwiKTt0aHJvdyBiO30sTWF0aC5mbG9vcigwKSl9fWZ1bmN0aW9uIG9kKGEsYixjKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtnZXQ6Y30pfTtmdW5jdGlvbiBwZChhKXt2YXIgYj17fTt0cnl7dmFyIGM9YS5zcGxpdChcIi5cIik7T2IoWGMoY1swXSl8fFwiXCIpO2I9T2IoWGMoY1sxXSl8fFwiXCIpO2RlbGV0ZSBiLmR9Y2F0Y2goZCl7fWE9YjtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJiEwPT09eChhLFwiYWRtaW5cIil9O3ZhciBxZD1udWxsO1widW5kZWZpbmVkXCIhPT10eXBlb2YgTW96V2ViU29ja2V0P3FkPU1veldlYlNvY2tldDpcInVuZGVmaW5lZFwiIT09dHlwZW9mIFdlYlNvY2tldCYmKHFkPVdlYlNvY2tldCk7ZnVuY3Rpb24gcmQoYSxiLGMsZCl7dGhpcy5aZD1hO3RoaXMuZj1iZCh0aGlzLlpkKTt0aGlzLmZyYW1lcz10aGlzLkFjPW51bGw7dGhpcy5xYj10aGlzLnJiPXRoaXMuRWU9MDt0aGlzLlhhPW9jKGIpO2E9e3Y6XCI1XCJ9O1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2MmJihhLnM9Yyk7ZCYmKGEubHM9ZCk7dGhpcy5MZT1oYyhiLFwid2Vic29ja2V0XCIsYSl9dmFyIHRkO1xucmQucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt0aGlzLmtiPWI7dGhpcy5mZz1hO3RoaXMuZihcIldlYnNvY2tldCBjb25uZWN0aW5nIHRvIFwiK3RoaXMuTGUpO3RoaXMueGM9ITE7WGIuc2V0KFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIiwhMCk7dHJ5e3RoaXMuTGE9bmV3IHFkKHRoaXMuTGUpfWNhdGNoKGMpe3RoaXMuZihcIkVycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LlwiKTt2YXIgZD1jLm1lc3NhZ2V8fGMuZGF0YTtkJiZ0aGlzLmYoZCk7dGhpcy5mYigpO3JldHVybn12YXIgZT10aGlzO3RoaXMuTGEub25vcGVuPWZ1bmN0aW9uKCl7ZS5mKFwiV2Vic29ja2V0IGNvbm5lY3RlZC5cIik7ZS54Yz0hMH07dGhpcy5MYS5vbmNsb3NlPWZ1bmN0aW9uKCl7ZS5mKFwiV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC5cIik7ZS5MYT1udWxsO2UuZmIoKX07dGhpcy5MYS5vbm1lc3NhZ2U9ZnVuY3Rpb24oYSl7aWYobnVsbCE9PWUuTGEpaWYoYT1hLmRhdGEsZS5xYis9XG5hLmxlbmd0aCxsYyhlLlhhLFwiYnl0ZXNfcmVjZWl2ZWRcIixhLmxlbmd0aCksdWQoZSksbnVsbCE9PWUuZnJhbWVzKXZkKGUsYSk7ZWxzZXthOntIKG51bGw9PT1lLmZyYW1lcyxcIldlIGFscmVhZHkgaGF2ZSBhIGZyYW1lIGJ1ZmZlclwiKTtpZig2Pj1hLmxlbmd0aCl7dmFyIGI9TnVtYmVyKGEpO2lmKCFpc05hTihiKSl7ZS5FZT1iO2UuZnJhbWVzPVtdO2E9bnVsbDticmVhayBhfX1lLkVlPTE7ZS5mcmFtZXM9W119bnVsbCE9PWEmJnZkKGUsYSl9fTt0aGlzLkxhLm9uZXJyb3I9ZnVuY3Rpb24oYSl7ZS5mKFwiV2ViU29ja2V0IGVycm9yLiAgQ2xvc2luZyBjb25uZWN0aW9uLlwiKTsoYT1hLm1lc3NhZ2V8fGEuZGF0YSkmJmUuZihhKTtlLmZiKCl9fTtyZC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt9O1xucmQuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXt2YXIgYT0hMTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCl7dmFyIGI9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZCAoWzAtOV17MCx9XFwuWzAtOV17MCx9KS8pO2ImJjE8Yi5sZW5ndGgmJjQuND5wYXJzZUZsb2F0KGJbMV0pJiYoYT0hMCl9cmV0dXJuIWEmJm51bGwhPT1xZCYmIXRkfTtyZC5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5PTI7cmQuaGVhbHRoeVRpbWVvdXQ9M0U0O2c9cmQucHJvdG90eXBlO2cuc2Q9ZnVuY3Rpb24oKXtYYi5yZW1vdmUoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKX07ZnVuY3Rpb24gdmQoYSxiKXthLmZyYW1lcy5wdXNoKGIpO2lmKGEuZnJhbWVzLmxlbmd0aD09YS5FZSl7dmFyIGM9YS5mcmFtZXMuam9pbihcIlwiKTthLmZyYW1lcz1udWxsO2M9T2IoYyk7YS5mZyhjKX19XG5nLnNlbmQ9ZnVuY3Rpb24oYSl7dWQodGhpcyk7YT1CKGEpO3RoaXMucmIrPWEubGVuZ3RoO2xjKHRoaXMuWGEsXCJieXRlc19zZW50XCIsYS5sZW5ndGgpO2E9a2QoYSwxNjM4NCk7MTxhLmxlbmd0aCYmd2QodGhpcyxTdHJpbmcoYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl3ZCh0aGlzLGFbYl0pfTtnLlRjPWZ1bmN0aW9uKCl7dGhpcy5CYj0hMDt0aGlzLkFjJiYoY2xlYXJJbnRlcnZhbCh0aGlzLkFjKSx0aGlzLkFjPW51bGwpO3RoaXMuTGEmJih0aGlzLkxhLmNsb3NlKCksdGhpcy5MYT1udWxsKX07Zy5mYj1mdW5jdGlvbigpe3RoaXMuQmJ8fCh0aGlzLmYoXCJXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5UYygpLHRoaXMua2ImJih0aGlzLmtiKHRoaXMueGMpLHRoaXMua2I9bnVsbCkpfTtnLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5CYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBiZWluZyBjbG9zZWRcIiksdGhpcy5UYygpKX07XG5mdW5jdGlvbiB1ZChhKXtjbGVhckludGVydmFsKGEuQWMpO2EuQWM9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLkxhJiZ3ZChhLFwiMFwiKTt1ZChhKX0sTWF0aC5mbG9vcig0NUUzKSl9ZnVuY3Rpb24gd2QoYSxiKXt0cnl7YS5MYS5zZW5kKGIpfWNhdGNoKGMpe2EuZihcIkV4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOlwiLGMubWVzc2FnZXx8Yy5kYXRhLFwiQ2xvc2luZyBjb25uZWN0aW9uLlwiKSxzZXRUaW1lb3V0KHIoYS5mYixhKSwwKX19O2Z1bmN0aW9uIHhkKGEsYixjKXt0aGlzLmY9YmQoXCJwOnJlc3Q6XCIpO3RoaXMuTT1hO3RoaXMuSGI9Yjt0aGlzLlZkPWM7dGhpcy4kPXt9fWZ1bmN0aW9uIHlkKGEsYil7aWYocChiKSlyZXR1cm5cInRhZyRcIitiO0goemQoYS5uKSxcInNob3VsZCBoYXZlIGEgdGFnIGlmIGl0J3Mgbm90IGEgZGVmYXVsdCBxdWVyeS5cIik7cmV0dXJuIGEucGF0aC50b1N0cmluZygpfWc9eGQucHJvdG90eXBlO1xuZy5iZj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hLnBhdGgudG9TdHJpbmcoKTt0aGlzLmYoXCJMaXN0ZW4gY2FsbGVkIGZvciBcIitlK1wiIFwiK2EueWEoKSk7dmFyIGY9eWQoYSxjKSxoPXt9O3RoaXMuJFtmXT1oO2E9QWQoYS5uKTt2YXIgaz10aGlzO0JkKHRoaXMsZStcIi5qc29uXCIsYSxmdW5jdGlvbihhLGIpe3ZhciB1PWI7NDA0PT09YSYmKGE9dT1udWxsKTtudWxsPT09YSYmay5IYihlLHUsITEsYyk7eChrLiQsZik9PT1oJiZkKGE/NDAxPT1hP1wicGVybWlzc2lvbl9kZW5pZWRcIjpcInJlc3RfZXJyb3I6XCIrYTpcIm9rXCIsbnVsbCl9KX07Zy5DZj1mdW5jdGlvbihhLGIpe3ZhciBjPXlkKGEsYik7ZGVsZXRlIHRoaXMuJFtjXX07Zy5vZj1mdW5jdGlvbigpe307Zy5xZT1mdW5jdGlvbigpe307Zy5lZj1mdW5jdGlvbigpe307Zy54ZD1mdW5jdGlvbigpe307Zy5wdXQ9ZnVuY3Rpb24oKXt9O2cuY2Y9ZnVuY3Rpb24oKXt9O2cueGU9ZnVuY3Rpb24oKXt9O1xuZnVuY3Rpb24gQmQoYSxiLGMsZCl7Yz1jfHx7fTtjLmZvcm1hdD1cImV4cG9ydFwiO2EuVmQuZ2V0VG9rZW4oITEpLnRoZW4oZnVuY3Rpb24oZSl7KGU9ZSYmZS5hY2Nlc3NUb2tlbikmJihjLmF1dGg9ZSk7dmFyIGY9KGEuTS5TYz9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK2EuTS5ob3N0K2IrXCI/XCIrRmIoYyk7YS5mKFwiU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yIFwiK2YpO3ZhciBoPW5ldyBYTUxIdHRwUmVxdWVzdDtoLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGQmJjQ9PT1oLnJlYWR5U3RhdGUpe2EuZihcIlJFU1QgUmVzcG9uc2UgZm9yIFwiK2YrXCIgcmVjZWl2ZWQuIHN0YXR1czpcIixoLnN0YXR1cyxcInJlc3BvbnNlOlwiLGgucmVzcG9uc2VUZXh0KTt2YXIgYj1udWxsO2lmKDIwMDw9aC5zdGF0dXMmJjMwMD5oLnN0YXR1cyl7dHJ5e2I9T2IoaC5yZXNwb25zZVRleHQpfWNhdGNoKGMpe08oXCJGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgXCIrZitcIjogXCIraC5yZXNwb25zZVRleHQpfWQobnVsbCxcbmIpfWVsc2UgNDAxIT09aC5zdGF0dXMmJjQwNCE9PWguc3RhdHVzJiZPKFwiR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciBcIitmK1wiIFN0YXR1czogXCIraC5zdGF0dXMpLGQoaC5zdGF0dXMpO2Q9bnVsbH19O2gub3BlbihcIkdFVFwiLGYsITApO2guc2VuZCgpfSl9O2Z1bmN0aW9uIENkKGEsYixjKXt0aGlzLnR5cGU9RGQ7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLmNoaWxkcmVuPWN9Q2QucHJvdG90eXBlLk5jPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpcmV0dXJuIGE9dGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBMKGEpKSxhLmUoKT9udWxsOmEudmFsdWU/bmV3IFpiKHRoaXMuc291cmNlLEMsYS52YWx1ZSk6bmV3IENkKHRoaXMuc291cmNlLEMsYSk7SChKKHRoaXMucGF0aCk9PT1hLFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7cmV0dXJuIG5ldyBDZCh0aGlzLnNvdXJjZSxEKHRoaXMucGF0aCksdGhpcy5jaGlsZHJlbil9O0NkLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBtZXJnZTogXCIrdGhpcy5jaGlsZHJlbi50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBFZCgpe3RoaXMuaGI9e319XG5mdW5jdGlvbiBGZChhLGIpe3ZhciBjPWIudHlwZSxkPWIuWmE7SChcImNoaWxkX2FkZGVkXCI9PWN8fFwiY2hpbGRfY2hhbmdlZFwiPT1jfHxcImNoaWxkX3JlbW92ZWRcIj09YyxcIk9ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nXCIpO0goXCIucHJpb3JpdHlcIiE9PWQsXCJPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLlwiKTt2YXIgZT14KGEuaGIsZCk7aWYoZSl7dmFyIGY9ZS50eXBlO2lmKFwiY2hpbGRfYWRkZWRcIj09YyYmXCJjaGlsZF9yZW1vdmVkXCI9PWYpYS5oYltkXT1uZXcgSShcImNoaWxkX2NoYW5nZWRcIixiLk1hLGQsZS5NYSk7ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9hZGRlZFwiPT1mKWRlbGV0ZSBhLmhiW2RdO2Vsc2UgaWYoXCJjaGlsZF9yZW1vdmVkXCI9PWMmJlwiY2hpbGRfY2hhbmdlZFwiPT1mKWEuaGJbZF09bmV3IEkoXCJjaGlsZF9yZW1vdmVkXCIsZS5wZSxkKTtlbHNlIGlmKFwiY2hpbGRfY2hhbmdlZFwiPT1jJiZcblwiY2hpbGRfYWRkZWRcIj09ZilhLmhiW2RdPW5ldyBJKFwiY2hpbGRfYWRkZWRcIixiLk1hLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlwiY2hpbGRfY2hhbmdlZFwiPT1mKWEuaGJbZF09bmV3IEkoXCJjaGlsZF9jaGFuZ2VkXCIsYi5NYSxkLGUucGUpO2Vsc2UgdGhyb3cgV2MoXCJJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6IFwiK2IrXCIgb2NjdXJyZWQgYWZ0ZXIgXCIrZSk7fWVsc2UgYS5oYltkXT1ifTtmdW5jdGlvbiBHZChhKXt0aGlzLlc9YTt0aGlzLmc9YS5uLmd9ZnVuY3Rpb24gSGQoYSxiLGMsZCl7dmFyIGU9W10sZj1bXTtKYShiLGZ1bmN0aW9uKGIpe1wiY2hpbGRfY2hhbmdlZFwiPT09Yi50eXBlJiZhLmcubmQoYi5wZSxiLk1hKSYmZi5wdXNoKG5ldyBJKFwiY2hpbGRfbW92ZWRcIixiLk1hLGIuWmEpKX0pO0lkKGEsZSxcImNoaWxkX3JlbW92ZWRcIixiLGQsYyk7SWQoYSxlLFwiY2hpbGRfYWRkZWRcIixiLGQsYyk7SWQoYSxlLFwiY2hpbGRfbW92ZWRcIixmLGQsYyk7SWQoYSxlLFwiY2hpbGRfY2hhbmdlZFwiLGIsZCxjKTtJZChhLGUsR2MsYixkLGMpO3JldHVybiBlfWZ1bmN0aW9uIElkKGEsYixjLGQsZSxmKXtkPUthKGQsZnVuY3Rpb24oYSl7cmV0dXJuIGEudHlwZT09PWN9KTtTYShkLHIoYS5NZixhKSk7SmEoZCxmdW5jdGlvbihjKXt2YXIgZD1KZChhLGMsZik7SmEoZSxmdW5jdGlvbihlKXtlLnJmKGMudHlwZSkmJmIucHVzaChlLmNyZWF0ZUV2ZW50KGQsYS5XKSl9KX0pfVxuZnVuY3Rpb24gSmQoYSxiLGMpe1widmFsdWVcIiE9PWIudHlwZSYmXCJjaGlsZF9yZW1vdmVkXCIhPT1iLnR5cGUmJihiLkRkPWMuWGUoYi5aYSxiLk1hLGEuZykpO3JldHVybiBifUdkLnByb3RvdHlwZS5NZj1mdW5jdGlvbihhLGIpe2lmKG51bGw9PWEuWmF8fG51bGw9PWIuWmEpdGhyb3cgV2MoXCJTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuXCIpO3JldHVybiB0aGlzLmcuY29tcGFyZShuZXcgSyhhLlphLGEuTWEpLG5ldyBLKGIuWmEsYi5NYSkpfTtmdW5jdGlvbiBLZChhLGIpe3RoaXMuU2Q9YTt0aGlzLktmPWJ9ZnVuY3Rpb24gTGQoYSl7dGhpcy5WPWF9XG5MZC5wcm90b3R5cGUuZ2I9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IEVkLGY7aWYoYi50eXBlPT09JGIpYi5zb3VyY2UuZWU/Yz1NZCh0aGlzLGEsYi5wYXRoLGIuSmEsYyxkLGUpOihIKGIuc291cmNlLlVlLFwiVW5rbm93biBzb3VyY2UuXCIpLGY9Yi5zb3VyY2UuRGV8fEljKGEudSgpKSYmIWIucGF0aC5lKCksYz1OZCh0aGlzLGEsYi5wYXRoLGIuSmEsYyxkLGYsZSkpO2Vsc2UgaWYoYi50eXBlPT09RGQpYi5zb3VyY2UuZWU/Yz1PZCh0aGlzLGEsYi5wYXRoLGIuY2hpbGRyZW4sYyxkLGUpOihIKGIuc291cmNlLlVlLFwiVW5rbm93biBzb3VyY2UuXCIpLGY9Yi5zb3VyY2UuRGV8fEljKGEudSgpKSxjPVBkKHRoaXMsYSxiLnBhdGgsYi5jaGlsZHJlbixjLGQsZixlKSk7ZWxzZSBpZihiLnR5cGU9PT1RZClpZihiLklkKWlmKGI9Yi5wYXRoLG51bGwhPWMubWMoYikpYz1hO2Vsc2V7Zj1uZXcgQmMoYyxhLGQpO2Q9YS5PLmooKTtpZihiLmUoKXx8XCIucHJpb3JpdHlcIj09PUooYikpSGMoYS51KCkpP1xuYj1jLkJhKEVjKGEpKTooYj1hLnUoKS5qKCksSChiIGluc3RhbmNlb2YgUCxcInNlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZVwiKSxiPWMuc2MoYikpLGI9dGhpcy5WLnphKGQsYixlKTtlbHNle3ZhciBoPUooYiksaz1jLnJjKGgsYS51KCkpO251bGw9PWsmJkNjKGEudSgpLGgpJiYoaz1kLlIoaCkpO2I9bnVsbCE9az90aGlzLlYuRihkLGgsayxEKGIpLGYsZSk6YS5PLmooKS5GYShoKT90aGlzLlYuRihkLGgsRixEKGIpLGYsZSk6ZDtiLmUoKSYmSGMoYS51KCkpJiYoZD1jLkJhKEVjKGEpKSxkLkooKSYmKGI9dGhpcy5WLnphKGIsZCxlKSkpfWQ9SGMoYS51KCkpfHxudWxsIT1jLm1jKEMpO2M9UmQoYSxiLGQsdGhpcy5WLlFhKCkpfWVsc2UgYz1TZCh0aGlzLGEsYi5wYXRoLGIuUGIsYyxkLGUpO2Vsc2UgaWYoYi50eXBlPT09YmMpZD1iLnBhdGgsYj1hLnUoKSxmPWIuaigpLGg9Yi5lYXx8ZC5lKCksYz1UZCh0aGlzLG5ldyBVZChhLk8sbmV3IERjKGYsXG5oLGIuVGIpKSxkLGMsQWMsZSk7ZWxzZSB0aHJvdyBXYyhcIlVua25vd24gb3BlcmF0aW9uIHR5cGU6IFwiK2IudHlwZSk7ZT1zYShlLmhiKTtkPWM7Yj1kLk87Yi5lYSYmKGY9Yi5qKCkuSigpfHxiLmooKS5lKCksaD1WZChhKSwoMDxlLmxlbmd0aHx8IWEuTy5lYXx8ZiYmIWIuaigpLmNhKGgpfHwhYi5qKCkuQygpLmNhKGguQygpKSkmJmUucHVzaChGYyhWZChkKSkpKTtyZXR1cm4gbmV3IEtkKGMsZSl9O1xuZnVuY3Rpb24gVGQoYSxiLGMsZCxlLGYpe3ZhciBoPWIuTztpZihudWxsIT1kLm1jKGMpKXJldHVybiBiO3ZhciBrO2lmKGMuZSgpKUgoSGMoYi51KCkpLFwiSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YVwiKSxJYyhiLnUoKSk/KGU9RWMoYiksZD1kLnNjKGUgaW5zdGFuY2VvZiBQP2U6RikpOmQ9ZC5CYShFYyhiKSksZj1hLlYuemEoYi5PLmooKSxkLGYpO2Vsc2V7dmFyIG09SihjKTtpZihcIi5wcmlvcml0eVwiPT1tKUgoMT09V2QoYyksXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKSxmPWguaigpLGs9Yi51KCkuaigpLGQ9ZC4kYyhjLGYsayksZj1udWxsIT1kP2EuVi5nYShmLGQpOmguaigpO2Vsc2V7dmFyIGw9RChjKTtDYyhoLG0pPyhrPWIudSgpLmooKSxkPWQuJGMoYyxoLmooKSxrKSxkPW51bGwhPWQ/aC5qKCkuUihtKS5GKGwsZCk6aC5qKCkuUihtKSk6ZD1kLnJjKG0sXG5iLnUoKSk7Zj1udWxsIT1kP2EuVi5GKGguaigpLG0sZCxsLGUsZik6aC5qKCl9fXJldHVybiBSZChiLGYsaC5lYXx8Yy5lKCksYS5WLlFhKCkpfWZ1bmN0aW9uIE5kKGEsYixjLGQsZSxmLGgsayl7dmFyIG09Yi51KCk7aD1oP2EuVjphLlYuVmIoKTtpZihjLmUoKSlkPWguemEobS5qKCksZCxudWxsKTtlbHNlIGlmKGguUWEoKSYmIW0uVGIpZD1tLmooKS5GKGMsZCksZD1oLnphKG0uaigpLGQsbnVsbCk7ZWxzZXt2YXIgbD1KKGMpO2lmKCFKYyhtLGMpJiYxPFdkKGMpKXJldHVybiBiO3ZhciB1PUQoYyk7ZD1tLmooKS5SKGwpLkYodSxkKTtkPVwiLnByaW9yaXR5XCI9PWw/aC5nYShtLmooKSxkKTpoLkYobS5qKCksbCxkLHUsQWMsbnVsbCl9bT1tLmVhfHxjLmUoKTtiPW5ldyBVZChiLk8sbmV3IERjKGQsbSxoLlFhKCkpKTtyZXR1cm4gVGQoYSxiLGMsZSxuZXcgQmMoZSxiLGYpLGspfVxuZnVuY3Rpb24gTWQoYSxiLGMsZCxlLGYsaCl7dmFyIGs9Yi5PO2U9bmV3IEJjKGUsYixmKTtpZihjLmUoKSloPWEuVi56YShiLk8uaigpLGQsaCksYT1SZChiLGgsITAsYS5WLlFhKCkpO2Vsc2UgaWYoZj1KKGMpLFwiLnByaW9yaXR5XCI9PT1mKWg9YS5WLmdhKGIuTy5qKCksZCksYT1SZChiLGgsay5lYSxrLlRiKTtlbHNle2M9RChjKTt2YXIgbT1rLmooKS5SKGYpO2lmKCFjLmUoKSl7dmFyIGw9ZS5WZShmKTtkPW51bGwhPWw/XCIucHJpb3JpdHlcIj09PVhkKGMpJiZsLlEoYy5wYXJlbnQoKSkuZSgpP2w6bC5GKGMsZCk6Rn1tLmNhKGQpP2E9YjooaD1hLlYuRihrLmooKSxmLGQsYyxlLGgpLGE9UmQoYixoLGsuZWEsYS5WLlFhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIE9kKGEsYixjLGQsZSxmLGgpe3ZhciBrPWI7WWQoZCxmdW5jdGlvbihkLGwpe3ZhciB1PWMubShkKTtDYyhiLk8sSih1KSkmJihrPU1kKGEsayx1LGwsZSxmLGgpKX0pO1lkKGQsZnVuY3Rpb24oZCxsKXt2YXIgdT1jLm0oZCk7Q2MoYi5PLEoodSkpfHwoaz1NZChhLGssdSxsLGUsZixoKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBaZChhLGIpe1lkKGIsZnVuY3Rpb24oYixkKXthPWEuRihiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBQZChhLGIsYyxkLGUsZixoLGspe2lmKGIudSgpLmooKS5lKCkmJiFIYyhiLnUoKSkpcmV0dXJuIGI7dmFyIG09YjtjPWMuZSgpP2Q6JGQoUSxjLGQpO3ZhciBsPWIudSgpLmooKTtjLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGMsZCl7aWYobC5GYShjKSl7dmFyIEc9Yi51KCkuaigpLlIoYyksRz1aZChHLGQpO209TmQoYSxtLG5ldyBMKGMpLEcsZSxmLGgsayl9fSk7Yy5jaGlsZHJlbi5pYShmdW5jdGlvbihjLGQpe3ZhciBHPSFDYyhiLnUoKSxjKSYmbnVsbD09ZC52YWx1ZTtsLkZhKGMpfHxHfHwoRz1iLnUoKS5qKCkuUihjKSxHPVpkKEcsZCksbT1OZChhLG0sbmV3IEwoYyksRyxlLGYsaCxrKSl9KTtyZXR1cm4gbX1cbmZ1bmN0aW9uIFNkKGEsYixjLGQsZSxmLGgpe2lmKG51bGwhPWUubWMoYykpcmV0dXJuIGI7dmFyIGs9SWMoYi51KCkpLG09Yi51KCk7aWYobnVsbCE9ZC52YWx1ZSl7aWYoYy5lKCkmJm0uZWF8fEpjKG0sYykpcmV0dXJuIE5kKGEsYixjLG0uaigpLlEoYyksZSxmLGssaCk7aWYoYy5lKCkpe3ZhciBsPVE7bS5qKCkuUChhZSxmdW5jdGlvbihhLGIpe2w9bC5zZXQobmV3IEwoYSksYil9KTtyZXR1cm4gUGQoYSxiLGMsbCxlLGYsayxoKX1yZXR1cm4gYn1sPVE7WWQoZCxmdW5jdGlvbihhKXt2YXIgYj1jLm0oYSk7SmMobSxiKSYmKGw9bC5zZXQoYSxtLmooKS5RKGIpKSl9KTtyZXR1cm4gUGQoYSxiLGMsbCxlLGYsayxoKX07ZnVuY3Rpb24gYmUoYSl7dGhpcy5nPWF9Zz1iZS5wcm90b3R5cGU7Zy5GPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtIKGEuemModGhpcy5nKSxcIkEgbm9kZSBtdXN0IGJlIGluZGV4ZWQgaWYgb25seSBhIGNoaWxkIGlzIHVwZGF0ZWRcIik7ZT1hLlIoYik7aWYoZS5RKGQpLmNhKGMuUShkKSkmJmUuZSgpPT1jLmUoKSlyZXR1cm4gYTtudWxsIT1mJiYoYy5lKCk/YS5GYShiKT9GZChmLG5ldyBJKFwiY2hpbGRfcmVtb3ZlZFwiLGUsYikpOkgoYS5KKCksXCJBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlXCIpOmUuZSgpP0ZkKGYsbmV3IEkoXCJjaGlsZF9hZGRlZFwiLGMsYikpOkZkKGYsbmV3IEkoXCJjaGlsZF9jaGFuZ2VkXCIsYyxiLGUpKSk7cmV0dXJuIGEuSigpJiZjLmUoKT9hOmEuVShiLGMpLm9iKHRoaXMuZyl9O1xuZy56YT1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YyYmKGEuSigpfHxhLlAoTixmdW5jdGlvbihhLGUpe2IuRmEoYSl8fEZkKGMsbmV3IEkoXCJjaGlsZF9yZW1vdmVkXCIsZSxhKSl9KSxiLkooKXx8Yi5QKE4sZnVuY3Rpb24oYixlKXtpZihhLkZhKGIpKXt2YXIgZj1hLlIoYik7Zi5jYShlKXx8RmQoYyxuZXcgSShcImNoaWxkX2NoYW5nZWRcIixlLGIsZikpfWVsc2UgRmQoYyxuZXcgSShcImNoaWxkX2FkZGVkXCIsZSxiKSl9KSk7cmV0dXJuIGIub2IodGhpcy5nKX07Zy5nYT1mdW5jdGlvbihhLGIpe3JldHVybiBhLmUoKT9GOmEuZ2EoYil9O2cuUWE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5WYj1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtmdW5jdGlvbiBjZShhKXt0aGlzLmhlPW5ldyBiZShhLmcpO3RoaXMuZz1hLmc7dmFyIGI7YS5rYT8oYj1kZShhKSxiPWEuZy5GYyhlZShhKSxiKSk6Yj1hLmcuSWMoKTt0aGlzLlVjPWI7YS5uYT8oYj1mZShhKSxhPWEuZy5GYyhnZShhKSxiKSk6YT1hLmcuR2MoKTt0aGlzLndjPWF9Zz1jZS5wcm90b3R5cGU7Zy5tYXRjaGVzPWZ1bmN0aW9uKGEpe3JldHVybiAwPj10aGlzLmcuY29tcGFyZSh0aGlzLlVjLGEpJiYwPj10aGlzLmcuY29tcGFyZShhLHRoaXMud2MpfTtnLkY9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMubWF0Y2hlcyhuZXcgSyhiLGMpKXx8KGM9Rik7cmV0dXJuIHRoaXMuaGUuRihhLGIsYyxkLGUsZil9O1xuZy56YT1mdW5jdGlvbihhLGIsYyl7Yi5KKCkmJihiPUYpO3ZhciBkPWIub2IodGhpcy5nKSxkPWQuZ2EoRiksZT10aGlzO2IuUChOLGZ1bmN0aW9uKGEsYil7ZS5tYXRjaGVzKG5ldyBLKGEsYikpfHwoZD1kLlUoYSxGKSl9KTtyZXR1cm4gdGhpcy5oZS56YShhLGQsYyl9O2cuZ2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2cuUWE9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5WYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhlfTtmdW5jdGlvbiBoZShhKXt0aGlzLnNhPW5ldyBjZShhKTt0aGlzLmc9YS5nO0goYS54YSxcIk9ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0XCIpO3RoaXMub2E9YS5vYTt0aGlzLkpiPSFpZShhKX1nPWhlLnByb3RvdHlwZTtnLkY9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuc2EubWF0Y2hlcyhuZXcgSyhiLGMpKXx8KGM9Rik7cmV0dXJuIGEuUihiKS5jYShjKT9hOmEuRmIoKTx0aGlzLm9hP3RoaXMuc2EuVmIoKS5GKGEsYixjLGQsZSxmKTpqZSh0aGlzLGEsYixjLGUsZil9O1xuZy56YT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoYi5KKCl8fGIuZSgpKWQ9Ri5vYih0aGlzLmcpO2Vsc2UgaWYoMip0aGlzLm9hPGIuRmIoKSYmYi56Yyh0aGlzLmcpKXtkPUYub2IodGhpcy5nKTtiPXRoaXMuSmI/Yi4kYih0aGlzLnNhLndjLHRoaXMuZyk6Yi5ZYih0aGlzLnNhLlVjLHRoaXMuZyk7Zm9yKHZhciBlPTA7MDxiLlNhLmxlbmd0aCYmZTx0aGlzLm9hOyl7dmFyIGY9UihiKSxoO2lmKGg9dGhpcy5KYj8wPj10aGlzLmcuY29tcGFyZSh0aGlzLnNhLlVjLGYpOjA+PXRoaXMuZy5jb21wYXJlKGYsdGhpcy5zYS53YykpZD1kLlUoZi5uYW1lLGYuUyksZSsrO2Vsc2UgYnJlYWt9fWVsc2V7ZD1iLm9iKHRoaXMuZyk7ZD1kLmdhKEYpO3ZhciBrLG0sbDtpZih0aGlzLkpiKXtiPWQuWWUodGhpcy5nKTtrPXRoaXMuc2Eud2M7bT10aGlzLnNhLlVjO3ZhciB1PWtlKHRoaXMuZyk7bD1mdW5jdGlvbihhLGIpe3JldHVybiB1KGIsYSl9fWVsc2UgYj1kLlhiKHRoaXMuZyksaz10aGlzLnNhLlVjLFxubT10aGlzLnNhLndjLGw9a2UodGhpcy5nKTtmb3IodmFyIGU9MCx6PSExOzA8Yi5TYS5sZW5ndGg7KWY9UihiKSwheiYmMD49bChrLGYpJiYoej0hMCksKGg9eiYmZTx0aGlzLm9hJiYwPj1sKGYsbSkpP2UrKzpkPWQuVShmLm5hbWUsRil9cmV0dXJuIHRoaXMuc2EuVmIoKS56YShhLGQsYyl9O2cuZ2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2cuUWE9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5WYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNhLlZiKCl9O1xuZnVuY3Rpb24gamUoYSxiLGMsZCxlLGYpe3ZhciBoO2lmKGEuSmIpe3ZhciBrPWtlKGEuZyk7aD1mdW5jdGlvbihhLGIpe3JldHVybiBrKGIsYSl9fWVsc2UgaD1rZShhLmcpO0goYi5GYigpPT1hLm9hLFwiXCIpO3ZhciBtPW5ldyBLKGMsZCksbD1hLkpiP2xlKGIsYS5nKTptZShiLGEuZyksdT1hLnNhLm1hdGNoZXMobSk7aWYoYi5GYShjKSl7Zm9yKHZhciB6PWIuUihjKSxsPWUuZmUoYS5nLGwsYS5KYik7bnVsbCE9bCYmKGwubmFtZT09Y3x8Yi5GYShsLm5hbWUpKTspbD1lLmZlKGEuZyxsLGEuSmIpO2U9bnVsbD09bD8xOmgobCxtKTtpZih1JiYhZC5lKCkmJjA8PWUpcmV0dXJuIG51bGwhPWYmJkZkKGYsbmV3IEkoXCJjaGlsZF9jaGFuZ2VkXCIsZCxjLHopKSxiLlUoYyxkKTtudWxsIT1mJiZGZChmLG5ldyBJKFwiY2hpbGRfcmVtb3ZlZFwiLHosYykpO2I9Yi5VKGMsRik7cmV0dXJuIG51bGwhPWwmJmEuc2EubWF0Y2hlcyhsKT8obnVsbCE9ZiYmRmQoZixuZXcgSShcImNoaWxkX2FkZGVkXCIsXG5sLlMsbC5uYW1lKSksYi5VKGwubmFtZSxsLlMpKTpifXJldHVybiBkLmUoKT9iOnUmJjA8PWgobCxtKT8obnVsbCE9ZiYmKEZkKGYsbmV3IEkoXCJjaGlsZF9yZW1vdmVkXCIsbC5TLGwubmFtZSkpLEZkKGYsbmV3IEkoXCJjaGlsZF9hZGRlZFwiLGQsYykpKSxiLlUoYyxkKS5VKGwubmFtZSxGKSk6Yn07ZnVuY3Rpb24gVWMoYSxiKXt0aGlzLkI9YTtIKHAodGhpcy5CKSYmbnVsbCE9PXRoaXMuQixcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO3RoaXMuYWE9Ynx8RjtuZSh0aGlzLmFhKTt0aGlzLkViPW51bGx9dmFyIG9lPVtcIm9iamVjdFwiLFwiYm9vbGVhblwiLFwibnVtYmVyXCIsXCJzdHJpbmdcIl07Zz1VYy5wcm90b3R5cGU7Zy5KPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuQz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFhfTtnLmdhPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVWModGhpcy5CLGEpfTtnLlI9ZnVuY3Rpb24oYSl7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5hYTpGfTtnLlE9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZSgpP3RoaXM6XCIucHJpb3JpdHlcIj09PUooYSk/dGhpcy5hYTpGfTtnLkZhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuWGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG5nLlU9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cIi5wcmlvcml0eVwiPT09YT90aGlzLmdhKGIpOmIuZSgpJiZcIi5wcmlvcml0eVwiIT09YT90aGlzOkYuVShhLGIpLmdhKHRoaXMuYWEpfTtnLkY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1KKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGIuZSgpJiZcIi5wcmlvcml0eVwiIT09YylyZXR1cm4gdGhpcztIKFwiLnByaW9yaXR5XCIhPT1jfHwxPT09V2QoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7cmV0dXJuIHRoaXMuVShjLEYuRihEKGEpLGIpKX07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuRmI9ZnVuY3Rpb24oKXtyZXR1cm4gMH07Zy5QPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuSD1mdW5jdGlvbihhKXtyZXR1cm4gYSYmIXRoaXMuQygpLmUoKT97XCIudmFsdWVcIjp0aGlzLkVhKCksXCIucHJpb3JpdHlcIjp0aGlzLkMoKS5IKCl9OnRoaXMuRWEoKX07XG5nLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5FYil7dmFyIGE9XCJcIjt0aGlzLmFhLmUoKXx8KGErPVwicHJpb3JpdHk6XCIrcGUodGhpcy5hYS5IKCkpK1wiOlwiKTt2YXIgYj10eXBlb2YgdGhpcy5CLGE9YSsoYitcIjpcIiksYT1cIm51bWJlclwiPT09Yj9hK21kKHRoaXMuQik6YSt0aGlzLkI7dGhpcy5FYj1ZYyhhKX1yZXR1cm4gdGhpcy5FYn07Zy5FYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkJ9O2cudGM9ZnVuY3Rpb24oYSl7aWYoYT09PUYpcmV0dXJuIDE7aWYoYSBpbnN0YW5jZW9mIFApcmV0dXJuLTE7SChhLkooKSxcIlVua25vd24gbm9kZSB0eXBlXCIpO3ZhciBiPXR5cGVvZiBhLkIsYz10eXBlb2YgdGhpcy5CLGQ9SWEob2UsYiksZT1JYShvZSxjKTtIKDA8PWQsXCJVbmtub3duIGxlYWYgdHlwZTogXCIrYik7SCgwPD1lLFwiVW5rbm93biBsZWFmIHR5cGU6IFwiK2MpO3JldHVybiBkPT09ZT9cIm9iamVjdFwiPT09Yz8wOnRoaXMuQjxhLkI/LTE6dGhpcy5CPT09YS5CPzA6MTplLWR9O1xuZy5vYj1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtnLnpjPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuY2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT10aGlzPyEwOmEuSigpP3RoaXMuQj09PWEuQiYmdGhpcy5hYS5jYShhLmFhKTohMX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBCKHRoaXMuSCghMCkpfTtmdW5jdGlvbiBxZSgpe312YXIgcmU9e307ZnVuY3Rpb24ga2UoYSl7cmV0dXJuIHIoYS5jb21wYXJlLGEpfXFlLnByb3RvdHlwZS5uZD1mdW5jdGlvbihhLGIpe3JldHVybiAwIT09dGhpcy5jb21wYXJlKG5ldyBLKFwiW01JTl9OQU1FXVwiLGEpLG5ldyBLKFwiW01JTl9OQU1FXVwiLGIpKX07cWUucHJvdG90eXBlLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHNlfTtmdW5jdGlvbiB0ZShhKXtIKCFhLmUoKSYmXCIucHJpb3JpdHlcIiE9PUooYSksXCJDYW4ndCBjcmVhdGUgUGF0aEluZGV4IHdpdGggZW1wdHkgcGF0aCBvciAucHJpb3JpdHkga2V5XCIpO3RoaXMuY2M9YX1rYSh0ZSxxZSk7Zz10ZS5wcm90b3R5cGU7Zy55Yz1mdW5jdGlvbihhKXtyZXR1cm4hYS5RKHRoaXMuY2MpLmUoKX07Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLlEodGhpcy5jYyksZD1iLlMuUSh0aGlzLmNjKSxjPWMudGMoZCk7cmV0dXJuIDA9PT1jP0xjKGEubmFtZSxiLm5hbWUpOmN9O1xuZy5GYz1mdW5jdGlvbihhLGIpe3ZhciBjPU0oYSksYz1GLkYodGhpcy5jYyxjKTtyZXR1cm4gbmV3IEsoYixjKX07Zy5HYz1mdW5jdGlvbigpe3ZhciBhPUYuRih0aGlzLmNjLHVlKTtyZXR1cm4gbmV3IEsoXCJbTUFYX05BTUVdXCIsYSl9O2cudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYy5zbGljZSgpLmpvaW4oXCIvXCIpfTtmdW5jdGlvbiB2ZSgpe31rYSh2ZSxxZSk7Zz12ZS5wcm90b3R5cGU7Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLkMoKSxkPWIuUy5DKCksYz1jLnRjKGQpO3JldHVybiAwPT09Yz9MYyhhLm5hbWUsYi5uYW1lKTpjfTtnLnljPWZ1bmN0aW9uKGEpe3JldHVybiFhLkMoKS5lKCl9O2cubmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5DKCkuY2EoYi5DKCkpfTtnLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHNlfTtnLkdjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBLKFwiW01BWF9OQU1FXVwiLG5ldyBVYyhcIltQUklPUklUWS1QT1NUXVwiLHVlKSl9O1xuZy5GYz1mdW5jdGlvbihhLGIpe3ZhciBjPU0oYSk7cmV0dXJuIG5ldyBLKGIsbmV3IFVjKFwiW1BSSU9SSVRZLVBPU1RdXCIsYykpfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIucHJpb3JpdHlcIn07dmFyIE49bmV3IHZlO2Z1bmN0aW9uIHdlKCl7fWthKHdlLHFlKTtnPXdlLnByb3RvdHlwZTtnLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTGMoYS5uYW1lLGIubmFtZSl9O2cueWM9ZnVuY3Rpb24oKXt0aHJvdyBXYyhcIktleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuXCIpO307Zy5uZD1mdW5jdGlvbigpe3JldHVybiExfTtnLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHNlfTtnLkdjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBLKFwiW01BWF9OQU1FXVwiLEYpfTtnLkZjPWZ1bmN0aW9uKGEpe0gocShhKSxcIktleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuXCIpO3JldHVybiBuZXcgSyhhLEYpfTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIua2V5XCJ9O1xudmFyIGFlPW5ldyB3ZTtmdW5jdGlvbiB4ZSgpe31rYSh4ZSxxZSk7Zz14ZS5wcm90b3R5cGU7Zy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TLnRjKGIuUyk7cmV0dXJuIDA9PT1jP0xjKGEubmFtZSxiLm5hbWUpOmN9O2cueWM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Zy5uZD1mdW5jdGlvbihhLGIpe3JldHVybiFhLmNhKGIpfTtnLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHNlfTtnLkdjPWZ1bmN0aW9uKCl7cmV0dXJuIHllfTtnLkZjPWZ1bmN0aW9uKGEsYil7dmFyIGM9TShhKTtyZXR1cm4gbmV3IEsoYixjKX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnZhbHVlXCJ9O3ZhciB6ZT1uZXcgeGU7ZnVuY3Rpb24gQWUoKXt0aGlzLlNiPXRoaXMubmE9dGhpcy5MYj10aGlzLmthPXRoaXMueGE9ITE7dGhpcy5vYT0wO3RoaXMub2M9XCJcIjt0aGlzLmVjPW51bGw7dGhpcy5BYj1cIlwiO3RoaXMuYmM9bnVsbDt0aGlzLnliPVwiXCI7dGhpcy5nPU59dmFyIEJlPW5ldyBBZTtmdW5jdGlvbiBpZShhKXtyZXR1cm5cIlwiPT09YS5vYz9hLmthOlwibFwiPT09YS5vY31mdW5jdGlvbiBlZShhKXtIKGEua2EsXCJPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5lY31mdW5jdGlvbiBkZShhKXtIKGEua2EsXCJPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5MYj9hLkFiOlwiW01JTl9OQU1FXVwifWZ1bmN0aW9uIGdlKGEpe0goYS5uYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5iY31cbmZ1bmN0aW9uIGZlKGEpe0goYS5uYSxcIk9ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldFwiKTtyZXR1cm4gYS5TYj9hLnliOlwiW01BWF9OQU1FXVwifWZ1bmN0aW9uIENlKGEpe3ZhciBiPW5ldyBBZTtiLnhhPWEueGE7Yi5vYT1hLm9hO2Iua2E9YS5rYTtiLmVjPWEuZWM7Yi5MYj1hLkxiO2IuQWI9YS5BYjtiLm5hPWEubmE7Yi5iYz1hLmJjO2IuU2I9YS5TYjtiLnliPWEueWI7Yi5nPWEuZztyZXR1cm4gYn1nPUFlLnByb3RvdHlwZTtnLm1lPWZ1bmN0aW9uKGEpe3ZhciBiPUNlKHRoaXMpO2IueGE9ITA7Yi5vYT1hO2Iub2M9XCJsXCI7cmV0dXJuIGJ9O2cubmU9ZnVuY3Rpb24oYSl7dmFyIGI9Q2UodGhpcyk7Yi54YT0hMDtiLm9hPWE7Yi5vYz1cInJcIjtyZXR1cm4gYn07Zy5OZD1mdW5jdGlvbihhLGIpe3ZhciBjPUNlKHRoaXMpO2Mua2E9ITA7cChhKXx8KGE9bnVsbCk7Yy5lYz1hO251bGwhPWI/KGMuTGI9ITAsYy5BYj1iKTooYy5MYj0hMSxjLkFiPVwiXCIpO3JldHVybiBjfTtcbmcuZmQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1DZSh0aGlzKTtjLm5hPSEwO3AoYSl8fChhPW51bGwpO2MuYmM9YTtwKGIpPyhjLlNiPSEwLGMueWI9Yik6KGMuRGc9ITEsYy55Yj1cIlwiKTtyZXR1cm4gY307ZnVuY3Rpb24gRGUoYSxiKXt2YXIgYz1DZShhKTtjLmc9YjtyZXR1cm4gY31mdW5jdGlvbiBFZShhKXt2YXIgYj17fTthLmthJiYoYi5zcD1hLmVjLGEuTGImJihiLnNuPWEuQWIpKTthLm5hJiYoYi5lcD1hLmJjLGEuU2ImJihiLmVuPWEueWIpKTtpZihhLnhhKXtiLmw9YS5vYTt2YXIgYz1hLm9jO1wiXCI9PT1jJiYoYz1pZShhKT9cImxcIjpcInJcIik7Yi52Zj1jfWEuZyE9PU4mJihiLmk9YS5nLnRvU3RyaW5nKCkpO3JldHVybiBifWZ1bmN0aW9uIFMoYSl7cmV0dXJuIShhLmthfHxhLm5hfHxhLnhhKX1mdW5jdGlvbiB6ZChhKXtyZXR1cm4gUyhhKSYmYS5nPT1OfVxuZnVuY3Rpb24gQWQoYSl7dmFyIGI9e307aWYoemQoYSkpcmV0dXJuIGI7dmFyIGM7YS5nPT09Tj9jPVwiJHByaW9yaXR5XCI6YS5nPT09emU/Yz1cIiR2YWx1ZVwiOmEuZz09PWFlP2M9XCIka2V5XCI6KEgoYS5nIGluc3RhbmNlb2YgdGUsXCJVbnJlY29nbml6ZWQgaW5kZXggdHlwZSFcIiksYz1hLmcudG9TdHJpbmcoKSk7Yi5vcmRlckJ5PUIoYyk7YS5rYSYmKGIuc3RhcnRBdD1CKGEuZWMpLGEuTGImJihiLnN0YXJ0QXQrPVwiLFwiK0IoYS5BYikpKTthLm5hJiYoYi5lbmRBdD1CKGEuYmMpLGEuU2ImJihiLmVuZEF0Kz1cIixcIitCKGEueWIpKSk7YS54YSYmKGllKGEpP2IubGltaXRUb0ZpcnN0PWEub2E6Yi5saW1pdFRvTGFzdD1hLm9hKTtyZXR1cm4gYn1nLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIEIoRWUodGhpcykpfTtmdW5jdGlvbiBGZShhLGIpe3RoaXMub2Q9YTt0aGlzLmRjPWJ9RmUucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXt2YXIgYj14KHRoaXMub2QsYSk7aWYoIWIpdGhyb3cgRXJyb3IoXCJObyBpbmRleCBkZWZpbmVkIGZvciBcIithKTtyZXR1cm4gYj09PXJlP251bGw6Yn07ZnVuY3Rpb24gR2UoYSxiLGMpe3ZhciBkPW9hKGEub2QsZnVuY3Rpb24oZCxmKXt2YXIgaD14KGEuZGMsZik7SChoLFwiTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgXCIrZik7aWYoZD09PXJlKXtpZihoLnljKGIuUykpe2Zvcih2YXIgaz1bXSxtPWMuWGIoTmMpLGw9UihtKTtsOylsLm5hbWUhPWIubmFtZSYmay5wdXNoKGwpLGw9UihtKTtrLnB1c2goYik7cmV0dXJuIEhlKGssa2UoaCkpfXJldHVybiByZX1oPWMuZ2V0KGIubmFtZSk7az1kO2gmJihrPWsucmVtb3ZlKG5ldyBLKGIubmFtZSxoKSkpO3JldHVybiBrLlJhKGIsYi5TKX0pO3JldHVybiBuZXcgRmUoZCxhLmRjKX1cbmZ1bmN0aW9uIEllKGEsYixjKXt2YXIgZD1vYShhLm9kLGZ1bmN0aW9uKGEpe2lmKGE9PT1yZSlyZXR1cm4gYTt2YXIgZD1jLmdldChiLm5hbWUpO3JldHVybiBkP2EucmVtb3ZlKG5ldyBLKGIubmFtZSxkKSk6YX0pO3JldHVybiBuZXcgRmUoZCxhLmRjKX12YXIgSmU9bmV3IEZlKHtcIi5wcmlvcml0eVwiOnJlfSx7XCIucHJpb3JpdHlcIjpOfSk7ZnVuY3Rpb24gS2UoKXt0aGlzLnNldD17fX1nPUtlLnByb3RvdHlwZTtnLmFkZD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0W2FdPW51bGwhPT1iP2I6ITB9O2cuY29udGFpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIEJiKHRoaXMuc2V0LGEpfTtnLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jb250YWlucyhhKT90aGlzLnNldFthXTp2b2lkIDB9O2cucmVtb3ZlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLnNldFthXX07Zy5jbGVhcj1mdW5jdGlvbigpe3RoaXMuc2V0PXt9fTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4geGEodGhpcy5zZXQpfTtnLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHFhKHRoaXMuc2V0KX07ZnVuY3Rpb24gTGUoYSxiKXt0KGEuc2V0LGZ1bmN0aW9uKGEsZCl7YihkLGEpfSl9Zy5rZXlzPWZ1bmN0aW9uKCl7dmFyIGE9W107dCh0aGlzLnNldCxmdW5jdGlvbihiLGMpe2EucHVzaChjKX0pO3JldHVybiBhfTtmdW5jdGlvbiBNZShhLGIsYyxkKXt0aGlzLlpkPWE7dGhpcy5mPWJkKGEpO3RoaXMua2M9Yjt0aGlzLnFiPXRoaXMucmI9MDt0aGlzLlhhPW9jKGIpO3RoaXMuemY9Yzt0aGlzLnhjPSExO3RoaXMuRGI9ZDt0aGlzLlljPWZ1bmN0aW9uKGEpe3JldHVybiBoYyhiLFwibG9uZ19wb2xsaW5nXCIsYSl9fXZhciBOZSxPZTtcbk1lLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy5PZT0wO3RoaXMuamE9Yjt0aGlzLmRmPW5ldyBRYihhKTt0aGlzLkJiPSExO3ZhciBjPXRoaXM7dGhpcy50Yj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mKFwiVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LlwiKTtjLmZiKCk7Yy50Yj1udWxsfSxNYXRoLmZsb29yKDNFNCkpO2dkKGZ1bmN0aW9uKCl7aWYoIWMuQmIpe2MuV2E9bmV3IFBlKGZ1bmN0aW9uKGEsYixkLGssbSl7UWUoYyxhcmd1bWVudHMpO2lmKGMuV2EpaWYoYy50YiYmKGNsZWFyVGltZW91dChjLnRiKSxjLnRiPW51bGwpLGMueGM9ITAsXCJzdGFydFwiPT1hKWMuaWQ9YixjLmtmPWQ7ZWxzZSBpZihcImNsb3NlXCI9PT1hKWI/KGMuV2EuS2Q9ITEsUmIoYy5kZixiLGZ1bmN0aW9uKCl7Yy5mYigpfSkpOmMuZmIoKTtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6IFwiK2EpO30sZnVuY3Rpb24oYSxiKXtRZShjLGFyZ3VtZW50cyk7XG5TYihjLmRmLGEsYil9LGZ1bmN0aW9uKCl7Yy5mYigpfSxjLlljKTt2YXIgYT17c3RhcnQ6XCJ0XCJ9O2Euc2VyPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO2MuV2EuUWQmJihhLmNiPWMuV2EuUWQpO2Eudj1cIjVcIjtjLnpmJiYoYS5zPWMuemYpO2MuRGImJihhLmxzPWMuRGIpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2E9Yy5ZYyhhKTtjLmYoXCJDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gXCIrYSk7UmUoYy5XYSxhLGZ1bmN0aW9uKCl7fSl9fSl9O1xuTWUucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5XYSxiPXRoaXMua2Y7YS5kZz10aGlzLmlkO2EuZWc9Yjtmb3IoYS5VZD0hMDtTZShhKTspO2E9dGhpcy5pZDtiPXRoaXMua2Y7dGhpcy5nYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3ZhciBjPXtkZnJhbWU6XCJ0XCJ9O2MuaWQ9YTtjLnB3PWI7dGhpcy5nYy5zcmM9dGhpcy5ZYyhjKTt0aGlzLmdjLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmdjKX07XG5NZS5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiBOZXx8IU9lJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZudWxsIT1kb2N1bWVudC5jcmVhdGVFbGVtZW50JiYhKFwib2JqZWN0XCI9PT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY2hyb21lJiZ3aW5kb3cuY2hyb21lLmV4dGVuc2lvbiYmIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkmJiEoXCJvYmplY3RcIj09PXR5cGVvZiBXaW5kb3dzJiZcIm9iamVjdFwiPT09dHlwZW9mIFdpbmRvd3MuQWcpJiYhMH07Zz1NZS5wcm90b3R5cGU7Zy5zZD1mdW5jdGlvbigpe307Zy5UYz1mdW5jdGlvbigpe3RoaXMuQmI9ITA7dGhpcy5XYSYmKHRoaXMuV2EuY2xvc2UoKSx0aGlzLldhPW51bGwpO3RoaXMuZ2MmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZ2MpLHRoaXMuZ2M9bnVsbCk7dGhpcy50YiYmKGNsZWFyVGltZW91dCh0aGlzLnRiKSx0aGlzLnRiPW51bGwpfTtcbmcuZmI9ZnVuY3Rpb24oKXt0aGlzLkJifHwodGhpcy5mKFwiTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5UYygpLHRoaXMuamEmJih0aGlzLmphKHRoaXMueGMpLHRoaXMuamE9bnVsbCkpfTtnLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5CYnx8KHRoaXMuZihcIkxvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC5cIiksdGhpcy5UYygpKX07Zy5zZW5kPWZ1bmN0aW9uKGEpe2E9QihhKTt0aGlzLnJiKz1hLmxlbmd0aDtsYyh0aGlzLlhhLFwiYnl0ZXNfc2VudFwiLGEubGVuZ3RoKTthPU1iKGEpO2E9YWIoYSwhMCk7YT1rZChhLDE4NDApO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLldhO2MuUWMucHVzaCh7c2c6dGhpcy5PZSx5ZzphLmxlbmd0aCxRZTphW2JdfSk7Yy5VZCYmU2UoYyk7dGhpcy5PZSsrfX07ZnVuY3Rpb24gUWUoYSxiKXt2YXIgYz1CKGIpLmxlbmd0aDthLnFiKz1jO2xjKGEuWGEsXCJieXRlc19yZWNlaXZlZFwiLGMpfVxuZnVuY3Rpb24gUGUoYSxiLGMsZCl7dGhpcy5ZYz1kO3RoaXMua2I9Yzt0aGlzLnVlPW5ldyBLZTt0aGlzLlFjPVtdO3RoaXMuJGQ9TWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7dGhpcy5LZD0hMDt0aGlzLlFkPVZjKCk7d2luZG93W1wicExQQ29tbWFuZFwiK3RoaXMuUWRdPWE7d2luZG93W1wicFJUTFBDQlwiK3RoaXMuUWRdPWI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtpZihkb2N1bWVudC5ib2R5KXtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO3RyeXthLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnR8fEUoXCJObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZFwiKX1jYXRjaChlKXthLnNyYz1cImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIitkb2N1bWVudC5kb21haW4rXCInO2RvY3VtZW50LmNsb3NlKCk7fSkoKSlcIn19ZWxzZSB0aHJvd1wiRG9jdW1lbnQgYm9keSBoYXMgbm90IGluaXRpYWxpemVkLiBXYWl0IHRvIGluaXRpYWxpemUgRmlyZWJhc2UgdW50aWwgYWZ0ZXIgdGhlIGRvY3VtZW50IGlzIHJlYWR5LlwiO1xuYS5jb250ZW50RG9jdW1lbnQ/YS5pYj1hLmNvbnRlbnREb2N1bWVudDphLmNvbnRlbnRXaW5kb3c/YS5pYj1hLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6YS5kb2N1bWVudCYmKGEuaWI9YS5kb2N1bWVudCk7dGhpcy5HYT1hO2E9XCJcIjt0aGlzLkdhLnNyYyYmXCJqYXZhc2NyaXB0OlwiPT09dGhpcy5HYS5zcmMuc3Vic3RyKDAsMTEpJiYoYT0nPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInK2RvY3VtZW50LmRvbWFpbisnXCI7XFx4M2Mvc2NyaXB0PicpO2E9XCI8aHRtbD48Ym9keT5cIithK1wiPC9ib2R5PjwvaHRtbD5cIjt0cnl7dGhpcy5HYS5pYi5vcGVuKCksdGhpcy5HYS5pYi53cml0ZShhKSx0aGlzLkdhLmliLmNsb3NlKCl9Y2F0Y2goZil7RShcImZyYW1lIHdyaXRpbmcgZXhjZXB0aW9uXCIpLGYuc3RhY2smJkUoZi5zdGFjayksRShmKX19XG5QZS5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLlVkPSExO2lmKHRoaXMuR2Epe3RoaXMuR2EuaWIuYm9keS5pbm5lckhUTUw9XCJcIjt2YXIgYT10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtudWxsIT09YS5HYSYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYS5HYSksYS5HYT1udWxsKX0sTWF0aC5mbG9vcigwKSl9dmFyIGI9dGhpcy5rYjtiJiYodGhpcy5rYj1udWxsLGIoKSl9O1xuZnVuY3Rpb24gU2UoYSl7aWYoYS5VZCYmYS5LZCYmYS51ZS5jb3VudCgpPCgwPGEuUWMubGVuZ3RoPzI6MSkpe2EuJGQrKzt2YXIgYj17fTtiLmlkPWEuZGc7Yi5wdz1hLmVnO2Iuc2VyPWEuJGQ7Zm9yKHZhciBiPWEuWWMoYiksYz1cIlwiLGQ9MDswPGEuUWMubGVuZ3RoOylpZigxODcwPj1hLlFjWzBdLlFlLmxlbmd0aCszMCtjLmxlbmd0aCl7dmFyIGU9YS5RYy5zaGlmdCgpLGM9YytcIiZzZWdcIitkK1wiPVwiK2Uuc2crXCImdHNcIitkK1wiPVwiK2UueWcrXCImZFwiK2QrXCI9XCIrZS5RZTtkKyt9ZWxzZSBicmVhaztUZShhLGIrYyxhLiRkKTtyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBUZShhLGIsYyl7ZnVuY3Rpb24gZCgpe2EudWUucmVtb3ZlKGMpO1NlKGEpfWEudWUuYWRkKGMsMSk7dmFyIGU9c2V0VGltZW91dChkLE1hdGguZmxvb3IoMjVFMykpO1JlKGEsYixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlKTtkKCl9KX1cbmZ1bmN0aW9uIFJlKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e2lmKGEuS2Qpe3ZhciBkPWEuR2EuaWIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmFzeW5jPSEwO2Quc3JjPWI7ZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT1kLnJlYWR5U3RhdGU7YSYmXCJsb2FkZWRcIiE9PWEmJlwiY29tcGxldGVcIiE9PWF8fChkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGQucGFyZW50Tm9kZSYmZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGMoKSl9O2Qub25lcnJvcj1mdW5jdGlvbigpe0UoXCJMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiBcIitiKTthLktkPSExO2EuY2xvc2UoKX07YS5HYS5pYi5ib2R5LmFwcGVuZENoaWxkKGQpfX1jYXRjaChlKXt9fSxNYXRoLmZsb29yKDEpKX07ZnVuY3Rpb24gVWUoYSl7VmUodGhpcyxhKX12YXIgV2U9W01lLHJkXTtmdW5jdGlvbiBWZShhLGIpe3ZhciBjPXJkJiZyZC5pc0F2YWlsYWJsZSgpLGQ9YyYmIShYYi5hZnx8ITA9PT1YYi5nZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKSk7Yi56ZyYmKGN8fE8oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpLGQ9ITApO2lmKGQpYS5XYz1bcmRdO2Vsc2V7dmFyIGU9YS5XYz1bXTtsZChXZSxmdW5jdGlvbihhLGIpe2ImJmIuaXNBdmFpbGFibGUoKSYmZS5wdXNoKGIpfSl9fWZ1bmN0aW9uIFhlKGEpe2lmKDA8YS5XYy5sZW5ndGgpcmV0dXJuIGEuV2NbMF07dGhyb3cgRXJyb3IoXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTt9O2Z1bmN0aW9uIFllKGEsYixjLGQsZSxmLGgpe3RoaXMuaWQ9YTt0aGlzLmY9YmQoXCJjOlwiK3RoaXMuaWQrXCI6XCIpO3RoaXMuc2U9Yzt0aGlzLk1jPWQ7dGhpcy5qYT1lO3RoaXMucmU9Zjt0aGlzLk09Yjt0aGlzLkFkPVtdO3RoaXMuTWU9MDt0aGlzLnlmPW5ldyBVZShiKTt0aGlzLkw9MDt0aGlzLkRiPWg7dGhpcy5mKFwiQ29ubmVjdGlvbiBjcmVhdGVkXCIpO1plKHRoaXMpfVxuZnVuY3Rpb24gWmUoYSl7dmFyIGI9WGUoYS55Zik7YS5JPW5ldyBiKFwiYzpcIithLmlkK1wiOlwiK2EuTWUrKyxhLk0sdm9pZCAwLGEuRGIpO2Eud2U9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO3ZhciBjPSRlKGEsYS5JKSxkPWFmKGEsYS5JKTthLlhjPWEuSTthLlJjPWEuSTthLkQ9bnVsbDthLkNiPSExO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkkmJmEuSS5vcGVuKGMsZCl9LE1hdGguZmxvb3IoMCkpO2I9Yi5oZWFsdGh5VGltZW91dHx8MDswPGImJihhLm1kPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLm1kPW51bGw7YS5DYnx8KGEuSSYmMTAyNDAwPGEuSS5xYj8oYS5mKFwiQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCBcIithLkkucWIrXCIgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS5cIiksYS5DYj0hMCxhLkkuc2QoKSk6YS5JJiYxMDI0MDxhLkkucmI/YS5mKFwiQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyBzZW50IFwiK1xuYS5JLnJiK1wiIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLlwiKTooYS5mKFwiQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LlwiKSxhLmNsb3NlKCkpKX0sTWF0aC5mbG9vcihiKSkpfWZ1bmN0aW9uIGFmKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2I9PT1hLkk/KGEuST1udWxsLGN8fDAhPT1hLkw/MT09PWEuTCYmYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LlwiKTooYS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuXCIpLFwicy1cIj09PWEuTS5iYi5zdWJzdHIoMCwyKSYmKFhiLnJlbW92ZShcImhvc3Q6XCIrYS5NLmhvc3QpLGEuTS5iYj1hLk0uaG9zdCkpLGEuY2xvc2UoKSk6Yj09PWEuRD8oYS5mKFwiU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC5cIiksYz1hLkQsYS5EPW51bGwsYS5YYyE9PWMmJmEuUmMhPT1jfHxhLmNsb3NlKCkpOmEuZihcImNsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb25cIil9fVxuZnVuY3Rpb24gJGUoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoMiE9YS5MKWlmKGI9PT1hLlJjKXt2YXIgZD1pZChcInRcIixjKTtjPWlkKFwiZFwiLGMpO2lmKFwiY1wiPT1kKXtpZihkPWlkKFwidFwiLGMpLFwiZFwiaW4gYylpZihjPWMuZCxcImhcIj09PWQpe3ZhciBkPWMudHMsZT1jLnYsZj1jLmg7YS53Zj1jLnM7Z2MoYS5NLGYpOzA9PWEuTCYmKGEuSS5zdGFydCgpLGJmKGEsYS5JLGQpLFwiNVwiIT09ZSYmTyhcIlByb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWRcIiksYz1hLnlmLChjPTE8Yy5XYy5sZW5ndGg/Yy5XY1sxXTpudWxsKSYmY2YoYSxjKSl9ZWxzZSBpZihcIm5cIj09PWQpe2EuZihcInJlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKTthLlJjPWEuRDtmb3IoYz0wO2M8YS5BZC5sZW5ndGg7KytjKWEud2QoYS5BZFtjXSk7YS5BZD1bXTtkZihhKX1lbHNlXCJzXCI9PT1kPyhhLmYoXCJDb25uZWN0aW9uIHNodXRkb3duIGNvbW1hbmQgcmVjZWl2ZWQuIFNodXR0aW5nIGRvd24uLi5cIiksXG5hLnJlJiYoYS5yZShjKSxhLnJlPW51bGwpLGEuamE9bnVsbCxhLmNsb3NlKCkpOlwiclwiPT09ZD8oYS5mKFwiUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6IFwiK2MpLGdjKGEuTSxjKSwxPT09YS5MP2EuY2xvc2UoKTooZWYoYSksWmUoYSkpKTpcImVcIj09PWQ/Y2QoXCJTZXJ2ZXIgRXJyb3I6IFwiK2MpOlwib1wiPT09ZD8oYS5mKFwiZ290IHBvbmcgb24gcHJpbWFyeS5cIiksZmYoYSksZ2YoYSkpOmNkKFwiVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiBcIitkKX1lbHNlXCJkXCI9PWQmJmEud2QoYyl9ZWxzZSBpZihiPT09YS5EKWlmKGQ9aWQoXCJ0XCIsYyksYz1pZChcImRcIixjKSxcImNcIj09ZClcInRcImluIGMmJihjPWMudCxcImFcIj09PWM/aGYoYSk6XCJyXCI9PT1jPyhhLmYoXCJHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXRcIiksYS5ELmNsb3NlKCksYS5YYyE9PWEuRCYmYS5SYyE9PWEuRHx8YS5jbG9zZSgpKTpcIm9cIj09PWMmJihhLmYoXCJnb3QgcG9uZyBvbiBzZWNvbmRhcnkuXCIpLFxuYS51Zi0tLGhmKGEpKSk7ZWxzZSBpZihcImRcIj09ZClhLkFkLnB1c2goYyk7ZWxzZSB0aHJvdyBFcnJvcihcIlVua25vd24gcHJvdG9jb2wgbGF5ZXI6IFwiK2QpO2Vsc2UgYS5mKFwibWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvblwiKX19WWUucHJvdG90eXBlLnVhPWZ1bmN0aW9uKGEpe2pmKHRoaXMse3Q6XCJkXCIsZDphfSl9O2Z1bmN0aW9uIGRmKGEpe2EuWGM9PT1hLkQmJmEuUmM9PT1hLkQmJihhLmYoXCJjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogXCIrYS5ELlpkKSxhLkk9YS5ELGEuRD1udWxsKX1cbmZ1bmN0aW9uIGhmKGEpezA+PWEudWY/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEuQ2I9ITAsYS5ELnNkKCksYS5ELnN0YXJ0KCksYS5mKFwic2VuZGluZyBjbGllbnQgYWNrIG9uIHNlY29uZGFyeVwiKSxhLkQuc2VuZCh7dDpcImNcIixkOnt0OlwiYVwiLGQ6e319fSksYS5mKFwiRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5XCIpLGEuSS5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJuXCIsZDp7fX19KSxhLlhjPWEuRCxkZihhKSk6KGEuZihcInNlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuXCIpLGEuRC5zZW5kKHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9WWUucHJvdG90eXBlLndkPWZ1bmN0aW9uKGEpe2ZmKHRoaXMpO3RoaXMuc2UoYSl9O2Z1bmN0aW9uIGZmKGEpe2EuQ2J8fChhLndlLS0sMD49YS53ZSYmKGEuZihcIlByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLkNiPSEwLGEuSS5zZCgpKSl9XG5mdW5jdGlvbiBjZihhLGIpe2EuRD1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLk1lKyssYS5NLGEud2YpO2EudWY9Yi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5fHwwO2EuRC5vcGVuKCRlKGEsYS5EKSxhZihhLGEuRCkpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLkQmJihhLmYoXCJUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuXCIpLGEuRC5jbG9zZSgpKX0sTWF0aC5mbG9vcig2RTQpKX1mdW5jdGlvbiBiZihhLGIsYyl7YS5mKFwiUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC5cIik7YS5JPWI7YS5MPTE7YS5NYyYmKGEuTWMoYyxhLndmKSxhLk1jPW51bGwpOzA9PT1hLndlPyhhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5DYj0hMCk6c2V0VGltZW91dChmdW5jdGlvbigpe2dmKGEpfSxNYXRoLmZsb29yKDVFMykpfVxuZnVuY3Rpb24gZ2YoYSl7YS5DYnx8MSE9PWEuTHx8KGEuZihcInNlbmRpbmcgcGluZyBvbiBwcmltYXJ5LlwiKSxqZihhLHt0OlwiY1wiLGQ6e3Q6XCJwXCIsZDp7fX19KSl9ZnVuY3Rpb24gamYoYSxiKXtpZigxIT09YS5MKXRocm93XCJDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWRcIjthLlhjLnNlbmQoYil9WWUucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7MiE9PXRoaXMuTCYmKHRoaXMuZihcIkNsb3NpbmcgcmVhbHRpbWUgY29ubmVjdGlvbi5cIiksdGhpcy5MPTIsZWYodGhpcyksdGhpcy5qYSYmKHRoaXMuamEoKSx0aGlzLmphPW51bGwpKX07ZnVuY3Rpb24gZWYoYSl7YS5mKFwiU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnNcIik7YS5JJiYoYS5JLmNsb3NlKCksYS5JPW51bGwpO2EuRCYmKGEuRC5jbG9zZSgpLGEuRD1udWxsKTthLm1kJiYoY2xlYXJUaW1lb3V0KGEubWQpLGEubWQ9bnVsbCl9O2Z1bmN0aW9uIEwoYSxiKXtpZigxPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLm89YS5zcGxpdChcIi9cIik7Zm9yKHZhciBjPTAsZD0wO2Q8dGhpcy5vLmxlbmd0aDtkKyspMDx0aGlzLm9bZF0ubGVuZ3RoJiYodGhpcy5vW2NdPXRoaXMub1tkXSxjKyspO3RoaXMuby5sZW5ndGg9Yzt0aGlzLlo9MH1lbHNlIHRoaXMubz1hLHRoaXMuWj1ifWZ1bmN0aW9uIFQoYSxiKXt2YXIgYz1KKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGM9PT1KKGIpKXJldHVybiBUKEQoYSksRChiKSk7dGhyb3cgRXJyb3IoXCJJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoIChcIitiK1wiKSBpcyBub3Qgd2l0aGluIG91dGVyUGF0aCAoXCIrYStcIilcIik7fVxuZnVuY3Rpb24ga2YoYSxiKXtmb3IodmFyIGM9YS5zbGljZSgpLGQ9Yi5zbGljZSgpLGU9MDtlPGMubGVuZ3RoJiZlPGQubGVuZ3RoO2UrKyl7dmFyIGY9TGMoY1tlXSxkW2VdKTtpZigwIT09ZilyZXR1cm4gZn1yZXR1cm4gYy5sZW5ndGg9PT1kLmxlbmd0aD8wOmMubGVuZ3RoPGQubGVuZ3RoPy0xOjF9ZnVuY3Rpb24gSihhKXtyZXR1cm4gYS5aPj1hLm8ubGVuZ3RoP251bGw6YS5vW2EuWl19ZnVuY3Rpb24gV2QoYSl7cmV0dXJuIGEuby5sZW5ndGgtYS5afWZ1bmN0aW9uIEQoYSl7dmFyIGI9YS5aO2I8YS5vLmxlbmd0aCYmYisrO3JldHVybiBuZXcgTChhLm8sYil9ZnVuY3Rpb24gWGQoYSl7cmV0dXJuIGEuWjxhLm8ubGVuZ3RoP2Eub1thLm8ubGVuZ3RoLTFdOm51bGx9Zz1MLnByb3RvdHlwZTtcbmcudG9TdHJpbmc9ZnVuY3Rpb24oKXtmb3IodmFyIGE9XCJcIixiPXRoaXMuWjtiPHRoaXMuby5sZW5ndGg7YisrKVwiXCIhPT10aGlzLm9bYl0mJihhKz1cIi9cIit0aGlzLm9bYl0pO3JldHVybiBhfHxcIi9cIn07Zy5zbGljZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vLnNsaWNlKHRoaXMuWisoYXx8MCkpfTtnLnBhcmVudD1mdW5jdGlvbigpe2lmKHRoaXMuWj49dGhpcy5vLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGE9W10sYj10aGlzLlo7Yjx0aGlzLm8ubGVuZ3RoLTE7YisrKWEucHVzaCh0aGlzLm9bYl0pO3JldHVybiBuZXcgTChhLDApfTtcbmcubT1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz10aGlzLlo7Yzx0aGlzLm8ubGVuZ3RoO2MrKyliLnB1c2godGhpcy5vW2NdKTtpZihhIGluc3RhbmNlb2YgTClmb3IoYz1hLlo7YzxhLm8ubGVuZ3RoO2MrKyliLnB1c2goYS5vW2NdKTtlbHNlIGZvcihhPWEuc3BsaXQoXCIvXCIpLGM9MDtjPGEubGVuZ3RoO2MrKykwPGFbY10ubGVuZ3RoJiZiLnB1c2goYVtjXSk7cmV0dXJuIG5ldyBMKGIsMCl9O2cuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLlo+PXRoaXMuby5sZW5ndGh9O2cuY2E9ZnVuY3Rpb24oYSl7aWYoV2QodGhpcykhPT1XZChhKSlyZXR1cm4hMTtmb3IodmFyIGI9dGhpcy5aLGM9YS5aO2I8PXRoaXMuby5sZW5ndGg7YisrLGMrKylpZih0aGlzLm9bYl0hPT1hLm9bY10pcmV0dXJuITE7cmV0dXJuITB9O1xuZy5jb250YWlucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLlosYz1hLlo7aWYoV2QodGhpcyk+V2QoYSkpcmV0dXJuITE7Zm9yKDtiPHRoaXMuby5sZW5ndGg7KXtpZih0aGlzLm9bYl0hPT1hLm9bY10pcmV0dXJuITE7KytiOysrY31yZXR1cm4hMH07dmFyIEM9bmV3IEwoXCJcIik7ZnVuY3Rpb24gbGYoYSxiKXt0aGlzLlRhPWEuc2xpY2UoKTt0aGlzLkthPU1hdGgubWF4KDEsdGhpcy5UYS5sZW5ndGgpO3RoaXMuUmU9Yjtmb3IodmFyIGM9MDtjPHRoaXMuVGEubGVuZ3RoO2MrKyl0aGlzLkthKz1OYih0aGlzLlRhW2NdKTttZih0aGlzKX1sZi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihhKXswPHRoaXMuVGEubGVuZ3RoJiYodGhpcy5LYSs9MSk7dGhpcy5UYS5wdXNoKGEpO3RoaXMuS2ErPU5iKGEpO21mKHRoaXMpfTtsZi5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5UYS5wb3AoKTt0aGlzLkthLT1OYihhKTswPHRoaXMuVGEubGVuZ3RoJiYtLXRoaXMuS2F9O1xuZnVuY3Rpb24gbWYoYSl7aWYoNzY4PGEuS2EpdGhyb3cgRXJyb3IoYS5SZStcImhhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuIDc2OCBieXRlcyAoXCIrYS5LYStcIikuXCIpO2lmKDMyPGEuVGEubGVuZ3RoKXRocm93IEVycm9yKGEuUmUrXCJwYXRoIHNwZWNpZmllZCBleGNlZWRzIHRoZSBtYXhpbXVtIGRlcHRoIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKDMyKSBvciBvYmplY3QgY29udGFpbnMgYSBjeWNsZSBcIituZihhKSk7fWZ1bmN0aW9uIG5mKGEpe3JldHVybiAwPT1hLlRhLmxlbmd0aD9cIlwiOlwiaW4gcHJvcGVydHkgJ1wiK2EuVGEuam9pbihcIi5cIikrXCInXCJ9O2Z1bmN0aW9uIG9mKGEpe2EgaW5zdGFuY2VvZiBwZnx8ZGQoXCJEb24ndCBjYWxsIG5ldyBEYXRhYmFzZSgpIGRpcmVjdGx5IC0gcGxlYXNlIHVzZSBmaXJlYmFzZS5kYXRhYmFzZSgpLlwiKTt0aGlzLnRhPWE7dGhpcy5iYT1uZXcgVShhLEMpO3RoaXMuSU5URVJOQUw9bmV3IHFmKHRoaXMpfXZhciByZj17VElNRVNUQU1QOntcIi5zdlwiOlwidGltZXN0YW1wXCJ9fTtnPW9mLnByb3RvdHlwZTtnLmFwcD1udWxsO2cubmY9ZnVuY3Rpb24oYSl7c2YodGhpcyxcInJlZlwiKTt5KFwiZGF0YWJhc2UucmVmXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiBwKGEpP3RoaXMuYmEubShhKTp0aGlzLmJhfTtcbmcucGc9ZnVuY3Rpb24oYSl7c2YodGhpcyxcImRhdGFiYXNlLnJlZkZyb21VUkxcIik7eShcImRhdGFiYXNlLnJlZkZyb21VUkxcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7dmFyIGI9ZWQoYSk7dGYoXCJkYXRhYmFzZS5yZWZGcm9tVVJMXCIsYik7dmFyIGM9Yi5rYztjLmhvc3QhPT10aGlzLnRhLk0uaG9zdCYmZGQoXCJkYXRhYmFzZS5yZWZGcm9tVVJMOiBIb3N0IG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgZGF0YWJhc2U6IChmb3VuZCBcIitjLmhvc3QrXCIgYnV0IGV4cGVjdGVkIFwiK3RoaXMudGEuTS5ob3N0K1wiKVwiKTtyZXR1cm4gdGhpcy5uZihiLnBhdGgudG9TdHJpbmcoKSl9O2Z1bmN0aW9uIHNmKGEsYil7bnVsbD09PWEudGEmJmRkKFwiQ2Fubm90IGNhbGwgXCIrYitcIiBvbiBhIGRlbGV0ZWQgZGF0YWJhc2UuXCIpfWcuWWY9ZnVuY3Rpb24oKXt5KFwiZGF0YWJhc2UuZ29PZmZsaW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3NmKHRoaXMsXCJnb09mZmxpbmVcIik7dGhpcy50YS5lYigpfTtcbmcuWmY9ZnVuY3Rpb24oKXt5KFwiZGF0YWJhc2UuZ29PbmxpbmVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7c2YodGhpcyxcImdvT25saW5lXCIpO3RoaXMudGEubGMoKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KG9mLnByb3RvdHlwZSxcImFwcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YS5hcHB9fSk7ZnVuY3Rpb24gcWYoYSl7dGhpcy4kYT1hfXFmLnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24oKXtzZih0aGlzLiRhLFwiZGVsZXRlXCIpO3ZhciBhPXVmLldiKCksYj10aGlzLiRhLnRhO3goYS5uYixiLmFwcC5uYW1lKSE9PWImJmRkKFwiRGF0YWJhc2UgXCIrYi5hcHAubmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQuXCIpO2IuZWIoKTtkZWxldGUgYS5uYltiLmFwcC5uYW1lXTt0aGlzLiRhLnRhPW51bGw7dGhpcy4kYS5iYT1udWxsO3RoaXMuJGE9dGhpcy4kYS5JTlRFUk5BTD1udWxsO3JldHVybiBQcm9taXNlLnJlc29sdmUoKX07b2YucHJvdG90eXBlLnJlZj1vZi5wcm90b3R5cGUubmY7XG5vZi5wcm90b3R5cGUucmVmRnJvbVVSTD1vZi5wcm90b3R5cGUucGc7b2YucHJvdG90eXBlLmdvT25saW5lPW9mLnByb3RvdHlwZS5aZjtvZi5wcm90b3R5cGUuZ29PZmZsaW5lPW9mLnByb3RvdHlwZS5ZZjtxZi5wcm90b3R5cGVbXCJkZWxldGVcIl09cWYucHJvdG90eXBlLmRlbGV0ZTtmdW5jdGlvbiBRYygpe3RoaXMuaz10aGlzLkI9bnVsbH1RYy5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLkIpcmV0dXJuIHRoaXMuQi5RKGEpO2lmKGEuZSgpfHxudWxsPT10aGlzLmspcmV0dXJuIG51bGw7dmFyIGI9SihhKTthPUQoYSk7cmV0dXJuIHRoaXMuay5jb250YWlucyhiKT90aGlzLmsuZ2V0KGIpLmZpbmQoYSk6bnVsbH07ZnVuY3Rpb24gU2MoYSxiLGMpe2lmKGIuZSgpKWEuQj1jLGEuaz1udWxsO2Vsc2UgaWYobnVsbCE9PWEuQilhLkI9YS5CLkYoYixjKTtlbHNle251bGw9PWEuayYmKGEuaz1uZXcgS2UpO3ZhciBkPUooYik7YS5rLmNvbnRhaW5zKGQpfHxhLmsuYWRkKGQsbmV3IFFjKTthPWEuay5nZXQoZCk7Yj1EKGIpO1NjKGEsYixjKX19XG5mdW5jdGlvbiB2ZihhLGIpe2lmKGIuZSgpKXJldHVybiBhLkI9bnVsbCxhLms9bnVsbCwhMDtpZihudWxsIT09YS5CKXtpZihhLkIuSigpKXJldHVybiExO3ZhciBjPWEuQjthLkI9bnVsbDtjLlAoTixmdW5jdGlvbihiLGMpe1NjKGEsbmV3IEwoYiksYyl9KTtyZXR1cm4gdmYoYSxiKX1yZXR1cm4gbnVsbCE9PWEuaz8oYz1KKGIpLGI9RChiKSxhLmsuY29udGFpbnMoYykmJnZmKGEuay5nZXQoYyksYikmJmEuay5yZW1vdmUoYyksYS5rLmUoKT8oYS5rPW51bGwsITApOiExKTohMH1mdW5jdGlvbiBSYyhhLGIsYyl7bnVsbCE9PWEuQj9jKGIsYS5CKTphLlAoZnVuY3Rpb24oYSxlKXt2YXIgZj1uZXcgTChiLnRvU3RyaW5nKCkrXCIvXCIrYSk7UmMoZSxmLGMpfSl9UWMucHJvdG90eXBlLlA9ZnVuY3Rpb24oYSl7bnVsbCE9PXRoaXMuayYmTGUodGhpcy5rLGZ1bmN0aW9uKGIsYyl7YShiLGMpfSl9O3ZhciB3Zj0vW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLyx4Zj0vW1xcW1xcXS4jJFxcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztmdW5jdGlvbiB5ZihhKXtyZXR1cm4gcShhKSYmMCE9PWEubGVuZ3RoJiYhd2YudGVzdChhKX1mdW5jdGlvbiB6ZihhKXtyZXR1cm4gbnVsbD09PWF8fHEoYSl8fGZhKGEpJiYhZmQoYSl8fGhhKGEpJiZCYihhLFwiLnN2XCIpfWZ1bmN0aW9uIEFmKGEsYixjLGQpe2QmJiFwKGIpfHxCZihEYihhLDEsZCksYixjKX1cbmZ1bmN0aW9uIEJmKGEsYixjKXtjIGluc3RhbmNlb2YgTCYmKGM9bmV3IGxmKGMsYSkpO2lmKCFwKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyB1bmRlZmluZWQgXCIrbmYoYykpO2lmKGdhKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIGZ1bmN0aW9uIFwiK25mKGMpK1wiIHdpdGggY29udGVudHM6IFwiK2IudG9TdHJpbmcoKSk7aWYoZmQoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIFwiK2IudG9TdHJpbmcoKStcIiBcIituZihjKSk7aWYocShiKSYmYi5sZW5ndGg+MTA0ODU3NjAvMyYmMTA0ODU3NjA8TmIoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAxMDQ4NTc2MCB1dGY4IGJ5dGVzIFwiK25mKGMpK1wiICgnXCIrYi5zdWJzdHJpbmcoMCw1MCkrXCIuLi4nKVwiKTtpZihoYShiKSl7dmFyIGQ9ITEsZT0hMTtDYihiLGZ1bmN0aW9uKGIsaCl7aWYoXCIudmFsdWVcIj09PWIpZD0hMDtlbHNlIGlmKFwiLnByaW9yaXR5XCIhPT1iJiZcIi5zdlwiIT09YiYmKGU9XG4hMCwheWYoYikpKXRocm93IEVycm9yKGErXCIgY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2IrXCIpIFwiK25mKGMpKycuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7Yy5wdXNoKGIpO0JmKGEsaCxjKTtjLnBvcCgpfSk7aWYoZCYmZSl0aHJvdyBFcnJvcihhKycgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCAnK25mKGMpK1wiIGluIGFkZGl0aW9uIHRvIGFjdHVhbCBjaGlsZHJlbi5cIik7fX1cbmZ1bmN0aW9uIENmKGEsYil7dmFyIGMsZDtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKXtkPWJbY107Zm9yKHZhciBlPWQuc2xpY2UoKSxmPTA7ZjxlLmxlbmd0aDtmKyspaWYoKFwiLnByaW9yaXR5XCIhPT1lW2ZdfHxmIT09ZS5sZW5ndGgtMSkmJiF5ZihlW2ZdKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2VbZl0rXCIpIGluIHBhdGggXCIrZC50b1N0cmluZygpKycuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTt9Yi5zb3J0KGtmKTtlPW51bGw7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl7ZD1iW2NdO2lmKG51bGwhPT1lJiZlLmNvbnRhaW5zKGQpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIHBhdGggXCIrZS50b1N0cmluZygpK1wiIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoIFwiK2QudG9TdHJpbmcoKSk7ZT1kfX1cbmZ1bmN0aW9uIERmKGEsYixjKXt2YXIgZD1EYihhLDEsITEpO2lmKCFoYShiKXx8ZGEoYikpdGhyb3cgRXJyb3IoZCtcIiBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLlwiKTt2YXIgZT1bXTtDYihiLGZ1bmN0aW9uKGEsYil7dmFyIGs9bmV3IEwoYSk7QmYoZCxiLGMubShrKSk7aWYoXCIucHJpb3JpdHlcIj09PVhkKGspJiYhemYoYikpdGhyb3cgRXJyb3IoZCtcImNvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIitrLnRvU3RyaW5nKCkrXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTtlLnB1c2goayl9KTtDZihkLGUpfVxuZnVuY3Rpb24gRWYoYSxiLGMpe2lmKGZkKGMpKXRocm93IEVycm9yKERiKGEsYiwhMSkrXCJpcyBcIitjLnRvU3RyaW5nKCkrXCIsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLlwiKTtpZighemYoYykpdGhyb3cgRXJyb3IoRGIoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO31cbmZ1bmN0aW9uIEZmKGEsYixjKXtpZighY3x8cChiKSlzd2l0Y2goYil7Y2FzZSBcInZhbHVlXCI6Y2FzZSBcImNoaWxkX2FkZGVkXCI6Y2FzZSBcImNoaWxkX3JlbW92ZWRcIjpjYXNlIFwiY2hpbGRfY2hhbmdlZFwiOmNhc2UgXCJjaGlsZF9tb3ZlZFwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoRGIoYSwxLGMpKydtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZTogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO319ZnVuY3Rpb24gR2YoYSxiKXtpZihwKGIpJiYheWYoYikpdGhyb3cgRXJyb3IoRGIoYSwyLCEwKSsnd2FzIGFuIGludmFsaWQga2V5OiBcIicrYisnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiKS4nKTt9XG5mdW5jdGlvbiBIZihhLGIpe2lmKCFxKGIpfHwwPT09Yi5sZW5ndGh8fHhmLnRlc3QoYikpdGhyb3cgRXJyb3IoRGIoYSwxLCExKSsnd2FzIGFuIGludmFsaWQgcGF0aDogXCInK2IrJ1wiLiBQYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7fWZ1bmN0aW9uIElmKGEsYil7aWYoXCIuaW5mb1wiPT09SihiKSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTt9XG5mdW5jdGlvbiB0ZihhLGIpe3ZhciBjPWIucGF0aC50b1N0cmluZygpLGQ7IShkPSFxKGIua2MuaG9zdCl8fDA9PT1iLmtjLmhvc3QubGVuZ3RofHwheWYoYi5rYy5vZSkpJiYoZD0wIT09Yy5sZW5ndGgpJiYoYyYmKGM9Yy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLyxcIi9cIikpLGQ9IShxKGMpJiYwIT09Yy5sZW5ndGgmJiF4Zi50ZXN0KGMpKSk7aWYoZCl0aHJvdyBFcnJvcihEYihhLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO307ZnVuY3Rpb24gVihhLGIpe3RoaXMudGE9YTt0aGlzLnFhPWJ9Vi5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKGEpe3koXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5jYW5jZWxcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDEsYSwhMCk7dmFyIGI9bmV3IEhiO3RoaXMudGEueGQodGhpcy5xYSxJYihiLGEpKTtyZXR1cm4gYi5yYX07Vi5wcm90b3R5cGUuY2FuY2VsPVYucHJvdG90eXBlLmNhbmNlbDtWLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7eShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnJlbW92ZVwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtJZihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnJlbW92ZVwiLHRoaXMucWEpO0EoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwxLGEsITApO3ZhciBiPW5ldyBIYjtKZih0aGlzLnRhLHRoaXMucWEsbnVsbCxJYihiLGEpKTtyZXR1cm4gYi5yYX07XG5WLnByb3RvdHlwZS5yZW1vdmU9Vi5wcm90b3R5cGUucmVtb3ZlO1YucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3koXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7SWYoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLnFhKTtBZihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsdGhpcy5xYSwhMSk7QShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLDIsYiwhMCk7dmFyIGM9bmV3IEhiO0pmKHRoaXMudGEsdGhpcy5xYSxhLEliKGMsYikpO3JldHVybiBjLnJhfTtWLnByb3RvdHlwZS5zZXQ9Vi5wcm90b3R5cGUuc2V0O1xuVi5wcm90b3R5cGUuS2I9ZnVuY3Rpb24oYSxiLGMpe3koXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7SWYoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLnFhKTtBZihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsdGhpcy5xYSwhMSk7RWYoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0EoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO3ZhciBkPW5ldyBIYjtLZih0aGlzLnRhLHRoaXMucWEsYSxiLEliKGQsYykpO3JldHVybiBkLnJhfTtWLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Vi5wcm90b3R5cGUuS2I7XG5WLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXt5KFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsdGhpcy5xYSk7aWYoZGEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO08oXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfURmKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsYSx0aGlzLnFhKTtBKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMixiLCEwKTtcbmM9bmV3IEhiO0xmKHRoaXMudGEsdGhpcy5xYSxhLEliKGMsYikpO3JldHVybiBjLnJhfTtWLnByb3RvdHlwZS51cGRhdGU9Vi5wcm90b3R5cGUudXBkYXRlO2Z1bmN0aW9uIE1mKGEpe0goZGEoYSkmJjA8YS5sZW5ndGgsXCJSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheVwiKTt0aGlzLklmPWE7dGhpcy5FYz17fX1NZi5wcm90b3R5cGUuRmU9ZnVuY3Rpb24oYSxiKXt2YXIgYztjPXRoaXMuRWNbYV18fFtdO3ZhciBkPWMubGVuZ3RoO2lmKDA8ZCl7Zm9yKHZhciBlPUFycmF5KGQpLGY9MDtmPGQ7ZisrKWVbZl09Y1tmXTtjPWV9ZWxzZSBjPVtdO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5KZS5hcHBseShjW2RdLlBhLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9O01mLnByb3RvdHlwZS5oYz1mdW5jdGlvbihhLGIsYyl7TmYodGhpcyxhKTt0aGlzLkVjW2FdPXRoaXMuRWNbYV18fFtdO3RoaXMuRWNbYV0ucHVzaCh7SmU6YixQYTpjfSk7KGE9dGhpcy5XZShhKSkmJmIuYXBwbHkoYyxhKX07XG5NZi5wcm90b3R5cGUuSmM9ZnVuY3Rpb24oYSxiLGMpe05mKHRoaXMsYSk7YT10aGlzLkVjW2FdfHxbXTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLkplPT09YiYmKCFjfHxjPT09YVtkXS5QYSkpe2Euc3BsaWNlKGQsMSk7YnJlYWt9fTtmdW5jdGlvbiBOZihhLGIpe0goT2EoYS5JZixmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9KSxcIlVua25vd24gZXZlbnQ6IFwiK2IpfTtmdW5jdGlvbiBPZigpe01mLmNhbGwodGhpcyxbXCJvbmxpbmVcIl0pO3RoaXMuaWM9ITA7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBhPXRoaXM7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIixmdW5jdGlvbigpe2EuaWN8fChhLmljPSEwLGEuRmUoXCJvbmxpbmVcIiwhMCkpfSwhMSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsZnVuY3Rpb24oKXthLmljJiYoYS5pYz0hMSxhLkZlKFwib25saW5lXCIsITEpKX0sITEpfX1rYShPZixNZik7T2YucHJvdG90eXBlLldlPWZ1bmN0aW9uKGEpe0goXCJvbmxpbmVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLmljXX07YmEoT2YpO2Z1bmN0aW9uIFBmKCl7TWYuY2FsbCh0aGlzLFtcInZpc2libGVcIl0pO3ZhciBhLGI7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyJiYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5oaWRkZW4/KGI9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cImhpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbj8oYj1cIm1venZpc2liaWxpdHljaGFuZ2VcIixhPVwibW96SGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4/KGI9XCJtc3Zpc2liaWxpdHljaGFuZ2VcIixhPVwibXNIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4mJihiPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJ3ZWJraXRIaWRkZW5cIikpO3RoaXMuTmI9ITA7aWYoYil7dmFyIGM9dGhpcztkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGIsXG5mdW5jdGlvbigpe3ZhciBiPSFkb2N1bWVudFthXTtiIT09Yy5OYiYmKGMuTmI9YixjLkZlKFwidmlzaWJsZVwiLGIpKX0sITEpfX1rYShQZixNZik7UGYucHJvdG90eXBlLldlPWZ1bmN0aW9uKGEpe0goXCJ2aXNpYmxlXCI9PT1hLFwiVW5rbm93biBldmVudCB0eXBlOiBcIithKTtyZXR1cm5bdGhpcy5OYl19O2JhKFBmKTt2YXIgUWY9ZnVuY3Rpb24oKXt2YXIgYT0wLGI9W107cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBkPWM9PT1hO2E9Yztmb3IodmFyIGU9QXJyYXkoOCksZj03OzA8PWY7Zi0tKWVbZl09XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGMlNjQpLGM9TWF0aC5mbG9vcihjLzY0KTtIKDA9PT1jLFwiQ2Fubm90IHB1c2ggYXQgdGltZSA9PSAwXCIpO2M9ZS5qb2luKFwiXCIpO2lmKGQpe2ZvcihmPTExOzA8PWYmJjYzPT09YltmXTtmLS0pYltmXT0wO2JbZl0rK31lbHNlIGZvcihmPTA7MTI+ZjtmKyspYltmXT1NYXRoLmZsb29yKDY0Kk1hdGgucmFuZG9tKCkpO2ZvcihmPTA7MTI+ZjtmKyspYys9XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGJbZl0pO0goMjA9PT1jLmxlbmd0aCxcIm5leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuXCIpO1xucmV0dXJuIGN9fSgpO2Z1bmN0aW9uIFJmKGEsYil7dGhpcy5PYT1hO3RoaXMuYmE9Yj9iOlNmfWc9UmYucHJvdG90eXBlO2cuUmE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IFJmKHRoaXMuT2EsdGhpcy5iYS5SYShhLGIsdGhpcy5PYSkuWShudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2cucmVtb3ZlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgUmYodGhpcy5PYSx0aGlzLmJhLnJlbW92ZShhLHRoaXMuT2EpLlkobnVsbCxudWxsLCExLG51bGwsbnVsbCkpfTtnLmdldD1mdW5jdGlvbihhKXtmb3IodmFyIGIsYz10aGlzLmJhOyFjLmUoKTspe2I9dGhpcy5PYShhLGMua2V5KTtpZigwPT09YilyZXR1cm4gYy52YWx1ZTswPmI/Yz1jLmxlZnQ6MDxiJiYoYz1jLnJpZ2h0KX1yZXR1cm4gbnVsbH07XG5mdW5jdGlvbiBUZihhLGIpe2Zvcih2YXIgYyxkPWEuYmEsZT1udWxsOyFkLmUoKTspe2M9YS5PYShiLGQua2V5KTtpZigwPT09Yyl7aWYoZC5sZWZ0LmUoKSlyZXR1cm4gZT9lLmtleTpudWxsO2ZvcihkPWQubGVmdDshZC5yaWdodC5lKCk7KWQ9ZC5yaWdodDtyZXR1cm4gZC5rZXl9MD5jP2Q9ZC5sZWZ0OjA8YyYmKGU9ZCxkPWQucmlnaHQpfXRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/XCIpO31nLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYS5lKCl9O2cuY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYS5jb3VudCgpfTtnLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmEuSGMoKX07Zy5mYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhLmZjKCl9O2cuaWE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYmEuaWEoYSl9O1xuZy5YYj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFVmKHRoaXMuYmEsbnVsbCx0aGlzLk9hLCExLGEpfTtnLlliPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBVZih0aGlzLmJhLGEsdGhpcy5PYSwhMSxiKX07Zy4kYj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgVWYodGhpcy5iYSxhLHRoaXMuT2EsITAsYil9O2cuWWU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBVZih0aGlzLmJhLG51bGwsdGhpcy5PYSwhMCxhKX07ZnVuY3Rpb24gVWYoYSxiLGMsZCxlKXt0aGlzLkhkPWV8fG51bGw7dGhpcy5rZT1kO3RoaXMuU2E9W107Zm9yKGU9MTshYS5lKCk7KWlmKGU9Yj9jKGEua2V5LGIpOjEsZCYmKGUqPS0xKSwwPmUpYT10aGlzLmtlP2EubGVmdDphLnJpZ2h0O2Vsc2UgaWYoMD09PWUpe3RoaXMuU2EucHVzaChhKTticmVha31lbHNlIHRoaXMuU2EucHVzaChhKSxhPXRoaXMua2U/YS5yaWdodDphLmxlZnR9XG5mdW5jdGlvbiBSKGEpe2lmKDA9PT1hLlNhLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYj1hLlNhLnBvcCgpLGM7Yz1hLkhkP2EuSGQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfTtpZihhLmtlKWZvcihiPWIubGVmdDshYi5lKCk7KWEuU2EucHVzaChiKSxiPWIucmlnaHQ7ZWxzZSBmb3IoYj1iLnJpZ2h0OyFiLmUoKTspYS5TYS5wdXNoKGIpLGI9Yi5sZWZ0O3JldHVybiBjfWZ1bmN0aW9uIFZmKGEpe2lmKDA9PT1hLlNhLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYjtiPWEuU2E7Yj1iW2IubGVuZ3RoLTFdO3JldHVybiBhLkhkP2EuSGQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfX1mdW5jdGlvbiBXZihhLGIsYyxkLGUpe3RoaXMua2V5PWE7dGhpcy52YWx1ZT1iO3RoaXMuY29sb3I9bnVsbCE9Yz9jOiEwO3RoaXMubGVmdD1udWxsIT1kP2Q6U2Y7dGhpcy5yaWdodD1udWxsIT1lP2U6U2Z9Zz1XZi5wcm90b3R5cGU7XG5nLlk9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IFdmKG51bGwhPWE/YTp0aGlzLmtleSxudWxsIT1iP2I6dGhpcy52YWx1ZSxudWxsIT1jP2M6dGhpcy5jb2xvcixudWxsIT1kP2Q6dGhpcy5sZWZ0LG51bGwhPWU/ZTp0aGlzLnJpZ2h0KX07Zy5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnQuY291bnQoKSsxK3RoaXMucmlnaHQuY291bnQoKX07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2cuaWE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubGVmdC5pYShhKXx8YSh0aGlzLmtleSx0aGlzLnZhbHVlKXx8dGhpcy5yaWdodC5pYShhKX07ZnVuY3Rpb24gWGYoYSl7cmV0dXJuIGEubGVmdC5lKCk/YTpYZihhLmxlZnQpfWcuSGM9ZnVuY3Rpb24oKXtyZXR1cm4gWGYodGhpcykua2V5fTtnLmZjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHQuZSgpP3RoaXMua2V5OnRoaXMucmlnaHQuZmMoKX07XG5nLlJhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlO2U9dGhpcztkPWMoYSxlLmtleSk7ZT0wPmQ/ZS5ZKG51bGwsbnVsbCxudWxsLGUubGVmdC5SYShhLGIsYyksbnVsbCk6MD09PWQ/ZS5ZKG51bGwsYixudWxsLG51bGwsbnVsbCk6ZS5ZKG51bGwsbnVsbCxudWxsLG51bGwsZS5yaWdodC5SYShhLGIsYykpO3JldHVybiBZZihlKX07ZnVuY3Rpb24gWmYoYSl7aWYoYS5sZWZ0LmUoKSlyZXR1cm4gU2Y7YS5sZWZ0LmZhKCl8fGEubGVmdC5sZWZ0LmZhKCl8fChhPSRmKGEpKTthPWEuWShudWxsLG51bGwsbnVsbCxaZihhLmxlZnQpLG51bGwpO3JldHVybiBZZihhKX1cbmcucmVtb3ZlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtjPXRoaXM7aWYoMD5iKGEsYy5rZXkpKWMubGVmdC5lKCl8fGMubGVmdC5mYSgpfHxjLmxlZnQubGVmdC5mYSgpfHwoYz0kZihjKSksYz1jLlkobnVsbCxudWxsLG51bGwsYy5sZWZ0LnJlbW92ZShhLGIpLG51bGwpO2Vsc2V7Yy5sZWZ0LmZhKCkmJihjPWFnKGMpKTtjLnJpZ2h0LmUoKXx8Yy5yaWdodC5mYSgpfHxjLnJpZ2h0LmxlZnQuZmEoKXx8KGM9YmcoYyksYy5sZWZ0LmxlZnQuZmEoKSYmKGM9YWcoYyksYz1iZyhjKSkpO2lmKDA9PT1iKGEsYy5rZXkpKXtpZihjLnJpZ2h0LmUoKSlyZXR1cm4gU2Y7ZD1YZihjLnJpZ2h0KTtjPWMuWShkLmtleSxkLnZhbHVlLG51bGwsbnVsbCxaZihjLnJpZ2h0KSl9Yz1jLlkobnVsbCxudWxsLG51bGwsbnVsbCxjLnJpZ2h0LnJlbW92ZShhLGIpKX1yZXR1cm4gWWYoYyl9O2cuZmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb2xvcn07XG5mdW5jdGlvbiBZZihhKXthLnJpZ2h0LmZhKCkmJiFhLmxlZnQuZmEoKSYmKGE9Y2coYSkpO2EubGVmdC5mYSgpJiZhLmxlZnQubGVmdC5mYSgpJiYoYT1hZyhhKSk7YS5sZWZ0LmZhKCkmJmEucmlnaHQuZmEoKSYmKGE9YmcoYSkpO3JldHVybiBhfWZ1bmN0aW9uICRmKGEpe2E9YmcoYSk7YS5yaWdodC5sZWZ0LmZhKCkmJihhPWEuWShudWxsLG51bGwsbnVsbCxudWxsLGFnKGEucmlnaHQpKSxhPWNnKGEpLGE9YmcoYSkpO3JldHVybiBhfWZ1bmN0aW9uIGNnKGEpe3JldHVybiBhLnJpZ2h0LlkobnVsbCxudWxsLGEuY29sb3IsYS5ZKG51bGwsbnVsbCwhMCxudWxsLGEucmlnaHQubGVmdCksbnVsbCl9ZnVuY3Rpb24gYWcoYSl7cmV0dXJuIGEubGVmdC5ZKG51bGwsbnVsbCxhLmNvbG9yLG51bGwsYS5ZKG51bGwsbnVsbCwhMCxhLmxlZnQucmlnaHQsbnVsbCkpfVxuZnVuY3Rpb24gYmcoYSl7cmV0dXJuIGEuWShudWxsLG51bGwsIWEuY29sb3IsYS5sZWZ0LlkobnVsbCxudWxsLCFhLmxlZnQuY29sb3IsbnVsbCxudWxsKSxhLnJpZ2h0LlkobnVsbCxudWxsLCFhLnJpZ2h0LmNvbG9yLG51bGwsbnVsbCkpfWZ1bmN0aW9uIGRnKCl7fWc9ZGcucHJvdG90eXBlO2cuWT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtnLlJhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBXZihhLGIsbnVsbCl9O2cucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2cuY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH07Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2cuaWE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5IYz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtnLmZjPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2cuZmE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIFNmPW5ldyBkZztmdW5jdGlvbiBQKGEsYixjKXt0aGlzLms9YTsodGhpcy5hYT1iKSYmbmUodGhpcy5hYSk7YS5lKCkmJkgoIXRoaXMuYWF8fHRoaXMuYWEuZSgpLFwiQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5XCIpO3RoaXMuemI9Yzt0aGlzLkViPW51bGx9Zz1QLnByb3RvdHlwZTtnLko9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Zy5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWF8fEZ9O2cuZ2E9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuay5lKCk/dGhpczpuZXcgUCh0aGlzLmssYSx0aGlzLnpiKX07Zy5SPWZ1bmN0aW9uKGEpe2lmKFwiLnByaW9yaXR5XCI9PT1hKXJldHVybiB0aGlzLkMoKTthPXRoaXMuay5nZXQoYSk7cmV0dXJuIG51bGw9PT1hP0Y6YX07Zy5RPWZ1bmN0aW9uKGEpe3ZhciBiPUooYSk7cmV0dXJuIG51bGw9PT1iP3RoaXM6dGhpcy5SKGIpLlEoRChhKSl9O2cuRmE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT10aGlzLmsuZ2V0KGEpfTtcbmcuVT1mdW5jdGlvbihhLGIpe0goYixcIldlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2Rlc1wiKTtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5nYShiKTt2YXIgYz1uZXcgSyhhLGIpLGQsZTtiLmUoKT8oZD10aGlzLmsucmVtb3ZlKGEpLGM9SWUodGhpcy56YixjLHRoaXMuaykpOihkPXRoaXMuay5SYShhLGIpLGM9R2UodGhpcy56YixjLHRoaXMuaykpO2U9ZC5lKCk/Rjp0aGlzLmFhO3JldHVybiBuZXcgUChkLGUsYyl9O2cuRj1mdW5jdGlvbihhLGIpe3ZhciBjPUooYSk7aWYobnVsbD09PWMpcmV0dXJuIGI7SChcIi5wcmlvcml0eVwiIT09SihhKXx8MT09PVdkKGEpLFwiLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoXCIpO3ZhciBkPXRoaXMuUihjKS5GKEQoYSksYik7cmV0dXJuIHRoaXMuVShjLGQpfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rLmUoKX07Zy5GYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmsuY291bnQoKX07XG52YXIgZWc9L14oMHxbMS05XVxcZCopJC87Zz1QLnByb3RvdHlwZTtnLkg9ZnVuY3Rpb24oYSl7aWYodGhpcy5lKCkpcmV0dXJuIG51bGw7dmFyIGI9e30sYz0wLGQ9MCxlPSEwO3RoaXMuUChOLGZ1bmN0aW9uKGYsaCl7YltmXT1oLkgoYSk7YysrO2UmJmVnLnRlc3QoZik/ZD1NYXRoLm1heChkLE51bWJlcihmKSk6ZT0hMX0pO2lmKCFhJiZlJiZkPDIqYyl7dmFyIGY9W10saDtmb3IoaCBpbiBiKWZbaF09YltoXTtyZXR1cm4gZn1hJiYhdGhpcy5DKCkuZSgpJiYoYltcIi5wcmlvcml0eVwiXT10aGlzLkMoKS5IKCkpO3JldHVybiBifTtnLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5FYil7dmFyIGE9XCJcIjt0aGlzLkMoKS5lKCl8fChhKz1cInByaW9yaXR5OlwiK3BlKHRoaXMuQygpLkgoKSkrXCI6XCIpO3RoaXMuUChOLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5oYXNoKCk7XCJcIiE9PWQmJihhKz1cIjpcIitiK1wiOlwiK2QpfSk7dGhpcy5FYj1cIlwiPT09YT9cIlwiOlljKGEpfXJldHVybiB0aGlzLkVifTtcbmcuWGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybihjPWZnKHRoaXMsYykpPyhhPVRmKGMsbmV3IEsoYSxiKSkpP2EubmFtZTpudWxsOlRmKHRoaXMuayxhKX07ZnVuY3Rpb24gbGUoYSxiKXt2YXIgYztjPShjPWZnKGEsYikpPyhjPWMuSGMoKSkmJmMubmFtZTphLmsuSGMoKTtyZXR1cm4gYz9uZXcgSyhjLGEuay5nZXQoYykpOm51bGx9ZnVuY3Rpb24gbWUoYSxiKXt2YXIgYztjPShjPWZnKGEsYikpPyhjPWMuZmMoKSkmJmMubmFtZTphLmsuZmMoKTtyZXR1cm4gYz9uZXcgSyhjLGEuay5nZXQoYykpOm51bGx9Zy5QPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZmcodGhpcyxhKTtyZXR1cm4gYz9jLmlhKGZ1bmN0aW9uKGEpe3JldHVybiBiKGEubmFtZSxhLlMpfSk6dGhpcy5rLmlhKGIpfTtnLlhiPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlliKGEuSWMoKSxhKX07XG5nLlliPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZmcodGhpcyxiKTtpZihjKXJldHVybiBjLlliKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5rLlliKGEubmFtZSxOYyksZD1WZihjKTtudWxsIT1kJiYwPmIuY29tcGFyZShkLGEpOylSKGMpLGQ9VmYoYyk7cmV0dXJuIGN9O2cuWWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuJGIoYS5HYygpLGEpfTtnLiRiPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZmcodGhpcyxiKTtpZihjKXJldHVybiBjLiRiKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5rLiRiKGEubmFtZSxOYyksZD1WZihjKTtudWxsIT1kJiYwPGIuY29tcGFyZShkLGEpOylSKGMpLGQ9VmYoYyk7cmV0dXJuIGN9O2cudGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZSgpP2EuZSgpPzA6LTE6YS5KKCl8fGEuZSgpPzE6YT09PXVlPy0xOjB9O1xuZy5vYj1mdW5jdGlvbihhKXtpZihhPT09YWV8fHVhKHRoaXMuemIuZGMsYS50b1N0cmluZygpKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLnpiLGM9dGhpcy5rO0goYSE9PWFlLFwiS2V5SW5kZXggYWx3YXlzIGV4aXN0cyBhbmQgaXNuJ3QgbWVhbnQgdG8gYmUgYWRkZWQgdG8gdGhlIEluZGV4TWFwLlwiKTtmb3IodmFyIGQ9W10sZT0hMSxjPWMuWGIoTmMpLGY9UihjKTtmOyllPWV8fGEueWMoZi5TKSxkLnB1c2goZiksZj1SKGMpO2Q9ZT9IZShkLGtlKGEpKTpyZTtlPWEudG9TdHJpbmcoKTtjPXlhKGIuZGMpO2NbZV09YTthPXlhKGIub2QpO2FbZV09ZDtyZXR1cm4gbmV3IFAodGhpcy5rLHRoaXMuYWEsbmV3IEZlKGEsYykpfTtnLnpjPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09YWV8fHVhKHRoaXMuemIuZGMsYS50b1N0cmluZygpKX07XG5nLmNhPWZ1bmN0aW9uKGEpe2lmKGE9PT10aGlzKXJldHVybiEwO2lmKGEuSigpKXJldHVybiExO2lmKHRoaXMuQygpLmNhKGEuQygpKSYmdGhpcy5rLmNvdW50KCk9PT1hLmsuY291bnQoKSl7dmFyIGI9dGhpcy5YYihOKTthPWEuWGIoTik7Zm9yKHZhciBjPVIoYiksZD1SKGEpO2MmJmQ7KXtpZihjLm5hbWUhPT1kLm5hbWV8fCFjLlMuY2EoZC5TKSlyZXR1cm4hMTtjPVIoYik7ZD1SKGEpfXJldHVybiBudWxsPT09YyYmbnVsbD09PWR9cmV0dXJuITF9O2Z1bmN0aW9uIGZnKGEsYil7cmV0dXJuIGI9PT1hZT9udWxsOmEuemIuZ2V0KGIudG9TdHJpbmcoKSl9Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBCKHRoaXMuSCghMCkpfTtmdW5jdGlvbiBNKGEsYil7aWYobnVsbD09PWEpcmV0dXJuIEY7dmFyIGM9bnVsbDtcIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiLnByaW9yaXR5XCJpbiBhP2M9YVtcIi5wcmlvcml0eVwiXTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJihjPWIpO0gobnVsbD09PWN8fFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjfHxcIm9iamVjdFwiPT09dHlwZW9mIGMmJlwiLnN2XCJpbiBjLFwiSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiBcIit0eXBlb2YgYyk7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi52YWx1ZVwiaW4gYSYmbnVsbCE9PWFbXCIudmFsdWVcIl0mJihhPWFbXCIudmFsdWVcIl0pO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8XCIuc3ZcImluIGEpcmV0dXJuIG5ldyBVYyhhLE0oYykpO2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGQ9RixlPWE7dChlLGZ1bmN0aW9uKGEsYil7aWYoQmIoZSxiKSYmXCIuXCIhPT1iLnN1YnN0cmluZygwLDEpKXt2YXIgYz1NKGEpO2lmKGMuSigpfHwhYy5lKCkpZD1cbmQuVShiLGMpfX0pO3JldHVybiBkLmdhKE0oYykpfXZhciBmPVtdLGg9ITEsaz1hO0NiKGssZnVuY3Rpb24oYSl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhfHxcIi5cIiE9PWEuc3Vic3RyaW5nKDAsMSkpe3ZhciBiPU0oa1thXSk7Yi5lKCl8fChoPWh8fCFiLkMoKS5lKCksZi5wdXNoKG5ldyBLKGEsYikpKX19KTtpZigwPT1mLmxlbmd0aClyZXR1cm4gRjt2YXIgbT1IZShmLEtjLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWV9LE1jKTtpZihoKXt2YXIgbD1IZShmLGtlKE4pKTtyZXR1cm4gbmV3IFAobSxNKGMpLG5ldyBGZSh7XCIucHJpb3JpdHlcIjpsfSx7XCIucHJpb3JpdHlcIjpOfSkpfXJldHVybiBuZXcgUChtLE0oYyksSmUpfXZhciBnZz1NYXRoLmxvZygyKTtcbmZ1bmN0aW9uIGhnKGEpe3RoaXMuY291bnQ9cGFyc2VJbnQoTWF0aC5sb2coYSsxKS9nZywxMCk7dGhpcy5QZT10aGlzLmNvdW50LTE7dGhpcy5KZj1hKzEmcGFyc2VJbnQoQXJyYXkodGhpcy5jb3VudCsxKS5qb2luKFwiMVwiKSwyKX1mdW5jdGlvbiBpZyhhKXt2YXIgYj0hKGEuSmYmMTw8YS5QZSk7YS5QZS0tO3JldHVybiBifVxuZnVuY3Rpb24gSGUoYSxiLGMsZCl7ZnVuY3Rpb24gZShiLGQpe3ZhciBmPWQtYjtpZigwPT1mKXJldHVybiBudWxsO2lmKDE9PWYpe3ZhciBsPWFbYl0sdT1jP2MobCk6bDtyZXR1cm4gbmV3IFdmKHUsbC5TLCExLG51bGwsbnVsbCl9dmFyIGw9cGFyc2VJbnQoZi8yLDEwKStiLGY9ZShiLGwpLHo9ZShsKzEsZCksbD1hW2xdLHU9Yz9jKGwpOmw7cmV0dXJuIG5ldyBXZih1LGwuUywhMSxmLHopfWEuc29ydChiKTt2YXIgZj1mdW5jdGlvbihiKXtmdW5jdGlvbiBkKGIsaCl7dmFyIGs9dS1iLHo9dTt1LT1iO3ZhciB6PWUoaysxLHopLGs9YVtrXSxHPWM/YyhrKTprLHo9bmV3IFdmKEcsay5TLGgsbnVsbCx6KTtmP2YubGVmdD16Omw9ejtmPXp9Zm9yKHZhciBmPW51bGwsbD1udWxsLHU9YS5sZW5ndGgsej0wO3o8Yi5jb3VudDsrK3ope3ZhciBHPWlnKGIpLHNkPU1hdGgucG93KDIsYi5jb3VudC0oeisxKSk7Rz9kKHNkLCExKTooZChzZCwhMSksZChzZCwhMCkpfXJldHVybiBsfShuZXcgaGcoYS5sZW5ndGgpKTtcbnJldHVybiBudWxsIT09Zj9uZXcgUmYoZHx8YixmKTpuZXcgUmYoZHx8Yil9ZnVuY3Rpb24gcGUoYSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhP1wibnVtYmVyOlwiK21kKGEpOlwic3RyaW5nOlwiK2F9ZnVuY3Rpb24gbmUoYSl7aWYoYS5KKCkpe3ZhciBiPWEuSCgpO0goXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwib2JqZWN0XCI9PT10eXBlb2YgYiYmQmIoYixcIi5zdlwiKSxcIlByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKX1lbHNlIEgoYT09PXVlfHxhLmUoKSxcInByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS5cIik7SChhPT09dWV8fGEuQygpLmUoKSxcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpfXZhciBGPW5ldyBQKG5ldyBSZihNYyksbnVsbCxKZSk7ZnVuY3Rpb24gamcoKXtQLmNhbGwodGhpcyxuZXcgUmYoTWMpLEYsSmUpfWthKGpnLFApO2c9amcucHJvdG90eXBlO1xuZy50Yz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/MDoxfTtnLmNhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpc307Zy5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2cuUj1mdW5jdGlvbigpe3JldHVybiBGfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIHVlPW5ldyBqZyxzZT1uZXcgSyhcIltNSU5fTkFNRV1cIixGKSx5ZT1uZXcgSyhcIltNQVhfTkFNRV1cIix1ZSk7ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5BPWE7dGhpcy5XPWI7dGhpcy5nPWN9Vy5wcm90b3R5cGUuSD1mdW5jdGlvbigpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QudmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSCgpfTtXLnByb3RvdHlwZS52YWw9Vy5wcm90b3R5cGUuSDtXLnByb3RvdHlwZS5TZT1mdW5jdGlvbigpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhwb3J0VmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSCghMCl9O1cucHJvdG90eXBlLmV4cG9ydFZhbD1XLnByb3RvdHlwZS5TZTtXLnByb3RvdHlwZS5UZj1mdW5jdGlvbigpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhpc3RzXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiF0aGlzLkEuZSgpfTtXLnByb3RvdHlwZS5leGlzdHM9Vy5wcm90b3R5cGUuVGY7XG5XLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7ZmEoYSkmJihhPVN0cmluZyhhKSk7SGYoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIixhKTt2YXIgYj1uZXcgTChhKSxjPXRoaXMuVy5tKGIpO3JldHVybiBuZXcgVyh0aGlzLkEuUShiKSxjLE4pfTtXLnByb3RvdHlwZS5jaGlsZD1XLnByb3RvdHlwZS5tO1cucHJvdG90eXBlLkZhPWZ1bmN0aW9uKGEpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuaGFzQ2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7SGYoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuaGFzQ2hpbGRcIixhKTt2YXIgYj1uZXcgTChhKTtyZXR1cm4hdGhpcy5BLlEoYikuZSgpfTtXLnByb3RvdHlwZS5oYXNDaGlsZD1XLnByb3RvdHlwZS5GYTtcblcucHJvdG90eXBlLkM9ZnVuY3Rpb24oKXt5KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmdldFByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuQygpLkgoKX07Vy5wcm90b3R5cGUuZ2V0UHJpb3JpdHk9Vy5wcm90b3R5cGUuQztXLnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGEpe3koXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtBKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmZvckVhY2hcIiwxLGEsITEpO2lmKHRoaXMuQS5KKCkpcmV0dXJuITE7dmFyIGI9dGhpcztyZXR1cm4hIXRoaXMuQS5QKHRoaXMuZyxmdW5jdGlvbihjLGQpe3JldHVybiBhKG5ldyBXKGQsYi5XLm0oYyksTikpfSl9O1cucHJvdG90eXBlLmZvckVhY2g9Vy5wcm90b3R5cGUuZm9yRWFjaDtcblcucHJvdG90eXBlLmtkPWZ1bmN0aW9uKCl7eShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkooKT8hMTohdGhpcy5BLmUoKX07Vy5wcm90b3R5cGUuaGFzQ2hpbGRyZW49Vy5wcm90b3R5cGUua2Q7Vy5wcm90b3R5cGUuZ2V0S2V5PWZ1bmN0aW9uKCl7eShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuVy5nZXRLZXkoKX07b2QoVy5wcm90b3R5cGUsXCJrZXlcIixXLnByb3RvdHlwZS5nZXRLZXkpO1cucHJvdG90eXBlLkZiPWZ1bmN0aW9uKCl7eShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5udW1DaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkZiKCl9O1cucHJvdG90eXBlLm51bUNoaWxkcmVuPVcucHJvdG90eXBlLkZiO1xuVy5wcm90b3R5cGUueGI9ZnVuY3Rpb24oKXt5KFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5XfTtvZChXLnByb3RvdHlwZSxcInJlZlwiLFcucHJvdG90eXBlLnhiKTtmdW5jdGlvbiBVZChhLGIpe3RoaXMuTz1hO3RoaXMuTGQ9Yn1mdW5jdGlvbiBSZChhLGIsYyxkKXtyZXR1cm4gbmV3IFVkKG5ldyBEYyhiLGMsZCksYS5MZCl9ZnVuY3Rpb24gVmQoYSl7cmV0dXJuIGEuTy5lYT9hLk8uaigpOm51bGx9VWQucHJvdG90eXBlLnU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5MZH07ZnVuY3Rpb24gRWMoYSl7cmV0dXJuIGEuTGQuZWE/YS5MZC5qKCk6bnVsbH07ZnVuY3Rpb24ga2coYSxiKXt0aGlzLlc9YTt2YXIgYz1hLm4sZD1uZXcgYmUoYy5nKSxjPVMoYyk/bmV3IGJlKGMuZyk6Yy54YT9uZXcgaGUoYyk6bmV3IGNlKGMpO3RoaXMubWY9bmV3IExkKGMpO3ZhciBlPWIudSgpLGY9Yi5PLGg9ZC56YShGLGUuaigpLG51bGwpLGs9Yy56YShGLGYuaigpLG51bGwpO3RoaXMuTmE9bmV3IFVkKG5ldyBEYyhrLGYuZWEsYy5RYSgpKSxuZXcgRGMoaCxlLmVhLGQuUWEoKSkpO3RoaXMuYWI9W107dGhpcy5RZj1uZXcgR2QoYSl9ZnVuY3Rpb24gbGcoYSl7cmV0dXJuIGEuV31nPWtnLnByb3RvdHlwZTtnLnU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5OYS51KCkuaigpfTtnLmpiPWZ1bmN0aW9uKGEpe3ZhciBiPUVjKHRoaXMuTmEpO3JldHVybiBiJiYoUyh0aGlzLlcubil8fCFhLmUoKSYmIWIuUihKKGEpKS5lKCkpP2IuUShhKTpudWxsfTtnLmU9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYWIubGVuZ3RofTtnLk9iPWZ1bmN0aW9uKGEpe3RoaXMuYWIucHVzaChhKX07XG5nLm1iPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYoYil7SChudWxsPT1hLFwiQSBjYW5jZWwgc2hvdWxkIGNhbmNlbCBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucy5cIik7dmFyIGQ9dGhpcy5XLnBhdGg7SmEodGhpcy5hYixmdW5jdGlvbihhKXsoYT1hLk5lKGIsZCkpJiZjLnB1c2goYSl9KX1pZihhKXtmb3IodmFyIGU9W10sZj0wO2Y8dGhpcy5hYi5sZW5ndGg7KytmKXt2YXIgaD10aGlzLmFiW2ZdO2lmKCFoLm1hdGNoZXMoYSkpZS5wdXNoKGgpO2Vsc2UgaWYoYS5aZSgpKXtlPWUuY29uY2F0KHRoaXMuYWIuc2xpY2UoZisxKSk7YnJlYWt9fXRoaXMuYWI9ZX1lbHNlIHRoaXMuYWI9W107cmV0dXJuIGN9O1xuZy5nYj1mdW5jdGlvbihhLGIsYyl7YS50eXBlPT09RGQmJm51bGwhPT1hLnNvdXJjZS5JYiYmKEgoRWModGhpcy5OYSksXCJXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXNcIiksSChWZCh0aGlzLk5hKSxcIk1pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGVcIikpO3ZhciBkPXRoaXMuTmE7YT10aGlzLm1mLmdiKGQsYSxiLGMpO2I9dGhpcy5tZjtjPWEuU2Q7SChjLk8uaigpLnpjKGIuVi5nKSxcIkV2ZW50IHNuYXAgbm90IGluZGV4ZWRcIik7SChjLnUoKS5qKCkuemMoYi5WLmcpLFwiU2VydmVyIHNuYXAgbm90IGluZGV4ZWRcIik7SChIYyhhLlNkLnUoKSl8fCFIYyhkLnUoKSksXCJPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrXCIpO3RoaXMuTmE9YS5TZDtyZXR1cm4gbWcodGhpcyxhLktmLGEuU2QuTy5qKCksbnVsbCl9O1xuZnVuY3Rpb24gbmcoYSxiKXt2YXIgYz1hLk5hLk8sZD1bXTtjLmooKS5KKCl8fGMuaigpLlAoTixmdW5jdGlvbihhLGIpe2QucHVzaChuZXcgSShcImNoaWxkX2FkZGVkXCIsYixhKSl9KTtjLmVhJiZkLnB1c2goRmMoYy5qKCkpKTtyZXR1cm4gbWcoYSxkLGMuaigpLGIpfWZ1bmN0aW9uIG1nKGEsYixjLGQpe3JldHVybiBIZChhLlFmLGIsYyxkP1tkXTphLmFiKX07ZnVuY3Rpb24gb2coYSxiLGMpe3RoaXMuUWI9YTt0aGlzLnNiPWI7dGhpcy51Yj1jfHxudWxsfWc9b2cucHJvdG90eXBlO2cucmY9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ2YWx1ZVwiPT09YX07Zy5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPWIubi5nO3JldHVybiBuZXcgeGMoXCJ2YWx1ZVwiLHRoaXMsbmV3IFcoYS5NYSxiLnhiKCksYykpfTtnLlViPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMudWI7aWYoXCJjYW5jZWxcIj09PWEuZ2UoKSl7SCh0aGlzLnNiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMuc2I7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuUWI7cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5NZCl9fTtnLk5lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuc2I/bmV3IHljKHRoaXMsYSxiKTpudWxsfTtcbmcubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIG9nP2EuUWImJnRoaXMuUWI/YS5RYj09PXRoaXMuUWImJmEudWI9PT10aGlzLnViOiEwOiExfTtnLlplPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLlFifTtmdW5jdGlvbiBwZyhhLGIsYyl7dGhpcy5oYT1hO3RoaXMuc2I9Yjt0aGlzLnViPWN9Zz1wZy5wcm90b3R5cGU7Zy5yZj1mdW5jdGlvbihhKXthPVwiY2hpbGRyZW5fYWRkZWRcIj09PWE/XCJjaGlsZF9hZGRlZFwiOmE7cmV0dXJuKFwiY2hpbGRyZW5fcmVtb3ZlZFwiPT09YT9cImNoaWxkX3JlbW92ZWRcIjphKWluIHRoaXMuaGF9O2cuTmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5zYj9uZXcgeWModGhpcyxhLGIpOm51bGx9O1xuZy5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe0gobnVsbCE9YS5aYSxcIkNoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS5cIik7dmFyIGM9Yi54YigpLm0oYS5aYSk7cmV0dXJuIG5ldyB4YyhhLnR5cGUsdGhpcyxuZXcgVyhhLk1hLGMsYi5uLmcpLGEuRGQpfTtnLlViPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMudWI7aWYoXCJjYW5jZWxcIj09PWEuZ2UoKSl7SCh0aGlzLnNiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMuc2I7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuaGFbYS5nZF07cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5NZCxhLkRkKX19O1xuZy5tYXRjaGVzPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBwZyl7aWYoIXRoaXMuaGF8fCFhLmhhKXJldHVybiEwO2lmKHRoaXMudWI9PT1hLnViKXt2YXIgYj1xYShhLmhhKTtpZihiPT09cWEodGhpcy5oYSkpe2lmKDE9PT1iKXt2YXIgYj1yYShhLmhhKSxjPXJhKHRoaXMuaGEpO3JldHVybiBjPT09YiYmKCFhLmhhW2JdfHwhdGhpcy5oYVtjXXx8YS5oYVtiXT09PXRoaXMuaGFbY10pfXJldHVybiBwYSh0aGlzLmhhLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGEuaGFbY109PT1ifSl9fX1yZXR1cm4hMX07Zy5aZT1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5oYX07ZnVuY3Rpb24gWChhLGIsYyxkKXt0aGlzLnc9YTt0aGlzLnBhdGg9Yjt0aGlzLm49Yzt0aGlzLk9jPWR9XG5mdW5jdGlvbiBxZyhhKXt2YXIgYj1udWxsLGM9bnVsbDthLmthJiYoYj1lZShhKSk7YS5uYSYmKGM9Z2UoYSkpO2lmKGEuZz09PWFlKXtpZihhLmthKXtpZihcIltNSU5fTkFNRV1cIiE9ZGUoYSkpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS5cIik7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBiKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fWlmKGEubmEpe2lmKFwiW01BWF9OQU1FXVwiIT1mZShhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihcInN0cmluZ1wiIT09XG50eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuXCIpO319ZWxzZSBpZihhLmc9PT1OKXtpZihudWxsIT1iJiYhemYoYil8fG51bGwhPWMmJiF6ZihjKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSB2YWxpZCBwcmlvcml0eSB2YWx1ZSAobnVsbCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nKS5cIik7fWVsc2UgaWYoSChhLmcgaW5zdGFuY2VvZiB0ZXx8YS5nPT09emUsXCJ1bmtub3duIGluZGV4IHR5cGUuXCIpLG51bGwhPWImJlwib2JqZWN0XCI9PT10eXBlb2YgYnx8bnVsbCE9YyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LlwiKTtcbn1mdW5jdGlvbiByZyhhKXtpZihhLmthJiZhLm5hJiZhLnhhJiYoIWEueGF8fFwiXCI9PT1hLm9jKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBDYW4ndCBjb21iaW5lIHN0YXJ0QXQoKSwgZW5kQXQoKSwgYW5kIGxpbWl0KCkuIFVzZSBsaW1pdFRvRmlyc3QoKSBvciBsaW1pdFRvTGFzdCgpIGluc3RlYWQuXCIpO31mdW5jdGlvbiBzZyhhLGIpe2lmKCEwPT09YS5PYyl0aHJvdyBFcnJvcihiK1wiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTt9Zz1YLnByb3RvdHlwZTtnLnhiPWZ1bmN0aW9uKCl7eShcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFUodGhpcy53LHRoaXMucGF0aCl9O1xuZy5oYz1mdW5jdGlvbihhLGIsYyxkKXt5KFwiUXVlcnkub25cIiwyLDQsYXJndW1lbnRzLmxlbmd0aCk7RmYoXCJRdWVyeS5vblwiLGEsITEpO0EoXCJRdWVyeS5vblwiLDIsYiwhMSk7dmFyIGU9dGcoXCJRdWVyeS5vblwiLGMsZCk7aWYoXCJ2YWx1ZVwiPT09YSl1Zyh0aGlzLncsdGhpcyxuZXcgb2coYixlLmNhbmNlbHx8bnVsbCxlLlBhfHxudWxsKSk7ZWxzZXt2YXIgZj17fTtmW2FdPWI7dWcodGhpcy53LHRoaXMsbmV3IHBnKGYsZS5jYW5jZWwsZS5QYSkpfXJldHVybiBifTtcbmcuSmM9ZnVuY3Rpb24oYSxiLGMpe3koXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7RmYoXCJRdWVyeS5vZmZcIixhLCEwKTtBKFwiUXVlcnkub2ZmXCIsMixiLCEwKTtFYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBvZyhifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgcGcoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMudztkPVwiLmluZm9cIj09PUoodGhpcy5wYXRoKT9lLnBkLm1iKHRoaXMsZCk6ZS5LLm1iKHRoaXMsZCk7dGMoZS5kYSx0aGlzLnBhdGgsZCl9O1xuZy5pZz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoayl7ZiYmKGY9ITEsZS5KYyhhLGMpLGImJmIuY2FsbChkLlBhLGspLGgucmVzb2x2ZShrKSl9eShcIlF1ZXJ5Lm9uY2VcIiwxLDQsYXJndW1lbnRzLmxlbmd0aCk7RmYoXCJRdWVyeS5vbmNlXCIsYSwhMSk7QShcIlF1ZXJ5Lm9uY2VcIiwyLGIsITApO3ZhciBkPXRnKFwiUXVlcnkub25jZVwiLGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pLGU9dGhpcyxmPSEwLGg9bmV3IEhiO0piKGgucmEpO3RoaXMuaGMoYSxjLGZ1bmN0aW9uKGIpe2UuSmMoYSxjKTtkLmNhbmNlbCYmZC5jYW5jZWwuY2FsbChkLlBhLGIpO2gucmVqZWN0KGIpfSk7cmV0dXJuIGgucmF9O1xuZy5tZT1mdW5jdGlvbihhKXt5KFwiUXVlcnkubGltaXRUb0ZpcnN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFmYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ueGEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS5cIik7cmV0dXJuIG5ldyBYKHRoaXMudyx0aGlzLnBhdGgsdGhpcy5uLm1lKGEpLHRoaXMuT2MpfTtcbmcubmU9ZnVuY3Rpb24oYSl7eShcIlF1ZXJ5LmxpbWl0VG9MYXN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFmYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi54YSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgWCh0aGlzLncsdGhpcy5wYXRoLHRoaXMubi5uZShhKSx0aGlzLk9jKX07XG5nLmpnPWZ1bmN0aW9uKGEpe3koXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoXCIka2V5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeUtleSgpIGluc3RlYWQuJyk7aWYoXCIkcHJpb3JpdHlcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7aWYoXCIkdmFsdWVcIj09PWEpdGhyb3cgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkdmFsdWVcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7SGYoXCJRdWVyeS5vcmRlckJ5Q2hpbGRcIixhKTtzZyh0aGlzLFwiUXVlcnkub3JkZXJCeUNoaWxkXCIpO3ZhciBiPW5ldyBMKGEpO2lmKGIuZSgpKXRocm93IEVycm9yKFwiUXVlcnkub3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuXCIpO1xuYj1uZXcgdGUoYik7Yj1EZSh0aGlzLm4sYik7cWcoYik7cmV0dXJuIG5ldyBYKHRoaXMudyx0aGlzLnBhdGgsYiwhMCl9O2cua2c9ZnVuY3Rpb24oKXt5KFwiUXVlcnkub3JkZXJCeUtleVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtzZyh0aGlzLFwiUXVlcnkub3JkZXJCeUtleVwiKTt2YXIgYT1EZSh0aGlzLm4sYWUpO3FnKGEpO3JldHVybiBuZXcgWCh0aGlzLncsdGhpcy5wYXRoLGEsITApfTtnLmxnPWZ1bmN0aW9uKCl7eShcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtzZyh0aGlzLFwiUXVlcnkub3JkZXJCeVByaW9yaXR5XCIpO3ZhciBhPURlKHRoaXMubixOKTtxZyhhKTtyZXR1cm4gbmV3IFgodGhpcy53LHRoaXMucGF0aCxhLCEwKX07XG5nLm1nPWZ1bmN0aW9uKCl7eShcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtzZyh0aGlzLFwiUXVlcnkub3JkZXJCeVZhbHVlXCIpO3ZhciBhPURlKHRoaXMubix6ZSk7cWcoYSk7cmV0dXJuIG5ldyBYKHRoaXMudyx0aGlzLnBhdGgsYSwhMCl9O2cuTmQ9ZnVuY3Rpb24oYSxiKXt5KFwiUXVlcnkuc3RhcnRBdFwiLDAsMixhcmd1bWVudHMubGVuZ3RoKTtBZihcIlF1ZXJ5LnN0YXJ0QXRcIixhLHRoaXMucGF0aCwhMCk7R2YoXCJRdWVyeS5zdGFydEF0XCIsYik7dmFyIGM9dGhpcy5uLk5kKGEsYik7cmcoYyk7cWcoYyk7aWYodGhpcy5uLmthKXRocm93IEVycm9yKFwiUXVlcnkuc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCBvciBlcXVhbFRvKS5cIik7cChhKXx8KGI9YT1udWxsKTtyZXR1cm4gbmV3IFgodGhpcy53LHRoaXMucGF0aCxjLHRoaXMuT2MpfTtcbmcuZmQ9ZnVuY3Rpb24oYSxiKXt5KFwiUXVlcnkuZW5kQXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7QWYoXCJRdWVyeS5lbmRBdFwiLGEsdGhpcy5wYXRoLCEwKTtHZihcIlF1ZXJ5LmVuZEF0XCIsYik7dmFyIGM9dGhpcy5uLmZkKGEsYik7cmcoYyk7cWcoYyk7aWYodGhpcy5uLm5hKXRocm93IEVycm9yKFwiUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7cmV0dXJuIG5ldyBYKHRoaXMudyx0aGlzLnBhdGgsYyx0aGlzLk9jKX07XG5nLlBmPWZ1bmN0aW9uKGEsYil7eShcIlF1ZXJ5LmVxdWFsVG9cIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7QWYoXCJRdWVyeS5lcXVhbFRvXCIsYSx0aGlzLnBhdGgsITEpO0dmKFwiUXVlcnkuZXF1YWxUb1wiLGIpO2lmKHRoaXMubi5rYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtpZih0aGlzLm4ubmEpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiB0aGlzLk5kKGEsYikuZmQoYSxiKX07XG5nLnRvU3RyaW5nPWZ1bmN0aW9uKCl7eShcIlF1ZXJ5LnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzLnBhdGgsYj1cIlwiLGM9YS5aO2M8YS5vLmxlbmd0aDtjKyspXCJcIiE9PWEub1tjXSYmKGIrPVwiL1wiK2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYS5vW2NdKSkpO3JldHVybiB0aGlzLncudG9TdHJpbmcoKSsoYnx8XCIvXCIpfTtnLnlhPWZ1bmN0aW9uKCl7dmFyIGE9amQoRWUodGhpcy5uKSk7cmV0dXJuXCJ7fVwiPT09YT9cImRlZmF1bHRcIjphfTtcbmZ1bmN0aW9uIHRnKGEsYixjKXt2YXIgZD17Y2FuY2VsOm51bGwsUGE6bnVsbH07aWYoYiYmYylkLmNhbmNlbD1iLEEoYSwzLGQuY2FuY2VsLCEwKSxkLlBhPWMsRWIoYSw0LGQuUGEpO2Vsc2UgaWYoYilpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKWQuUGE9YjtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKWQuY2FuY2VsPWI7ZWxzZSB0aHJvdyBFcnJvcihEYihhLDMsITApK1wiIG11c3QgZWl0aGVyIGJlIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dCBvYmplY3QuXCIpO3JldHVybiBkfVgucHJvdG90eXBlLm9uPVgucHJvdG90eXBlLmhjO1gucHJvdG90eXBlLm9mZj1YLnByb3RvdHlwZS5KYztYLnByb3RvdHlwZS5vbmNlPVgucHJvdG90eXBlLmlnO1gucHJvdG90eXBlLmxpbWl0VG9GaXJzdD1YLnByb3RvdHlwZS5tZTtYLnByb3RvdHlwZS5saW1pdFRvTGFzdD1YLnByb3RvdHlwZS5uZTtYLnByb3RvdHlwZS5vcmRlckJ5Q2hpbGQ9WC5wcm90b3R5cGUuamc7XG5YLnByb3RvdHlwZS5vcmRlckJ5S2V5PVgucHJvdG90eXBlLmtnO1gucHJvdG90eXBlLm9yZGVyQnlQcmlvcml0eT1YLnByb3RvdHlwZS5sZztYLnByb3RvdHlwZS5vcmRlckJ5VmFsdWU9WC5wcm90b3R5cGUubWc7WC5wcm90b3R5cGUuc3RhcnRBdD1YLnByb3RvdHlwZS5OZDtYLnByb3RvdHlwZS5lbmRBdD1YLnByb3RvdHlwZS5mZDtYLnByb3RvdHlwZS5lcXVhbFRvPVgucHJvdG90eXBlLlBmO1gucHJvdG90eXBlLnRvU3RyaW5nPVgucHJvdG90eXBlLnRvU3RyaW5nO29kKFgucHJvdG90eXBlLFwicmVmXCIsWC5wcm90b3R5cGUueGIpO2Z1bmN0aW9uIHZnKGEsYil7dGhpcy52YWx1ZT1hO3RoaXMuY2hpbGRyZW49Ynx8d2d9dmFyIHdnPW5ldyBSZihmdW5jdGlvbihhLGIpe3JldHVybiBhPT09Yj8wOmE8Yj8tMToxfSk7ZnVuY3Rpb24geGcoYSl7dmFyIGI9UTt0KGEsZnVuY3Rpb24oYSxkKXtiPWIuc2V0KG5ldyBMKGQpLGEpfSk7cmV0dXJuIGJ9Zz12Zy5wcm90b3R5cGU7Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlJiZ0aGlzLmNoaWxkcmVuLmUoKX07ZnVuY3Rpb24geWcoYSxiLGMpe2lmKG51bGwhPWEudmFsdWUmJmMoYS52YWx1ZSkpcmV0dXJue3BhdGg6Qyx2YWx1ZTphLnZhbHVlfTtpZihiLmUoKSlyZXR1cm4gbnVsbDt2YXIgZD1KKGIpO2E9YS5jaGlsZHJlbi5nZXQoZCk7cmV0dXJuIG51bGwhPT1hPyhiPXlnKGEsRChiKSxjKSxudWxsIT1iP3twYXRoOihuZXcgTChkKSkubShiLnBhdGgpLHZhbHVlOmIudmFsdWV9Om51bGwpOm51bGx9XG5mdW5jdGlvbiB6ZyhhLGIpe3JldHVybiB5ZyhhLGIsZnVuY3Rpb24oKXtyZXR1cm4hMH0pfWcuc3VidHJlZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLmNoaWxkcmVuLmdldChKKGEpKTtyZXR1cm4gbnVsbCE9PWI/Yi5zdWJ0cmVlKEQoYSkpOlF9O2cuc2V0PWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpcmV0dXJuIG5ldyB2ZyhiLHRoaXMuY2hpbGRyZW4pO3ZhciBjPUooYSksZD0odGhpcy5jaGlsZHJlbi5nZXQoYyl8fFEpLnNldChEKGEpLGIpLGM9dGhpcy5jaGlsZHJlbi5SYShjLGQpO3JldHVybiBuZXcgdmcodGhpcy52YWx1ZSxjKX07XG5nLnJlbW92ZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy5jaGlsZHJlbi5lKCk/UTpuZXcgdmcobnVsbCx0aGlzLmNoaWxkcmVuKTt2YXIgYj1KKGEpLGM9dGhpcy5jaGlsZHJlbi5nZXQoYik7cmV0dXJuIGM/KGE9Yy5yZW1vdmUoRChhKSksYj1hLmUoKT90aGlzLmNoaWxkcmVuLnJlbW92ZShiKTp0aGlzLmNoaWxkcmVuLlJhKGIsYSksbnVsbD09PXRoaXMudmFsdWUmJmIuZSgpP1E6bmV3IHZnKHRoaXMudmFsdWUsYikpOnRoaXN9O2cuZ2V0PWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzLnZhbHVlO3ZhciBiPXRoaXMuY2hpbGRyZW4uZ2V0KEooYSkpO3JldHVybiBiP2IuZ2V0KEQoYSkpOm51bGx9O1xuZnVuY3Rpb24gJGQoYSxiLGMpe2lmKGIuZSgpKXJldHVybiBjO3ZhciBkPUooYik7Yj0kZChhLmNoaWxkcmVuLmdldChkKXx8USxEKGIpLGMpO2Q9Yi5lKCk/YS5jaGlsZHJlbi5yZW1vdmUoZCk6YS5jaGlsZHJlbi5SYShkLGIpO3JldHVybiBuZXcgdmcoYS52YWx1ZSxkKX1mdW5jdGlvbiBBZyhhLGIpe3JldHVybiBCZyhhLEMsYil9ZnVuY3Rpb24gQmcoYSxiLGMpe3ZhciBkPXt9O2EuY2hpbGRyZW4uaWEoZnVuY3Rpb24oYSxmKXtkW2FdPUJnKGYsYi5tKGEpLGMpfSk7cmV0dXJuIGMoYixhLnZhbHVlLGQpfWZ1bmN0aW9uIENnKGEsYixjKXtyZXR1cm4gRGcoYSxiLEMsYyl9ZnVuY3Rpb24gRGcoYSxiLGMsZCl7dmFyIGU9YS52YWx1ZT9kKGMsYS52YWx1ZSk6ITE7aWYoZSlyZXR1cm4gZTtpZihiLmUoKSlyZXR1cm4gbnVsbDtlPUooYik7cmV0dXJuKGE9YS5jaGlsZHJlbi5nZXQoZSkpP0RnKGEsRChiKSxjLm0oZSksZCk6bnVsbH1cbmZ1bmN0aW9uIEVnKGEsYixjKXtGZyhhLGIsQyxjKX1mdW5jdGlvbiBGZyhhLGIsYyxkKXtpZihiLmUoKSlyZXR1cm4gYTthLnZhbHVlJiZkKGMsYS52YWx1ZSk7dmFyIGU9SihiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/RmcoYSxEKGIpLGMubShlKSxkKTpRfWZ1bmN0aW9uIFlkKGEsYil7R2coYSxDLGIpfWZ1bmN0aW9uIEdnKGEsYixjKXthLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGEsZSl7R2coZSxiLm0oYSksYyl9KTthLnZhbHVlJiZjKGIsYS52YWx1ZSl9ZnVuY3Rpb24gSGcoYSxiKXthLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGEsZCl7ZC52YWx1ZSYmYihhLGQudmFsdWUpfSl9dmFyIFE9bmV3IHZnKG51bGwpO3ZnLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPXt9O1lkKHRoaXMsZnVuY3Rpb24oYixjKXthW2IudG9TdHJpbmcoKV09Yy50b1N0cmluZygpfSk7cmV0dXJuIEIoYSl9O2Z1bmN0aW9uIElnKGEsYixjKXt0aGlzLnR5cGU9UWQ7dGhpcy5zb3VyY2U9Smc7dGhpcy5wYXRoPWE7dGhpcy5QYj1iO3RoaXMuSWQ9Y31JZy5wcm90b3R5cGUuTmM9ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXRoLmUoKSl7aWYobnVsbCE9dGhpcy5QYi52YWx1ZSlyZXR1cm4gSCh0aGlzLlBiLmNoaWxkcmVuLmUoKSxcImFmZmVjdGVkVHJlZSBzaG91bGQgbm90IGhhdmUgb3ZlcmxhcHBpbmcgYWZmZWN0ZWQgcGF0aHMuXCIpLHRoaXM7YT10aGlzLlBiLnN1YnRyZWUobmV3IEwoYSkpO3JldHVybiBuZXcgSWcoQyxhLHRoaXMuSWQpfUgoSih0aGlzLnBhdGgpPT09YSxcIm9wZXJhdGlvbkZvckNoaWxkIGNhbGxlZCBmb3IgdW5yZWxhdGVkIGNoaWxkLlwiKTtyZXR1cm4gbmV3IElnKEQodGhpcy5wYXRoKSx0aGlzLlBiLHRoaXMuSWQpfTtcbklnLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBhY2sgd3JpdGUgcmV2ZXJ0PVwiK3RoaXMuSWQrXCIgYWZmZWN0ZWRUcmVlPVwiK3RoaXMuUGIrXCIpXCJ9O3ZhciAkYj0wLERkPTEsUWQ9MixiYz0zO2Z1bmN0aW9uIEtnKGEsYixjLGQpe3RoaXMuZWU9YTt0aGlzLlVlPWI7dGhpcy5JYj1jO3RoaXMuRGU9ZDtIKCFkfHxiLFwiVGFnZ2VkIHF1ZXJpZXMgbXVzdCBiZSBmcm9tIHNlcnZlci5cIil9dmFyIEpnPW5ldyBLZyghMCwhMSxudWxsLCExKSxMZz1uZXcgS2coITEsITAsbnVsbCwhMSk7S2cucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWU/XCJ1c2VyXCI6dGhpcy5EZT9cInNlcnZlcihxdWVyeUlEPVwiK3RoaXMuSWIrXCIpXCI6XCJzZXJ2ZXJcIn07ZnVuY3Rpb24gTWcoYSl7dGhpcy5YPWF9dmFyIE5nPW5ldyBNZyhuZXcgdmcobnVsbCkpO2Z1bmN0aW9uIE9nKGEsYixjKXtpZihiLmUoKSlyZXR1cm4gbmV3IE1nKG5ldyB2ZyhjKSk7dmFyIGQ9emcoYS5YLGIpO2lmKG51bGwhPWQpe3ZhciBlPWQucGF0aCxkPWQudmFsdWU7Yj1UKGUsYik7ZD1kLkYoYixjKTtyZXR1cm4gbmV3IE1nKGEuWC5zZXQoZSxkKSl9YT0kZChhLlgsYixuZXcgdmcoYykpO3JldHVybiBuZXcgTWcoYSl9ZnVuY3Rpb24gUGcoYSxiLGMpe3ZhciBkPWE7Q2IoYyxmdW5jdGlvbihhLGMpe2Q9T2coZCxiLm0oYSksYyl9KTtyZXR1cm4gZH1NZy5wcm90b3R5cGUuRWQ9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIE5nO2E9JGQodGhpcy5YLGEsUSk7cmV0dXJuIG5ldyBNZyhhKX07ZnVuY3Rpb24gUWcoYSxiKXt2YXIgYz16ZyhhLlgsYik7cmV0dXJuIG51bGwhPWM/YS5YLmdldChjLnBhdGgpLlEoVChjLnBhdGgsYikpOm51bGx9XG5mdW5jdGlvbiBSZyhhKXt2YXIgYj1bXSxjPWEuWC52YWx1ZTtudWxsIT1jP2MuSigpfHxjLlAoTixmdW5jdGlvbihhLGMpe2IucHVzaChuZXcgSyhhLGMpKX0pOmEuWC5jaGlsZHJlbi5pYShmdW5jdGlvbihhLGMpe251bGwhPWMudmFsdWUmJmIucHVzaChuZXcgSyhhLGMudmFsdWUpKX0pO3JldHVybiBifWZ1bmN0aW9uIFNnKGEsYil7aWYoYi5lKCkpcmV0dXJuIGE7dmFyIGM9UWcoYSxiKTtyZXR1cm4gbnVsbCE9Yz9uZXcgTWcobmV3IHZnKGMpKTpuZXcgTWcoYS5YLnN1YnRyZWUoYikpfU1nLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWC5lKCl9O01nLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXtyZXR1cm4gVGcoQyx0aGlzLlgsYSl9O1xuZnVuY3Rpb24gVGcoYSxiLGMpe2lmKG51bGwhPWIudmFsdWUpcmV0dXJuIGMuRihhLGIudmFsdWUpO3ZhciBkPW51bGw7Yi5jaGlsZHJlbi5pYShmdW5jdGlvbihiLGYpe1wiLnByaW9yaXR5XCI9PT1iPyhIKG51bGwhPT1mLnZhbHVlLFwiUHJpb3JpdHkgd3JpdGVzIG11c3QgYWx3YXlzIGJlIGxlYWYgbm9kZXNcIiksZD1mLnZhbHVlKTpjPVRnKGEubShiKSxmLGMpfSk7Yy5RKGEpLmUoKXx8bnVsbD09PWR8fChjPWMuRihhLm0oXCIucHJpb3JpdHlcIiksZCkpO3JldHVybiBjfTtmdW5jdGlvbiBVZygpe3RoaXMuQWE9e319Zz1VZy5wcm90b3R5cGU7Zy5lPWZ1bmN0aW9uKCl7cmV0dXJuIHhhKHRoaXMuQWEpfTtnLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnNvdXJjZS5JYjtpZihudWxsIT09ZClyZXR1cm4gZD14KHRoaXMuQWEsZCksSChudWxsIT1kLFwiU3luY1RyZWUgZ2F2ZSB1cyBhbiBvcCBmb3IgYW4gaW52YWxpZCBxdWVyeS5cIiksZC5nYihhLGIsYyk7dmFyIGU9W107dCh0aGlzLkFhLGZ1bmN0aW9uKGQpe2U9ZS5jb25jYXQoZC5nYihhLGIsYykpfSk7cmV0dXJuIGV9O2cuT2I9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLnlhKCksaD14KHRoaXMuQWEsZik7aWYoIWgpe3ZhciBoPWMuQmEoZT9kOm51bGwpLGs9ITE7aD9rPSEwOihoPWQgaW5zdGFuY2VvZiBQP2Muc2MoZCk6RixrPSExKTtoPW5ldyBrZyhhLG5ldyBVZChuZXcgRGMoaCxrLCExKSxuZXcgRGMoZCxlLCExKSkpO3RoaXMuQWFbZl09aH1oLk9iKGIpO3JldHVybiBuZyhoLGIpfTtcbmcubWI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEueWEoKSxlPVtdLGY9W10saD1udWxsIT1WZyh0aGlzKTtpZihcImRlZmF1bHRcIj09PWQpe3ZhciBrPXRoaXM7dCh0aGlzLkFhLGZ1bmN0aW9uKGEsZCl7Zj1mLmNvbmNhdChhLm1iKGIsYykpO2EuZSgpJiYoZGVsZXRlIGsuQWFbZF0sUyhhLlcubil8fGUucHVzaChhLlcpKX0pfWVsc2V7dmFyIG09eCh0aGlzLkFhLGQpO20mJihmPWYuY29uY2F0KG0ubWIoYixjKSksbS5lKCkmJihkZWxldGUgdGhpcy5BYVtkXSxTKG0uVy5uKXx8ZS5wdXNoKG0uVykpKX1oJiZudWxsPT1WZyh0aGlzKSYmZS5wdXNoKG5ldyBVKGEudyxhLnBhdGgpKTtyZXR1cm57cWc6ZSxSZjpmfX07ZnVuY3Rpb24gV2coYSl7cmV0dXJuIEthKHNhKGEuQWEpLGZ1bmN0aW9uKGEpe3JldHVybiFTKGEuVy5uKX0pfWcuamI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDt0KHRoaXMuQWEsZnVuY3Rpb24oYyl7Yj1ifHxjLmpiKGEpfSk7cmV0dXJuIGJ9O1xuZnVuY3Rpb24gWGcoYSxiKXtpZihTKGIubikpcmV0dXJuIFZnKGEpO3ZhciBjPWIueWEoKTtyZXR1cm4geChhLkFhLGMpfWZ1bmN0aW9uIFZnKGEpe3JldHVybiB3YShhLkFhLGZ1bmN0aW9uKGEpe3JldHVybiBTKGEuVy5uKX0pfHxudWxsfTtmdW5jdGlvbiBZZygpe3RoaXMuVD1OZzt0aGlzLmxhPVtdO3RoaXMuQ2M9LTF9ZnVuY3Rpb24gWmcoYSxiKXtmb3IodmFyIGM9MDtjPGEubGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5sYVtjXTtpZihkLlpjPT09YilyZXR1cm4gZH1yZXR1cm4gbnVsbH1nPVlnLnByb3RvdHlwZTtcbmcuRWQ9ZnVuY3Rpb24oYSl7dmFyIGI9UGEodGhpcy5sYSxmdW5jdGlvbihiKXtyZXR1cm4gYi5aYz09PWF9KTtIKDA8PWIsXCJyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLlwiKTt2YXIgYz10aGlzLmxhW2JdO3RoaXMubGEuc3BsaWNlKGIsMSk7Zm9yKHZhciBkPWMudmlzaWJsZSxlPSExLGY9dGhpcy5sYS5sZW5ndGgtMTtkJiYwPD1mOyl7dmFyIGg9dGhpcy5sYVtmXTtoLnZpc2libGUmJihmPj1iJiYkZyhoLGMucGF0aCk/ZD0hMTpjLnBhdGguY29udGFpbnMoaC5wYXRoKSYmKGU9ITApKTtmLS19aWYoZCl7aWYoZSl0aGlzLlQ9YWgodGhpcy5sYSxiaCxDKSx0aGlzLkNjPTA8dGhpcy5sYS5sZW5ndGg/dGhpcy5sYVt0aGlzLmxhLmxlbmd0aC0xXS5aYzotMTtlbHNlIGlmKGMuSmEpdGhpcy5UPXRoaXMuVC5FZChjLnBhdGgpO2Vsc2V7dmFyIGs9dGhpczt0KGMuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtrLlQ9ay5ULkVkKGMucGF0aC5tKGIpKX0pfXJldHVybiEwfXJldHVybiExfTtcbmcuQmE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoY3x8ZCl7dmFyIGU9U2codGhpcy5ULGEpO3JldHVybiFkJiZlLmUoKT9iOmR8fG51bGwhPWJ8fG51bGwhPVFnKGUsQyk/KGU9YWgodGhpcy5sYSxmdW5jdGlvbihiKXtyZXR1cm4oYi52aXNpYmxlfHxkKSYmKCFjfHwhKDA8PUlhKGMsYi5aYykpKSYmKGIucGF0aC5jb250YWlucyhhKXx8YS5jb250YWlucyhiLnBhdGgpKX0sYSksYj1ifHxGLGUuYXBwbHkoYikpOm51bGx9ZT1RZyh0aGlzLlQsYSk7aWYobnVsbCE9ZSlyZXR1cm4gZTtlPVNnKHRoaXMuVCxhKTtyZXR1cm4gZS5lKCk/YjpudWxsIT1ifHxudWxsIT1RZyhlLEMpPyhiPWJ8fEYsZS5hcHBseShiKSk6bnVsbH07XG5nLnNjPWZ1bmN0aW9uKGEsYil7dmFyIGM9RixkPVFnKHRoaXMuVCxhKTtpZihkKWQuSigpfHxkLlAoTixmdW5jdGlvbihhLGIpe2M9Yy5VKGEsYil9KTtlbHNlIGlmKGIpe3ZhciBlPVNnKHRoaXMuVCxhKTtiLlAoTixmdW5jdGlvbihhLGIpe3ZhciBkPVNnKGUsbmV3IEwoYSkpLmFwcGx5KGIpO2M9Yy5VKGEsZCl9KTtKYShSZyhlKSxmdW5jdGlvbihhKXtjPWMuVShhLm5hbWUsYS5TKX0pfWVsc2UgZT1TZyh0aGlzLlQsYSksSmEoUmcoZSksZnVuY3Rpb24oYSl7Yz1jLlUoYS5uYW1lLGEuUyl9KTtyZXR1cm4gY307Zy4kYz1mdW5jdGlvbihhLGIsYyxkKXtIKGN8fGQsXCJFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcIik7YT1hLm0oYik7aWYobnVsbCE9UWcodGhpcy5ULGEpKXJldHVybiBudWxsO2E9U2codGhpcy5ULGEpO3JldHVybiBhLmUoKT9kLlEoYik6YS5hcHBseShkLlEoYikpfTtcbmcucmM9ZnVuY3Rpb24oYSxiLGMpe2E9YS5tKGIpO3ZhciBkPVFnKHRoaXMuVCxhKTtyZXR1cm4gbnVsbCE9ZD9kOkNjKGMsYik/U2codGhpcy5ULGEpLmFwcGx5KGMuaigpLlIoYikpOm51bGx9O2cubWM9ZnVuY3Rpb24oYSl7cmV0dXJuIFFnKHRoaXMuVCxhKX07Zy5YZD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGg7YT1TZyh0aGlzLlQsYSk7aD1RZyhhLEMpO2lmKG51bGw9PWgpaWYobnVsbCE9YiloPWEuYXBwbHkoYik7ZWxzZSByZXR1cm5bXTtoPWgub2IoZik7aWYoaC5lKCl8fGguSigpKXJldHVybltdO2I9W107YT1rZShmKTtlPWU/aC4kYihjLGYpOmguWWIoYyxmKTtmb3IoZj1SKGUpO2YmJmIubGVuZ3RoPGQ7KTAhPT1hKGYsYykmJmIucHVzaChmKSxmPVIoZSk7cmV0dXJuIGJ9O1xuZnVuY3Rpb24gJGcoYSxiKXtyZXR1cm4gYS5KYT9hLnBhdGguY29udGFpbnMoYik6ISF2YShhLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEucGF0aC5tKGQpLmNvbnRhaW5zKGIpfSl9ZnVuY3Rpb24gYmgoYSl7cmV0dXJuIGEudmlzaWJsZX1cbmZ1bmN0aW9uIGFoKGEsYixjKXtmb3IodmFyIGQ9TmcsZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKGIoZikpe3ZhciBoPWYucGF0aDtpZihmLkphKWMuY29udGFpbnMoaCk/KGg9VChjLGgpLGQ9T2coZCxoLGYuSmEpKTpoLmNvbnRhaW5zKGMpJiYoaD1UKGgsYyksZD1PZyhkLEMsZi5KYS5RKGgpKSk7ZWxzZSBpZihmLmNoaWxkcmVuKWlmKGMuY29udGFpbnMoaCkpaD1UKGMsaCksZD1QZyhkLGgsZi5jaGlsZHJlbik7ZWxzZXtpZihoLmNvbnRhaW5zKGMpKWlmKGg9VChoLGMpLGguZSgpKWQ9UGcoZCxDLGYuY2hpbGRyZW4pO2Vsc2UgaWYoZj14KGYuY2hpbGRyZW4sSihoKSkpZj1mLlEoRChoKSksZD1PZyhkLEMsZil9ZWxzZSB0aHJvdyBXYyhcIldyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlblwiKTt9fXJldHVybiBkfWZ1bmN0aW9uIGNoKGEsYil7dGhpcy5NYj1hO3RoaXMuWD1ifWc9Y2gucHJvdG90eXBlO1xuZy5CYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuWC5CYSh0aGlzLk1iLGEsYixjKX07Zy5zYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5YLnNjKHRoaXMuTWIsYSl9O2cuJGM9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlguJGModGhpcy5NYixhLGIsYyl9O2cubWM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWC5tYyh0aGlzLk1iLm0oYSkpfTtnLlhkPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuWC5YZCh0aGlzLk1iLGEsYixjLGQsZSl9O2cucmM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5YLnJjKHRoaXMuTWIsYSxiKX07Zy5tPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgY2godGhpcy5NYi5tKGEpLHRoaXMuWCl9O2Z1bmN0aW9uIGRoKCl7dGhpcy5jaGlsZHJlbj17fTt0aGlzLmFkPTA7dGhpcy52YWx1ZT1udWxsfWZ1bmN0aW9uIGVoKGEsYixjKXt0aGlzLnVkPWE/YTpcIlwiO3RoaXMuSGE9Yj9iOm51bGw7dGhpcy5BPWM/YzpuZXcgZGh9ZnVuY3Rpb24gZmgoYSxiKXtmb3IodmFyIGM9YiBpbnN0YW5jZW9mIEw/YjpuZXcgTChiKSxkPWEsZTtudWxsIT09KGU9SihjKSk7KWQ9bmV3IGVoKGUsZCx4KGQuQS5jaGlsZHJlbixlKXx8bmV3IGRoKSxjPUQoYyk7cmV0dXJuIGR9Zz1laC5wcm90b3R5cGU7Zy5FYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkEudmFsdWV9O2Z1bmN0aW9uIGdoKGEsYil7SChcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIsXCJDYW5ub3Qgc2V0IHZhbHVlIHRvIHVuZGVmaW5lZFwiKTthLkEudmFsdWU9YjtoaChhKX1nLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5BLnZhbHVlPW51bGw7dGhpcy5BLmNoaWxkcmVuPXt9O3RoaXMuQS5hZD0wO2hoKHRoaXMpfTtcbmcua2Q9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLkEuYWR9O2cuZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5FYSgpJiYhdGhpcy5rZCgpfTtnLlA9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0KHRoaXMuQS5jaGlsZHJlbixmdW5jdGlvbihjLGQpe2EobmV3IGVoKGQsYixjKSl9KX07ZnVuY3Rpb24gaWgoYSxiLGMsZCl7YyYmIWQmJmIoYSk7YS5QKGZ1bmN0aW9uKGEpe2loKGEsYiwhMCxkKX0pO2MmJmQmJmIoYSl9ZnVuY3Rpb24gamgoYSxiKXtmb3IodmFyIGM9YS5wYXJlbnQoKTtudWxsIT09YyYmIWIoYyk7KWM9Yy5wYXJlbnQoKX1nLnBhdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEwobnVsbD09PXRoaXMuSGE/dGhpcy51ZDp0aGlzLkhhLnBhdGgoKStcIi9cIit0aGlzLnVkKX07Zy5uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWR9O2cucGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuSGF9O1xuZnVuY3Rpb24gaGgoYSl7aWYobnVsbCE9PWEuSGEpe3ZhciBiPWEuSGEsYz1hLnVkLGQ9YS5lKCksZT1CYihiLkEuY2hpbGRyZW4sYyk7ZCYmZT8oZGVsZXRlIGIuQS5jaGlsZHJlbltjXSxiLkEuYWQtLSxoaChiKSk6ZHx8ZXx8KGIuQS5jaGlsZHJlbltjXT1hLkEsYi5BLmFkKyssaGgoYikpfX07ZnVuY3Rpb24ga2goYSxiLGMsZCxlLGYpe3RoaXMuaWQ9bGgrKzt0aGlzLmY9YmQoXCJwOlwiK3RoaXMuaWQrXCI6XCIpO3RoaXMucWQ9e307dGhpcy4kPXt9O3RoaXMucGE9W107dGhpcy5QYz0wO3RoaXMuTGM9W107dGhpcy5tYT0hMTt0aGlzLlZhPTFFMzt0aGlzLnRkPTNFNTt0aGlzLkhiPWI7dGhpcy5LYz1jO3RoaXMudGU9ZDt0aGlzLk09YTt0aGlzLnBiPXRoaXMuSWE9dGhpcy5EYj10aGlzLnllPW51bGw7dGhpcy5WZD1lO3RoaXMuZGU9ITE7aWYoZil0aHJvdyBFcnJvcihcIkF1dGggb3ZlcnJpZGUgc3BlY2lmaWVkIGluIG9wdGlvbnMsIGJ1dCBub3Qgc3VwcG9ydGVkIG9uIG5vbiBOb2RlLmpzIHBsYXRmb3Jtc1wiKTt0aGlzLkllPWZ8fG51bGw7dGhpcy52Yj1udWxsO3RoaXMuTmI9ITE7dGhpcy5HZD17fTt0aGlzLnJnPTA7dGhpcy5UZT0hMDt0aGlzLkJjPXRoaXMubGU9bnVsbDttaCh0aGlzLDApO1BmLldiKCkuaGMoXCJ2aXNpYmxlXCIsdGhpcy5oZyx0aGlzKTstMT09PWEuaG9zdC5pbmRleE9mKFwiZmJsb2NhbFwiKSYmXG5PZi5XYigpLmhjKFwib25saW5lXCIsdGhpcy5nZyx0aGlzKX12YXIgbGg9MCxuaD0wO2c9a2gucHJvdG90eXBlO2cudWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPSsrdGhpcy5yZzthPXtyOmQsYTphLGI6Yn07dGhpcy5mKEIoYSkpO0godGhpcy5tYSxcInNlbmRSZXF1ZXN0IGNhbGwgd2hlbiB3ZSdyZSBub3QgY29ubmVjdGVkIG5vdCBhbGxvd2VkLlwiKTt0aGlzLklhLnVhKGEpO2MmJih0aGlzLkdkW2RdPWMpfTtcbmcuYmY9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS55YSgpLGY9YS5wYXRoLnRvU3RyaW5nKCk7dGhpcy5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZitcIiBcIitlKTt0aGlzLiRbZl09dGhpcy4kW2ZdfHx7fTtIKHpkKGEubil8fCFTKGEubiksXCJsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeVwiKTtIKCF0aGlzLiRbZl1bZV0sXCJsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLlwiKTthPXtHOmQsbGQ6YixuZzphLHRhZzpjfTt0aGlzLiRbZl1bZV09YTt0aGlzLm1hJiZvaCh0aGlzLGEpfTtcbmZ1bmN0aW9uIG9oKGEsYil7dmFyIGM9Yi5uZyxkPWMucGF0aC50b1N0cmluZygpLGU9Yy55YSgpO2EuZihcIkxpc3RlbiBvbiBcIitkK1wiIGZvciBcIitlKTt2YXIgZj17cDpkfTtiLnRhZyYmKGYucT1FZShjLm4pLGYudD1iLnRhZyk7Zi5oPWIubGQoKTthLnVhKFwicVwiLGYsZnVuY3Rpb24oZil7dmFyIGs9Zi5kLG09Zi5zO2lmKGsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmQmIoayxcIndcIikpe3ZhciBsPXgoayxcIndcIik7ZGEobCkmJjA8PUlhKGwsXCJub19pbmRleFwiKSYmTyhcIlVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBDb25zaWRlciBhZGRpbmcgXCIrKCdcIi5pbmRleE9uXCI6IFwiJytjLm4uZy50b1N0cmluZygpKydcIicpK1wiIGF0IFwiK2MucGF0aC50b1N0cmluZygpK1wiIHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZVwiKX0oYS4kW2RdJiZhLiRbZF1bZV0pPT09YiYmKGEuZihcImxpc3RlbiByZXNwb25zZVwiLGYpLFwib2tcIiE9PW0mJnBoKGEsZCxlKSxiLkcmJmIuRyhtLFxuaykpfSl9Zy5vZj1mdW5jdGlvbihhKXt0aGlzLnBiPWE7dGhpcy5mKFwiQXV0aCB0b2tlbiByZWZyZXNoZWRcIik7dGhpcy5wYj9xaCh0aGlzKTp0aGlzLm1hJiZ0aGlzLnVhKFwidW5hdXRoXCIse30sZnVuY3Rpb24oKXt9KTtpZihhJiY0MD09PWEubGVuZ3RofHxwZChhKSl0aGlzLmYoXCJBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuXCIpLHRoaXMudGQ9M0U0fTtmdW5jdGlvbiBxaChhKXtpZihhLm1hJiZhLnBiKXt2YXIgYj1hLnBiLGM9e2NyZWQ6Yn07YS5JZSYmKGMuYXV0aHZhcj1hLkllKTthLnVhKFwiYXV0aFwiLGMsZnVuY3Rpb24oYyl7dmFyIGU9Yy5zO2M9Yy5kfHxcImVycm9yXCI7XCJva1wiIT09ZSYmYS5wYj09PWImJnJoKGEsZSxjKX0pfX1cbmcuQ2Y9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnBhdGgudG9TdHJpbmcoKSxkPWEueWEoKTt0aGlzLmYoXCJVbmxpc3RlbiBjYWxsZWQgZm9yIFwiK2MrXCIgXCIrZCk7SCh6ZChhLm4pfHwhUyhhLm4pLFwidW5saXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeVwiKTtpZihwaCh0aGlzLGMsZCkmJnRoaXMubWEpe3ZhciBlPUVlKGEubik7dGhpcy5mKFwiVW5saXN0ZW4gb24gXCIrYytcIiBmb3IgXCIrZCk7Yz17cDpjfTtiJiYoYy5xPWUsYy50PWIpO3RoaXMudWEoXCJuXCIsYyl9fTtnLnFlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLm1hP3NoKHRoaXMsXCJvXCIsYSxiLGMpOnRoaXMuTGMucHVzaCh7dmU6YSxhY3Rpb246XCJvXCIsZGF0YTpiLEc6Y30pfTtnLmVmPWZ1bmN0aW9uKGEsYixjKXt0aGlzLm1hP3NoKHRoaXMsXCJvbVwiLGEsYixjKTp0aGlzLkxjLnB1c2goe3ZlOmEsYWN0aW9uOlwib21cIixkYXRhOmIsRzpjfSl9O1xuZy54ZD1mdW5jdGlvbihhLGIpe3RoaXMubWE/c2godGhpcyxcIm9jXCIsYSxudWxsLGIpOnRoaXMuTGMucHVzaCh7dmU6YSxhY3Rpb246XCJvY1wiLGRhdGE6bnVsbCxHOmJ9KX07ZnVuY3Rpb24gc2goYSxiLGMsZCxlKXtjPXtwOmMsZDpkfTthLmYoXCJvbkRpc2Nvbm5lY3QgXCIrYixjKTthLnVhKGIsYyxmdW5jdGlvbihhKXtlJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShhLnMsYS5kKX0sTWF0aC5mbG9vcigwKSl9KX1nLnB1dD1mdW5jdGlvbihhLGIsYyxkKXt0aCh0aGlzLFwicFwiLGEsYixjLGQpfTtnLmNmPWZ1bmN0aW9uKGEsYixjLGQpe3RoKHRoaXMsXCJtXCIsYSxiLGMsZCl9O2Z1bmN0aW9uIHRoKGEsYixjLGQsZSxmKXtkPXtwOmMsZDpkfTtwKGYpJiYoZC5oPWYpO2EucGEucHVzaCh7YWN0aW9uOmIscWY6ZCxHOmV9KTthLlBjKys7Yj1hLnBhLmxlbmd0aC0xO2EubWE/dWgoYSxiKTphLmYoXCJCdWZmZXJpbmcgcHV0OiBcIitjKX1cbmZ1bmN0aW9uIHVoKGEsYil7dmFyIGM9YS5wYVtiXS5hY3Rpb24sZD1hLnBhW2JdLnFmLGU9YS5wYVtiXS5HO2EucGFbYl0ub2c9YS5tYTthLnVhKGMsZCxmdW5jdGlvbihkKXthLmYoYytcIiByZXNwb25zZVwiLGQpO2RlbGV0ZSBhLnBhW2JdO2EuUGMtLTswPT09YS5QYyYmKGEucGE9W10pO2UmJmUoZC5zLGQuZCl9KX1nLnhlPWZ1bmN0aW9uKGEpe3RoaXMubWEmJihhPXtjOmF9LHRoaXMuZihcInJlcG9ydFN0YXRzXCIsYSksdGhpcy51YShcInNcIixhLGZ1bmN0aW9uKGEpe1wib2tcIiE9PWEucyYmdGhpcy5mKFwicmVwb3J0U3RhdHNcIixcIkVycm9yIHNlbmRpbmcgc3RhdHM6IFwiK2EuZCl9KSl9O1xuZy53ZD1mdW5jdGlvbihhKXtpZihcInJcImluIGEpe3RoaXMuZihcImZyb20gc2VydmVyOiBcIitCKGEpKTt2YXIgYj1hLnIsYz10aGlzLkdkW2JdO2MmJihkZWxldGUgdGhpcy5HZFtiXSxjKGEuYikpfWVsc2V7aWYoXCJlcnJvclwiaW4gYSl0aHJvd1wiQSBzZXJ2ZXItc2lkZSBlcnJvciBoYXMgb2NjdXJyZWQ6IFwiK2EuZXJyb3I7XCJhXCJpbiBhJiYoYj1hLmEsYT1hLmIsdGhpcy5mKFwiaGFuZGxlU2VydmVyTWVzc2FnZVwiLGIsYSksXCJkXCI9PT1iP3RoaXMuSGIoYS5wLGEuZCwhMSxhLnQpOlwibVwiPT09Yj90aGlzLkhiKGEucCxhLmQsITAsYS50KTpcImNcIj09PWI/dmgodGhpcyxhLnAsYS5xKTpcImFjXCI9PT1iP3JoKHRoaXMsYS5zLGEuZCk6XCJzZFwiPT09Yj90aGlzLnllP3RoaXMueWUoYSk6XCJtc2dcImluIGEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2coXCJGSVJFQkFTRTogXCIrYS5tc2cucmVwbGFjZShcIlxcblwiLFwiXFxuRklSRUJBU0U6IFwiKSk6Y2QoXCJVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIitcbkIoYikrXCJcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50P1wiKSl9fTtcbmcuTWM9ZnVuY3Rpb24oYSxiKXt0aGlzLmYoXCJjb25uZWN0aW9uIHJlYWR5XCIpO3RoaXMubWE9ITA7dGhpcy5CYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLnRlKHtzZXJ2ZXJUaW1lT2Zmc2V0OmEtKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTt0aGlzLkRiPWI7aWYodGhpcy5UZSl7dmFyIGM9e307Y1tcInNkay5qcy5cIitmaXJlYmFzZS5TREtfVkVSU0lPTi5yZXBsYWNlKC9cXC4vZyxcIi1cIildPTE7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJih3aW5kb3cuY29yZG92YXx8d2luZG93LnBob25lZ2FwfHx3aW5kb3cuUGhvbmVHYXApJiYvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChcInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmXCJzdHJpbmdcIj09PXR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50P25hdmlnYXRvci51c2VyQWdlbnQ6XCJcIik/Y1tcImZyYW1ld29yay5jb3Jkb3ZhXCJdPTE6XCJvYmplY3RcIj09PXR5cGVvZiBuYXZpZ2F0b3ImJlxuXCJSZWFjdE5hdGl2ZVwiPT09bmF2aWdhdG9yLnByb2R1Y3QmJihjW1wiZnJhbWV3b3JrLnJlYWN0bmF0aXZlXCJdPTEpO3RoaXMueGUoYyl9d2godGhpcyk7dGhpcy5UZT0hMTt0aGlzLktjKCEwKX07ZnVuY3Rpb24gbWgoYSxiKXtIKCFhLklhLFwiU2NoZWR1bGluZyBhIGNvbm5lY3Qgd2hlbiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZC9pbmc/XCIpO2EudmImJmNsZWFyVGltZW91dChhLnZiKTthLnZiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLnZiPW51bGw7eGgoYSl9LE1hdGguZmxvb3IoYikpfWcuaGc9ZnVuY3Rpb24oYSl7YSYmIXRoaXMuTmImJnRoaXMuVmE9PT10aGlzLnRkJiYodGhpcy5mKFwiV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuXCIpLHRoaXMuVmE9MUUzLHRoaXMuSWF8fG1oKHRoaXMsMCkpO3RoaXMuTmI9YX07XG5nLmdnPWZ1bmN0aW9uKGEpe2E/KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvbmxpbmUuXCIpLHRoaXMuVmE9MUUzLHRoaXMuSWF8fG1oKHRoaXMsMCkpOih0aGlzLmYoXCJCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi5cIiksdGhpcy5JYSYmdGhpcy5JYS5jbG9zZSgpKX07XG5nLmdmPWZ1bmN0aW9uKCl7dGhpcy5mKFwiZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkXCIpO3RoaXMubWE9ITE7dGhpcy5JYT1udWxsO2Zvcih2YXIgYT0wO2E8dGhpcy5wYS5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLnBhW2FdO2ImJlwiaFwiaW4gYi5xZiYmYi5vZyYmKGIuRyYmYi5HKFwiZGlzY29ubmVjdFwiKSxkZWxldGUgdGhpcy5wYVthXSx0aGlzLlBjLS0pfTA9PT10aGlzLlBjJiYodGhpcy5wYT1bXSk7dGhpcy5HZD17fTt5aCh0aGlzKSYmKHRoaXMuTmI/dGhpcy5CYyYmKDNFNDwobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLkJjJiYodGhpcy5WYT0xRTMpLHRoaXMuQmM9bnVsbCk6KHRoaXMuZihcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKSx0aGlzLlZhPXRoaXMudGQsdGhpcy5sZT0obmV3IERhdGUpLmdldFRpbWUoKSksYT1NYXRoLm1heCgwLHRoaXMuVmEtKChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMubGUpKSxhKj1NYXRoLnJhbmRvbSgpLHRoaXMuZihcIlRyeWluZyB0byByZWNvbm5lY3QgaW4gXCIrXG5hK1wibXNcIiksbWgodGhpcyxhKSx0aGlzLlZhPU1hdGgubWluKHRoaXMudGQsMS4zKnRoaXMuVmEpKTt0aGlzLktjKCExKX07XG5mdW5jdGlvbiB4aChhKXtpZih5aChhKSl7YS5mKFwiTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0XCIpO2EubGU9KG5ldyBEYXRlKS5nZXRUaW1lKCk7YS5CYz1udWxsO3ZhciBiPXIoYS53ZCxhKSxjPXIoYS5NYyxhKSxkPXIoYS5nZixhKSxlPWEuaWQrXCI6XCIrbmgrKyxmPWEuRGIsaD0hMSxrPW51bGwsbT1mdW5jdGlvbigpe2s/ay5jbG9zZSgpOihoPSEwLGQoKSl9O2EuSWE9e2Nsb3NlOm0sdWE6ZnVuY3Rpb24oYSl7SChrLFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO2sudWEoYSl9fTt2YXIgbD1hLmRlO2EuZGU9ITE7YS5WZC5nZXRUb2tlbihsKS50aGVuKGZ1bmN0aW9uKGwpe2g/RShcImdldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWRcIik6KEUoXCJnZXRUb2tlbigpIGNvbXBsZXRlZC4gQ3JlYXRpbmcgY29ubmVjdGlvbi5cIiksYS5wYj1sJiZsLmFjY2Vzc1Rva2VuLGs9bmV3IFllKGUsYS5NLGIsYyxkLGZ1bmN0aW9uKGIpe08oYitcblwiIChcIithLk0udG9TdHJpbmcoKStcIilcIik7YS5lYihcInNlcnZlcl9raWxsXCIpfSxmKSl9KS50aGVuKG51bGwsZnVuY3Rpb24oYil7YS5mKFwiRmFpbGVkIHRvIGdldCB0b2tlbjogXCIrYik7aHx8bSgpfSl9fWcuZWI9ZnVuY3Rpb24oYSl7RShcIkludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246IFwiK2EpO3RoaXMucWRbYV09ITA7dGhpcy5JYT90aGlzLklhLmNsb3NlKCk6KHRoaXMudmImJihjbGVhclRpbWVvdXQodGhpcy52YiksdGhpcy52Yj1udWxsKSx0aGlzLm1hJiZ0aGlzLmdmKCkpfTtnLmxjPWZ1bmN0aW9uKGEpe0UoXCJSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246IFwiK2EpO2RlbGV0ZSB0aGlzLnFkW2FdO3hhKHRoaXMucWQpJiYodGhpcy5WYT0xRTMsdGhpcy5JYXx8bWgodGhpcywwKSl9O1xuZnVuY3Rpb24gdmgoYSxiLGMpe2M9Yz9MYShjLGZ1bmN0aW9uKGEpe3JldHVybiBqZChhKX0pLmpvaW4oXCIkXCIpOlwiZGVmYXVsdFwiOyhhPXBoKGEsYixjKSkmJmEuRyYmYS5HKFwicGVybWlzc2lvbl9kZW5pZWRcIil9ZnVuY3Rpb24gcGgoYSxiLGMpe2I9KG5ldyBMKGIpKS50b1N0cmluZygpO3ZhciBkO3AoYS4kW2JdKT8oZD1hLiRbYl1bY10sZGVsZXRlIGEuJFtiXVtjXSwwPT09cWEoYS4kW2JdKSYmZGVsZXRlIGEuJFtiXSk6ZD12b2lkIDA7cmV0dXJuIGR9XG5mdW5jdGlvbiByaChhLGIsYyl7RShcIkF1dGggdG9rZW4gcmV2b2tlZDogXCIrYitcIi9cIitjKTthLnBiPW51bGw7YS5kZT0hMDthLklhLmNsb3NlKCk7XCJpbnZhbGlkX3Rva2VuXCI9PT1iJiYoYS5WYT0zRTQsTyhcIlByb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgRmlyZWJhc2VBcHAgaW5zdGFuY2Ugd2FzIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHkuIE1ha2Ugc3VyZSB5b3VyIGFwaUtleSBhbmQgZGF0YWJhc2VVUkwgbWF0Y2ggdGhlIHZhbHVlcyBwcm92aWRlZCBmb3IgeW91ciBhcHAgYXQgaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20vLCBvciBpZiB5b3UncmUgdXNpbmcgYSBzZXJ2aWNlIGFjY291bnQsIG1ha2Ugc3VyZSBpdCdzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2VVUkwgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgcHJvamVjdC5cIikpfVxuZnVuY3Rpb24gd2goYSl7cWgoYSk7dChhLiQsZnVuY3Rpb24oYil7dChiLGZ1bmN0aW9uKGIpe29oKGEsYil9KX0pO2Zvcih2YXIgYj0wO2I8YS5wYS5sZW5ndGg7YisrKWEucGFbYl0mJnVoKGEsYik7Zm9yKDthLkxjLmxlbmd0aDspYj1hLkxjLnNoaWZ0KCksc2goYSxiLmFjdGlvbixiLnZlLGIuZGF0YSxiLkcpfWZ1bmN0aW9uIHloKGEpe3ZhciBiO2I9T2YuV2IoKS5pYztyZXR1cm4geGEoYS5xZCkmJmJ9O3ZhciBZPXtWZjpmdW5jdGlvbigpe05lPXRkPSEwfX07WS5mb3JjZUxvbmdQb2xsaW5nPVkuVmY7WS5XZj1mdW5jdGlvbigpe09lPSEwfTtZLmZvcmNlV2ViU29ja2V0cz1ZLldmO1kuYmc9ZnVuY3Rpb24oKXtyZXR1cm4gcmQuaXNBdmFpbGFibGUoKX07WS5pc1dlYlNvY2tldHNBdmFpbGFibGU9WS5iZztZLnVnPWZ1bmN0aW9uKGEsYil7YS53LlVhLnllPWJ9O1kuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVkudWc7WS5BZT1mdW5jdGlvbihhLGIpe2Eudy5BZShiKX07WS5zdGF0cz1ZLkFlO1kuQmU9ZnVuY3Rpb24oYSxiKXthLncuQmUoYil9O1kuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVkuQmU7WS5lZD1mdW5jdGlvbihhKXtyZXR1cm4gYS53LmVkfTtZLmRhdGFVcGRhdGVDb3VudD1ZLmVkO1kuYWc9ZnVuY3Rpb24oYSxiKXthLncuamU9Yn07WS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVkuYWc7ZnVuY3Rpb24gemgoYSl7dGhpcy53YT1RO3RoaXMubGI9bmV3IFlnO3RoaXMuQ2U9e307dGhpcy5qYz17fTt0aGlzLkRjPWF9ZnVuY3Rpb24gQWgoYSxiLGMsZCxlKXt2YXIgZj1hLmxiLGg9ZTtIKGQ+Zi5DYyxcIlN0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzXCIpO3AoaCl8fChoPSEwKTtmLmxhLnB1c2goe3BhdGg6YixKYTpjLFpjOmQsdmlzaWJsZTpofSk7aCYmKGYuVD1PZyhmLlQsYixjKSk7Zi5DYz1kO3JldHVybiBlP0JoKGEsbmV3IFpiKEpnLGIsYykpOltdfWZ1bmN0aW9uIENoKGEsYixjLGQpe3ZhciBlPWEubGI7SChkPmUuQ2MsXCJTdGFja2luZyBhbiBvbGRlciBtZXJnZSBvbiB0b3Agb2YgbmV3ZXIgb25lc1wiKTtlLmxhLnB1c2goe3BhdGg6YixjaGlsZHJlbjpjLFpjOmQsdmlzaWJsZTohMH0pO2UuVD1QZyhlLlQsYixjKTtlLkNjPWQ7Yz14ZyhjKTtyZXR1cm4gQmgoYSxuZXcgQ2QoSmcsYixjKSl9XG5mdW5jdGlvbiBEaChhLGIsYyl7Yz1jfHwhMTt2YXIgZD1aZyhhLmxiLGIpO2lmKGEubGIuRWQoYikpe3ZhciBlPVE7bnVsbCE9ZC5KYT9lPWUuc2V0KEMsITApOkNiKGQuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtlPWUuc2V0KG5ldyBMKGEpLGIpfSk7cmV0dXJuIEJoKGEsbmV3IElnKGQucGF0aCxlLGMpKX1yZXR1cm5bXX1mdW5jdGlvbiBFaChhLGIsYyl7Yz14ZyhjKTtyZXR1cm4gQmgoYSxuZXcgQ2QoTGcsYixjKSl9ZnVuY3Rpb24gRmgoYSxiLGMsZCl7ZD1HaChhLGQpO2lmKG51bGwhPWQpe3ZhciBlPUhoKGQpO2Q9ZS5wYXRoO2U9ZS5JYjtiPVQoZCxiKTtjPW5ldyBaYihuZXcgS2coITEsITAsZSwhMCksYixjKTtyZXR1cm4gSWgoYSxkLGMpfXJldHVybltdfVxuZnVuY3Rpb24gSmgoYSxiLGMsZCl7aWYoZD1HaChhLGQpKXt2YXIgZT1IaChkKTtkPWUucGF0aDtlPWUuSWI7Yj1UKGQsYik7Yz14ZyhjKTtjPW5ldyBDZChuZXcgS2coITEsITAsZSwhMCksYixjKTtyZXR1cm4gSWgoYSxkLGMpfXJldHVybltdfVxuemgucHJvdG90eXBlLk9iPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLGQ9bnVsbCxlPSExO0VnKHRoaXMud2EsYyxmdW5jdGlvbihhLGIpe3ZhciBmPVQoYSxjKTtkPWR8fGIuamIoZik7ZT1lfHxudWxsIT1WZyhiKX0pO3ZhciBmPXRoaXMud2EuZ2V0KGMpO2Y/KGU9ZXx8bnVsbCE9VmcoZiksZD1kfHxmLmpiKEMpKTooZj1uZXcgVWcsdGhpcy53YT10aGlzLndhLnNldChjLGYpKTt2YXIgaDtudWxsIT1kP2g9ITA6KGg9ITEsZD1GLEhnKHRoaXMud2Euc3VidHJlZShjKSxmdW5jdGlvbihhLGIpe3ZhciBjPWIuamIoQyk7YyYmKGQ9ZC5VKGEsYykpfSkpO3ZhciBrPW51bGwhPVhnKGYsYSk7aWYoIWsmJiFTKGEubikpe3ZhciBtPUtoKGEpO0goIShtIGluIHRoaXMuamMpLFwiVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWdcIik7dmFyIGw9TGgrKzt0aGlzLmpjW21dPWw7dGhpcy5DZVtcIl9cIitsXT1tfWg9Zi5PYihhLGIsbmV3IGNoKGMsdGhpcy5sYiksZCxoKTtrfHxcbmV8fChmPVhnKGYsYSksaD1oLmNvbmNhdChNaCh0aGlzLGEsZikpKTtyZXR1cm4gaH07XG56aC5wcm90b3R5cGUubWI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEucGF0aCxlPXRoaXMud2EuZ2V0KGQpLGY9W107aWYoZSYmKFwiZGVmYXVsdFwiPT09YS55YSgpfHxudWxsIT1YZyhlLGEpKSl7Zj1lLm1iKGEsYixjKTtlLmUoKSYmKHRoaXMud2E9dGhpcy53YS5yZW1vdmUoZCkpO2U9Zi5xZztmPWYuUmY7Yj0tMSE9PVBhKGUsZnVuY3Rpb24oYSl7cmV0dXJuIFMoYS5uKX0pO3ZhciBoPUNnKHRoaXMud2EsZCxmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1WZyhiKX0pO2lmKGImJiFoJiYoZD10aGlzLndhLnN1YnRyZWUoZCksIWQuZSgpKSlmb3IodmFyIGQ9TmgoZCksaz0wO2s8ZC5sZW5ndGg7KytrKXt2YXIgbT1kW2tdLGw9bS5XLG09T2godGhpcyxtKTt0aGlzLkRjLnplKFBoKGwpLFFoKHRoaXMsbCksbS5sZCxtLkcpfWlmKCFoJiYwPGUubGVuZ3RoJiYhYylpZihiKXRoaXMuRGMuT2QoUGgoYSksbnVsbCk7ZWxzZXt2YXIgdT10aGlzO0phKGUsZnVuY3Rpb24oYSl7YS55YSgpO1xudmFyIGI9dS5qY1tLaChhKV07dS5EYy5PZChQaChhKSxiKX0pfVJoKHRoaXMsZSl9cmV0dXJuIGZ9O3poLnByb3RvdHlwZS5CYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMubGIsZD1DZyh0aGlzLndhLGEsZnVuY3Rpb24oYixjKXt2YXIgZD1UKGIsYSk7aWYoZD1jLmpiKGQpKXJldHVybiBkfSk7cmV0dXJuIGMuQmEoYSxkLGIsITApfTtmdW5jdGlvbiBOaChhKXtyZXR1cm4gQWcoYSxmdW5jdGlvbihhLGMsZCl7aWYoYyYmbnVsbCE9VmcoYykpcmV0dXJuW1ZnKGMpXTt2YXIgZT1bXTtjJiYoZT1XZyhjKSk7dChkLGZ1bmN0aW9uKGEpe2U9ZS5jb25jYXQoYSl9KTtyZXR1cm4gZX0pfWZ1bmN0aW9uIFJoKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDsrK2Mpe3ZhciBkPWJbY107aWYoIVMoZC5uKSl7dmFyIGQ9S2goZCksZT1hLmpjW2RdO2RlbGV0ZSBhLmpjW2RdO2RlbGV0ZSBhLkNlW1wiX1wiK2VdfX19XG5mdW5jdGlvbiBQaChhKXtyZXR1cm4gUyhhLm4pJiYhemQoYS5uKT9hLnhiKCk6YX1mdW5jdGlvbiBNaChhLGIsYyl7dmFyIGQ9Yi5wYXRoLGU9UWgoYSxiKTtjPU9oKGEsYyk7Yj1hLkRjLnplKFBoKGIpLGUsYy5sZCxjLkcpO2Q9YS53YS5zdWJ0cmVlKGQpO2lmKGUpSChudWxsPT1WZyhkLnZhbHVlKSxcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIik7ZWxzZSBmb3IoZT1BZyhkLGZ1bmN0aW9uKGEsYixjKXtpZighYS5lKCkmJmImJm51bGwhPVZnKGIpKXJldHVybltsZyhWZyhiKSldO3ZhciBkPVtdO2ImJihkPWQuY29uY2F0KExhKFdnKGIpLGZ1bmN0aW9uKGEpe3JldHVybiBhLld9KSkpO3QoYyxmdW5jdGlvbihhKXtkPWQuY29uY2F0KGEpfSk7cmV0dXJuIGR9KSxkPTA7ZDxlLmxlbmd0aDsrK2QpYz1lW2RdLGEuRGMuT2QoUGgoYyksUWgoYSxjKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBPaChhLGIpe3ZhciBjPWIuVyxkPVFoKGEsYyk7cmV0dXJue2xkOmZ1bmN0aW9uKCl7cmV0dXJuKGIudSgpfHxGKS5oYXNoKCl9LEc6ZnVuY3Rpb24oYil7aWYoXCJva1wiPT09Yil7aWYoZCl7dmFyIGY9Yy5wYXRoO2lmKGI9R2goYSxkKSl7dmFyIGg9SGgoYik7Yj1oLnBhdGg7aD1oLkliO2Y9VChiLGYpO2Y9bmV3IGFjKG5ldyBLZyghMSwhMCxoLCEwKSxmKTtiPUloKGEsYixmKX1lbHNlIGI9W119ZWxzZSBiPUJoKGEsbmV3IGFjKExnLGMucGF0aCkpO3JldHVybiBifWY9XCJVbmtub3duIEVycm9yXCI7XCJ0b29fYmlnXCI9PT1iP2Y9XCJUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC5cIjpcInBlcm1pc3Npb25fZGVuaWVkXCI9PWI/Zj1cIkNsaWVudCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIGRlc2lyZWQgZGF0YS5cIjpcInVuYXZhaWxhYmxlXCI9PWImJlxuKGY9XCJUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZVwiKTtmPUVycm9yKGIrXCIgYXQgXCIrYy5wYXRoLnRvU3RyaW5nKCkrXCI6IFwiK2YpO2YuY29kZT1iLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGEubWIoYyxudWxsLGYpfX19ZnVuY3Rpb24gS2goYSl7cmV0dXJuIGEucGF0aC50b1N0cmluZygpK1wiJFwiK2EueWEoKX1mdW5jdGlvbiBIaChhKXt2YXIgYj1hLmluZGV4T2YoXCIkXCIpO0goLTEhPT1iJiZiPGEubGVuZ3RoLTEsXCJCYWQgcXVlcnlLZXkuXCIpO3JldHVybntJYjphLnN1YnN0cihiKzEpLHBhdGg6bmV3IEwoYS5zdWJzdHIoMCxiKSl9fWZ1bmN0aW9uIEdoKGEsYil7dmFyIGM9YS5DZSxkPVwiX1wiK2I7cmV0dXJuIGQgaW4gYz9jW2RdOnZvaWQgMH1mdW5jdGlvbiBRaChhLGIpe3ZhciBjPUtoKGIpO3JldHVybiB4KGEuamMsYyl9dmFyIExoPTE7XG5mdW5jdGlvbiBJaChhLGIsYyl7dmFyIGQ9YS53YS5nZXQoYik7SChkLFwiTWlzc2luZyBzeW5jIHBvaW50IGZvciBxdWVyeSB0YWcgdGhhdCB3ZSdyZSB0cmFja2luZ1wiKTtyZXR1cm4gZC5nYihjLG5ldyBjaChiLGEubGIpLG51bGwpfWZ1bmN0aW9uIEJoKGEsYil7cmV0dXJuIFNoKGEsYixhLndhLG51bGwsbmV3IGNoKEMsYS5sYikpfWZ1bmN0aW9uIFNoKGEsYixjLGQsZSl7aWYoYi5wYXRoLmUoKSlyZXR1cm4gVGgoYSxiLGMsZCxlKTt2YXIgZj1jLmdldChDKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmpiKEMpKTt2YXIgaD1bXSxrPUooYi5wYXRoKSxtPWIuTmMoayk7aWYoKGM9Yy5jaGlsZHJlbi5nZXQoaykpJiZtKXZhciBsPWQ/ZC5SKGspOm51bGwsaz1lLm0oayksaD1oLmNvbmNhdChTaChhLG0sYyxsLGspKTtmJiYoaD1oLmNvbmNhdChmLmdiKGIsZSxkKSkpO3JldHVybiBofVxuZnVuY3Rpb24gVGgoYSxiLGMsZCxlKXt2YXIgZj1jLmdldChDKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmpiKEMpKTt2YXIgaD1bXTtjLmNoaWxkcmVuLmlhKGZ1bmN0aW9uKGMsZil7dmFyIGw9ZD9kLlIoYyk6bnVsbCx1PWUubShjKSx6PWIuTmMoYyk7eiYmKGg9aC5jb25jYXQoVGgoYSx6LGYsbCx1KSkpfSk7ZiYmKGg9aC5jb25jYXQoZi5nYihiLGUsZCkpKTtyZXR1cm4gaH07ZnVuY3Rpb24gcGYoYSxiLGMpe3RoaXMuYXBwPWM7dmFyIGQ9bmV3IGNjKGMpO3RoaXMuTT1hO3RoaXMuWGE9b2MoYSk7dGhpcy5WYz1udWxsO3RoaXMuZGE9bmV3IHFjO3RoaXMudmQ9MTt0aGlzLlVhPW51bGw7aWYoYnx8MDw9KFwib2JqZWN0XCI9PT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubmF2aWdhdG9yJiZ3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIikuc2VhcmNoKC9nb29nbGVib3R8Z29vZ2xlIHdlYm1hc3RlciB0b29sc3xiaW5nYm90fHlhaG9vISBzbHVycHxiYWlkdXNwaWRlcnx5YW5kZXhib3R8ZHVja2R1Y2tib3QvaSkpdGhpcy52YT1uZXcgeGQodGhpcy5NLHIodGhpcy5IYix0aGlzKSxkKSxzZXRUaW1lb3V0KHIodGhpcy5LYyx0aGlzLCEwKSwwKTtlbHNle2I9Yy5vcHRpb25zLmRhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGV8fG51bGw7aWYobnVsbCE9PWIpe2lmKFwib2JqZWN0XCIhPT1jYShiKSl0aHJvdyBFcnJvcihcIk9ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZVwiKTtcbnRyeXtCKGIpfWNhdGNoKGUpe3Rocm93IEVycm9yKFwiSW52YWxpZCBhdXRoT3ZlcnJpZGUgcHJvdmlkZWQ6IFwiK2UpO319dGhpcy52YT10aGlzLlVhPW5ldyBraCh0aGlzLk0scih0aGlzLkhiLHRoaXMpLHIodGhpcy5LYyx0aGlzKSxyKHRoaXMudGUsdGhpcyksZCxiKX12YXIgZj10aGlzO2RjKGQsZnVuY3Rpb24oYSl7Zi52YS5vZihhKX0pO3RoaXMud2c9cGMoYSxyKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpYyh0aGlzLlhhLHRoaXMudmEpfSx0aGlzKSk7dGhpcy5uYz1uZXcgZWg7dGhpcy5pZT1uZXcgZWM7dGhpcy5wZD1uZXcgemgoe3plOmZ1bmN0aW9uKGEsYixjLGQpe2I9W107Yz1mLmllLmooYS5wYXRoKTtjLmUoKXx8KGI9QmgoZi5wZCxuZXcgWmIoTGcsYS5wYXRoLGMpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZChcIm9rXCIpfSwwKSk7cmV0dXJuIGJ9LE9kOmFhfSk7VWgodGhpcyxcImNvbm5lY3RlZFwiLCExKTt0aGlzLmphPW5ldyBRYzt0aGlzLiRhPW5ldyBvZih0aGlzKTt0aGlzLmVkPVxuMDt0aGlzLmplPW51bGw7dGhpcy5LPW5ldyB6aCh7emU6ZnVuY3Rpb24oYSxiLGMsZCl7Zi52YS5iZihhLGMsYixmdW5jdGlvbihiLGMpe3ZhciBlPWQoYixjKTt2YyhmLmRhLGEucGF0aCxlKX0pO3JldHVybltdfSxPZDpmdW5jdGlvbihhLGIpe2YudmEuQ2YoYSxiKX19KX1nPXBmLnByb3RvdHlwZTtnLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuTS5TYz9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuTS5ob3N0fTtnLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5NLm9lfTtmdW5jdGlvbiBWaChhKXthPWEuaWUuaihuZXcgTChcIi5pbmZvL3NlcnZlclRpbWVPZmZzZXRcIikpLkgoKXx8MDtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKSthfWZ1bmN0aW9uIFdoKGEpe2E9YT17dGltZXN0YW1wOlZoKGEpfTthLnRpbWVzdGFtcD1hLnRpbWVzdGFtcHx8KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIGF9XG5nLkhiPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuZWQrKzt2YXIgZT1uZXcgTChhKTtiPXRoaXMuamU/dGhpcy5qZShhLGIpOmI7YT1bXTtkP2M/KGI9b2EoYixmdW5jdGlvbihhKXtyZXR1cm4gTShhKX0pLGE9SmgodGhpcy5LLGUsYixkKSk6KGI9TShiKSxhPUZoKHRoaXMuSyxlLGIsZCkpOmM/KGQ9b2EoYixmdW5jdGlvbihhKXtyZXR1cm4gTShhKX0pLGE9RWgodGhpcy5LLGUsZCkpOihkPU0oYiksYT1CaCh0aGlzLkssbmV3IFpiKExnLGUsZCkpKTtkPWU7MDxhLmxlbmd0aCYmKGQ9WGgodGhpcyxlKSk7dmModGhpcy5kYSxkLGEpfTtnLktjPWZ1bmN0aW9uKGEpe1VoKHRoaXMsXCJjb25uZWN0ZWRcIixhKTshMT09PWEmJlloKHRoaXMpfTtnLnRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7bGQoYSxmdW5jdGlvbihhLGQpe1VoKGIsZCxhKX0pfTtcbmZ1bmN0aW9uIFVoKGEsYixjKXtiPW5ldyBMKFwiLy5pbmZvL1wiK2IpO2M9TShjKTt2YXIgZD1hLmllO2QuSmQ9ZC5KZC5GKGIsYyk7Yz1CaChhLnBkLG5ldyBaYihMZyxiLGMpKTt2YyhhLmRhLGIsYyl9Zy5LYj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmYoXCJzZXRcIix7cGF0aDphLnRvU3RyaW5nKCksdmFsdWU6YixDZzpjfSk7dmFyIGU9V2godGhpcyk7Yj1NKGIsYyk7dmFyIGU9VGMoYixlKSxmPXRoaXMudmQrKyxlPUFoKHRoaXMuSyxhLGUsZiwhMCk7cmModGhpcy5kYSxlKTt2YXIgaD10aGlzO3RoaXMudmEucHV0KGEudG9TdHJpbmcoKSxiLkgoITApLGZ1bmN0aW9uKGIsYyl7dmFyIGU9XCJva1wiPT09YjtlfHxPKFwic2V0IGF0IFwiK2ErXCIgZmFpbGVkOiBcIitiKTtlPURoKGguSyxmLCFlKTt2YyhoLmRhLGEsZSk7WmgoZCxiLGMpfSk7ZT0kaCh0aGlzLGEpO1hoKHRoaXMsZSk7dmModGhpcy5kYSxlLFtdKX07XG5nLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mKFwidXBkYXRlXCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmJ9KTt2YXIgZD0hMCxlPVdoKHRoaXMpLGY9e307dChiLGZ1bmN0aW9uKGEsYil7ZD0hMTt2YXIgYz1NKGEpO2ZbYl09VGMoYyxlKX0pO2lmKGQpRShcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIiksWmgoYyxcIm9rXCIpO2Vsc2V7dmFyIGg9dGhpcy52ZCsrLGs9Q2godGhpcy5LLGEsZixoKTtyYyh0aGlzLmRhLGspO3ZhciBtPXRoaXM7dGhpcy52YS5jZihhLnRvU3RyaW5nKCksYixmdW5jdGlvbihiLGQpe3ZhciBlPVwib2tcIj09PWI7ZXx8TyhcInVwZGF0ZSBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7dmFyIGU9RGgobS5LLGgsIWUpLGY9YTswPGUubGVuZ3RoJiYoZj1YaChtLGEpKTt2YyhtLmRhLGYsZSk7WmgoYyxiLGQpfSk7Yj0kaCh0aGlzLGEpO1hoKHRoaXMsYik7dmModGhpcy5kYSxhLFtdKX19O1xuZnVuY3Rpb24gWWgoYSl7YS5mKFwib25EaXNjb25uZWN0RXZlbnRzXCIpO3ZhciBiPVdoKGEpLGM9W107UmMoUGMoYS5qYSxiKSxDLGZ1bmN0aW9uKGIsZSl7Yz1jLmNvbmNhdChCaChhLkssbmV3IFpiKExnLGIsZSkpKTt2YXIgZj0kaChhLGIpO1hoKGEsZil9KTthLmphPW5ldyBRYzt2YyhhLmRhLEMsYyl9Zy54ZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy52YS54ZChhLnRvU3RyaW5nKCksZnVuY3Rpb24oZCxlKXtcIm9rXCI9PT1kJiZ2ZihjLmphLGEpO1poKGIsZCxlKX0pfTtmdW5jdGlvbiBKZihhLGIsYyxkKXt2YXIgZT1NKGMpO2EudmEucWUoYi50b1N0cmluZygpLGUuSCghMCksZnVuY3Rpb24oYyxoKXtcIm9rXCI9PT1jJiZTYyhhLmphLGIsZSk7WmgoZCxjLGgpfSl9ZnVuY3Rpb24gS2YoYSxiLGMsZCxlKXt2YXIgZj1NKGMsZCk7YS52YS5xZShiLnRvU3RyaW5nKCksZi5IKCEwKSxmdW5jdGlvbihjLGQpe1wib2tcIj09PWMmJlNjKGEuamEsYixmKTtaaChlLGMsZCl9KX1cbmZ1bmN0aW9uIExmKGEsYixjLGQpe3ZhciBlPSEwLGY7Zm9yKGYgaW4gYyllPSExO2U/KEUoXCJvbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLFpoKGQsXCJva1wiKSk6YS52YS5lZihiLnRvU3RyaW5nKCksYyxmdW5jdGlvbihlLGYpe2lmKFwib2tcIj09PWUpZm9yKHZhciBtIGluIGMpe3ZhciBsPU0oY1ttXSk7U2MoYS5qYSxiLm0obSksbCl9WmgoZCxlLGYpfSl9ZnVuY3Rpb24gdWcoYSxiLGMpe2M9XCIuaW5mb1wiPT09SihiLnBhdGgpP2EucGQuT2IoYixjKTphLksuT2IoYixjKTt0YyhhLmRhLGIucGF0aCxjKX1nLmViPWZ1bmN0aW9uKCl7dGhpcy5VYSYmdGhpcy5VYS5lYihcInJlcG9faW50ZXJydXB0XCIpfTtnLmxjPWZ1bmN0aW9uKCl7dGhpcy5VYSYmdGhpcy5VYS5sYyhcInJlcG9faW50ZXJydXB0XCIpfTtcbmcuQWU9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXthPyh0aGlzLlZjfHwodGhpcy5WYz1uZXcgamModGhpcy5YYSkpLGE9dGhpcy5WYy5nZXQoKSk6YT10aGlzLlhhLmdldCgpO3ZhciBiPU1hKHRhKGEpLGZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgubWF4KGIubGVuZ3RoLGEpfSwwKSxjO2ZvcihjIGluIGEpe2Zvcih2YXIgZD1hW2NdLGU9Yy5sZW5ndGg7ZTxiKzI7ZSsrKWMrPVwiIFwiO2NvbnNvbGUubG9nKGMrZCl9fX07Zy5CZT1mdW5jdGlvbihhKXtsYyh0aGlzLlhhLGEpO3RoaXMud2cueGZbYV09ITB9O2cuZj1mdW5jdGlvbihhKXt2YXIgYj1cIlwiO3RoaXMuVWEmJihiPXRoaXMuVWEuaWQrXCI6XCIpO0UoYixhcmd1bWVudHMpfTtcbmZ1bmN0aW9uIFpoKGEsYixjKXthJiZUYihmdW5jdGlvbigpe2lmKFwib2tcIj09YilhKG51bGwpO2Vsc2V7dmFyIGQ9KGJ8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxlPWQ7YyYmKGUrPVwiOiBcIitjKTtlPUVycm9yKGUpO2UuY29kZT1kO2EoZSl9fSl9O2Z1bmN0aW9uIGFpKGEsYixjLGQsZSl7ZnVuY3Rpb24gZigpe31hLmYoXCJ0cmFuc2FjdGlvbiBvbiBcIitiKTt2YXIgaD1uZXcgVShhLGIpO2guaGMoXCJ2YWx1ZVwiLGYpO2M9e3BhdGg6Yix1cGRhdGU6YyxHOmQsc3RhdHVzOm51bGwsamY6VmMoKSxIZTplLHRmOjAsUmQ6ZnVuY3Rpb24oKXtoLkpjKFwidmFsdWVcIixmKX0sVGQ6bnVsbCxEYTpudWxsLGJkOm51bGwsY2Q6bnVsbCxkZDpudWxsfTtkPWEuSy5CYShiLHZvaWQgMCl8fEY7Yy5iZD1kO2Q9Yy51cGRhdGUoZC5IKCkpO2lmKHAoZCkpe0JmKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLGQsYy5wYXRoKTtjLnN0YXR1cz0xO2U9ZmgoYS5uYyxiKTt2YXIgaz1lLkVhKCl8fFtdO2sucHVzaChjKTtnaChlLGspO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJkJiKGQsXCIucHJpb3JpdHlcIik/KGs9eChkLFwiLnByaW9yaXR5XCIpLEgoemYoayksXCJJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiBQcmlvcml0eSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwuXCIpKTpcbms9KGEuSy5CYShiKXx8RikuQygpLkgoKTtlPVdoKGEpO2Q9TShkLGspO2U9VGMoZCxlKTtjLmNkPWQ7Yy5kZD1lO2MuRGE9YS52ZCsrO2M9QWgoYS5LLGIsZSxjLkRhLGMuSGUpO3ZjKGEuZGEsYixjKTtiaShhKX1lbHNlIGMuUmQoKSxjLmNkPW51bGwsYy5kZD1udWxsLGMuRyYmKGE9bmV3IFcoYy5iZCxuZXcgVShhLGMucGF0aCksTiksYy5HKG51bGwsITEsYSkpfWZ1bmN0aW9uIGJpKGEsYil7dmFyIGM9Ynx8YS5uYztifHxjaShhLGMpO2lmKG51bGwhPT1jLkVhKCkpe3ZhciBkPWRpKGEsYyk7SCgwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtOYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmZWkoYSxjLnBhdGgoKSxkKX1lbHNlIGMua2QoKSYmYy5QKGZ1bmN0aW9uKGIpe2JpKGEsYil9KX1cbmZ1bmN0aW9uIGVpKGEsYixjKXtmb3IodmFyIGQ9TGEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS5EYX0pLGU9YS5LLkJhKGIsZCl8fEYsZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO0goMT09PWguc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtoLnN0YXR1cz0yO2gudGYrKzt2YXIgaz1UKGIsaC5wYXRoKSxkPWQuRihrLGguY2QpfWQ9ZC5IKCEwKTthLnZhLnB1dChiLnRvU3RyaW5nKCksZCxmdW5jdGlvbihkKXthLmYoXCJ0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2VcIix7cGF0aDpiLnRvU3RyaW5nKCksc3RhdHVzOmR9KTt2YXIgZT1bXTtpZihcIm9rXCI9PT1kKXtkPVtdO2ZvcihmPTA7ZjxjLmxlbmd0aDtmKyspe2NbZl0uc3RhdHVzPTM7ZT1lLmNvbmNhdChEaChhLkssY1tmXS5EYSkpO2lmKGNbZl0uRyl7dmFyIGg9Y1tmXS5kZCxrPW5ldyBVKGEsY1tmXS5wYXRoKTtkLnB1c2gocihjW2ZdLkcsXG5udWxsLG51bGwsITAsbmV3IFcoaCxrLE4pKSl9Y1tmXS5SZCgpfWNpKGEsZmgoYS5uYyxiKSk7YmkoYSk7dmMoYS5kYSxiLGUpO2ZvcihmPTA7ZjxkLmxlbmd0aDtmKyspVGIoZFtmXSl9ZWxzZXtpZihcImRhdGFzdGFsZVwiPT09ZClmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0uc3RhdHVzPTQ9PT1jW2ZdLnN0YXR1cz81OjE7ZWxzZSBmb3IoTyhcInRyYW5zYWN0aW9uIGF0IFwiK2IudG9TdHJpbmcoKStcIiBmYWlsZWQ6IFwiK2QpLGY9MDtmPGMubGVuZ3RoO2YrKyljW2ZdLnN0YXR1cz01LGNbZl0uVGQ9ZDtYaChhLGIpfX0sZSl9ZnVuY3Rpb24gWGgoYSxiKXt2YXIgYz1maShhLGIpLGQ9Yy5wYXRoKCksYz1kaShhLGMpO2dpKGEsYyxkKTtyZXR1cm4gZH1cbmZ1bmN0aW9uIGdpKGEsYixjKXtpZigwIT09Yi5sZW5ndGgpe2Zvcih2YXIgZD1bXSxlPVtdLGY9TGEoYixmdW5jdGlvbihhKXtyZXR1cm4gYS5EYX0pLGg9MDtoPGIubGVuZ3RoO2grKyl7dmFyIGs9YltoXSxtPVQoYyxrLnBhdGgpLGw9ITEsdTtIKG51bGwhPT1tLFwicmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLlwiKTtpZig1PT09ay5zdGF0dXMpbD0hMCx1PWsuVGQsZT1lLmNvbmNhdChEaChhLkssay5EYSwhMCkpO2Vsc2UgaWYoMT09PWsuc3RhdHVzKWlmKDI1PD1rLnRmKWw9ITAsdT1cIm1heHJldHJ5XCIsZT1lLmNvbmNhdChEaChhLkssay5EYSwhMCkpO2Vsc2V7dmFyIHo9YS5LLkJhKGsucGF0aCxmKXx8RjtrLmJkPXo7dmFyIEc9YltoXS51cGRhdGUoei5IKCkpO3AoRyk/KEJmKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLEcsay5wYXRoKSxtPU0oRyksXCJvYmplY3RcIj09PXR5cGVvZiBHJiZudWxsIT1cbkcmJkJiKEcsXCIucHJpb3JpdHlcIil8fChtPW0uZ2Eoei5DKCkpKSx6PWsuRGEsRz1XaChhKSxHPVRjKG0sRyksay5jZD1tLGsuZGQ9RyxrLkRhPWEudmQrKyxRYShmLHopLGU9ZS5jb25jYXQoQWgoYS5LLGsucGF0aCxHLGsuRGEsay5IZSkpLGU9ZS5jb25jYXQoRGgoYS5LLHosITApKSk6KGw9ITAsdT1cIm5vZGF0YVwiLGU9ZS5jb25jYXQoRGgoYS5LLGsuRGEsITApKSl9dmMoYS5kYSxjLGUpO2U9W107bCYmKGJbaF0uc3RhdHVzPTMsc2V0VGltZW91dChiW2hdLlJkLE1hdGguZmxvb3IoMCkpLGJbaF0uRyYmKFwibm9kYXRhXCI9PT11PyhrPW5ldyBVKGEsYltoXS5wYXRoKSxkLnB1c2gocihiW2hdLkcsbnVsbCxudWxsLCExLG5ldyBXKGJbaF0uYmQsayxOKSkpKTpkLnB1c2gocihiW2hdLkcsbnVsbCxFcnJvcih1KSwhMSxudWxsKSkpKX1jaShhLGEubmMpO2ZvcihoPTA7aDxkLmxlbmd0aDtoKyspVGIoZFtoXSk7YmkoYSl9fVxuZnVuY3Rpb24gZmkoYSxiKXtmb3IodmFyIGMsZD1hLm5jO251bGwhPT0oYz1KKGIpKSYmbnVsbD09PWQuRWEoKTspZD1maChkLGMpLGI9RChiKTtyZXR1cm4gZH1mdW5jdGlvbiBkaShhLGIpe3ZhciBjPVtdO2hpKGEsYixjKTtjLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5qZi1iLmpmfSk7cmV0dXJuIGN9ZnVuY3Rpb24gaGkoYSxiLGMpe3ZhciBkPWIuRWEoKTtpZihudWxsIT09ZClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyljLnB1c2goZFtlXSk7Yi5QKGZ1bmN0aW9uKGIpe2hpKGEsYixjKX0pfWZ1bmN0aW9uIGNpKGEsYil7dmFyIGM9Yi5FYSgpO2lmKGMpe2Zvcih2YXIgZD0wLGU9MDtlPGMubGVuZ3RoO2UrKykzIT09Y1tlXS5zdGF0dXMmJihjW2RdPWNbZV0sZCsrKTtjLmxlbmd0aD1kO2doKGIsMDxjLmxlbmd0aD9jOm51bGwpfWIuUChmdW5jdGlvbihiKXtjaShhLGIpfSl9XG5mdW5jdGlvbiAkaChhLGIpe3ZhciBjPWZpKGEsYikucGF0aCgpLGQ9ZmgoYS5uYyxiKTtqaChkLGZ1bmN0aW9uKGIpe2lpKGEsYil9KTtpaShhLGQpO2loKGQsZnVuY3Rpb24oYil7aWkoYSxiKX0pO3JldHVybiBjfVxuZnVuY3Rpb24gaWkoYSxiKXt2YXIgYz1iLkVhKCk7aWYobnVsbCE9PWMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9LTEsaD0wO2g8Yy5sZW5ndGg7aCsrKTQhPT1jW2hdLnN0YXR1cyYmKDI9PT1jW2hdLnN0YXR1cz8oSChmPT09aC0xLFwiQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS5cIiksZj1oLGNbaF0uc3RhdHVzPTQsY1toXS5UZD1cInNldFwiKTooSCgxPT09Y1toXS5zdGF0dXMsXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHN0YXR1cyBpbiBhYm9ydFwiKSxjW2hdLlJkKCksZT1lLmNvbmNhdChEaChhLkssY1toXS5EYSwhMCkpLGNbaF0uRyYmZC5wdXNoKHIoY1toXS5HLG51bGwsRXJyb3IoXCJzZXRcIiksITEsbnVsbCkpKSk7LTE9PT1mP2doKGIsbnVsbCk6Yy5sZW5ndGg9ZisxO3ZjKGEuZGEsYi5wYXRoKCksZSk7Zm9yKGg9MDtoPGQubGVuZ3RoO2grKylUYihkW2hdKX19O2Z1bmN0aW9uIHVmKCl7dGhpcy5uYj17fTt0aGlzLkRmPSExfXVmLnByb3RvdHlwZS5lYj1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLm5iKXRoaXMubmJbYV0uZWIoKX07dWYucHJvdG90eXBlLmxjPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMubmIpdGhpcy5uYlthXS5sYygpfTt1Zi5wcm90b3R5cGUuY2U9ZnVuY3Rpb24oYSl7dGhpcy5EZj1hfTtiYSh1Zik7dWYucHJvdG90eXBlLmludGVycnVwdD11Zi5wcm90b3R5cGUuZWI7dWYucHJvdG90eXBlLnJlc3VtZT11Zi5wcm90b3R5cGUubGM7dmFyIFo9e307Wi5wYz1raDtaLkRhdGFDb25uZWN0aW9uPVoucGM7a2gucHJvdG90eXBlLnZnPWZ1bmN0aW9uKGEsYil7dGhpcy51YShcInFcIix7cDphfSxiKX07Wi5wYy5wcm90b3R5cGUuc2ltcGxlTGlzdGVuPVoucGMucHJvdG90eXBlLnZnO2toLnByb3RvdHlwZS5PZj1mdW5jdGlvbihhLGIpe3RoaXMudWEoXCJlY2hvXCIse2Q6YX0sYil9O1oucGMucHJvdG90eXBlLmVjaG89Wi5wYy5wcm90b3R5cGUuT2Y7a2gucHJvdG90eXBlLmludGVycnVwdD1raC5wcm90b3R5cGUuZWI7Wi5HZj1ZZTtaLlJlYWxUaW1lQ29ubmVjdGlvbj1aLkdmO1llLnByb3RvdHlwZS5zZW5kUmVxdWVzdD1ZZS5wcm90b3R5cGUudWE7WWUucHJvdG90eXBlLmNsb3NlPVllLnByb3RvdHlwZS5jbG9zZTtcblouJGY9ZnVuY3Rpb24oYSl7dmFyIGI9a2gucHJvdG90eXBlLnB1dDtraC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKGMsZCxlLGYpe3AoZikmJihmPWEoKSk7Yi5jYWxsKHRoaXMsYyxkLGUsZil9O3JldHVybiBmdW5jdGlvbigpe2toLnByb3RvdHlwZS5wdXQ9Yn19O1ouaGlqYWNrSGFzaD1aLiRmO1ouRmY9ZmM7Wi5Db25uZWN0aW9uVGFyZ2V0PVouRmY7Wi55YT1mdW5jdGlvbihhKXtyZXR1cm4gYS55YSgpfTtaLnF1ZXJ5SWRlbnRpZmllcj1aLnlhO1ouY2c9ZnVuY3Rpb24oYSl7cmV0dXJuIGEudy5VYS4kfTtaLmxpc3RlbnM9Wi5jZztaLmNlPWZ1bmN0aW9uKGEpe3VmLldiKCkuY2UoYSl9O1ouZm9yY2VSZXN0Q2xpZW50PVouY2U7Wi5Db250ZXh0PXVmO2Z1bmN0aW9uIFUoYSxiKXtpZighKGEgaW5zdGFuY2VvZiBwZikpdGhyb3cgRXJyb3IoXCJuZXcgRmlyZWJhc2UoKSBubyBsb25nZXIgc3VwcG9ydGVkIC0gdXNlIGFwcC5kYXRhYmFzZSgpLlwiKTtYLmNhbGwodGhpcyxhLGIsQmUsITEpO3RoaXMudGhlbj12b2lkIDA7dGhpc1tcImNhdGNoXCJdPXZvaWQgMH1rYShVLFgpO2c9VS5wcm90b3R5cGU7Zy5nZXRLZXk9ZnVuY3Rpb24oKXt5KFwiRmlyZWJhc2Uua2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLnBhdGguZSgpP251bGw6WGQodGhpcy5wYXRoKX07XG5nLm09ZnVuY3Rpb24oYSl7eShcIkZpcmViYXNlLmNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKGZhKGEpKWE9U3RyaW5nKGEpO2Vsc2UgaWYoIShhIGluc3RhbmNlb2YgTCkpaWYobnVsbD09PUoodGhpcy5wYXRoKSl7dmFyIGI9YTtiJiYoYj1iLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSk7SGYoXCJGaXJlYmFzZS5jaGlsZFwiLGIpfWVsc2UgSGYoXCJGaXJlYmFzZS5jaGlsZFwiLGEpO3JldHVybiBuZXcgVSh0aGlzLncsdGhpcy5wYXRoLm0oYSkpfTtnLmdldFBhcmVudD1mdW5jdGlvbigpe3koXCJGaXJlYmFzZS5wYXJlbnRcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7dmFyIGE9dGhpcy5wYXRoLnBhcmVudCgpO3JldHVybiBudWxsPT09YT9udWxsOm5ldyBVKHRoaXMudyxhKX07XG5nLlhmPWZ1bmN0aW9uKCl7eShcIkZpcmViYXNlLnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGE9dGhpcztudWxsIT09YS5nZXRQYXJlbnQoKTspYT1hLmdldFBhcmVudCgpO3JldHVybiBhfTtnLk5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudy4kYX07Zy5zZXQ9ZnVuY3Rpb24oYSxiKXt5KFwiRmlyZWJhc2Uuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2Uuc2V0XCIsdGhpcy5wYXRoKTtBZihcIkZpcmViYXNlLnNldFwiLGEsdGhpcy5wYXRoLCExKTtBKFwiRmlyZWJhc2Uuc2V0XCIsMixiLCEwKTt2YXIgYz1uZXcgSGI7dGhpcy53LktiKHRoaXMucGF0aCxhLG51bGwsSWIoYyxiKSk7cmV0dXJuIGMucmF9O1xuZy51cGRhdGU9ZnVuY3Rpb24oYSxiKXt5KFwiRmlyZWJhc2UudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2UudXBkYXRlXCIsdGhpcy5wYXRoKTtpZihkYShhKSl7Zm9yKHZhciBjPXt9LGQ9MDtkPGEubGVuZ3RoOysrZCljW1wiXCIrZF09YVtkXTthPWM7TyhcIlBhc3NpbmcgYW4gQXJyYXkgdG8gRmlyZWJhc2UudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byBvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi5cIil9RGYoXCJGaXJlYmFzZS51cGRhdGVcIixhLHRoaXMucGF0aCk7QShcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7Yz1uZXcgSGI7dGhpcy53LnVwZGF0ZSh0aGlzLnBhdGgsYSxJYihjLGIpKTtyZXR1cm4gYy5yYX07XG5nLktiPWZ1bmN0aW9uKGEsYixjKXt5KFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsdGhpcy5wYXRoKTtBZihcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLGEsdGhpcy5wYXRoLCExKTtFZihcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDIsYik7QShcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDMsYywhMCk7aWYoXCIubGVuZ3RoXCI9PT10aGlzLmdldEtleSgpfHxcIi5rZXlzXCI9PT10aGlzLmdldEtleSgpKXRocm93XCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHkgZmFpbGVkOiBcIit0aGlzLmdldEtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjt2YXIgZD1uZXcgSGI7dGhpcy53LktiKHRoaXMucGF0aCxhLGIsSWIoZCxjKSk7cmV0dXJuIGQucmF9O1xuZy5yZW1vdmU9ZnVuY3Rpb24oYSl7eShcIkZpcmViYXNlLnJlbW92ZVwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtJZihcIkZpcmViYXNlLnJlbW92ZVwiLHRoaXMucGF0aCk7QShcIkZpcmViYXNlLnJlbW92ZVwiLDEsYSwhMCk7cmV0dXJuIHRoaXMuc2V0KG51bGwsYSl9O1xuZy50cmFuc2FjdGlvbj1mdW5jdGlvbihhLGIsYyl7eShcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIix0aGlzLnBhdGgpO0EoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsYSwhMSk7QShcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMixiLCEwKTtpZihwKGMpJiZcImJvb2xlYW5cIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoRGIoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDMsITApK1wibXVzdCBiZSBhIGJvb2xlYW4uXCIpO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5nZXRLZXkoKXx8XCIua2V5c1wiPT09dGhpcy5nZXRLZXkoKSl0aHJvd1wiRmlyZWJhc2UudHJhbnNhY3Rpb24gZmFpbGVkOiBcIit0aGlzLmdldEtleSgpK1wiIGlzIGEgcmVhZC1vbmx5IG9iamVjdC5cIjtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPSEwKTt2YXIgZD1uZXcgSGI7Z2EoYikmJkpiKGQucmEpO2FpKHRoaXMudyx0aGlzLnBhdGgsYSxmdW5jdGlvbihhLGMsXG5oKXthP2QucmVqZWN0KGEpOmQucmVzb2x2ZShuZXcgUGIoYyxoKSk7Z2EoYikmJmIoYSxjLGgpfSxjKTtyZXR1cm4gZC5yYX07Zy50Zz1mdW5jdGlvbihhLGIpe3koXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtJZihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsdGhpcy5wYXRoKTtFZihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMSxhKTtBKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwyLGIsITApO3ZhciBjPW5ldyBIYjt0aGlzLncuS2IodGhpcy5wYXRoLm0oXCIucHJpb3JpdHlcIiksYSxudWxsLEliKGMsYikpO3JldHVybiBjLnJhfTtcbmcucHVzaD1mdW5jdGlvbihhLGIpe3koXCJGaXJlYmFzZS5wdXNoXCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO0lmKFwiRmlyZWJhc2UucHVzaFwiLHRoaXMucGF0aCk7QWYoXCJGaXJlYmFzZS5wdXNoXCIsYSx0aGlzLnBhdGgsITApO0EoXCJGaXJlYmFzZS5wdXNoXCIsMixiLCEwKTt2YXIgYz1WaCh0aGlzLncpLGQ9UWYoYyksYz10aGlzLm0oZCk7aWYobnVsbCE9YSl7dmFyIGU9dGhpcyxmPWMuc2V0KGEsYikudGhlbihmdW5jdGlvbigpe3JldHVybiBlLm0oZCl9KTtjLnRoZW49cihmLnRoZW4sZik7Y1tcImNhdGNoXCJdPXIoZi50aGVuLGYsdm9pZCAwKTtnYShiKSYmSmIoZil9cmV0dXJuIGN9O2cua2I9ZnVuY3Rpb24oKXtJZihcIkZpcmViYXNlLm9uRGlzY29ubmVjdFwiLHRoaXMucGF0aCk7cmV0dXJuIG5ldyBWKHRoaXMudyx0aGlzLnBhdGgpfTtVLnByb3RvdHlwZS5jaGlsZD1VLnByb3RvdHlwZS5tO1UucHJvdG90eXBlLnNldD1VLnByb3RvdHlwZS5zZXQ7VS5wcm90b3R5cGUudXBkYXRlPVUucHJvdG90eXBlLnVwZGF0ZTtcblUucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1VLnByb3RvdHlwZS5LYjtVLnByb3RvdHlwZS5yZW1vdmU9VS5wcm90b3R5cGUucmVtb3ZlO1UucHJvdG90eXBlLnRyYW5zYWN0aW9uPVUucHJvdG90eXBlLnRyYW5zYWN0aW9uO1UucHJvdG90eXBlLnNldFByaW9yaXR5PVUucHJvdG90eXBlLnRnO1UucHJvdG90eXBlLnB1c2g9VS5wcm90b3R5cGUucHVzaDtVLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3Q9VS5wcm90b3R5cGUua2I7b2QoVS5wcm90b3R5cGUsXCJkYXRhYmFzZVwiLFUucHJvdG90eXBlLk5mKTtvZChVLnByb3RvdHlwZSxcImtleVwiLFUucHJvdG90eXBlLmdldEtleSk7b2QoVS5wcm90b3R5cGUsXCJwYXJlbnRcIixVLnByb3RvdHlwZS5nZXRQYXJlbnQpO29kKFUucHJvdG90eXBlLFwicm9vdFwiLFUucHJvdG90eXBlLlhmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGZpcmViYXNlKXRocm93IEVycm9yKFwiQ2Fubm90IGluc3RhbGwgRmlyZWJhc2UgRGF0YWJhc2UgLSBiZSBzdXJlIHRvIGxvYWQgZmlyZWJhc2UtYXBwLmpzIGZpcnN0LlwiKTtcbnRyeXtmaXJlYmFzZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UoXCJkYXRhYmFzZVwiLGZ1bmN0aW9uKGEpe3ZhciBiPXVmLldiKCksYz1hLm9wdGlvbnMuZGF0YWJhc2VVUkw7cChjKXx8ZGQoXCJDYW4ndCBkZXRlcm1pbmUgRmlyZWJhc2UgRGF0YWJhc2UgVVJMLiAgQmUgc3VyZSB0byBpbmNsdWRlIGRhdGFiYXNlVVJMIG9wdGlvbiB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW50aWFsaXplQXBwKCkuXCIpO3ZhciBkPWVkKGMpLGM9ZC5rYzt0ZihcIkludmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMXCIsZCk7ZC5wYXRoLmUoKXx8ZGQoXCJEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlIChub3QgaW5jbHVkaW5nIGEgY2hpbGQgcGF0aCkuXCIpOyhkPXgoYi5uYixhLm5hbWUpKSYmZGQoXCJGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuXCIpO2Q9bmV3IHBmKGMsYi5EZixhKTtiLm5iW2EubmFtZV09XG5kO3JldHVybiBkLiRhfSx7UmVmZXJlbmNlOlUsUXVlcnk6WCxEYXRhYmFzZTpvZixlbmFibGVMb2dnaW5nOmFkLElOVEVSTkFMOlksVEVTVF9BQ0NFU1M6WixTZXJ2ZXJWYWx1ZTpyZn0pfWNhdGNoKGppKXtkZChcIkZhaWxlZCB0byByZWdpc3RlciB0aGUgRmlyZWJhc2UgRGF0YWJhc2UgU2VydmljZSAoXCIramkrXCIpXCIpfTt9KSgpO1xuXG4oZnVuY3Rpb24oKSB7dmFyIGssYWE9YWF8fHt9LG09dGhpcyxuPWZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDAhPT1hfSxiYT1mdW5jdGlvbigpe30scD1mdW5jdGlvbihhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT1cbnR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpcmV0dXJuXCJmdW5jdGlvblwifWVsc2UgcmV0dXJuXCJudWxsXCI7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn0sY2E9ZnVuY3Rpb24oYSl7dmFyIGI9cChhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH0scT1mdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYX0scj1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXAoYSl9LGRhPWZ1bmN0aW9uKGEpe3ZhciBiPXR5cGVvZiBhO3JldHVyblwib2JqZWN0XCI9PWImJm51bGwhPWF8fFwiZnVuY3Rpb25cIj09Yn0sZWE9XCJjbG9zdXJlX3VpZF9cIisoMUU5Kk1hdGgucmFuZG9tKCk+Pj4wKSxmYT0wLGdhPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxcbmFyZ3VtZW50cyl9LGhhPWZ1bmN0aW9uKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYyxkKTtyZXR1cm4gYS5hcHBseShiLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fSx0PWZ1bmN0aW9uKGEsYixjKXt0PUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/Z2E6aGE7cmV0dXJuIHQuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxpYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9LHU9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fVxuYy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5HPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EuTWE9ZnVuY3Rpb24oYSxjLGYpe2Zvcih2YXIgZz1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLGg9MjtoPGFyZ3VtZW50cy5sZW5ndGg7aCsrKWdbaC0yXT1hcmd1bWVudHNbaF07cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsZyl9fTt2YXIgamE9ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtPfHwoTz0hMCxiLmFwcGx5KG51bGwsYXJndW1lbnRzKSl9ZnVuY3Rpb24gZShiKXtsPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsPW51bGw7YShmLDI9PT12KX0sYil9ZnVuY3Rpb24gZihhLGIpe2lmKCFPKWlmKGEpZC5hcHBseShudWxsLGFyZ3VtZW50cyk7ZWxzZSBpZigyPT09dnx8QilkLmFwcGx5KG51bGwsYXJndW1lbnRzKTtlbHNlezY0PmgmJihoKj0yKTt2YXIgYzsxPT09dj8odj0yLGM9MCk6Yz0xRTMqKGgrTWF0aC5yYW5kb20oKSk7ZShjKX19ZnVuY3Rpb24gZyhhKXtTYnx8KFNiPSEwLE98fChudWxsIT09bD8oYXx8KHY9MiksY2xlYXJUaW1lb3V0KGwpLGUoMCkpOmF8fCh2PTEpKSl9dmFyIGg9MSxsPW51bGwsQj0hMSx2PTAsTz0hMSxTYj0hMTtlKDApO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtCPSEwO2coITApfSxjKTtyZXR1cm4gZ307dmFyIGthPVwiaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb21cIjt2YXIgdz1mdW5jdGlvbihhLGIpe3RoaXMuY29kZT1cInN0b3JhZ2UvXCIrYTt0aGlzLm1lc3NhZ2U9XCJGaXJlYmFzZSBTdG9yYWdlOiBcIitiO3RoaXMuc2VydmVyUmVzcG9uc2U9bnVsbDt0aGlzLm5hbWU9XCJGaXJlYmFzZUVycm9yXCJ9O3UodyxFcnJvcik7XG52YXIgbGE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHcoXCJ1bmtub3duXCIsXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLCBwbGVhc2UgY2hlY2sgdGhlIGVycm9yIHBheWxvYWQgZm9yIHNlcnZlciByZXNwb25zZS5cIil9LG1hPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB3KFwidW5hdXRoZW50aWNhdGVkXCIsXCJVc2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkLCBwbGVhc2UgYXV0aGVudGljYXRlIHVzaW5nIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIGFuZCB0cnkgYWdhaW4uXCIpfSxuYT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IHcoXCJ1bmF1dGhvcml6ZWRcIixcIlVzZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyAnXCIrYStcIicuXCIpfSxvYT1mdW5jdGlvbigpe3JldHVybiBuZXcgdyhcImNhbmNlbGVkXCIsXCJVc2VyIGNhbmNlbGVkIHRoZSB1cGxvYWQvZG93bmxvYWQuXCIpfSxwYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyB3KFwiaW52YWxpZC1hcmd1bWVudFwiLFwiSW52YWxpZCBhcmd1bWVudCBpbiBgXCIrXG5iK1wiYCBhdCBpbmRleCBcIithK1wiOiBcIitjKX0scWE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHcoXCJhcHAtZGVsZXRlZFwiLFwiVGhlIEZpcmViYXNlIGFwcCB3YXMgZGVsZXRlZC5cIil9O3ZhciByYT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBhKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGMpJiZiKGMsYVtjXSl9LHNhPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O3JhKGEsZnVuY3Rpb24oYSxkKXtiW2FdPWR9KTtyZXR1cm4gYn07dmFyIHg9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5sPWE7dGhpcy5mPXt9O3RoaXMuaT1iO3RoaXMuYj17fTt0aGlzLmM9XCJcIjt0aGlzLk49Yzt0aGlzLmc9dGhpcy5hPW51bGw7dGhpcy5oPVsyMDBdO3RoaXMuaj1kfTt2YXIgdGE9e1NUQVRFX0NIQU5HRUQ6XCJzdGF0ZV9jaGFuZ2VkXCJ9LHVhPXtSVU5OSU5HOlwicnVubmluZ1wiLFBBVVNFRDpcInBhdXNlZFwiLFNVQ0NFU1M6XCJzdWNjZXNzXCIsQ0FOQ0VMRUQ6XCJjYW5jZWxlZFwiLEVSUk9SOlwiZXJyb3JcIn0sdmE9ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgXCJydW5uaW5nXCI6Y2FzZSBcInBhdXNpbmdcIjpjYXNlIFwiY2FuY2VsaW5nXCI6cmV0dXJuXCJydW5uaW5nXCI7Y2FzZSBcInBhdXNlZFwiOnJldHVyblwicGF1c2VkXCI7Y2FzZSBcInN1Y2Nlc3NcIjpyZXR1cm5cInN1Y2Nlc3NcIjtjYXNlIFwiY2FuY2VsZWRcIjpyZXR1cm5cImNhbmNlbGVkXCI7Y2FzZSBcImVycm9yXCI6cmV0dXJuXCJlcnJvclwiO2RlZmF1bHQ6cmV0dXJuXCJlcnJvclwifX07dmFyIHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG4oYSkmJm51bGwhPT1hfSx3YT1mdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGF8fGEgaW5zdGFuY2VvZiBTdHJpbmd9O3ZhciB4YT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mPWM7dGhpcy5jPWE7dGhpcy5nPWI7dGhpcy5iPTA7dGhpcy5hPW51bGx9O3hhLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt2YXIgYTswPHRoaXMuYj8odGhpcy5iLS0sYT10aGlzLmEsdGhpcy5hPWEubmV4dCxhLm5leHQ9bnVsbCk6YT10aGlzLmMoKTtyZXR1cm4gYX07dmFyIHlhPWZ1bmN0aW9uKGEsYil7YS5nKGIpO2EuYjxhLmYmJihhLmIrKyxiLm5leHQ9YS5hLGEuYT1iKX07dmFyIHphPWZ1bmN0aW9uKGEpe2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsemEpO2Vsc2V7dmFyIGI9RXJyb3IoKS5zdGFjaztiJiYodGhpcy5zdGFjaz1iKX1hJiYodGhpcy5tZXNzYWdlPVN0cmluZyhhKSl9O3UoemEsRXJyb3IpO3phLnByb3RvdHlwZS5uYW1lPVwiQ3VzdG9tRXJyb3JcIjt2YXIgQWE9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnJlc2V0KGEsYixjLGQsZSl9O0FhLnByb3RvdHlwZS5hPW51bGw7dmFyIEJhPTA7QWEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGEsYixjLGQsZSl7XCJudW1iZXJcIj09dHlwZW9mIGV8fEJhKys7ZHx8aWEoKTt0aGlzLmI9YjtkZWxldGUgdGhpcy5hfTt2YXIgQ2E9ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109YVtkXTtyZXR1cm4gYn0sRGE9ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn0sRWE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gYX0sRmE9XCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIiksR2E9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZCxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7ZD1hcmd1bWVudHNbZV07Zm9yKGMgaW4gZClhW2NdPWRbY107Zm9yKHZhciBmPTA7ZjxGYS5sZW5ndGg7ZisrKWM9RmFbZl0sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsYykmJihhW2NdPWRbY10pfX07dmFyIEhhPWZ1bmN0aW9uKGEpe2EucHJvdG90eXBlLnRoZW49YS5wcm90b3R5cGUudGhlbjthLnByb3RvdHlwZS4kZ29vZ19UaGVuYWJsZT0hMH0sSWE9ZnVuY3Rpb24oYSl7aWYoIWEpcmV0dXJuITE7dHJ5e3JldHVybiEhYS4kZ29vZ19UaGVuYWJsZX1jYXRjaChiKXtyZXR1cm4hMX19O3ZhciBKYT1mdW5jdGlvbihhKXtKYVtcIiBcIl0oYSk7cmV0dXJuIGF9O0phW1wiIFwiXT1iYTt2YXIgS2E9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS5zcGxpdChcIiVzXCIpLGQ9XCJcIixlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtlLmxlbmd0aCYmMTxjLmxlbmd0aDspZCs9Yy5zaGlmdCgpK2Uuc2hpZnQoKTtyZXR1cm4gZCtjLmpvaW4oXCIlc1wiKX0sTGE9U3RyaW5nLnByb3RvdHlwZS50cmltP2Z1bmN0aW9uKGEpe3JldHVybiBhLnRyaW0oKX06ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvXltcXHNcXHhhMF0rfFtcXHNcXHhhMF0rJC9nLFwiXCIpfSxNYT1mdW5jdGlvbihhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07dmFyIE5hPWZ1bmN0aW9uKGEsYil7dGhpcy5hPWE7dGhpcy5iPWJ9O05hLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgTmEodGhpcy5hLHRoaXMuYil9O3ZhciB6PWZ1bmN0aW9uKGEsYil7dGhpcy5idWNrZXQ9YTt0aGlzLnBhdGg9Yn0sT2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZW5jb2RlVVJJQ29tcG9uZW50O3JldHVyblwiL2IvXCIrYihhLmJ1Y2tldCkrXCIvby9cIitiKGEucGF0aCl9LFBhPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1udWxsLGM9W3tqYTovXmdzOlxcL1xcLyhbQS1aYS16MC05LlxcLV0rKShcXC8oLiopKT8kL2ksYWE6e2J1Y2tldDoxLHBhdGg6M30saWE6ZnVuY3Rpb24oYSl7XCIvXCI9PT1hLnBhdGguY2hhckF0KGEucGF0aC5sZW5ndGgtMSkmJihhLnBhdGg9YS5wYXRoLnNsaWNlKDAsLTEpKX19LHtqYTovXmh0dHBzPzpcXC9cXC9maXJlYmFzZXN0b3JhZ2VcXC5nb29nbGVhcGlzXFwuY29tXFwvdltBLVphLXowLTlfXStcXC9iXFwvKFtBLVphLXowLTkuXFwtXSspXFwvbyhcXC8oW14/I10qKS4qKT8kL2ksYWE6e2J1Y2tldDoxLHBhdGg6M30saWE6ZnVuY3Rpb24oYSl7YS5wYXRoPWRlY29kZVVSSUNvbXBvbmVudChhLnBhdGgpfX1dLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9XG5jW2RdLGY9ZS5qYS5leGVjKGEpO2lmKGYpe2I9ZltlLmFhLmJ1Y2tldF07KGY9ZltlLmFhLnBhdGhdKXx8KGY9XCJcIik7Yj1uZXcgeihiLGYpO2UuaWEoYik7YnJlYWt9fWlmKG51bGw9PWIpdGhyb3cgbmV3IHcoXCJpbnZhbGlkLXVybFwiLFwiSW52YWxpZCBVUkwgJ1wiK2ErXCInLlwiKTtyZXR1cm4gYn07dmFyIFFhPWZ1bmN0aW9uKGEsYixjKXtyKGEpfHx5KGIpfHx5KGMpPyh0aGlzLm5leHQ9YSx0aGlzLmVycm9yPWJ8fG51bGwsdGhpcy5hPWN8fG51bGwpOih0aGlzLm5leHQ9YS5uZXh0fHxudWxsLHRoaXMuZXJyb3I9YS5lcnJvcnx8bnVsbCx0aGlzLmE9YS5jb21wbGV0ZXx8bnVsbCl9O3ZhciBSYT1mdW5jdGlvbihhKXt2YXIgYj1lbmNvZGVVUklDb21wb25lbnQsYz1cIj9cIjtyYShhLGZ1bmN0aW9uKGEsZSl7YT1iKGEpK1wiPVwiK2IoZSk7Yz1jK2ErXCImXCJ9KTtyZXR1cm4gYz1jLnNsaWNlKDAsLTEpfTt2YXIgQT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5iPWE7dGhpcy5oPWI7dGhpcy5mPWM7dGhpcy5hPWQ7dGhpcy5nPWU7dGhpcy5jPWZ9O2s9QS5wcm90b3R5cGU7ay5xYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ9O2suTGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ofTtrLklhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZn07ay5EYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF9O2suc2E9ZnVuY3Rpb24oKXtpZih5KHRoaXMuYSkpe3ZhciBhPXRoaXMuYS5kb3dubG9hZFVSTHM7cmV0dXJuIHkoYSkmJnkoYVswXSk/YVswXTpudWxsfXJldHVybiBudWxsfTtrLkthPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ307ay5HYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O3ZhciBTYT1mdW5jdGlvbihhLGIpe2IudW5zaGlmdChhKTt6YS5jYWxsKHRoaXMsS2EuYXBwbHkobnVsbCxiKSk7Yi5zaGlmdCgpfTt1KFNhLHphKTtTYS5wcm90b3R5cGUubmFtZT1cIkFzc2VydGlvbkVycm9yXCI7XG52YXIgVGE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJBc3NlcnRpb24gZmFpbGVkXCI7aWYoYyl2YXIgZT1lKyhcIjogXCIrYyksZj1kO2Vsc2UgYSYmKGUrPVwiOiBcIithLGY9Yik7dGhyb3cgbmV3IFNhKFwiXCIrZSxmfHxbXSk7fSxDPWZ1bmN0aW9uKGEsYixjKXthfHxUYShcIlwiLG51bGwsYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpfSxVYT1mdW5jdGlvbihhLGIpe3Rocm93IG5ldyBTYShcIkZhaWx1cmVcIisoYT9cIjogXCIrYTpcIlwiKSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO30sV2E9ZnVuY3Rpb24oYSxiLGMpe3IoYSl8fFRhKFwiRXhwZWN0ZWQgZnVuY3Rpb24gYnV0IGdvdCAlczogJXMuXCIsW3AoYSksYV0sYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpfTt2YXIgRD1mdW5jdGlvbigpe3RoaXMuZz10aGlzLmc7dGhpcy5zPXRoaXMuc307RC5wcm90b3R5cGUuZz0hMTtELnByb3RvdHlwZS5mYT1mdW5jdGlvbigpe3RoaXMuZ3x8KHRoaXMuZz0hMCx0aGlzLkEoKSl9O0QucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtpZih0aGlzLnMpZm9yKDt0aGlzLnMubGVuZ3RoOyl0aGlzLnMuc2hpZnQoKSgpfTt2YXIgWGE9XCJjbG9zdXJlX2xpc3RlbmFibGVfXCIrKDFFNipNYXRoLnJhbmRvbSgpfDApLFlhPTA7dmFyIFphO2E6e3ZhciAkYT1tLm5hdmlnYXRvcjtpZigkYSl7dmFyIGFiPSRhLnVzZXJBZ2VudDtpZihhYil7WmE9YWI7YnJlYWsgYX19WmE9XCJcIn12YXIgRT1mdW5jdGlvbihhKXtyZXR1cm4tMSE9WmEuaW5kZXhPZihhKX07dmFyIGJiPWZ1bmN0aW9uKCl7fTtiYi5wcm90b3R5cGUuYT1udWxsO3ZhciBkYj1mdW5jdGlvbihhKXt2YXIgYjsoYj1hLmEpfHwoYj17fSxjYihhKSYmKGJbMF09ITAsYlsxXT0hMCksYj1hLmE9Yik7cmV0dXJuIGJ9O3ZhciBlYj1BcnJheS5wcm90b3R5cGUuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7QyhudWxsIT1hLmxlbmd0aCk7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Yz1udWxsPT1jPzA6MD5jP01hdGgubWF4KDAsYS5sZW5ndGgrYyk6YztpZihxKGEpKXJldHVybiBxKGIpJiYxPT1iLmxlbmd0aD9hLmluZGV4T2YoYixjKTotMTtmb3IoO2M8YS5sZW5ndGg7YysrKWlmKGMgaW4gYSYmYVtjXT09PWIpcmV0dXJuIGM7cmV0dXJuLTF9LGZiPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXtDKG51bGwhPWEubGVuZ3RoKTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXEoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfSxnYj1BcnJheS5wcm90b3R5cGUuZmlsdGVyP2Z1bmN0aW9uKGEsXG5iLGMpe0MobnVsbCE9YS5sZW5ndGgpO3JldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9W10sZj0wLGc9cShhKT9hLnNwbGl0KFwiXCIpOmEsaD0wO2g8ZDtoKyspaWYoaCBpbiBnKXt2YXIgbD1nW2hdO2IuY2FsbChjLGwsaCxhKSYmKGVbZisrXT1sKX1yZXR1cm4gZX0saGI9QXJyYXkucHJvdG90eXBlLm1hcD9mdW5jdGlvbihhLGIsYyl7QyhudWxsIT1hLmxlbmd0aCk7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1BcnJheShkKSxmPXEoYSk/YS5zcGxpdChcIlwiKTphLGc9MDtnPGQ7ZysrKWcgaW4gZiYmKGVbZ109Yi5jYWxsKGMsZltnXSxnLGEpKTtyZXR1cm4gZX0saWI9QXJyYXkucHJvdG90eXBlLnNvbWU/ZnVuY3Rpb24oYSxiLGMpe0MobnVsbCE9YS5sZW5ndGgpO3JldHVybiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGEsXG5iLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9cShhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuITA7cmV0dXJuITF9LGtiPWZ1bmN0aW9uKGEpe3ZhciBiO2E6e2I9amI7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9cShhKT9hLnNwbGl0KFwiXCIpOmEsZT0wO2U8YztlKyspaWYoZSBpbiBkJiZiLmNhbGwodm9pZCAwLGRbZV0sZSxhKSl7Yj1lO2JyZWFrIGF9Yj0tMX1yZXR1cm4gMD5iP251bGw6cShhKT9hLmNoYXJBdChiKTphW2JdfSxsYj1mdW5jdGlvbihhKXtpZihcImFycmF5XCIhPXAoYSkpZm9yKHZhciBiPWEubGVuZ3RoLTE7MDw9YjtiLS0pZGVsZXRlIGFbYl07YS5sZW5ndGg9MH0sbWI9ZnVuY3Rpb24oYSxiKXtiPWViKGEsYik7dmFyIGM7aWYoYz0wPD1iKUMobnVsbCE9YS5sZW5ndGgpLEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhLGIsMSk7cmV0dXJuIGN9LG5iPWZ1bmN0aW9uKGEpe3ZhciBiPVxuYS5sZW5ndGg7aWYoMDxiKXtmb3IodmFyIGM9QXJyYXkoYiksZD0wO2Q8YjtkKyspY1tkXT1hW2RdO3JldHVybiBjfXJldHVybltdfTt2YXIgcGI9bmV3IHhhKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvYn0sZnVuY3Rpb24oYSl7YS5yZXNldCgpfSwxMDApLHJiPWZ1bmN0aW9uKCl7dmFyIGE9cWIsYj1udWxsO2EuYSYmKGI9YS5hLGEuYT1hLmEubmV4dCxhLmF8fChhLmI9bnVsbCksYi5uZXh0PW51bGwpO3JldHVybiBifSxvYj1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLmI9dGhpcy5hPW51bGx9O29iLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLm5leHQ9bnVsbH07b2IucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuYj10aGlzLmE9bnVsbH07dmFyIHNiPWZ1bmN0aW9uKGEsYil7dGhpcy50eXBlPWE7dGhpcy5hPXRoaXMudGFyZ2V0PWI7dGhpcy5rYT0hMH07c2IucHJvdG90eXBlLmI9ZnVuY3Rpb24oKXt0aGlzLmthPSExfTt2YXIgdGI9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLmxpc3RlbmVyPWE7dGhpcy5hPW51bGw7dGhpcy5zcmM9Yjt0aGlzLnR5cGU9Yzt0aGlzLlU9ISFkO3RoaXMuTj1lOysrWWE7dGhpcy5PPXRoaXMuVD0hMX0sdWI9ZnVuY3Rpb24oYSl7YS5PPSEwO2EubGlzdGVuZXI9bnVsbDthLmE9bnVsbDthLnNyYz1udWxsO2EuTj1udWxsfTt2YXIgdmI9L14oPzooW146Lz8jLl0rKTopPyg/OlxcL1xcLyg/OihbXi8/I10qKUApPyhbXi8jP10qPykoPzo6KFswLTldKykpPyg/PVsvIz9dfCQpKT8oW14/I10rKT8oPzpcXD8oW14jXSopKT8oPzojKC4qKSk/JC87dmFyIHdiPWZ1bmN0aW9uKGEsYil7Yj1nYihiLnNwbGl0KFwiL1wiKSxmdW5jdGlvbihhKXtyZXR1cm4gMDxhLmxlbmd0aH0pLmpvaW4oXCIvXCIpO3JldHVybiAwPT09YS5sZW5ndGg/YjphK1wiL1wiK2J9LHhiPWZ1bmN0aW9uKGEpe3ZhciBiPWEubGFzdEluZGV4T2YoXCIvXCIsYS5sZW5ndGgtMik7cmV0dXJuLTE9PT1iP2E6YS5zbGljZShiKzEpfTt2YXIgeWI9ZnVuY3Rpb24oYSl7dGhpcy5zcmM9YTt0aGlzLmE9e307dGhpcy5iPTB9LEFiPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1iLnRvU3RyaW5nKCk7Yj1hLmFbZ107Ynx8KGI9YS5hW2ddPVtdLGEuYisrKTt2YXIgaD16YihiLGMsZSxmKTstMTxoPyhhPWJbaF0sZHx8KGEuVD0hMSkpOihhPW5ldyB0YihjLGEuc3JjLGcsISFlLGYpLGEuVD1kLGIucHVzaChhKSk7cmV0dXJuIGF9LEJiPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi50eXBlO2MgaW4gYS5hJiZtYihhLmFbY10sYikmJih1YihiKSwwPT1hLmFbY10ubGVuZ3RoJiYoZGVsZXRlIGEuYVtjXSxhLmItLSkpfSx6Yj1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZighZi5PJiZmLmxpc3RlbmVyPT1iJiZmLlU9PSEhYyYmZi5OPT1kKXJldHVybiBlfXJldHVybi0xfTt2YXIgQ2IsRGI9ZnVuY3Rpb24oKXt9O3UoRGIsYmIpO3ZhciBFYj1mdW5jdGlvbihhKXtyZXR1cm4oYT1jYihhKSk/bmV3IEFjdGl2ZVhPYmplY3QoYSk6bmV3IFhNTEh0dHBSZXF1ZXN0fSxjYj1mdW5jdGlvbihhKXtpZighYS5iJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgWE1MSHR0cFJlcXVlc3QmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBBY3RpdmVYT2JqZWN0KXtmb3IodmFyIGI9W1wiTVNYTUwyLlhNTEhUVFAuNi4wXCIsXCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcIk1TWE1MMi5YTUxIVFRQXCIsXCJNaWNyb3NvZnQuWE1MSFRUUFwiXSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChkKSxhLmI9ZH1jYXRjaChlKXt9fXRocm93IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBBY3RpdmVYT2JqZWN0LiBBY3RpdmVYIG1pZ2h0IGJlIGRpc2FibGVkLCBvciBNU1hNTCBtaWdodCBub3QgYmUgaW5zdGFsbGVkXCIpO31yZXR1cm4gYS5ifTtDYj1uZXcgRGI7dmFyIEZiPWZ1bmN0aW9uKGEpe3RoaXMuYT1bXTtpZihhKWE6e3ZhciBiO2lmKGEgaW5zdGFuY2VvZiBGYil7aWYoYj1hLkQoKSxhPWEudygpLDA+PXRoaXMubygpKXtmb3IodmFyIGM9dGhpcy5hLGQ9MDtkPGIubGVuZ3RoO2QrKyljLnB1c2gobmV3IE5hKGJbZF0sYVtkXSkpO2JyZWFrIGF9fWVsc2UgYj1EYShhKSxhPUNhKGEpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspR2IodGhpcyxiW2RdLGFbZF0pfX0sR2I9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuYTtkLnB1c2gobmV3IE5hKGIsYykpO2I9ZC5sZW5ndGgtMTthPWEuYTtmb3IoYz1hW2JdOzA8YjspaWYoZD1iLTE+PjEsYVtkXS5hPmMuYSlhW2JdPWFbZF0sYj1kO2Vsc2UgYnJlYWs7YVtiXT1jfTtrPUZiLnByb3RvdHlwZTtrLnc9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5hLGI9W10sYz1hLmxlbmd0aCxkPTA7ZDxjO2QrKyliLnB1c2goYVtkXS5iKTtyZXR1cm4gYn07XG5rLkQ9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5hLGI9W10sYz1hLmxlbmd0aCxkPTA7ZDxjO2QrKyliLnB1c2goYVtkXS5hKTtyZXR1cm4gYn07ay5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgRmIodGhpcyl9O2subz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmEubGVuZ3RofTtrLkY9ZnVuY3Rpb24oKXtyZXR1cm4gMD09dGhpcy5hLmxlbmd0aH07ay5jbGVhcj1mdW5jdGlvbigpe2xiKHRoaXMuYSl9O3ZhciBIYj1mdW5jdGlvbigpe3RoaXMuYj1bXTt0aGlzLmE9W119LEliPWZ1bmN0aW9uKGEpezA9PWEuYi5sZW5ndGgmJihhLmI9YS5hLGEuYi5yZXZlcnNlKCksYS5hPVtdKTtyZXR1cm4gYS5iLnBvcCgpfTtIYi5wcm90b3R5cGUubz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmIubGVuZ3RoK3RoaXMuYS5sZW5ndGh9O0hiLnByb3RvdHlwZS5GPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PXRoaXMuYi5sZW5ndGgmJjA9PXRoaXMuYS5sZW5ndGh9O0hiLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYj1bXTt0aGlzLmE9W119O0hiLnByb3RvdHlwZS53PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9dGhpcy5iLmxlbmd0aC0xOzA8PWI7LS1iKWEucHVzaCh0aGlzLmJbYl0pO2Zvcih2YXIgYz10aGlzLmEubGVuZ3RoLGI9MDtiPGM7KytiKWEucHVzaCh0aGlzLmFbYl0pO3JldHVybiBhfTt2YXIgSmI9ZnVuY3Rpb24oYSl7aWYoYS53JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLncpcmV0dXJuIGEudygpO2lmKHEoYSkpcmV0dXJuIGEuc3BsaXQoXCJcIik7aWYoY2EoYSkpe2Zvcih2YXIgYj1bXSxjPWEubGVuZ3RoLGQ9MDtkPGM7ZCsrKWIucHVzaChhW2RdKTtyZXR1cm4gYn1yZXR1cm4gQ2EoYSl9LEtiPWZ1bmN0aW9uKGEsYil7aWYoYS5mb3JFYWNoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmZvckVhY2gpYS5mb3JFYWNoKGIsdm9pZCAwKTtlbHNlIGlmKGNhKGEpfHxxKGEpKWZiKGEsYix2b2lkIDApO2Vsc2V7dmFyIGM7aWYoYS5EJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLkQpYz1hLkQoKTtlbHNlIGlmKGEudyYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS53KWM9dm9pZCAwO2Vsc2UgaWYoY2EoYSl8fHEoYSkpe2M9W107Zm9yKHZhciBkPWEubGVuZ3RoLGU9MDtlPGQ7ZSsrKWMucHVzaChlKX1lbHNlIGM9RGEoYSk7Zm9yKHZhciBkPUpiKGEpLGU9ZC5sZW5ndGgsZj0wO2Y8ZTtmKyspYi5jYWxsKHZvaWQgMCxcbmRbZl0sYyYmY1tmXSxhKX19O3ZhciBMYj1mdW5jdGlvbihhKXttLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBhO30sMCl9LE1iLE5iPWZ1bmN0aW9uKCl7dmFyIGE9bS5NZXNzYWdlQ2hhbm5lbDtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucG9zdE1lc3NhZ2UmJndpbmRvdy5hZGRFdmVudExpc3RlbmVyJiYhRShcIlByZXN0b1wiKSYmKGE9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSUZSQU1FXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjthLnNyYz1cIlwiO2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTt2YXIgYj1hLmNvbnRlbnRXaW5kb3csYT1iLmRvY3VtZW50O2Eub3BlbigpO2Eud3JpdGUoXCJcIik7YS5jbG9zZSgpO3ZhciBjPVwiY2FsbEltbWVkaWF0ZVwiK01hdGgucmFuZG9tKCksZD1cImZpbGU6XCI9PWIubG9jYXRpb24ucHJvdG9jb2w/XCIqXCI6Yi5sb2NhdGlvbi5wcm90b2NvbCtcIi8vXCIrYi5sb2NhdGlvbi5ob3N0LFxuYT10KGZ1bmN0aW9uKGEpe2lmKChcIipcIj09ZHx8YS5vcmlnaW49PWQpJiZhLmRhdGE9PWMpdGhpcy5wb3J0MS5vbm1lc3NhZ2UoKX0sdGhpcyk7Yi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGEsITEpO3RoaXMucG9ydDE9e307dGhpcy5wb3J0Mj17cG9zdE1lc3NhZ2U6ZnVuY3Rpb24oKXtiLnBvc3RNZXNzYWdlKGMsZCl9fX0pO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmIUUoXCJUcmlkZW50XCIpJiYhRShcIk1TSUVcIikpe3ZhciBiPW5ldyBhLGM9e30sZD1jO2IucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKCl7aWYobihjLm5leHQpKXtjPWMubmV4dDt2YXIgYT1jLmVhO2MuZWE9bnVsbDthKCl9fTtyZXR1cm4gZnVuY3Rpb24oYSl7ZC5uZXh0PXtlYTphfTtkPWQubmV4dDtiLnBvcnQyLnBvc3RNZXNzYWdlKDApfX1yZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKT9cbmZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJTQ1JJUFRcIik7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPW51bGw7YSgpO2E9bnVsbH07ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXttLnNldFRpbWVvdXQoYSwwKX19O3ZhciBPYj1cIlN0b3BJdGVyYXRpb25cImluIG0/bS5TdG9wSXRlcmF0aW9uOnttZXNzYWdlOlwiU3RvcEl0ZXJhdGlvblwiLHN0YWNrOlwiXCJ9LFBiPWZ1bmN0aW9uKCl7fTtQYi5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3Rocm93IE9iO307UGIucHJvdG90eXBlLlg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307dmFyIFFiPWZ1bmN0aW9uKCl7RmIuY2FsbCh0aGlzKX07dShRYixGYik7dmFyIFJiPUUoXCJPcGVyYVwiKSxGPUUoXCJUcmlkZW50XCIpfHxFKFwiTVNJRVwiKSxUYj1FKFwiRWRnZVwiKSxVYj1FKFwiR2Vja29cIikmJiEoLTEhPVphLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIUUoXCJFZGdlXCIpKSYmIShFKFwiVHJpZGVudFwiKXx8RShcIk1TSUVcIikpJiYhRShcIkVkZ2VcIiksVmI9LTEhPVphLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIndlYmtpdFwiKSYmIUUoXCJFZGdlXCIpLFdiPWZ1bmN0aW9uKCl7dmFyIGE9bS5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9LFhiO1xuYTp7dmFyIFliPVwiXCIsWmI9ZnVuY3Rpb24oKXt2YXIgYT1aYTtpZihVYilyZXR1cm4vcnZcXDooW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZihUYilyZXR1cm4vRWRnZVxcLyhbXFxkXFwuXSspLy5leGVjKGEpO2lmKEYpcmV0dXJuL1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKFZiKXJldHVybi9XZWJLaXRcXC8oXFxTKykvLmV4ZWMoYSk7aWYoUmIpcmV0dXJuLyg/OlZlcnNpb24pWyBcXC9dPyhcXFMrKS8uZXhlYyhhKX0oKTtaYiYmKFliPVpiP1piWzFdOlwiXCIpO2lmKEYpe3ZhciAkYj1XYigpO2lmKG51bGwhPSRiJiYkYj5wYXJzZUZsb2F0KFliKSl7WGI9U3RyaW5nKCRiKTticmVhayBhfX1YYj1ZYn1cbnZhciBhYz1YYixiYz17fSxHPWZ1bmN0aW9uKGEpe3ZhciBiO2lmKCEoYj1iY1thXSkpe2I9MDtmb3IodmFyIGM9TGEoU3RyaW5nKGFjKSkuc3BsaXQoXCIuXCIpLGQ9TGEoU3RyaW5nKGEpKS5zcGxpdChcIi5cIiksZT1NYXRoLm1heChjLmxlbmd0aCxkLmxlbmd0aCksZj0wOzA9PWImJmY8ZTtmKyspe3ZhciBnPWNbZl18fFwiXCIsaD1kW2ZdfHxcIlwiLGw9LyhcXGQqKShcXEQqKS9nLEI9LyhcXGQqKShcXEQqKS9nO2Rve3ZhciB2PWwuZXhlYyhnKXx8W1wiXCIsXCJcIixcIlwiXSxPPUIuZXhlYyhoKXx8W1wiXCIsXCJcIixcIlwiXTtpZigwPT12WzBdLmxlbmd0aCYmMD09T1swXS5sZW5ndGgpYnJlYWs7Yj1NYSgwPT12WzFdLmxlbmd0aD8wOnBhcnNlSW50KHZbMV0sMTApLDA9PU9bMV0ubGVuZ3RoPzA6cGFyc2VJbnQoT1sxXSwxMCkpfHxNYSgwPT12WzJdLmxlbmd0aCwwPT1PWzJdLmxlbmd0aCl8fE1hKHZbMl0sT1syXSl9d2hpbGUoMD09Yil9Yj1iY1thXT0wPD1ifXJldHVybiBifSxjYz1tLmRvY3VtZW50LGRjPWNjJiZcbkY/V2IoKXx8KFwiQ1NTMUNvbXBhdFwiPT1jYy5jb21wYXRNb2RlP3BhcnNlSW50KGFjLDEwKTo1KTp2b2lkIDA7dmFyIGhjPWZ1bmN0aW9uKGEsYil7ZWN8fGZjKCk7Z2N8fChlYygpLGdjPSEwKTt2YXIgYz1xYixkPXBiLmdldCgpO2Quc2V0KGEsYik7Yy5iP2MuYi5uZXh0PWQ6KEMoIWMuYSksYy5hPWQpO2MuYj1kfSxlYyxmYz1mdW5jdGlvbigpe2lmKG0uUHJvbWlzZSYmbS5Qcm9taXNlLnJlc29sdmUpe3ZhciBhPW0uUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7ZWM9ZnVuY3Rpb24oKXthLnRoZW4oaWMpfX1lbHNlIGVjPWZ1bmN0aW9uKCl7dmFyIGE9aWM7IXIobS5zZXRJbW1lZGlhdGUpfHxtLldpbmRvdyYmbS5XaW5kb3cucHJvdG90eXBlJiYhRShcIkVkZ2VcIikmJm0uV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PW0uc2V0SW1tZWRpYXRlPyhNYnx8KE1iPU5iKCkpLE1iKGEpKTptLnNldEltbWVkaWF0ZShhKX19LGdjPSExLHFiPW5ldyBmdW5jdGlvbigpe3RoaXMuYj10aGlzLmE9bnVsbH0saWM9ZnVuY3Rpb24oKXtmb3IodmFyIGE7YT1yYigpOyl7dHJ5e2EuYS5jYWxsKGEuYil9Y2F0Y2goYil7TGIoYil9eWEocGIsXG5hKX1nYz0hMX07dmFyIGpjOyhqYz0hRil8fChqYz05PD1OdW1iZXIoZGMpKTt2YXIga2M9amMsbGM9RiYmIUcoXCI5XCIpOyFWYnx8RyhcIjUyOFwiKTtVYiYmRyhcIjEuOWJcIil8fEYmJkcoXCI4XCIpfHxSYiYmRyhcIjkuNVwiKXx8VmImJkcoXCI1MjhcIik7VWImJiFHKFwiOFwiKXx8RiYmRyhcIjlcIik7dmFyIG1jPWZ1bmN0aW9uKGEsYil7dGhpcy5iPXt9O3RoaXMuYT1bXTt0aGlzLmY9dGhpcy5jPTA7dmFyIGM9YXJndW1lbnRzLmxlbmd0aDtpZigxPGMpe2lmKGMlMil0aHJvdyBFcnJvcihcIlVuZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzXCIpO2Zvcih2YXIgZD0wO2Q8YztkKz0yKXRoaXMuc2V0KGFyZ3VtZW50c1tkXSxhcmd1bWVudHNbZCsxXSl9ZWxzZSBpZihhKXthIGluc3RhbmNlb2YgbWM/KGM9YS5EKCksZD1hLncoKSk6KGM9RGEoYSksZD1DYShhKSk7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspdGhpcy5zZXQoY1tlXSxkW2VdKX19O2s9bWMucHJvdG90eXBlO2subz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O2sudz1mdW5jdGlvbigpe25jKHRoaXMpO2Zvcih2YXIgYT1bXSxiPTA7Yjx0aGlzLmEubGVuZ3RoO2IrKylhLnB1c2godGhpcy5iW3RoaXMuYVtiXV0pO3JldHVybiBhfTtrLkQ9ZnVuY3Rpb24oKXtuYyh0aGlzKTtyZXR1cm4gdGhpcy5hLmNvbmNhdCgpfTtcbmsuRj1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLmN9O2suY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmI9e307dGhpcy5mPXRoaXMuYz10aGlzLmEubGVuZ3RoPTB9O1xudmFyIG9jPWZ1bmN0aW9uKGEsYil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLmIsYik/KGRlbGV0ZSBhLmJbYl0sYS5jLS0sYS5mKyssYS5hLmxlbmd0aD4yKmEuYyYmbmMoYSksITApOiExfSxuYz1mdW5jdGlvbihhKXtpZihhLmMhPWEuYS5sZW5ndGgpe2Zvcih2YXIgYj0wLGM9MDtiPGEuYS5sZW5ndGg7KXt2YXIgZD1hLmFbYl07T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEuYixkKSYmKGEuYVtjKytdPWQpO2IrK31hLmEubGVuZ3RoPWN9aWYoYS5jIT1hLmEubGVuZ3RoKXtmb3IodmFyIGU9e30sYz1iPTA7YjxhLmEubGVuZ3RoOylkPWEuYVtiXSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxkKXx8KGEuYVtjKytdPWQsZVtkXT0xKSxiKys7YS5hLmxlbmd0aD1jfX07az1tYy5wcm90b3R5cGU7XG5rLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5iLGEpP3RoaXMuYlthXTpifTtrLnNldD1mdW5jdGlvbihhLGIpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmIsYSl8fCh0aGlzLmMrKyx0aGlzLmEucHVzaChhKSx0aGlzLmYrKyk7dGhpcy5iW2FdPWJ9O2suZm9yRWFjaD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz10aGlzLkQoKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj10aGlzLmdldChlKTthLmNhbGwoYixmLGUsdGhpcyl9fTtrLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBtYyh0aGlzKX07XG5rLlg9ZnVuY3Rpb24oYSl7bmModGhpcyk7dmFyIGI9MCxjPXRoaXMuZixkPXRoaXMsZT1uZXcgUGI7ZS5uZXh0PWZ1bmN0aW9uKCl7aWYoYyE9ZC5mKXRocm93IEVycm9yKFwiVGhlIG1hcCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgaXRlcmF0b3Igd2FzIGNyZWF0ZWRcIik7aWYoYj49ZC5hLmxlbmd0aCl0aHJvdyBPYjt2YXIgZT1kLmFbYisrXTtyZXR1cm4gYT9lOmQuYltlXX07cmV0dXJuIGV9O3ZhciBwYz1mdW5jdGlvbihhLGIpe3NiLmNhbGwodGhpcyxhP2EudHlwZTpcIlwiKTt0aGlzLmM9dGhpcy5hPXRoaXMudGFyZ2V0PW51bGw7aWYoYSl7dGhpcy50eXBlPWEudHlwZTt0aGlzLnRhcmdldD1hLnRhcmdldHx8YS5zcmNFbGVtZW50O3RoaXMuYT1iO2lmKChiPWEucmVsYXRlZFRhcmdldCkmJlViKXRyeXtKYShiLm5vZGVOYW1lKX1jYXRjaChjKXt9dGhpcy5jPWE7YS5kZWZhdWx0UHJldmVudGVkJiZ0aGlzLmIoKX19O3UocGMsc2IpO3BjLnByb3RvdHlwZS5iPWZ1bmN0aW9uKCl7cGMuRy5iLmNhbGwodGhpcyk7dmFyIGE9dGhpcy5jO2lmKGEucHJldmVudERlZmF1bHQpYS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgaWYoYS5yZXR1cm5WYWx1ZT0hMSxsYyl0cnl7aWYoYS5jdHJsS2V5fHwxMTI8PWEua2V5Q29kZSYmMTIzPj1hLmtleUNvZGUpYS5rZXlDb2RlPS0xfWNhdGNoKGIpe319O3ZhciBIPWZ1bmN0aW9uKGEsYil7dGhpcy5hPTA7dGhpcy5pPXZvaWQgMDt0aGlzLmM9dGhpcy5iPXRoaXMuZj1udWxsO3RoaXMuZz10aGlzLmg9ITE7aWYoYSE9YmEpdHJ5e3ZhciBjPXRoaXM7YS5jYWxsKGIsZnVuY3Rpb24oYSl7cWMoYywyLGEpfSxmdW5jdGlvbihhKXt0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goYil7fXFjKGMsMyxhKX0pfWNhdGNoKGQpe3FjKHRoaXMsMyxkKX19LHJjPWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuZj10aGlzLmM9dGhpcy5hPXRoaXMuYj1udWxsO3RoaXMuZz0hMX07cmMucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mPXRoaXMuYz10aGlzLmE9dGhpcy5iPW51bGw7dGhpcy5nPSExfTtcbnZhciBzYz1uZXcgeGEoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHJjfSxmdW5jdGlvbihhKXthLnJlc2V0KCl9LDEwMCksdGM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXNjLmdldCgpO2QuYT1hO2QuYz1iO2QuZj1jO3JldHVybiBkfSx1Yz1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgSClyZXR1cm4gYTt2YXIgYj1uZXcgSChiYSk7cWMoYiwyLGEpO3JldHVybiBifSx2Yz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEgoZnVuY3Rpb24oYixjKXtjKGEpfSl9O1xuSC5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YSYmV2EoYSxcIm9wdF9vbkZ1bGZpbGxlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7bnVsbCE9YiYmV2EoYixcIm9wdF9vblJlamVjdGVkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IHBhc3Mgb3B0X2NvbnRleHQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkIG9mIHRoZSB0aGlyZD9cIik7cmV0dXJuIHdjKHRoaXMscihhKT9hOm51bGwscihiKT9iOm51bGwsYyl9O0hhKEgpO0gucHJvdG90eXBlLmw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gd2ModGhpcyxudWxsLGEsYil9O1xudmFyIHljPWZ1bmN0aW9uKGEsYil7YS5ifHwyIT1hLmEmJjMhPWEuYXx8eGMoYSk7QyhudWxsIT1iLmEpO2EuYz9hLmMubmV4dD1iOmEuYj1iO2EuYz1ifSx3Yz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10YyhudWxsLG51bGwsbnVsbCk7ZS5iPW5ldyBIKGZ1bmN0aW9uKGEsZyl7ZS5hPWI/ZnVuY3Rpb24oYyl7dHJ5e3ZhciBlPWIuY2FsbChkLGMpO2EoZSl9Y2F0Y2goQil7ZyhCKX19OmE7ZS5jPWM/ZnVuY3Rpb24oYil7dHJ5e3ZhciBlPWMuY2FsbChkLGIpO2EoZSl9Y2F0Y2goQil7ZyhCKX19Omd9KTtlLmIuZj1hO3ljKGEsZSk7cmV0dXJuIGUuYn07SC5wcm90b3R5cGUucz1mdW5jdGlvbihhKXtDKDE9PXRoaXMuYSk7dGhpcy5hPTA7cWModGhpcywyLGEpfTtILnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe0MoMT09dGhpcy5hKTt0aGlzLmE9MDtxYyh0aGlzLDMsYSl9O1xudmFyIHFjPWZ1bmN0aW9uKGEsYixjKXtpZigwPT1hLmEpe2E9PWMmJihiPTMsYz1uZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW5ub3QgcmVzb2x2ZSB0byBpdHNlbGZcIikpO2EuYT0xO3ZhciBkO2E6e3ZhciBlPWMsZj1hLnMsZz1hLm07aWYoZSBpbnN0YW5jZW9mIEgpbnVsbCE9ZiYmV2EoZixcIm9wdF9vbkZ1bGZpbGxlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIiksbnVsbCE9ZyYmV2EoZyxcIm9wdF9vblJlamVjdGVkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IHBhc3Mgb3B0X2NvbnRleHQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkIG9mIHRoZSB0aGlyZD9cIikseWMoZSx0YyhmfHxiYSxnfHxudWxsLGEpKSxkPSEwO2Vsc2UgaWYoSWEoZSkpZS50aGVuKGYsZyxhKSxkPSEwO2Vsc2V7aWYoZGEoZSkpdHJ5e3ZhciBoPWUudGhlbjtpZihyKGgpKXt6YyhlLGgsZixnLGEpO2Q9ITA7YnJlYWsgYX19Y2F0Y2gobCl7Zy5jYWxsKGEsbCk7ZD0hMDticmVhayBhfWQ9ITF9fWR8fFxuKGEuaT1jLGEuYT1iLGEuZj1udWxsLHhjKGEpLDMhPWJ8fEFjKGEsYykpfX0semM9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj0hMSxnPWZ1bmN0aW9uKGEpe2Z8fChmPSEwLGMuY2FsbChlLGEpKX0saD1mdW5jdGlvbihhKXtmfHwoZj0hMCxkLmNhbGwoZSxhKSl9O3RyeXtiLmNhbGwoYSxnLGgpfWNhdGNoKGwpe2gobCl9fSx4Yz1mdW5jdGlvbihhKXthLmh8fChhLmg9ITAsaGMoYS5qLGEpKX0sQmM9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDthLmImJihiPWEuYixhLmI9Yi5uZXh0LGIubmV4dD1udWxsKTthLmJ8fChhLmM9bnVsbCk7bnVsbCE9YiYmQyhudWxsIT1iLmEpO3JldHVybiBifTtcbkgucHJvdG90eXBlLmo9ZnVuY3Rpb24oKXtmb3IodmFyIGE7YT1CYyh0aGlzKTspe3ZhciBiPXRoaXMuYSxjPXRoaXMuaTtpZigzPT1iJiZhLmMmJiFhLmcpe3ZhciBkO2ZvcihkPXRoaXM7ZCYmZC5nO2Q9ZC5mKWQuZz0hMX1pZihhLmIpYS5iLmY9bnVsbCxDYyhhLGIsYyk7ZWxzZSB0cnl7YS5nP2EuYS5jYWxsKGEuZik6Q2MoYSxiLGMpfWNhdGNoKGUpe0RjLmNhbGwobnVsbCxlKX15YShzYyxhKX10aGlzLmg9ITF9O3ZhciBDYz1mdW5jdGlvbihhLGIsYyl7Mj09Yj9hLmEuY2FsbChhLmYsYyk6YS5jJiZhLmMuY2FsbChhLmYsYyl9LEFjPWZ1bmN0aW9uKGEsYil7YS5nPSEwO2hjKGZ1bmN0aW9uKCl7YS5nJiZEYy5jYWxsKG51bGwsYil9KX0sRGM9TGI7dmFyIEZjPWZ1bmN0aW9uKGEpe3RoaXMuYT1uZXcgbWM7aWYoYSl7YT1KYihhKTtmb3IodmFyIGI9YS5sZW5ndGgsYz0wO2M8YjtjKyspe3ZhciBkPWFbY107dGhpcy5hLnNldChFYyhkKSxkKX19fSxFYz1mdW5jdGlvbihhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZhfHxcImZ1bmN0aW9uXCI9PWI/XCJvXCIrKGFbZWFdfHwoYVtlYV09KytmYSkpOmIuc3Vic3RyKDAsMSkrYX07az1GYy5wcm90b3R5cGU7ay5vPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYS5vKCl9O2suY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmEuY2xlYXIoKX07ay5GPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYS5GKCl9O2sudz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmEudygpfTtrLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGYyh0aGlzKX07ay5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYS5YKCExKX07dmFyIEdjPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3ZhciBiPVtdO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGIsYXJndW1lbnRzKTt1YyghMCkudGhlbihmdW5jdGlvbigpe2EuYXBwbHkobnVsbCxiKX0pfX07dmFyIEhjPVwiY2xvc3VyZV9sbV9cIisoMUU2Kk1hdGgucmFuZG9tKCl8MCksSWM9e30sSmM9MCxLYz1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKFwiYXJyYXlcIj09cChiKSl7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspS2MoYSxiW2ZdLGMsZCxlKTtyZXR1cm4gbnVsbH1jPUxjKGMpO2EmJmFbWGFdPyhNYyhhKSxhPUFiKGEuYixTdHJpbmcoYiksYywhMSxkLGUpKTphPU5jKGEsYixjLCExLGQsZSk7cmV0dXJuIGF9LE5jPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighYil0aHJvdyBFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTt2YXIgZz0hIWUsaD1PYyhhKTtofHwoYVtIY109aD1uZXcgeWIoYSkpO2M9QWIoaCxiLGMsZCxlLGYpO2lmKGMuYSlyZXR1cm4gYztkPVBjKCk7Yy5hPWQ7ZC5zcmM9YTtkLmxpc3RlbmVyPWM7aWYoYS5hZGRFdmVudExpc3RlbmVyKWEuYWRkRXZlbnRMaXN0ZW5lcihiLnRvU3RyaW5nKCksZCxnKTtlbHNlIGlmKGEuYXR0YWNoRXZlbnQpYS5hdHRhY2hFdmVudChRYyhiLnRvU3RyaW5nKCkpLFxuZCk7ZWxzZSB0aHJvdyBFcnJvcihcImFkZEV2ZW50TGlzdGVuZXIgYW5kIGF0dGFjaEV2ZW50IGFyZSB1bmF2YWlsYWJsZS5cIik7SmMrKztyZXR1cm4gY30sUGM9ZnVuY3Rpb24oKXt2YXIgYT1SYyxiPWtjP2Z1bmN0aW9uKGMpe3JldHVybiBhLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKX06ZnVuY3Rpb24oYyl7Yz1hLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKTtpZighYylyZXR1cm4gY307cmV0dXJuIGJ9LFNjPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoXCJhcnJheVwiPT1wKGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKVNjKGEsYltmXSxjLGQsZSk7ZWxzZSBjPUxjKGMpLGEmJmFbWGFdP0FiKGEuYixTdHJpbmcoYiksYywhMCxkLGUpOk5jKGEsYixjLCEwLGQsZSl9LFRjPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoXCJhcnJheVwiPT1wKGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKVRjKGEsYltmXSxjLGQsZSk7ZWxzZShjPUxjKGMpLGEmJmFbWGFdKT8oYT1hLmIsYj1TdHJpbmcoYikudG9TdHJpbmcoKSxcbmIgaW4gYS5hJiYoZj1hLmFbYl0sYz16YihmLGMsZCxlKSwtMTxjJiYodWIoZltjXSksQyhudWxsIT1mLmxlbmd0aCksQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGYsYywxKSwwPT1mLmxlbmd0aCYmKGRlbGV0ZSBhLmFbYl0sYS5iLS0pKSkpOmEmJihhPU9jKGEpKSYmKGI9YS5hW2IudG9TdHJpbmcoKV0sYT0tMSxiJiYoYT16YihiLGMsISFkLGUpKSwoYz0tMTxhP2JbYV06bnVsbCkmJlVjKGMpKX0sVWM9ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGEmJmEmJiFhLk8pe3ZhciBiPWEuc3JjO2lmKGImJmJbWGFdKUJiKGIuYixhKTtlbHNle3ZhciBjPWEudHlwZSxkPWEuYTtiLnJlbW92ZUV2ZW50TGlzdGVuZXI/Yi5yZW1vdmVFdmVudExpc3RlbmVyKGMsZCxhLlUpOmIuZGV0YWNoRXZlbnQmJmIuZGV0YWNoRXZlbnQoUWMoYyksZCk7SmMtLTsoYz1PYyhiKSk/KEJiKGMsYSksMD09Yy5iJiYoYy5zcmM9bnVsbCxiW0hjXT1udWxsKSk6dWIoYSl9fX0sUWM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5cbkljP0ljW2FdOkljW2FdPVwib25cIithfSxXYz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0hMDtpZihhPU9jKGEpKWlmKGI9YS5hW2IudG9TdHJpbmcoKV0pZm9yKGI9Yi5jb25jYXQoKSxhPTA7YTxiLmxlbmd0aDthKyspe3ZhciBmPWJbYV07ZiYmZi5VPT1jJiYhZi5PJiYoZj1WYyhmLGQpLGU9ZSYmITEhPT1mKX1yZXR1cm4gZX0sVmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmxpc3RlbmVyLGQ9YS5OfHxhLnNyYzthLlQmJlVjKGEpO3JldHVybiBjLmNhbGwoZCxiKX0sUmM9ZnVuY3Rpb24oYSxiKXtpZihhLk8pcmV0dXJuITA7aWYoIWtjKXtpZighYilhOntiPVtcIndpbmRvd1wiLFwiZXZlbnRcIl07Zm9yKHZhciBjPW0sZDtkPWIuc2hpZnQoKTspaWYobnVsbCE9Y1tkXSljPWNbZF07ZWxzZXtiPW51bGw7YnJlYWsgYX1iPWN9ZD1iO2I9bmV3IHBjKGQsdGhpcyk7Yz0hMDtpZighKDA+ZC5rZXlDb2RlfHx2b2lkIDAhPWQucmV0dXJuVmFsdWUpKXthOnt2YXIgZT0hMTtpZigwPT1kLmtleUNvZGUpdHJ5e2Qua2V5Q29kZT1cbi0xO2JyZWFrIGF9Y2F0Y2goZyl7ZT0hMH1pZihlfHx2b2lkIDA9PWQucmV0dXJuVmFsdWUpZC5yZXR1cm5WYWx1ZT0hMH1kPVtdO2ZvcihlPWIuYTtlO2U9ZS5wYXJlbnROb2RlKWQucHVzaChlKTthPWEudHlwZTtmb3IoZT1kLmxlbmd0aC0xOzA8PWU7ZS0tKXtiLmE9ZFtlXTt2YXIgZj1XYyhkW2VdLGEsITAsYiksYz1jJiZmfWZvcihlPTA7ZTxkLmxlbmd0aDtlKyspYi5hPWRbZV0sZj1XYyhkW2VdLGEsITEsYiksYz1jJiZmfXJldHVybiBjfXJldHVybiBWYyhhLG5ldyBwYyhiLHRoaXMpKX0sT2M9ZnVuY3Rpb24oYSl7YT1hW0hjXTtyZXR1cm4gYSBpbnN0YW5jZW9mIHliP2E6bnVsbH0sWGM9XCJfX2Nsb3N1cmVfZXZlbnRzX2ZuX1wiKygxRTkqTWF0aC5yYW5kb20oKT4+PjApLExjPWZ1bmN0aW9uKGEpe0MoYSxcIkxpc3RlbmVyIGNhbiBub3QgYmUgbnVsbC5cIik7aWYocihhKSlyZXR1cm4gYTtDKGEuaGFuZGxlRXZlbnQsXCJBbiBvYmplY3QgbGlzdGVuZXIgbXVzdCBoYXZlIGhhbmRsZUV2ZW50IG1ldGhvZC5cIik7XG5hW1hjXXx8KGFbWGNdPWZ1bmN0aW9uKGIpe3JldHVybiBhLmhhbmRsZUV2ZW50KGIpfSk7cmV0dXJuIGFbWGNdfTt2YXIgST1mdW5jdGlvbihhLGIpe0QuY2FsbCh0aGlzKTt0aGlzLmw9YXx8MDt0aGlzLmM9Ynx8MTA7aWYodGhpcy5sPnRoaXMuYyl0aHJvdyBFcnJvcihcIltnb29nLnN0cnVjdHMuUG9vbF0gTWluIGNhbiBub3QgYmUgZ3JlYXRlciB0aGFuIG1heFwiKTt0aGlzLmE9bmV3IEhiO3RoaXMuYj1uZXcgRmM7dGhpcy5pPW51bGw7dGhpcy5TKCl9O3UoSSxEKTtJLnByb3RvdHlwZS5XPWZ1bmN0aW9uKCl7dmFyIGE9aWEoKTtpZighKG51bGwhPXRoaXMuaSYmMD5hLXRoaXMuaSkpe2Zvcih2YXIgYjswPHRoaXMuYS5vKCkmJihiPUliKHRoaXMuYSksIXRoaXMuaihiKSk7KXRoaXMuUygpOyFiJiZ0aGlzLm8oKTx0aGlzLmMmJihiPXRoaXMuaCgpKTtiJiYodGhpcy5pPWEsdGhpcy5iLmEuc2V0KEVjKGIpLGIpKTtyZXR1cm4gYn19O3ZhciBaYz1mdW5jdGlvbihhKXt2YXIgYj1ZYztvYyhiLmIuYSxFYyhhKSkmJmIuWShhKX07XG5JLnByb3RvdHlwZS5ZPWZ1bmN0aW9uKGEpe29jKHRoaXMuYi5hLEVjKGEpKTt0aGlzLmooYSkmJnRoaXMubygpPHRoaXMuYz90aGlzLmEuYS5wdXNoKGEpOiRjKGEpfTtJLnByb3RvdHlwZS5TPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuYTt0aGlzLm8oKTx0aGlzLmw7KXt2YXIgYj10aGlzLmgoKTthLmEucHVzaChiKX1mb3IoO3RoaXMubygpPnRoaXMuYyYmMDx0aGlzLmEubygpOykkYyhJYihhKSl9O0kucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtyZXR1cm57fX07dmFyICRjPWZ1bmN0aW9uKGEpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZmEpYS5mYSgpO2Vsc2UgZm9yKHZhciBiIGluIGEpYVtiXT1udWxsfTtJLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEucmE/YS5yYSgpOiEwfTtJLnByb3RvdHlwZS5vPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYS5vKCkrdGhpcy5iLm8oKX07XG5JLnByb3RvdHlwZS5GPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYS5GKCkmJnRoaXMuYi5GKCl9O0kucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtJLkcuQS5jYWxsKHRoaXMpO2lmKDA8dGhpcy5iLm8oKSl0aHJvdyBFcnJvcihcIltnb29nLnN0cnVjdHMuUG9vbF0gT2JqZWN0cyBub3QgcmVsZWFzZWRcIik7ZGVsZXRlIHRoaXMuYjtmb3IodmFyIGE9dGhpcy5hOyFhLkYoKTspJGMoSWIoYSkpO2RlbGV0ZSB0aGlzLmF9Oy8qXG4gUG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBmcm9tIE1vY2hpS2l0LCByZWNlaXZlZCBieVxuIFRoZSBDbG9zdXJlIEF1dGhvcnMgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBBbGwgb3RoZXIgY29kZSBpcyBDb3B5cmlnaHRcbiAyMDA1LTIwMDkgVGhlIENsb3N1cmUgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiovXG52YXIgYWQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmM9W107dGhpcy5tPWJ8fG51bGw7dGhpcy5hPXRoaXMuaD0hMTt0aGlzLmI9dm9pZCAwO3RoaXMuaj10aGlzLmc9ITE7dGhpcy5mPTA7dGhpcy5pPW51bGw7dGhpcy5zPTB9O2FkLnByb3RvdHlwZS5sPWZ1bmN0aW9uKGEsYil7dGhpcy5nPSExO3RoaXMuaD0hMDt0aGlzLmI9Yjt0aGlzLmE9IWE7YmQodGhpcyl9O3ZhciBjZD1mdW5jdGlvbihhLGIsYyl7QyghYS5qLFwiQmxvY2tpbmcgRGVmZXJyZWRzIGNhbiBub3QgYmUgcmUtdXNlZFwiKTthLmMucHVzaChbYixjLHZvaWQgMF0pO2EuaCYmYmQoYSl9O2FkLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9bmV3IEgoZnVuY3Rpb24oYSxiKXtkPWE7ZT1ifSk7Y2QodGhpcyxkLGZ1bmN0aW9uKGEpe2UoYSl9KTtyZXR1cm4gZi50aGVuKGEsYixjKX07SGEoYWQpO1xudmFyIGRkPWZ1bmN0aW9uKGEpe3JldHVybiBpYihhLmMsZnVuY3Rpb24oYSl7cmV0dXJuIHIoYVsxXSl9KX0sYmQ9ZnVuY3Rpb24oYSl7aWYoYS5mJiZhLmgmJmRkKGEpKXt2YXIgYj1hLmYsYz1lZFtiXTtjJiYobS5jbGVhclRpbWVvdXQoYy5hKSxkZWxldGUgZWRbYl0pO2EuZj0wfWEuaSYmKGEuaS5zLS0sZGVsZXRlIGEuaSk7Zm9yKHZhciBiPWEuYixkPWM9ITE7YS5jLmxlbmd0aCYmIWEuZzspe3ZhciBlPWEuYy5zaGlmdCgpLGY9ZVswXSxnPWVbMV0sZT1lWzJdO2lmKGY9YS5hP2c6Zil0cnl7dmFyIGg9Zi5jYWxsKGV8fGEubSxiKTtuKGgpJiYoYS5hPWEuYSYmKGg9PWJ8fGggaW5zdGFuY2VvZiBFcnJvciksYS5iPWI9aCk7aWYoSWEoYil8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBtLlByb21pc2UmJmIgaW5zdGFuY2VvZiBtLlByb21pc2UpZD0hMCxhLmc9ITB9Y2F0Y2gobCl7Yj1sLGEuYT0hMCxkZChhKXx8KGM9ITApfX1hLmI9YjtkJiYoaD10KGEubCxhLCEwKSxkPXQoYS5sLGEsXG4hMSksYiBpbnN0YW5jZW9mIGFkPyhjZChiLGgsZCksYi5qPSEwKTpiLnRoZW4oaCxkKSk7YyYmKGI9bmV3IGZkKGIpLGVkW2IuYV09YixhLmY9Yi5hKX0sZmQ9ZnVuY3Rpb24oYSl7dGhpcy5hPW0uc2V0VGltZW91dCh0KHRoaXMuYyx0aGlzKSwwKTt0aGlzLmI9YX07ZmQucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXtDKGVkW3RoaXMuYV0sXCJDYW5ub3QgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBub3Qgc2NoZWR1bGVkLlwiKTtkZWxldGUgZWRbdGhpcy5hXTt0aHJvdyB0aGlzLmI7fTt2YXIgZWQ9e307dmFyIGdkPWZ1bmN0aW9uKGEpe3RoaXMuZj1hO3RoaXMuYj10aGlzLmM9dGhpcy5hPW51bGx9LGhkPWZ1bmN0aW9uKGEsYil7dGhpcy5uYW1lPWE7dGhpcy52YWx1ZT1ifTtoZC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfTt2YXIgaWQ9bmV3IGhkKFwiU0VWRVJFXCIsMUUzKSxqZD1uZXcgaGQoXCJDT05GSUdcIiw3MDApLGtkPW5ldyBoZChcIkZJTkVcIiw1MDApLGxkPWZ1bmN0aW9uKGEpe2lmKGEuYylyZXR1cm4gYS5jO2lmKGEuYSlyZXR1cm4gbGQoYS5hKTtVYShcIlJvb3QgbG9nZ2VyIGhhcyBubyBsZXZlbCBzZXQuXCIpO3JldHVybiBudWxsfTtcbmdkLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oYSxiLGMpe2lmKGEudmFsdWU+PWxkKHRoaXMpLnZhbHVlKWZvcihyKGIpJiYoYj1iKCkpLGE9bmV3IEFhKGEsU3RyaW5nKGIpLHRoaXMuZiksYyYmKGEuYT1jKSxjPVwibG9nOlwiK2EuYixtLmNvbnNvbGUmJihtLmNvbnNvbGUudGltZVN0YW1wP20uY29uc29sZS50aW1lU3RhbXAoYyk6bS5jb25zb2xlLm1hcmtUaW1lbGluZSYmbS5jb25zb2xlLm1hcmtUaW1lbGluZShjKSksbS5tc1dyaXRlUHJvZmlsZXJNYXJrJiZtLm1zV3JpdGVQcm9maWxlck1hcmsoYyksYz10aGlzO2M7KWM9Yy5hfTtcbnZhciBtZD17fSxuZD1udWxsLG9kPWZ1bmN0aW9uKGEpe25kfHwobmQ9bmV3IGdkKFwiXCIpLG1kW1wiXCJdPW5kLG5kLmM9amQpO3ZhciBiO2lmKCEoYj1tZFthXSkpe2I9bmV3IGdkKGEpO3ZhciBjPWEubGFzdEluZGV4T2YoXCIuXCIpLGQ9YS5zdWJzdHIoYysxKSxjPW9kKGEuc3Vic3RyKDAsYykpO2MuYnx8KGMuYj17fSk7Yy5iW2RdPWI7Yi5hPWM7bWRbYV09Yn1yZXR1cm4gYn07dmFyIEo9ZnVuY3Rpb24oKXtELmNhbGwodGhpcyk7dGhpcy5iPW5ldyB5Yih0aGlzKTt0aGlzLm1hPXRoaXM7dGhpcy5JPW51bGx9O3UoSixEKTtKLnByb3RvdHlwZVtYYV09ITA7Si5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyxkKXtUYyh0aGlzLGEsYixjLGQpfTtcbnZhciBLPWZ1bmN0aW9uKGEsYil7TWMoYSk7dmFyIGMsZD1hLkk7aWYoZCl7Yz1bXTtmb3IodmFyIGU9MTtkO2Q9ZC5JKWMucHVzaChkKSxDKDFFMz4rK2UsXCJpbmZpbml0ZSBsb29wXCIpfWE9YS5tYTtkPWIudHlwZXx8YjtxKGIpP2I9bmV3IHNiKGIsYSk6YiBpbnN0YW5jZW9mIHNiP2IudGFyZ2V0PWIudGFyZ2V0fHxhOihlPWIsYj1uZXcgc2IoZCxhKSxHYShiLGUpKTt2YXIgZT0hMCxmO2lmKGMpZm9yKHZhciBnPWMubGVuZ3RoLTE7MDw9ZztnLS0pZj1iLmE9Y1tnXSxlPXBkKGYsZCwhMCxiKSYmZTtmPWIuYT1hO2U9cGQoZixkLCEwLGIpJiZlO2U9cGQoZixkLCExLGIpJiZlO2lmKGMpZm9yKGc9MDtnPGMubGVuZ3RoO2crKylmPWIuYT1jW2ddLGU9cGQoZixkLCExLGIpJiZlfTtcbkoucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtKLkcuQS5jYWxsKHRoaXMpO2lmKHRoaXMuYil7dmFyIGE9dGhpcy5iLGI9MCxjO2ZvcihjIGluIGEuYSl7Zm9yKHZhciBkPWEuYVtjXSxlPTA7ZTxkLmxlbmd0aDtlKyspKytiLHViKGRbZV0pO2RlbGV0ZSBhLmFbY107YS5iLS19fXRoaXMuST1udWxsfTt2YXIgcGQ9ZnVuY3Rpb24oYSxiLGMsZCl7Yj1hLmIuYVtTdHJpbmcoYildO2lmKCFiKXJldHVybiEwO2I9Yi5jb25jYXQoKTtmb3IodmFyIGU9ITAsZj0wO2Y8Yi5sZW5ndGg7KytmKXt2YXIgZz1iW2ZdO2lmKGcmJiFnLk8mJmcuVT09Yyl7dmFyIGg9Zy5saXN0ZW5lcixsPWcuTnx8Zy5zcmM7Zy5UJiZCYihhLmIsZyk7ZT0hMSE9PWguY2FsbChsLGQpJiZlfX1yZXR1cm4gZSYmMCE9ZC5rYX0sTWM9ZnVuY3Rpb24oYSl7QyhhLmIsXCJFdmVudCB0YXJnZXQgaXMgbm90IGluaXRpYWxpemVkLiBEaWQgeW91IGNhbGwgdGhlIHN1cGVyY2xhc3MgKGdvb2cuZXZlbnRzLkV2ZW50VGFyZ2V0KSBjb25zdHJ1Y3Rvcj9cIil9O3ZhciBMPWZ1bmN0aW9uKGEsYil7dGhpcy5mPW5ldyBRYjtJLmNhbGwodGhpcyxhLGIpfTt1KEwsSSk7az1MLnByb3RvdHlwZTtrLlc9ZnVuY3Rpb24oYSxiKXtpZighYSlyZXR1cm4gTC5HLlcuY2FsbCh0aGlzKTtHYih0aGlzLmYsbihiKT9iOjEwMCxhKTt0aGlzLiQoKX07ay4kPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuZjswPGEubygpOyl7dmFyIGI9dGhpcy5XKCk7aWYoYil7dmFyIGM7dmFyIGQ9YSxlPWQuYSxmPWUubGVuZ3RoO2M9ZVswXTtpZigwPj1mKWM9dm9pZCAwO2Vsc2V7aWYoMT09ZilsYihlKTtlbHNle2VbMF09ZS5wb3AoKTtmb3IodmFyIGU9MCxkPWQuYSxmPWQubGVuZ3RoLGc9ZFtlXTtlPGY+PjE7KXt2YXIgaD0yKmUrMSxsPTIqZSsyLGg9bDxmJiZkW2xdLmE8ZFtoXS5hP2w6aDtpZihkW2hdLmE+Zy5hKWJyZWFrO2RbZV09ZFtoXTtlPWh9ZFtlXT1nfWM9Yy5ifWMuYXBwbHkodGhpcyxbYl0pfWVsc2UgYnJlYWt9fTtcbmsuWT1mdW5jdGlvbihhKXtMLkcuWS5jYWxsKHRoaXMsYSk7dGhpcy4kKCl9O2suUz1mdW5jdGlvbigpe0wuRy5TLmNhbGwodGhpcyk7dGhpcy4kKCl9O2suQT1mdW5jdGlvbigpe0wuRy5BLmNhbGwodGhpcyk7bS5jbGVhclRpbWVvdXQodm9pZCAwKTt0aGlzLmYuY2xlYXIoKTt0aGlzLmY9bnVsbH07dmFyIE09ZnVuY3Rpb24oYSxiKXthJiZhLmxvZyhrZCxiLHZvaWQgMCl9O3ZhciBxZD1mdW5jdGlvbihhLGIsYyl7aWYocihhKSljJiYoYT10KGEsYykpO2Vsc2UgaWYoYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5oYW5kbGVFdmVudClhPXQoYS5oYW5kbGVFdmVudCxhKTtlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCBsaXN0ZW5lciBhcmd1bWVudFwiKTtyZXR1cm4gMjE0NzQ4MzY0NzxOdW1iZXIoYik/LTE6bS5zZXRUaW1lb3V0KGEsYnx8MCl9O3ZhciBOPWZ1bmN0aW9uKGEpe0ouY2FsbCh0aGlzKTt0aGlzLkw9bmV3IG1jO3RoaXMuQz1hfHxudWxsO3RoaXMuYz0hMTt0aGlzLkI9dGhpcy5hPW51bGw7dGhpcy5QPXRoaXMubD1cIlwiO3RoaXMuSj0wO3RoaXMuaD1cIlwiO3RoaXMuZj10aGlzLkg9dGhpcy5qPXRoaXMuSz0hMTt0aGlzLmk9MDt0aGlzLm09bnVsbDt0aGlzLmRhPVwiXCI7dGhpcy52PXRoaXMuYmE9dGhpcy5aPSExfTt1KE4sSik7dmFyIHJkPU4ucHJvdG90eXBlLHNkPW9kKFwiZ29vZy5uZXQuWGhySW9cIik7cmQudT1zZDt2YXIgdGQ9L15odHRwcz8kL2ksdWQ9W1wiUE9TVFwiLFwiUFVUXCJdO1xuTi5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbihhLGIsYyxkKXtpZih0aGlzLmEpdGhyb3cgRXJyb3IoXCJbZ29vZy5uZXQuWGhySW9dIE9iamVjdCBpcyBhY3RpdmUgd2l0aCBhbm90aGVyIHJlcXVlc3Q9XCIrdGhpcy5sK1wiOyBuZXdVcmk9XCIrYSk7Yj1iP2IudG9VcHBlckNhc2UoKTpcIkdFVFwiO3RoaXMubD1hO3RoaXMuaD1cIlwiO3RoaXMuSj0wO3RoaXMuUD1iO3RoaXMuSz0hMTt0aGlzLmM9ITA7dGhpcy5hPXRoaXMuQz9FYih0aGlzLkMpOkViKENiKTt0aGlzLkI9dGhpcy5DP2RiKHRoaXMuQyk6ZGIoQ2IpO3RoaXMuYS5vbnJlYWR5c3RhdGVjaGFuZ2U9dCh0aGlzLmNhLHRoaXMpO3RoaXMuYmEmJlwib25wcm9ncmVzc1wiaW4gdGhpcy5hJiYodGhpcy5hLm9ucHJvZ3Jlc3M9dChmdW5jdGlvbihhKXt0aGlzLlIoYSwhMCl9LHRoaXMpLHRoaXMuYS51cGxvYWQmJih0aGlzLmEudXBsb2FkLm9ucHJvZ3Jlc3M9dCh0aGlzLlIsdGhpcykpKTt0cnl7TSh0aGlzLnUsUCh0aGlzLFwiT3BlbmluZyBYaHJcIikpLFxudGhpcy5IPSEwLHRoaXMuYS5vcGVuKGIsU3RyaW5nKGEpLCEwKSx0aGlzLkg9ITF9Y2F0Y2goZil7TSh0aGlzLnUsUCh0aGlzLFwiRXJyb3Igb3BlbmluZyBYaHI6IFwiK2YubWVzc2FnZSkpO3ZkKHRoaXMsZik7cmV0dXJufWE9Y3x8XCJcIjt2YXIgZT10aGlzLkwuY2xvbmUoKTtkJiZLYihkLGZ1bmN0aW9uKGEsYil7ZS5zZXQoYixhKX0pO2Q9a2IoZS5EKCkpO2M9bS5Gb3JtRGF0YSYmYSBpbnN0YW5jZW9mIG0uRm9ybURhdGE7ISgwPD1lYih1ZCxiKSl8fGR8fGN8fGUuc2V0KFwiQ29udGVudC1UeXBlXCIsXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiKTtlLmZvckVhY2goZnVuY3Rpb24oYSxiKXt0aGlzLmEuc2V0UmVxdWVzdEhlYWRlcihiLGEpfSx0aGlzKTt0aGlzLmRhJiYodGhpcy5hLnJlc3BvbnNlVHlwZT10aGlzLmRhKTtFYSh0aGlzLmEpJiYodGhpcy5hLndpdGhDcmVkZW50aWFscz10aGlzLlopO3RyeXt3ZCh0aGlzKSwwPHRoaXMuaSYmKHRoaXMudj1cbnhkKHRoaXMuYSksTSh0aGlzLnUsUCh0aGlzLFwiV2lsbCBhYm9ydCBhZnRlciBcIit0aGlzLmkrXCJtcyBpZiBpbmNvbXBsZXRlLCB4aHIyIFwiK3RoaXMudikpLHRoaXMudj8odGhpcy5hLnRpbWVvdXQ9dGhpcy5pLHRoaXMuYS5vbnRpbWVvdXQ9dCh0aGlzLk0sdGhpcykpOnRoaXMubT1xZCh0aGlzLk0sdGhpcy5pLHRoaXMpKSxNKHRoaXMudSxQKHRoaXMsXCJTZW5kaW5nIHJlcXVlc3RcIikpLHRoaXMuaj0hMCx0aGlzLmEuc2VuZChhKSx0aGlzLmo9ITF9Y2F0Y2goZil7TSh0aGlzLnUsUCh0aGlzLFwiU2VuZCBlcnJvcjogXCIrZi5tZXNzYWdlKSksdmQodGhpcyxmKX19O3ZhciB4ZD1mdW5jdGlvbihhKXtyZXR1cm4gRiYmRyg5KSYmXCJudW1iZXJcIj09dHlwZW9mIGEudGltZW91dCYmbihhLm9udGltZW91dCl9LGpiPWZ1bmN0aW9uKGEpe3JldHVyblwiY29udGVudC10eXBlXCI9PWEudG9Mb3dlckNhc2UoKX07XG5OLnByb3RvdHlwZS5NPWZ1bmN0aW9uKCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGFhJiZ0aGlzLmEmJih0aGlzLmg9XCJUaW1lZCBvdXQgYWZ0ZXIgXCIrdGhpcy5pK1wibXMsIGFib3J0aW5nXCIsdGhpcy5KPTgsTSh0aGlzLnUsUCh0aGlzLHRoaXMuaCkpLEsodGhpcyxcInRpbWVvdXRcIikseWQodGhpcyw4KSl9O3ZhciB2ZD1mdW5jdGlvbihhLGIpe2EuYz0hMTthLmEmJihhLmY9ITAsYS5hLmFib3J0KCksYS5mPSExKTthLmg9YjthLko9NTt6ZChhKTtBZChhKX0semQ9ZnVuY3Rpb24oYSl7YS5LfHwoYS5LPSEwLEsoYSxcImNvbXBsZXRlXCIpLEsoYSxcImVycm9yXCIpKX0seWQ9ZnVuY3Rpb24oYSxiKXthLmEmJmEuYyYmKE0oYS51LFAoYSxcIkFib3J0aW5nXCIpKSxhLmM9ITEsYS5mPSEwLGEuYS5hYm9ydCgpLGEuZj0hMSxhLko9Ynx8NyxLKGEsXCJjb21wbGV0ZVwiKSxLKGEsXCJhYm9ydFwiKSxBZChhKSl9O1xuTi5wcm90b3R5cGUuQT1mdW5jdGlvbigpe3RoaXMuYSYmKHRoaXMuYyYmKHRoaXMuYz0hMSx0aGlzLmY9ITAsdGhpcy5hLmFib3J0KCksdGhpcy5mPSExKSxBZCh0aGlzLCEwKSk7Ti5HLkEuY2FsbCh0aGlzKX07Ti5wcm90b3R5cGUuY2E9ZnVuY3Rpb24oKXt0aGlzLmd8fCh0aGlzLkh8fHRoaXMuanx8dGhpcy5mP0JkKHRoaXMpOnRoaXMubmEoKSl9O04ucHJvdG90eXBlLm5hPWZ1bmN0aW9uKCl7QmQodGhpcyl9O1xudmFyIEJkPWZ1bmN0aW9uKGEpe2lmKGEuYyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGFhKWlmKGEuQlsxXSYmND09RGQoYSkmJjI9PVEoYSkpTShhLnUsUChhLFwiTG9jYWwgcmVxdWVzdCBlcnJvciBkZXRlY3RlZCBhbmQgaWdub3JlZFwiKSk7ZWxzZSBpZihhLmomJjQ9PURkKGEpKXFkKGEuY2EsMCxhKTtlbHNlIGlmKEsoYSxcInJlYWR5c3RhdGVjaGFuZ2VcIiksND09RGQoYSkpe00oYS51LFAoYSxcIlJlcXVlc3QgY29tcGxldGVcIikpO2EuYz0hMTt0cnl7aWYoRWQoYSkpSyhhLFwiY29tcGxldGVcIiksSyhhLFwic3VjY2Vzc1wiKTtlbHNle2EuSj02O3ZhciBiO3RyeXtiPTI8RGQoYSk/YS5hLnN0YXR1c1RleHQ6XCJcIn1jYXRjaChjKXtNKGEudSxcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIrYy5tZXNzYWdlKSxiPVwiXCJ9YS5oPWIrXCIgW1wiK1EoYSkrXCJdXCI7emQoYSl9fWZpbmFsbHl7QWQoYSl9fX07XG5OLnByb3RvdHlwZS5SPWZ1bmN0aW9uKGEsYil7QyhcInByb2dyZXNzXCI9PT1hLnR5cGUsXCJnb29nLm5ldC5FdmVudFR5cGUuUFJPR1JFU1MgaXMgb2YgdGhlIHNhbWUgdHlwZSBhcyByYXcgWEhSIHByb2dyZXNzLlwiKTtLKHRoaXMsRmQoYSxcInByb2dyZXNzXCIpKTtLKHRoaXMsRmQoYSxiP1wiZG93bmxvYWRwcm9ncmVzc1wiOlwidXBsb2FkcHJvZ3Jlc3NcIikpfTtcbnZhciBGZD1mdW5jdGlvbihhLGIpe3JldHVybnt0eXBlOmIsbGVuZ3RoQ29tcHV0YWJsZTphLmxlbmd0aENvbXB1dGFibGUsbG9hZGVkOmEubG9hZGVkLHRvdGFsOmEudG90YWx9fSxBZD1mdW5jdGlvbihhLGIpe2lmKGEuYSl7d2QoYSk7dmFyIGM9YS5hLGQ9YS5CWzBdP2JhOm51bGw7YS5hPW51bGw7YS5CPW51bGw7Ynx8SyhhLFwicmVhZHlcIik7dHJ5e2Mub25yZWFkeXN0YXRlY2hhbmdlPWR9Y2F0Y2goZSl7KGE9YS51KSYmYS5sb2coaWQsXCJQcm9ibGVtIGVuY291bnRlcmVkIHJlc2V0dGluZyBvbnJlYWR5c3RhdGVjaGFuZ2U6IFwiK2UubWVzc2FnZSx2b2lkIDApfX19LHdkPWZ1bmN0aW9uKGEpe2EuYSYmYS52JiYoYS5hLm9udGltZW91dD1udWxsKTtcIm51bWJlclwiPT10eXBlb2YgYS5tJiYobS5jbGVhclRpbWVvdXQoYS5tKSxhLm09bnVsbCl9LEVkPWZ1bmN0aW9uKGEpe3ZhciBiPVEoYSksYzthOnN3aXRjaChiKXtjYXNlIDIwMDpjYXNlIDIwMTpjYXNlIDIwMjpjYXNlIDIwNDpjYXNlIDIwNjpjYXNlIDMwNDpjYXNlIDEyMjM6Yz1cbiEwO2JyZWFrIGE7ZGVmYXVsdDpjPSExfWlmKCFjKXtpZihiPTA9PT1iKWE9U3RyaW5nKGEubCkubWF0Y2godmIpWzFdfHxudWxsLCFhJiZtLnNlbGYmJm0uc2VsZi5sb2NhdGlvbiYmKGE9bS5zZWxmLmxvY2F0aW9uLnByb3RvY29sLGE9YS5zdWJzdHIoMCxhLmxlbmd0aC0xKSksYj0hdGQudGVzdChhP2EudG9Mb3dlckNhc2UoKTpcIlwiKTtjPWJ9cmV0dXJuIGN9LERkPWZ1bmN0aW9uKGEpe3JldHVybiBhLmE/YS5hLnJlYWR5U3RhdGU6MH0sUT1mdW5jdGlvbihhKXt0cnl7cmV0dXJuIDI8RGQoYSk/YS5hLnN0YXR1czotMX1jYXRjaChiKXtyZXR1cm4tMX19LEdkPWZ1bmN0aW9uKGEpe3RyeXtyZXR1cm4gYS5hP2EuYS5yZXNwb25zZVRleHQ6XCJcIn1jYXRjaChiKXtyZXR1cm4gTShhLnUsXCJDYW4gbm90IGdldCByZXNwb25zZVRleHQ6IFwiK2IubWVzc2FnZSksXCJcIn19LEhkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuYSYmND09RGQoYSk/YS5hLmdldFJlc3BvbnNlSGVhZGVyKGIpOnZvaWQgMH0sXG5QPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIrXCIgW1wiK2EuUCtcIiBcIithLmwrXCIgXCIrUShhKStcIl1cIn07dmFyIElkPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMubT1hO3RoaXMudj0hIWQ7TC5jYWxsKHRoaXMsYixjKX07dShJZCxMKTtJZC5wcm90b3R5cGUuaD1mdW5jdGlvbigpe3ZhciBhPW5ldyBOLGI9dGhpcy5tO2ImJmIuZm9yRWFjaChmdW5jdGlvbihiLGQpe2EuTC5zZXQoZCxiKX0pO3RoaXMudiYmKGEuWj0hMCk7cmV0dXJuIGF9O0lkLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEpe3JldHVybiFhLmcmJiFhLmF9O3ZhciBZYz1uZXcgSWQ7dmFyIEtkPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxsLEIpe3RoaXMuTD1hO3RoaXMuSD1iO3RoaXMuQj1jO3RoaXMubT1kO3RoaXMuST1lLnNsaWNlKCk7dGhpcy5zPXRoaXMubD10aGlzLmY9dGhpcy5jPW51bGw7dGhpcy5oPXRoaXMuaT0hMTt0aGlzLnY9Zjt0aGlzLmo9Zzt0aGlzLmc9bDt0aGlzLk09Qjt0aGlzLks9aDt2YXIgdj10aGlzO3RoaXMuQz1uZXcgSChmdW5jdGlvbihhLGIpe3YubD1hO3Yucz1iO0pkKHYpfSl9LExkPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmI9YTt0aGlzLmM9Yjt0aGlzLmE9ISFjfSxKZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYil7Yj9hKCExLG5ldyBMZCghMSxudWxsLCEwKSk6WWMuVyhmdW5jdGlvbihiKXtiLlo9ZC5NO2QuYz1iO3ZhciBjPW51bGw7bnVsbCE9PWQuZyYmKGIuYmE9ITAsYz1LYyhiLFwidXBsb2FkcHJvZ3Jlc3NcIixmdW5jdGlvbihhKXtkLmcoYS5sb2FkZWQsYS5sZW5ndGhDb21wdXRhYmxlP2EudG90YWw6LTEpfSksYi5iYT1cbm51bGwhPT1kLmcpO2Iuc2VuZChkLkwsZC5ILGQubSxkLkIpO1NjKGIsXCJjb21wbGV0ZVwiLGZ1bmN0aW9uKGIpe251bGwhPT1jJiZVYyhjKTtkLmM9bnVsbDtiPWIudGFyZ2V0O3ZhciBmPTY9PT1iLkomJjEwMDw9UShiKSxmPUVkKGIpfHxmLGc9UShiKTshZnx8NTAwPD1nJiY2MDA+Z3x8NDI5PT09Zz8oZj03PT09Yi5KLFpjKGIpLGEoITEsbmV3IExkKCExLG51bGwsZikpKTooZj0wPD1lYihkLkksZyksYSghMCxuZXcgTGQoZixiKSkpfSl9KX1mdW5jdGlvbiBjKGEsYil7dmFyIGM9ZC5sO2E9ZC5zO3ZhciBoPWIuYztpZihiLmIpdHJ5e3ZhciBsPWQudihoLEdkKGgpKTtuKGwpP2MobCk6YygpfWNhdGNoKEIpe2EoQil9ZWxzZSBudWxsIT09aD8oYj1sYSgpLGw9R2QoaCksYi5zZXJ2ZXJSZXNwb25zZT1sLGQuaj9hKGQuaihoLGIpKTphKGIpKTooYj1iLmE/ZC5oP3FhKCk6b2EoKTpuZXcgdyhcInJldHJ5LWxpbWl0LWV4Y2VlZGVkXCIsXCJNYXggcmV0cnkgdGltZSBmb3Igb3BlcmF0aW9uIGV4Y2VlZGVkLCBwbGVhc2UgdHJ5IGFnYWluLlwiKSxcbmEoYikpO1pjKGgpfXZhciBkPWE7YS5pP2MoMCxuZXcgTGQoITEsbnVsbCwhMCkpOmEuZj1qYShiLGMsYS5LKX07S2QucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5DfTtLZC5wcm90b3R5cGUuYj1mdW5jdGlvbihhKXt0aGlzLmk9ITA7dGhpcy5oPWF8fCExO251bGwhPT10aGlzLmYmJigwLHRoaXMuZikoITEpO251bGwhPT10aGlzLmMmJnlkKHRoaXMuYyl9O3ZhciBNZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9UmEoYS5mKSxkPWEubCtkLGU9YS5iP3NhKGEuYik6e307bnVsbCE9PWImJjA8Yi5sZW5ndGgmJihlLkF1dGhvcml6YXRpb249XCJGaXJlYmFzZSBcIitiKTtlW1wiWC1GaXJlYmFzZS1TdG9yYWdlLVZlcnNpb25cIl09XCJ3ZWJqcy8xLjAuMFwiO3JldHVybiBuZXcgS2QoZCxhLmksZSxhLmMsYS5oLGEuTixhLmEsYS5qLGEuZyxjKX07dmFyIE5kPWZ1bmN0aW9uKGEpe3ZhciBiPW0uQmxvYkJ1aWxkZXJ8fG0uV2ViS2l0QmxvYkJ1aWxkZXI7aWYobihiKSl7Zm9yKHZhciBiPW5ldyBiLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWIuYXBwZW5kKGFyZ3VtZW50c1tjXSk7cmV0dXJuIGIuZ2V0QmxvYigpfWI9bmIoYXJndW1lbnRzKTtjPW0uQmxvYkJ1aWxkZXJ8fG0uV2ViS2l0QmxvYkJ1aWxkZXI7aWYobihjKSl7Zm9yKHZhciBjPW5ldyBjLGQ9MDtkPGIubGVuZ3RoO2QrKyljLmFwcGVuZChiW2RdLHZvaWQgMCk7Yj1jLmdldEJsb2Iodm9pZCAwKX1lbHNlIGlmKG4obS5CbG9iKSliPW5ldyBCbG9iKGIse30pO2Vsc2UgdGhyb3cgRXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgY3JlYXRpbmcgQmxvYnNcIik7cmV0dXJuIGJ9LE9kPWZ1bmN0aW9uKGEsYixjKXtuKGMpfHwoYz1hLnNpemUpO3JldHVybiBhLndlYmtpdFNsaWNlP2Eud2Via2l0U2xpY2UoYixjKTphLm1velNsaWNlP2EubW96U2xpY2UoYixcbmMpOmEuc2xpY2U/VWImJiFHKFwiMTMuMFwiKXx8VmImJiFHKFwiNTM3LjFcIik/KDA+YiYmKGIrPWEuc2l6ZSksMD5iJiYoYj0wKSwwPmMmJihjKz1hLnNpemUpLGM8YiYmKGM9YiksYS5zbGljZShiLGMtYikpOmEuc2xpY2UoYixjKTpudWxsfTt2YXIgUGQ9ZnVuY3Rpb24oYSl7dGhpcy5jPXZjKGEpfTtQZC5wcm90b3R5cGUuYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O1BkLnByb3RvdHlwZS5iPWZ1bmN0aW9uKCl7fTt2YXIgUWQ9ZnVuY3Rpb24oKXt0aGlzLmE9e307dGhpcy5iPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSfSxSZD1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXtkZWxldGUgZS5hW2RdfXZhciBkPWEuYjthLmIrKzthLmFbZF09Yjt2YXIgZT1hO2IuYSgpLnRoZW4oYyxjKX07UWQucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7cmEodGhpcy5hLGZ1bmN0aW9uKGEsYil7YiYmYi5iKCEwKX0pO3RoaXMuYT17fX07dmFyIFNkPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuYT1hO3RoaXMuZj1udWxsO251bGwhPT10aGlzLmEmJihhPXRoaXMuYS5vcHRpb25zLHkoYSk/dGhpcy5mPWEuc3RvcmFnZUJ1Y2tldHx8bnVsbDp0aGlzLmY9bnVsbCk7dGhpcy5sPWI7dGhpcy5qPWM7dGhpcy5pPWQ7dGhpcy5jPTEyRTQ7dGhpcy5iPTZFNDt0aGlzLmg9bmV3IFFkO3RoaXMuZz0hMX0sVGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hLmEmJnkoYS5hLklOVEVSTkFMKSYmeShhLmEuSU5URVJOQUwuZ2V0VG9rZW4pP2EuYS5JTlRFUk5BTC5nZXRUb2tlbigpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSk/YS5hY2Nlc3NUb2tlbjpudWxsfSxmdW5jdGlvbigpe3JldHVybiBudWxsfSk6dWMobnVsbCl9O1NkLnByb3RvdHlwZS5idWNrZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLmcpdGhyb3cgcWEoKTtyZXR1cm4gdGhpcy5mfTtcbnZhciBSPWZ1bmN0aW9uKGEsYixjKXtpZihhLmcpcmV0dXJuIG5ldyBQZChxYSgpKTtiPWEuaihiLGMsbnVsbD09PWEuYSk7UmQoYS5oLGIpO3JldHVybiBifTt2YXIgVWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYn0sUz1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmM9YTt0aGlzLmI9Ynx8YTt0aGlzLmY9ISFjO3RoaXMuYT1kfHxVZH0sVmQ9bnVsbCxXZD1mdW5jdGlvbigpe2lmKFZkKXJldHVybiBWZDt2YXIgYT1bXTthLnB1c2gobmV3IFMoXCJidWNrZXRcIikpO2EucHVzaChuZXcgUyhcImdlbmVyYXRpb25cIikpO2EucHVzaChuZXcgUyhcIm1ldGFnZW5lcmF0aW9uXCIpKTthLnB1c2gobmV3IFMoXCJuYW1lXCIsXCJmdWxsUGF0aFwiLCEwKSk7dmFyIGI9bmV3IFMoXCJuYW1lXCIpO2IuYT1mdW5jdGlvbihhLGIpe3JldHVybiF3YShiKXx8Mj5iLmxlbmd0aD9iOnhiKGIpfTthLnB1c2goYik7Yj1uZXcgUyhcInNpemVcIik7Yi5hPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHkoYik/K2I6Yn07YS5wdXNoKGIpO2EucHVzaChuZXcgUyhcInRpbWVDcmVhdGVkXCIpKTthLnB1c2gobmV3IFMoXCJ1cGRhdGVkXCIpKTthLnB1c2gobmV3IFMoXCJtZDVIYXNoXCIsbnVsbCwhMCkpO2EucHVzaChuZXcgUyhcImNhY2hlQ29udHJvbFwiLFxubnVsbCwhMCkpO2EucHVzaChuZXcgUyhcImNvbnRlbnREaXNwb3NpdGlvblwiLG51bGwsITApKTthLnB1c2gobmV3IFMoXCJjb250ZW50RW5jb2RpbmdcIixudWxsLCEwKSk7YS5wdXNoKG5ldyBTKFwiY29udGVudExhbmd1YWdlXCIsbnVsbCwhMCkpO2EucHVzaChuZXcgUyhcImNvbnRlbnRUeXBlXCIsbnVsbCwhMCkpO2EucHVzaChuZXcgUyhcIm1ldGFkYXRhXCIsXCJjdXN0b21NZXRhZGF0YVwiLCEwKSk7YS5wdXNoKG5ldyBTKFwiZG93bmxvYWRUb2tlbnNcIixcImRvd25sb2FkVVJMc1wiLCExLGZ1bmN0aW9uKGEsYil7aWYoISh3YShiKSYmMDxiLmxlbmd0aCkpcmV0dXJuW107dmFyIGU9ZW5jb2RlVVJJQ29tcG9uZW50O3JldHVybiBoYihiLnNwbGl0KFwiLFwiKSxmdW5jdGlvbihiKXt2YXIgZD1hLmZ1bGxQYXRoLGQ9XCJodHRwczovL2ZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbS92MFwiKyhcIi9iL1wiK2UoYS5idWNrZXQpK1wiL28vXCIrZShkKSk7Yj1SYSh7YWx0OlwibWVkaWFcIix0b2tlbjpifSk7cmV0dXJuIGQrXG5ifSl9KSk7cmV0dXJuIFZkPWF9LFhkPWZ1bmN0aW9uKGEsYil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJyZWZcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIubChiLG5ldyB6KGEuYnVja2V0LGEuZnVsbFBhdGgpKX19KX0sWWQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9e30sZD1iLmxlbmd0aCxlPTA7ZTxkO2UrKyl7dmFyIGY9YltlXTtmLmYmJihjW2YuY109YVtmLmJdKX1yZXR1cm4gSlNPTi5zdHJpbmdpZnkoYyl9LFpkPWZ1bmN0aW9uKGEpe2lmKCFhfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpdGhyb3dcIkV4cGVjdGVkIE1ldGFkYXRhIG9iamVjdC5cIjtmb3IodmFyIGIgaW4gYSl7dmFyIGM9YVtiXTtpZihcImN1c3RvbU1ldGFkYXRhXCI9PT1iJiZcIm9iamVjdFwiIT09dHlwZW9mIGMpdGhyb3dcIkV4cGVjdGVkIG9iamVjdCBmb3IgJ2N1c3RvbU1ldGFkYXRhJyBtYXBwaW5nLlwiO319O3ZhciBUPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9Yi5sZW5ndGgsZT1iLmxlbmd0aCxmPTA7ZjxiLmxlbmd0aDtmKyspaWYoYltmXS5iKXtkPWY7YnJlYWt9aWYoIShkPD1jLmxlbmd0aCYmYy5sZW5ndGg8PWUpKXRocm93IGQ9PT1lPyhiPWQsZD0xPT09ZD9cImFyZ3VtZW50XCI6XCJhcmd1bWVudHNcIik6KGI9XCJiZXR3ZWVuIFwiK2QrXCIgYW5kIFwiK2UsZD1cImFyZ3VtZW50c1wiKSxuZXcgdyhcImludmFsaWQtYXJndW1lbnQtY291bnRcIixcIkludmFsaWQgYXJndW1lbnQgY291bnQgaW4gYFwiK2ErXCJgOiBFeHBlY3RlZCBcIitiK1wiIFwiK2QrXCIsIHJlY2VpdmVkIFwiK2MubGVuZ3RoK1wiLlwiKTtmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKXRyeXtiW2ZdLmEoY1tmXSl9Y2F0Y2goZyl7aWYoZyBpbnN0YW5jZW9mIEVycm9yKXRocm93IHBhKGYsYSxnLm1lc3NhZ2UpO3Rocm93IHBhKGYsYSxnKTt9fSxVPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczt0aGlzLmE9ZnVuY3Rpb24oYil7Yy5iJiYhbihiKXx8YShiKX07XG50aGlzLmI9ISFifSwkZD1mdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbihjKXthKGMpO2IoYyl9fSxhZT1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7aWYoIShcInN0cmluZ1wiPT09dHlwZW9mIGF8fGEgaW5zdGFuY2VvZiBTdHJpbmcpKXRocm93XCJFeHBlY3RlZCBzdHJpbmcuXCI7fXZhciBkO2E/ZD0kZChjLGEpOmQ9YztyZXR1cm4gbmV3IFUoZCxiKX0sYmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFUoZnVuY3Rpb24oYSl7aWYoIShhIGluc3RhbmNlb2YgQmxvYikpdGhyb3dcIkV4cGVjdGVkIEJsb2Igb3IgRmlsZS5cIjt9KX0sY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFUoZnVuY3Rpb24oYSl7aWYoISgoXCJudW1iZXJcIj09PXR5cGVvZiBhfHxhIGluc3RhbmNlb2YgTnVtYmVyKSYmMDw9YSkpdGhyb3dcIkV4cGVjdGVkIGEgbnVtYmVyIDAgb3IgZ3JlYXRlci5cIjt9KX0sZGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IFUoZnVuY3Rpb24oYil7aWYoIShudWxsPT09Ynx8eShiKSYmXG5iIGluc3RhbmNlb2YgT2JqZWN0KSl0aHJvd1wiRXhwZWN0ZWQgYW4gT2JqZWN0LlwiO3koYSkmJmEoYil9LGIpfSxlZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVShmdW5jdGlvbihhKXtpZihudWxsIT09YSYmIXIoYSkpdGhyb3dcIkV4cGVjdGVkIGEgRnVuY3Rpb24uXCI7fSwhMCl9O3ZhciBmZT1mdW5jdGlvbihhKXtpZighYSl0aHJvdyBsYSgpO30sZ2U9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXthOnt2YXIgZTt0cnl7ZT1KU09OLnBhcnNlKGQpfWNhdGNoKGgpe2M9bnVsbDticmVhayBhfWM9ZGEoZSk/ZTpudWxsfWlmKG51bGw9PT1jKWM9bnVsbDtlbHNle2Q9e3R5cGU6XCJmaWxlXCJ9O2U9Yi5sZW5ndGg7Zm9yKHZhciBmPTA7ZjxlO2YrKyl7dmFyIGc9YltmXTtkW2cuYl09Zy5hKGQsY1tnLmNdKX1YZChkLGEpO2M9ZH1mZShudWxsIT09Yyk7cmV0dXJuIGN9fSxoZT1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYixjKXtiPTQwND09PVEoYik/bmV3IHcoXCJvYmplY3Qtbm90LWZvdW5kXCIsXCJPYmplY3QgJ1wiK2EucGF0aCtcIicgZG9lcyBub3QgZXhpc3QuXCIpOjQwMT09PVEoYik/bWEoKTo0MDM9PT1RKGIpP25hKGEucGF0aCk6YztiLnNlcnZlclJlc3BvbnNlPWMuc2VydmVyUmVzcG9uc2U7cmV0dXJuIGJ9fSxpZT1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYixcbmMpe2I9NDAxPT09UShiKT9tYSgpOjQwMz09PVEoYik/bmEoYS5wYXRoKTpjO2Iuc2VydmVyUmVzcG9uc2U9Yy5zZXJ2ZXJSZXNwb25zZTtyZXR1cm4gYn19LGplPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1PYShiKTthPW5ldyB4KGthK1wiL3YwXCIrZCxcIkdFVFwiLGdlKGEsYyksYS5jKTthLmE9aGUoYik7cmV0dXJuIGF9LGtlPWZ1bmN0aW9uKGEsYil7dmFyIGM9T2EoYik7YT1uZXcgeChrYStcIi92MFwiK2MsXCJERUxFVEVcIixmdW5jdGlvbigpe30sYS5jKTthLmg9WzIwMCwyMDRdO2EuYT1oZShiKTtyZXR1cm4gYX0sbGU9ZnVuY3Rpb24oYSxiLGMpe2M9Yz9zYShjKTp7fTtjLmZ1bGxQYXRoPWEucGF0aDtjLnNpemU9Yi5zaXplO2MuY29udGVudFR5cGV8fChjLmNvbnRlbnRUeXBlPWImJmIudHlwZXx8XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7cmV0dXJuIGN9LG1lPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9XCIvYi9cIitlbmNvZGVVUklDb21wb25lbnQoYi5idWNrZXQpK1wiL29cIixnPVxue1wiWC1Hb29nLVVwbG9hZC1Qcm90b2NvbFwiOlwibXVsdGlwYXJ0XCJ9LGg7aD1cIlwiO2Zvcih2YXIgbD0wOzI+bDtsKyspaCs9TWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpO2dbXCJDb250ZW50LVR5cGVcIl09XCJtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9XCIraDtlPWxlKGIsZCxlKTtsPVlkKGUsYyk7ZD1OZChcIi0tXCIraCtcIlxcclxcbkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFxcclxcblxcclxcblwiK2wrXCJcXHJcXG4tLVwiK2grXCJcXHJcXG5Db250ZW50LVR5cGU6IFwiK2UuY29udGVudFR5cGUrXCJcXHJcXG5cXHJcXG5cIixkLFwiXFxyXFxuLS1cIitoK1wiLS1cIik7YT1uZXcgeChrYStcIi92MFwiK2YsXCJQT1NUXCIsZ2UoYSxjKSxhLmIpO2EuZj17bmFtZTplLmZ1bGxQYXRofTthLmI9ZzthLmM9ZDthLmE9aWUoYik7cmV0dXJuIGF9LG5lPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuYT1hO3RoaXMudG90YWw9Yjt0aGlzLmI9ISFjO3RoaXMuYz1kfHxudWxsfSxvZT1mdW5jdGlvbihhLFxuYil7dmFyIGM7dHJ5e2M9SGQoYSxcIlgtR29vZy1VcGxvYWQtU3RhdHVzXCIpfWNhdGNoKGQpe2ZlKCExKX1hPTA8PWViKGJ8fFtcImFjdGl2ZVwiXSxjKTtmZShhKTtyZXR1cm4gY30scGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1cIi9iL1wiK2VuY29kZVVSSUNvbXBvbmVudChiLmJ1Y2tldCkrXCIvb1wiLGc9bGUoYixkLGUpO2U9e25hbWU6Zy5mdWxsUGF0aH07Zj1rYStcIi92MFwiK2Y7ZD17XCJYLUdvb2ctVXBsb2FkLVByb3RvY29sXCI6XCJyZXN1bWFibGVcIixcIlgtR29vZy1VcGxvYWQtQ29tbWFuZFwiOlwic3RhcnRcIixcIlgtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoXCI6ZC5zaXplLFwiWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlXCI6Zy5jb250ZW50VHlwZSxcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwifTtjPVlkKGcsYyk7YT1uZXcgeChmLFwiUE9TVFwiLGZ1bmN0aW9uKGEpe29lKGEpO3ZhciBiO3RyeXtiPUhkKGEsXCJYLUdvb2ctVXBsb2FkLVVSTFwiKX1jYXRjaChjKXtmZSghMSl9ZmUod2EoYikpO1xucmV0dXJuIGJ9LGEuYik7YS5mPWU7YS5iPWQ7YS5jPWM7YS5hPWllKGIpO3JldHVybiBhfSxxZT1mdW5jdGlvbihhLGIsYyxkKXthPW5ldyB4KGMsXCJQT1NUXCIsZnVuY3Rpb24oYSl7dmFyIGI9b2UoYSxbXCJhY3RpdmVcIixcImZpbmFsXCJdKSxjO3RyeXtjPUhkKGEsXCJYLUdvb2ctVXBsb2FkLVNpemUtUmVjZWl2ZWRcIil9Y2F0Y2goaCl7ZmUoITEpfWE9Yztpc0Zpbml0ZShhKSYmKGE9U3RyaW5nKGEpKTthPXEoYSk/L15cXHMqLT8weC9pLnRlc3QoYSk/cGFyc2VJbnQoYSwxNik6cGFyc2VJbnQoYSwxMCk6TmFOO2ZlKCFpc05hTihhKSk7cmV0dXJuIG5ldyBuZShhLGQuc2l6ZSxcImZpbmFsXCI9PT1iKX0sYS5iKTthLmI9e1wiWC1Hb29nLVVwbG9hZC1Db21tYW5kXCI6XCJxdWVyeVwifTthLmE9aWUoYik7cmV0dXJuIGF9LHJlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1uZXcgbmUoMCwwKTtmPyhnLmE9Zi5hLGcudG90YWw9Zi50b3RhbCk6KGcuYT0wLGcudG90YWw9ZC5zaXplKTtpZihkLnNpemUhPT1cbmcudG90YWwpdGhyb3cgbmV3IHcoXCJzZXJ2ZXItZmlsZS13cm9uZy1zaXplXCIsXCJTZXJ2ZXIgcmVjb3JkZWQgaW5jb3JyZWN0IHVwbG9hZCBmaWxlIHNpemUsIHBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLlwiKTt2YXIgaD1mPWcudG90YWwtZy5hLGg9TWF0aC5taW4oaCwyNjIxNDQpLGw9Zy5hO2Y9e1wiWC1Hb29nLVVwbG9hZC1Db21tYW5kXCI6aD09PWY/XCJ1cGxvYWQsIGZpbmFsaXplXCI6XCJ1cGxvYWRcIixcIlgtR29vZy1VcGxvYWQtT2Zmc2V0XCI6Zy5hfTtsPU9kKGQsbCxsK2gpO2lmKG51bGw9PT1sKXRocm93IG5ldyB3KFwiY2Fubm90LXNsaWNlLWJsb2JcIixcIkNhbm5vdCBzbGljZSBibG9iIGZvciB1cGxvYWQuIFBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLlwiKTtjPW5ldyB4KGMsXCJQT1NUXCIsZnVuY3Rpb24oYSxjKXt2YXIgZj1vZShhLFtcImFjdGl2ZVwiLFwiZmluYWxcIl0pLGw9Zy5hK2gsQ2Q9ZC5zaXplLFZhO1wiZmluYWxcIj09PWY/VmE9Z2UoYixlKShhLGMpOlZhPW51bGw7cmV0dXJuIG5ldyBuZShsLFxuQ2QsXCJmaW5hbFwiPT09ZixWYSl9LGIuYik7Yy5iPWY7Yy5jPWw7Yy5nPW51bGw7Yy5hPWllKGEpO3JldHVybiBjfTt2YXIgVz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5LPWE7dGhpcy5jPWI7dGhpcy5pPWM7dGhpcy5mPWU7dGhpcy5oPWZ8fG51bGw7dGhpcy5sPWQ7dGhpcy5qPTA7dGhpcy5CPXRoaXMucz0hMTt0aGlzLnY9W107dGhpcy5SPTI2MjE0NDx0aGlzLmYuc2l6ZTt0aGlzLmI9XCJydW5uaW5nXCI7dGhpcy5hPXRoaXMubT10aGlzLmc9bnVsbDt2YXIgZz10aGlzO3RoaXMuVj1mdW5jdGlvbihhKXtnLmE9bnVsbDtcInN0b3JhZ2UvY2FuY2VsZWRcIj09PWEuY29kZT8oZy5zPSEwLHNlKGcpKTooZy5nPWEsVihnLFwiZXJyb3JcIikpfTt0aGlzLlA9ZnVuY3Rpb24oYSl7Zy5hPW51bGw7XCJzdG9yYWdlL2NhbmNlbGVkXCI9PT1hLmNvZGU/c2UoZyk6KGcuZz1hLFYoZyxcImVycm9yXCIpKX07dGUodGhpcyl9LHRlPWZ1bmN0aW9uKGEpe1wicnVubmluZ1wiPT09YS5iJiZudWxsPT09YS5hJiYoYS5SP251bGw9PT1hLm0/dWUoYSk6YS5zP3ZlKGEpOmEuQj93ZShhKTp4ZShhKTp5ZShhKSl9LHplPWZ1bmN0aW9uKGEsXG5iKXtUZChhLmMpLnRoZW4oZnVuY3Rpb24oYyl7c3dpdGNoKGEuYil7Y2FzZSBcInJ1bm5pbmdcIjpiKGMpO2JyZWFrO2Nhc2UgXCJjYW5jZWxpbmdcIjpWKGEsXCJjYW5jZWxlZFwiKTticmVhaztjYXNlIFwicGF1c2luZ1wiOlYoYSxcInBhdXNlZFwiKX19KX0sdWU9ZnVuY3Rpb24oYSl7emUoYSxmdW5jdGlvbihiKXt2YXIgYz1wZShhLmMsYS5pLGEubCxhLmYsYS5oKTthLmE9UihhLmMsYyxiKTthLmEuYSgpLnRoZW4oZnVuY3Rpb24oYil7YS5hPW51bGw7YS5tPWI7YS5zPSExO3NlKGEpfSx0aGlzLlYpfSl9LHZlPWZ1bmN0aW9uKGEpe3ZhciBiPWEubTt6ZShhLGZ1bmN0aW9uKGMpe3ZhciBkPXFlKGEuYyxhLmksYixhLmYpO2EuYT1SKGEuYyxkLGMpO2EuYS5hKCkudGhlbihmdW5jdGlvbihiKXthLmE9bnVsbDtBZShhLGIuYSk7YS5zPSExO2IuYiYmKGEuQj0hMCk7c2UoYSl9LGEuVil9KX0seGU9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG5lKGEuaixhLmYuc2l6ZSksYz1hLm07emUoYSxmdW5jdGlvbihkKXt2YXIgZTtcbnRyeXtlPXJlKGEuaSxhLmMsYyxhLmYsYS5sLGIpfWNhdGNoKGYpe2EuZz1mO1YoYSxcImVycm9yXCIpO3JldHVybn1hLmE9UihhLmMsZSxkKTthLmEuYSgpLnRoZW4oZnVuY3Rpb24oYil7YS5hPW51bGw7QWUoYSxiLmEpO2IuYj8oYS5oPWIuYyxWKGEsXCJzdWNjZXNzXCIpKTpzZShhKX0sYS5WKX0pfSx3ZT1mdW5jdGlvbihhKXt6ZShhLGZ1bmN0aW9uKGIpe3ZhciBjPWplKGEuYyxhLmksYS5sKTthLmE9UihhLmMsYyxiKTthLmEuYSgpLnRoZW4oZnVuY3Rpb24oYil7YS5hPW51bGw7YS5oPWI7VihhLFwic3VjY2Vzc1wiKX0sYS5QKX0pfSx5ZT1mdW5jdGlvbihhKXt6ZShhLGZ1bmN0aW9uKGIpe3ZhciBjPW1lKGEuYyxhLmksYS5sLGEuZixhLmgpO2EuYT1SKGEuYyxjLGIpO2EuYS5hKCkudGhlbihmdW5jdGlvbihiKXthLmE9bnVsbDthLmg9YjtBZShhLGEuZi5zaXplKTtWKGEsXCJzdWNjZXNzXCIpfSxhLlYpfSl9LEFlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5qO2Euaj1iO2Euaj5jJiZCZShhKX0sXG5WPWZ1bmN0aW9uKGEsYil7aWYoYS5iIT09Yilzd2l0Y2goYil7Y2FzZSBcImNhbmNlbGluZ1wiOmEuYj1iO251bGwhPT1hLmEmJmEuYS5iKCk7YnJlYWs7Y2FzZSBcInBhdXNpbmdcIjphLmI9YjtudWxsIT09YS5hJiZhLmEuYigpO2JyZWFrO2Nhc2UgXCJydW5uaW5nXCI6dmFyIGM9XCJwYXVzZWRcIj09PWEuYjthLmI9YjtjJiYoQmUoYSksdGUoYSkpO2JyZWFrO2Nhc2UgXCJwYXVzZWRcIjphLmI9YjtCZShhKTticmVhaztjYXNlIFwiY2FuY2VsZWRcIjphLmc9b2EoKTthLmI9YjtCZShhKTticmVhaztjYXNlIFwiZXJyb3JcIjphLmI9YjtCZShhKTticmVhaztjYXNlIFwic3VjY2Vzc1wiOmEuYj1iLEJlKGEpfX0sc2U9ZnVuY3Rpb24oYSl7c3dpdGNoKGEuYil7Y2FzZSBcInBhdXNpbmdcIjpWKGEsXCJwYXVzZWRcIik7YnJlYWs7Y2FzZSBcImNhbmNlbGluZ1wiOlYoYSxcImNhbmNlbGVkXCIpO2JyZWFrO2Nhc2UgXCJydW5uaW5nXCI6dGUoYSl9fTtcblcucHJvdG90eXBlLkM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEodGhpcy5qLHRoaXMuZi5zaXplLHZhKHRoaXMuYiksdGhpcy5oLHRoaXMsdGhpcy5LKX07XG5XLnByb3RvdHlwZS5JPWZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoYSl7dHJ5e2coYSk7cmV0dXJufWNhdGNoKGIpe310cnl7aWYoaChhKSwhKG4oYS5uZXh0KXx8bihhLmVycm9yKXx8bihhLmNvbXBsZXRlKSkpdGhyb3dcIlwiO31jYXRjaChiKXt0aHJvd1wiRXhwZWN0ZWQgYSBmdW5jdGlvbiBvciBhbiBPYmplY3Qgd2l0aCBvbmUgb2YgYG5leHRgLCBgZXJyb3JgLCBgY29tcGxldGVgIHByb3BlcnRpZXMuXCI7fX1mdW5jdGlvbiBmKGEpe3JldHVybiBmdW5jdGlvbihiLGMsZCl7bnVsbCE9PWEmJlQoXCJvblwiLGEsYXJndW1lbnRzKTt2YXIgZT1uZXcgUWEoYixjLGQpO0NlKGwsZSk7cmV0dXJuIGZ1bmN0aW9uKCl7bWIobC52LGUpfX19dmFyIGc9ZWUoKS5hLGg9ZGUobnVsbCwhMCkuYTtUKFwib25cIixbYWUoZnVuY3Rpb24oKXtpZihcInN0YXRlX2NoYW5nZWRcIiE9PWEpdGhyb3dcIkV4cGVjdGVkIG9uZSBvZiB0aGUgZXZlbnQgdHlwZXM6IFtzdGF0ZV9jaGFuZ2VkXS5cIjt9KSxkZShlLCEwKSxcbmVlKCksZWUoKV0sYXJndW1lbnRzKTt2YXIgbD10aGlzLEI9W2RlKGZ1bmN0aW9uKGEpe2lmKG51bGw9PT1hKXRocm93XCJFeHBlY3RlZCBhIGZ1bmN0aW9uIG9yIGFuIE9iamVjdCB3aXRoIG9uZSBvZiBgbmV4dGAsIGBlcnJvcmAsIGBjb21wbGV0ZWAgcHJvcGVydGllcy5cIjtlKGEpfSksZWUoKSxlZSgpXTtyZXR1cm4gbihiKXx8bihjKXx8bihkKT9mKG51bGwpKGIsYyxkKTpmKEIpfTtcbnZhciBDZT1mdW5jdGlvbihhLGIpe2Eudi5wdXNoKGIpO0RlKGEsYil9LEJlPWZ1bmN0aW9uKGEpe3ZhciBiPW5iKGEudik7ZmIoYixmdW5jdGlvbihiKXtEZShhLGIpfSl9LERlPWZ1bmN0aW9uKGEsYil7c3dpdGNoKHZhKGEuYikpe2Nhc2UgXCJydW5uaW5nXCI6Y2FzZSBcInBhdXNlZFwiOm51bGwhPT1iLm5leHQmJkdjKGIubmV4dC5iaW5kKGIsYS5DKCkpKSgpO2JyZWFrO2Nhc2UgXCJzdWNjZXNzXCI6bnVsbCE9PWIuYSYmR2MoYi5hLmJpbmQoYikpKCk7YnJlYWs7Y2FzZSBcImNhbmNlbGVkXCI6Y2FzZSBcImVycm9yXCI6bnVsbCE9PWIuZXJyb3ImJkdjKGIuZXJyb3IuYmluZChiLGEuZykpKCk7YnJlYWs7ZGVmYXVsdDpudWxsIT09Yi5lcnJvciYmR2MoYi5lcnJvci5iaW5kKGIsYS5nKSkoKX19O1xuVy5wcm90b3R5cGUuTT1mdW5jdGlvbigpe1QoXCJyZXN1bWVcIixbXSxhcmd1bWVudHMpO3ZhciBhPVwicGF1c2VkXCI9PT10aGlzLmJ8fFwicGF1c2luZ1wiPT09dGhpcy5iO2EmJlYodGhpcyxcInJ1bm5pbmdcIik7cmV0dXJuIGF9O1cucHJvdG90eXBlLkw9ZnVuY3Rpb24oKXtUKFwicGF1c2VcIixbXSxhcmd1bWVudHMpO3ZhciBhPVwicnVubmluZ1wiPT09dGhpcy5iO2EmJlYodGhpcyxcInBhdXNpbmdcIik7cmV0dXJuIGF9O1cucHJvdG90eXBlLkg9ZnVuY3Rpb24oKXtUKFwiY2FuY2VsXCIsW10sYXJndW1lbnRzKTt2YXIgYT1cInJ1bm5pbmdcIj09PXRoaXMuYnx8XCJwYXVzaW5nXCI9PT10aGlzLmI7YSYmVih0aGlzLFwiY2FuY2VsaW5nXCIpO3JldHVybiBhfTt2YXIgWD1mdW5jdGlvbihhLGIpe3RoaXMuYj1hO2lmKGIpdGhpcy5hPWIgaW5zdGFuY2VvZiB6P2I6UGEoYik7ZWxzZSBpZihhPWEuYnVja2V0KCksbnVsbCE9PWEpdGhpcy5hPW5ldyB6KGEsXCJcIik7ZWxzZSB0aHJvdyBuZXcgdyhcIm5vLWRlZmF1bHQtYnVja2V0XCIsXCJObyBkZWZhdWx0IGJ1Y2tldCBmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdzdG9yYWdlQnVja2V0JyBwcm9wZXJ0eSB3aGVuIGluaXRpYWxpemluZyB0aGUgYXBwP1wiKTt9O1gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7VChcInRvU3RyaW5nXCIsW10sYXJndW1lbnRzKTtyZXR1cm5cImdzOi8vXCIrdGhpcy5hLmJ1Y2tldCtcIi9cIit0aGlzLmEucGF0aH07dmFyIEVlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBYKGEsYil9O2s9WC5wcm90b3R5cGU7XG5rLmdhPWZ1bmN0aW9uKGEpe1QoXCJjaGlsZFwiLFthZSgpXSxhcmd1bWVudHMpO3ZhciBiPXdiKHRoaXMuYS5wYXRoLGEpO3JldHVybiBFZSh0aGlzLmIsbmV3IHoodGhpcy5hLmJ1Y2tldCxiKSl9O2suRmE9ZnVuY3Rpb24oKXt2YXIgYTthPXRoaXMuYS5wYXRoO2lmKDA9PWEubGVuZ3RoKWE9bnVsbDtlbHNle3ZhciBiPWEubGFzdEluZGV4T2YoXCIvXCIpO2E9LTE9PT1iP1wiXCI6YS5zbGljZSgwLGIpfXJldHVybiBudWxsPT09YT9udWxsOkVlKHRoaXMuYixuZXcgeih0aGlzLmEuYnVja2V0LGEpKX07ay5IYT1mdW5jdGlvbigpe3JldHVybiBFZSh0aGlzLmIsbmV3IHoodGhpcy5hLmJ1Y2tldCxcIlwiKSl9O2sucGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hLmJ1Y2tldH07ay5BYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmEucGF0aH07ay5FYT1mdW5jdGlvbigpe3JldHVybiB4Yih0aGlzLmEucGF0aCl9O2suSmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iLml9O1xuay51YT1mdW5jdGlvbihhLGIpe1QoXCJwdXRcIixbYmUoKSxuZXcgVShaZCwhMCldLGFyZ3VtZW50cyk7RmUodGhpcyxcInB1dFwiKTtyZXR1cm4gbmV3IFcodGhpcyx0aGlzLmIsdGhpcy5hLFdkKCksYSxiKX07ay5kZWxldGU9ZnVuY3Rpb24oKXtUKFwiZGVsZXRlXCIsW10sYXJndW1lbnRzKTtGZSh0aGlzLFwiZGVsZXRlXCIpO3ZhciBhPXRoaXM7cmV0dXJuIFRkKHRoaXMuYikudGhlbihmdW5jdGlvbihiKXt2YXIgYz1rZShhLmIsYS5hKTtyZXR1cm4gUihhLmIsYyxiKS5hKCl9KX07ay5oYT1mdW5jdGlvbigpe1QoXCJnZXRNZXRhZGF0YVwiLFtdLGFyZ3VtZW50cyk7RmUodGhpcyxcImdldE1ldGFkYXRhXCIpO3ZhciBhPXRoaXM7cmV0dXJuIFRkKHRoaXMuYikudGhlbihmdW5jdGlvbihiKXt2YXIgYz1qZShhLmIsYS5hLFdkKCkpO3JldHVybiBSKGEuYixjLGIpLmEoKX0pfTtcbmsudmE9ZnVuY3Rpb24oYSl7VChcInVwZGF0ZU1ldGFkYXRhXCIsW25ldyBVKFpkLHZvaWQgMCldLGFyZ3VtZW50cyk7RmUodGhpcyxcInVwZGF0ZU1ldGFkYXRhXCIpO3ZhciBiPXRoaXM7cmV0dXJuIFRkKHRoaXMuYikudGhlbihmdW5jdGlvbihjKXt2YXIgZD1iLmIsZT1iLmEsZj1hLGc9V2QoKSxoPU9hKGUpLGg9a2ErXCIvdjBcIitoLGY9WWQoZixnKSxkPW5ldyB4KGgsXCJQQVRDSFwiLGdlKGQsZyksZC5jKTtkLmI9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJ9O2QuYz1mO2QuYT1oZShlKTtyZXR1cm4gUihiLmIsZCxjKS5hKCl9KX07XG5rLnRhPWZ1bmN0aW9uKCl7VChcImdldERvd25sb2FkVVJMXCIsW10sYXJndW1lbnRzKTtGZSh0aGlzLFwiZ2V0RG93bmxvYWRVUkxcIik7cmV0dXJuIHRoaXMuaGEoKS50aGVuKGZ1bmN0aW9uKGEpe2E9YS5kb3dubG9hZFVSTHNbMF07aWYoeShhKSlyZXR1cm4gYTt0aHJvdyBuZXcgdyhcIm5vLWRvd25sb2FkLXVybFwiLFwiVGhlIGdpdmVuIGZpbGUgZG9lcyBub3QgaGF2ZSBhbnkgZG93bmxvYWQgVVJMcy5cIik7fSl9O3ZhciBGZT1mdW5jdGlvbihhLGIpe2lmKFwiXCI9PT1hLmEucGF0aCl0aHJvdyBuZXcgdyhcImludmFsaWQtcm9vdC1vcGVyYXRpb25cIixcIlRoZSBvcGVyYXRpb24gJ1wiK2IrXCInIGNhbm5vdCBiZSBwZXJmb3JtZWQgb24gYSByb290IHJlZmVyZW5jZSwgY3JlYXRlIGEgbm9uLXJvb3QgcmVmZXJlbmNlIHVzaW5nIGNoaWxkLCBzdWNoIGFzIC5jaGlsZCgnZmlsZS5wbmcnKS5cIik7fTt2YXIgWT1mdW5jdGlvbihhKXt0aGlzLmE9bmV3IFNkKGEsZnVuY3Rpb24oYSxjKXtyZXR1cm4gbmV3IFgoYSxjKX0sTWQsdGhpcyk7dGhpcy5iPWE7dGhpcy5jPW5ldyBHZSh0aGlzKX07az1ZLnByb3RvdHlwZTtrLndhPWZ1bmN0aW9uKGEpe1QoXCJyZWZcIixbYWUoZnVuY3Rpb24oYSl7aWYoL15bQS1aYS16XSs6XFwvXFwvLy50ZXN0KGEpKXRocm93XCJFeHBlY3RlZCBjaGlsZCBwYXRoIGJ1dCBnb3QgYSBVUkwsIHVzZSByZWZGcm9tVVJMIGluc3RlYWQuXCI7fSwhMCldLGFyZ3VtZW50cyk7dmFyIGI9bmV3IFgodGhpcy5hKTtyZXR1cm4gbihhKT9iLmdhKGEpOmJ9O1xuay54YT1mdW5jdGlvbihhKXtUKFwicmVmRnJvbVVSTFwiLFthZShmdW5jdGlvbihhKXtpZighL15bQS1aYS16XSs6XFwvXFwvLy50ZXN0KGEpKXRocm93XCJFeHBlY3RlZCBmdWxsIFVSTCBidXQgZ290IGEgY2hpbGQgcGF0aCwgdXNlIHJlZiBpbnN0ZWFkLlwiO3RyeXtQYShhKX1jYXRjaChjKXt0aHJvd1wiRXhwZWN0ZWQgdmFsaWQgZnVsbCBVUkwgYnV0IGdvdCBhbiBpbnZhbGlkIG9uZS5cIjt9fSwhMSldLGFyZ3VtZW50cyk7cmV0dXJuIG5ldyBYKHRoaXMuYSxhKX07ay5DYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmEuYn07ay56YT1mdW5jdGlvbihhKXtUKFwic2V0TWF4VXBsb2FkUmV0cnlUaW1lXCIsW2NlKCldLGFyZ3VtZW50cyk7dGhpcy5hLmI9YX07ay5CYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmEuY307ay55YT1mdW5jdGlvbihhKXtUKFwic2V0TWF4T3BlcmF0aW9uUmV0cnlUaW1lXCIsW2NlKCldLGFyZ3VtZW50cyk7dGhpcy5hLmM9YX07ay5vYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ9O1xuay5sYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN9O3ZhciBHZT1mdW5jdGlvbihhKXt0aGlzLmE9YX07R2UucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYS5hO2EuZz0hMDthLmE9bnVsbDthLmguY2xlYXIoKX07dmFyIFo9ZnVuY3Rpb24oYSxiLGMpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2dldDpjfSl9O1gucHJvdG90eXBlLnRvU3RyaW5nPVgucHJvdG90eXBlLnRvU3RyaW5nO1gucHJvdG90eXBlLmNoaWxkPVgucHJvdG90eXBlLmdhO1gucHJvdG90eXBlLnB1dD1YLnByb3RvdHlwZS51YTtYLnByb3RvdHlwZVtcImRlbGV0ZVwiXT1YLnByb3RvdHlwZS5kZWxldGU7WC5wcm90b3R5cGUuZ2V0TWV0YWRhdGE9WC5wcm90b3R5cGUuaGE7WC5wcm90b3R5cGUudXBkYXRlTWV0YWRhdGE9WC5wcm90b3R5cGUudmE7WC5wcm90b3R5cGUuZ2V0RG93bmxvYWRVUkw9WC5wcm90b3R5cGUudGE7WihYLnByb3RvdHlwZSxcInBhcmVudFwiLFgucHJvdG90eXBlLkZhKTtaKFgucHJvdG90eXBlLFwicm9vdFwiLFgucHJvdG90eXBlLkhhKTtaKFgucHJvdG90eXBlLFwiYnVja2V0XCIsWC5wcm90b3R5cGUucGEpO1ooWC5wcm90b3R5cGUsXCJmdWxsUGF0aFwiLFgucHJvdG90eXBlLkFhKTtcblooWC5wcm90b3R5cGUsXCJuYW1lXCIsWC5wcm90b3R5cGUuRWEpO1ooWC5wcm90b3R5cGUsXCJzdG9yYWdlXCIsWC5wcm90b3R5cGUuSmEpO1kucHJvdG90eXBlLnJlZj1ZLnByb3RvdHlwZS53YTtZLnByb3RvdHlwZS5yZWZGcm9tVVJMPVkucHJvdG90eXBlLnhhO1ooWS5wcm90b3R5cGUsXCJtYXhPcGVyYXRpb25SZXRyeVRpbWVcIixZLnByb3RvdHlwZS5CYSk7WS5wcm90b3R5cGUuc2V0TWF4T3BlcmF0aW9uUmV0cnlUaW1lPVkucHJvdG90eXBlLnlhO1ooWS5wcm90b3R5cGUsXCJtYXhVcGxvYWRSZXRyeVRpbWVcIixZLnByb3RvdHlwZS5DYSk7WS5wcm90b3R5cGUuc2V0TWF4VXBsb2FkUmV0cnlUaW1lPVkucHJvdG90eXBlLnphO1ooWS5wcm90b3R5cGUsXCJhcHBcIixZLnByb3RvdHlwZS5vYSk7WihZLnByb3RvdHlwZSxcIklOVEVSTkFMXCIsWS5wcm90b3R5cGUubGEpO0dlLnByb3RvdHlwZVtcImRlbGV0ZVwiXT1HZS5wcm90b3R5cGUuZGVsZXRlO1xuWS5wcm90b3R5cGUuY2FwaV89ZnVuY3Rpb24oYSl7a2E9YX07Vy5wcm90b3R5cGUub249Vy5wcm90b3R5cGUuSTtXLnByb3RvdHlwZS5yZXN1bWU9Vy5wcm90b3R5cGUuTTtXLnByb3RvdHlwZS5wYXVzZT1XLnByb3RvdHlwZS5MO1cucHJvdG90eXBlLmNhbmNlbD1XLnByb3RvdHlwZS5IO1ooVy5wcm90b3R5cGUsXCJzbmFwc2hvdFwiLFcucHJvdG90eXBlLkMpO1ooQS5wcm90b3R5cGUsXCJieXRlc1RyYW5zZmVycmVkXCIsQS5wcm90b3R5cGUucWEpO1ooQS5wcm90b3R5cGUsXCJ0b3RhbEJ5dGVzXCIsQS5wcm90b3R5cGUuTGEpO1ooQS5wcm90b3R5cGUsXCJzdGF0ZVwiLEEucHJvdG90eXBlLklhKTtaKEEucHJvdG90eXBlLFwibWV0YWRhdGFcIixBLnByb3RvdHlwZS5EYSk7WihBLnByb3RvdHlwZSxcImRvd25sb2FkVVJMXCIsQS5wcm90b3R5cGUuc2EpO1ooQS5wcm90b3R5cGUsXCJ0YXNrXCIsQS5wcm90b3R5cGUuS2EpO1ooQS5wcm90b3R5cGUsXCJyZWZcIixBLnByb3RvdHlwZS5HYSk7XG50YS5TVEFURV9DSEFOR0VEPVwic3RhdGVfY2hhbmdlZFwiO3VhLlJVTk5JTkc9XCJydW5uaW5nXCI7dWEuUEFVU0VEPVwicGF1c2VkXCI7dWEuU1VDQ0VTUz1cInN1Y2Nlc3NcIjt1YS5DQU5DRUxFRD1cImNhbmNlbGVkXCI7dWEuRVJST1I9XCJlcnJvclwiO0gucHJvdG90eXBlW1wiY2F0Y2hcIl09SC5wcm90b3R5cGUubDtILnByb3RvdHlwZS50aGVuPUgucHJvdG90eXBlLnRoZW47XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe3JldHVybiBuZXcgWShhKX12YXIgYj17VGFza1N0YXRlOnVhLFRhc2tFdmVudDp0YSxTdG9yYWdlOlksUmVmZXJlbmNlOlh9O2lmKHdpbmRvdy5maXJlYmFzZSYmZmlyZWJhc2UuSU5URVJOQUwmJmZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZSlmaXJlYmFzZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UoXCJzdG9yYWdlXCIsYSxiKTtlbHNlIHRocm93IEVycm9yKFwiQ2Fubm90IGluc3RhbGwgRmlyZWJhc2UgU3RvcmFnZSAtIGJlIHN1cmUgdG8gbG9hZCBmaXJlYmFzZS1hcHAuanMgZmlyc3QuXCIpO30pKCk7fSkoKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZWJhc2UuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvZmlyZWJhc2VcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjIuNFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA1LTIwVDE3OjIzWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMi4yLjRcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuXHRcdHZhciByZWFsU3RyaW5nT2JqID0gb2JqICYmIG9iai50b1N0cmluZygpO1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmICggcmVhbFN0cmluZ09iaiAtIHBhcnNlRmxvYXQoIHJlYWxTdHJpbmdPYmogKSArIDEgKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLCBcImNvbnN0cnVjdG9yXCIgKSAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd25cblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzotXSspW14+XSopXFwvPi9naSxcblxuXHQvLyBTdXBwb3J0OiBJRSAxMC0xMSwgRWRnZSAxMDI0MCtcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcblx0Ly8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuXHQvLyBjb21wdXRlZCBpcyB1bmRlZmluZWQgZm9yIGVsZW1zIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuXHRpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSwgU2FmYXJpXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOC0xMStcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gaWYgdXJsIGlzIG1hbGZvcm1lZCwgZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSApLmVuZCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdC8vIFVzZSBPUiBpbnN0ZWFkIG9mIEFORCBhcyB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSBpZiBlaXRoZXIgaXMgdHJ1ZVxuXHQvLyBTZWUgdGlja2V0cyAjMTA0MDYgYW5kICMxMzEzMlxuXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA+IDAgfHwgZWxlbS5vZmZzZXRIZWlnaHQgPiAwIHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpPDctOCssIENocm9tZTwzNy00NCtcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXHRzaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5yZXR1cm4galF1ZXJ5O1xufSkpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInJIMUpQR1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3RcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiFcbiAqIEphdmFTY3JpcHQgQ29va2llIHYyLjEuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzLWNvb2tpZS9qcy1jb29raWVcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiwgMjAxNSBLbGF1cyBIYXJ0bCAmIEZhZ25lciBCcmFja1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgT2xkQ29va2llcyA9IHdpbmRvdy5Db29raWVzO1xuXHRcdHZhciBhcGkgPSB3aW5kb3cuQ29va2llcyA9IGZhY3RvcnkoKTtcblx0XHRhcGkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHdpbmRvdy5Db29raWVzID0gT2xkQ29va2llcztcblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fTtcblx0fVxufShmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbIGkgXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdCAoY29udmVydGVyKSB7XG5cdFx0ZnVuY3Rpb24gYXBpIChrZXksIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcml0ZVxuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0YXR0cmlidXRlcyA9IGV4dGVuZCh7XG5cdFx0XHRcdFx0cGF0aDogJy8nXG5cdFx0XHRcdH0sIGFwaS5kZWZhdWx0cywgYXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmV4cGlyZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFyIGV4cGlyZXMgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdGV4cGlyZXMuc2V0TWlsbGlzZWNvbmRzKGV4cGlyZXMuZ2V0TWlsbGlzZWNvbmRzKCkgKyBhdHRyaWJ1dGVzLmV4cGlyZXMgKiA4NjRlKzUpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXMuZXhwaXJlcyA9IGV4cGlyZXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0XHRpZiAoL15bXFx7XFxbXS8udGVzdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0aWYgKCFjb252ZXJ0ZXIud3JpdGUpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLyUoMjN8MjR8MjZ8MkJ8M0F8M0N8M0V8M0R8MkZ8M0Z8NDB8NUJ8NUR8NUV8NjB8N0J8N0R8N0MpL2csIGRlY29kZVVSSUNvbXBvbmVudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb252ZXJ0ZXIud3JpdGUodmFsdWUsIGtleSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGtleSkpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnw1RXw2MHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KTtcblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1tcXChcXCldL2csIGVzY2FwZSk7XG5cblx0XHRcdFx0cmV0dXJuIChkb2N1bWVudC5jb29raWUgPSBbXG5cdFx0XHRcdFx0a2V5LCAnPScsIHZhbHVlLFxuXHRcdFx0XHRcdGF0dHJpYnV0ZXMuZXhwaXJlcyAmJiAnOyBleHBpcmVzPScgKyBhdHRyaWJ1dGVzLmV4cGlyZXMudG9VVENTdHJpbmcoKSwgLy8gdXNlIGV4cGlyZXMgYXR0cmlidXRlLCBtYXgtYWdlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnBhdGggICAgJiYgJzsgcGF0aD0nICsgYXR0cmlidXRlcy5wYXRoLFxuXHRcdFx0XHRcdGF0dHJpYnV0ZXMuZG9tYWluICAmJiAnOyBkb21haW49JyArIGF0dHJpYnV0ZXMuZG9tYWluLFxuXHRcdFx0XHRcdGF0dHJpYnV0ZXMuc2VjdXJlID8gJzsgc2VjdXJlJyA6ICcnXG5cdFx0XHRcdF0uam9pbignJykpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWFkXG5cblx0XHRcdGlmICgha2V5KSB7XG5cdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUbyBwcmV2ZW50IHRoZSBmb3IgbG9vcCBpbiB0aGUgZmlyc3QgcGxhY2UgYXNzaWduIGFuIGVtcHR5IGFycmF5XG5cdFx0XHQvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjb29raWVzIGF0IGFsbC4gQWxzbyBwcmV2ZW50cyBvZGQgcmVzdWx0IHdoZW5cblx0XHRcdC8vIGNhbGxpbmcgXCJnZXQoKVwiXG5cdFx0XHR2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZSA/IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xuXHRcdFx0dmFyIHJkZWNvZGUgPSAvKCVbMC05QS1aXXsyfSkrL2c7XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdGZvciAoOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBjb29raWVzW2ldLnNwbGl0KCc9Jyk7XG5cdFx0XHRcdHZhciBjb29raWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc9Jyk7XG5cblx0XHRcdFx0aWYgKGNvb2tpZS5jaGFyQXQoMCkgPT09ICdcIicpIHtcblx0XHRcdFx0XHRjb29raWUgPSBjb29raWUuc2xpY2UoMSwgLTEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IHBhcnRzWzBdLnJlcGxhY2UocmRlY29kZSwgZGVjb2RlVVJJQ29tcG9uZW50KTtcblx0XHRcdFx0XHRjb29raWUgPSBjb252ZXJ0ZXIucmVhZCA/XG5cdFx0XHRcdFx0XHRjb252ZXJ0ZXIucmVhZChjb29raWUsIG5hbWUpIDogY29udmVydGVyKGNvb2tpZSwgbmFtZSkgfHxcblx0XHRcdFx0XHRcdGNvb2tpZS5yZXBsYWNlKHJkZWNvZGUsIGRlY29kZVVSSUNvbXBvbmVudCk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5qc29uKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjb29raWUgPSBKU09OLnBhcnNlKGNvb2tpZSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChrZXkgPT09IG5hbWUpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGNvb2tpZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICgha2V5KSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbbmFtZV0gPSBjb29raWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdGFwaS5zZXQgPSBhcGk7XG5cdFx0YXBpLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBhcGkoa2V5KTtcblx0XHR9O1xuXHRcdGFwaS5nZXRKU09OID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGFwaS5hcHBseSh7XG5cdFx0XHRcdGpzb246IHRydWVcblx0XHRcdH0sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdFx0fTtcblx0XHRhcGkuZGVmYXVsdHMgPSB7fTtcblxuXHRcdGFwaS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRhcGkoa2V5LCAnJywgZXh0ZW5kKGF0dHJpYnV0ZXMsIHtcblx0XHRcdFx0ZXhwaXJlczogLTFcblx0XHRcdH0pKTtcblx0XHR9O1xuXG5cdFx0YXBpLndpdGhDb252ZXJ0ZXIgPSBpbml0O1xuXG5cdFx0cmV0dXJuIGFwaTtcblx0fVxuXG5cdHJldHVybiBpbml0KGZ1bmN0aW9uICgpIHt9KTtcbn0pKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyYy9qcy5jb29raWUuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInJIMUpQR1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXG5cdFJhY3RpdmUuanMgdjAuNy4zXG5cdFNhdCBBcHIgMjUgMjAxNSAxMzo1MjozOCBHTVQtMDQwMCAoRURUKSAtIGNvbW1pdCBkYTQwZjgxYzY2MGJhMmYwOWM0NWEwOWE5YzIwZmRkMzRlZTM2ZDgwXG5cblx0aHR0cDovL3JhY3RpdmVqcy5vcmdcblx0aHR0cDovL3R3aXR0ZXIuY29tL1JhY3RpdmVKU1xuXG5cdFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZ2xvYmFsLlJhY3RpdmUgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRFTVBMQVRFX1ZFUlNJT04gPSAzO1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblxuICBcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG4gIFx0ZWw6IHZvaWQgMCxcbiAgXHRhcHBlbmQ6IGZhbHNlLFxuXG4gIFx0Ly8gdGVtcGxhdGU6XG4gIFx0dGVtcGxhdGU6IHsgdjogVEVNUExBVEVfVkVSU0lPTiwgdDogW10gfSxcblxuICBcdC8vIHBhcnNlOiAgICAgLy8gVE9ETyBzdGF0aWMgZGVsaW1pdGVycz9cbiAgXHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuICBcdHNhbml0aXplOiBmYWxzZSxcbiAgXHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuICBcdGRlbGltaXRlcnM6IFtcInt7XCIsIFwifX1cIl0sXG4gIFx0dHJpcGxlRGVsaW1pdGVyczogW1wie3t7XCIsIFwifX19XCJdLFxuICBcdGludGVycG9sYXRlOiBmYWxzZSxcblxuICBcdC8vIGRhdGEgJiBiaW5kaW5nOlxuICBcdGRhdGE6IHt9LFxuICBcdGNvbXB1dGVkOiB7fSxcbiAgXHRtYWdpYzogZmFsc2UsXG4gIFx0bW9kaWZ5QXJyYXlzOiB0cnVlLFxuICBcdGFkYXB0OiBbXSxcbiAgXHRpc29sYXRlZDogZmFsc2UsXG4gIFx0dHdvd2F5OiB0cnVlLFxuICBcdGxhenk6IGZhbHNlLFxuXG4gIFx0Ly8gdHJhbnNpdGlvbnM6XG4gIFx0bm9JbnRybzogZmFsc2UsXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkOiB0cnVlLFxuICBcdGNvbXBsZXRlOiB2b2lkIDAsXG5cbiAgXHQvLyBjc3M6XG4gIFx0Y3NzOiBudWxsLFxuICBcdG5vQ3NzVHJhbnNmb3JtOiBmYWxzZVxuICB9O1xuXG4gIHZhciBjb25maWdfZGVmYXVsdHMgPSBkZWZhdWx0T3B0aW9ucztcblxuICAvLyBUaGVzZSBhcmUgYSBzdWJzZXQgb2YgdGhlIGVhc2luZyBlcXVhdGlvbnMgZm91bmQgYXRcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMgLSBsaWNlbnNlIGluZm9cbiAgLy8gZm9sbG93czpcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBlYXNpbmcuanMgdjAuNS40XG4gIC8vIEdlbmVyaWMgc2V0IG9mIGVhc2luZyBmdW5jdGlvbnMgd2l0aCBBTUQgc3VwcG9ydFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzXG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAvLyBodHRwOi8vZGFucm8ubWl0LWxpY2Vuc2Uub3JnL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbGwgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBUaG9tYXMgRnVjaHMgJiBKZXJlbXkgS2FoblxuICAvLyBFYXNpbmcgRXF1YXRpb25zIChjKSAyMDAzIFJvYmVydCBQZW5uZXIsIEJTRCBsaWNlbnNlXG4gIC8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzL21hc3Rlci9MSUNFTlNFXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSW4gdGhhdCBsaWJyYXJ5LCB0aGUgZnVuY3Rpb25zIG5hbWVkIGVhc2VJbiwgZWFzZU91dCwgYW5kXG4gIC8vIGVhc2VJbk91dCBiZWxvdyBhcmUgbmFtZWQgZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgYW5kXG4gIC8vICh5b3UgZ3Vlc3NlZCBpdCkgZWFzZUluT3V0Q3ViaWMuXG4gIC8vXG4gIC8vIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgZWFzaW5nIGZ1bmN0aW9ucyB0byB0aGlzIGxpc3QsIGFuZCB0aGV5XG4gIC8vIHdpbGwgYmUgZ2xvYmFsbHkgYXZhaWxhYmxlLlxuXG4gIHZhciBzdGF0aWNfZWFzaW5nID0ge1xuICBcdGxpbmVhcjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIHBvcztcbiAgXHR9LFxuICBcdGVhc2VJbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KHBvcywgMyk7XG4gIFx0fSxcbiAgXHRlYXNlT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zIC0gMSwgMykgKyAxO1xuICBcdH0sXG4gIFx0ZWFzZUluT3V0OiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRpZiAoKHBvcyAvPSAwLjUpIDwgMSkge1xuICBcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3cocG9zLCAzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiAwLjUgKiAoTWF0aC5wb3cocG9zIC0gMiwgMykgKyAyKTtcbiAgXHR9XG4gIH07XG5cbiAgLypnbG9iYWwgY29uc29sZSwgbmF2aWdhdG9yICovXG4gIHZhciBpc0NsaWVudCwgaXNKc2RvbSwgaGFzQ29uc29sZSwgZW52aXJvbm1lbnRfX21hZ2ljLCBuYW1lc3BhY2VzLCBzdmcsIHZlbmRvcnM7XG5cbiAgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwib2JqZWN0XCI7XG5cbiAgaXNKc2RvbSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL2pzRG9tLy50ZXN0KG5hdmlnYXRvci5hcHBOYW1lKTtcblxuICBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09IFwiZnVuY3Rpb25cIjtcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICBcdGVudmlyb25tZW50X19tYWdpYyA9IGZhbHNlO1xuICB9XG5cbiAgbmFtZXNwYWNlcyA9IHtcbiAgXHRodG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcbiAgXHRtYXRobWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICBcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBcdHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgXHR4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIFx0eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRzdmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgXHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZVwiLCBcIjEuMVwiKTtcbiAgfVxuXG4gIHZlbmRvcnMgPSBbXCJvXCIsIFwibXNcIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIl07XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnQsIG1hdGNoZXMsIGRvbV9fZGl2LCBtZXRob2ROYW1lcywgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIGRvbV9faSwgaiwgbWFrZUZ1bmN0aW9uO1xuXG4gIC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG4gIGlmICghc3ZnKSB7XG4gIFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBucykge1xuICBcdFx0aWYgKG5zICYmIG5zICE9PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0dGhyb3cgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3UncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb25cIjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAoIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50KGlucHV0KSB7XG4gIFx0dmFyIG91dHB1dDtcblxuICBcdGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICFkb2N1bWVudCB8fCAhaW5wdXQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcbiAgXHRpZiAoaW5wdXQubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dDtcbiAgXHR9XG5cbiAgXHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuICBcdGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIHRyeSBJRCBmaXJzdFxuICBcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXQpO1xuXG4gIFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuICBcdFx0aWYgKCFvdXRwdXQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICBcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlucHV0KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZGlkIGl0IHdvcms/XG4gIFx0XHRpZiAob3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSkge1xuICBcdFx0XHRyZXR1cm4gb3V0cHV0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cbiAgXHRpZiAoaW5wdXRbMF0gJiYgaW5wdXRbMF0ubm9kZVR5cGUpIHtcbiAgXHRcdHJldHVybiBpbnB1dFswXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRtYXRjaGVzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRkb21fX2RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIFx0bWV0aG9kTmFtZXMgPSBbXCJtYXRjaGVzXCIsIFwibWF0Y2hlc1NlbGVjdG9yXCJdO1xuXG4gIFx0bWFrZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHRcdHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGVbbWV0aG9kTmFtZV0oc2VsZWN0b3IpO1xuICBcdFx0fTtcbiAgXHR9O1xuXG4gIFx0ZG9tX19pID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGRvbV9faS0tICYmICFtYXRjaGVzKSB7XG4gIFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbZG9tX19pXTtcblxuICBcdFx0aWYgKGRvbV9fZGl2W3VucHJlZml4ZWRdKSB7XG4gIFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24odW5wcmVmaXhlZCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRqID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChqLS0pIHtcbiAgXHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbZG9tX19pXSArIHVucHJlZml4ZWQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZygxKTtcblxuICBcdFx0XHRcdGlmIChkb21fX2RpdltwcmVmaXhlZF0pIHtcbiAgXHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24ocHJlZml4ZWQpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSUU4Li4uXG4gIFx0aWYgKCFtYXRjaGVzKSB7XG4gIFx0XHRtYXRjaGVzID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gIFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblxuICBcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIFx0XHRcdGlmICghcGFyZW50Tm9kZSkge1xuICBcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG4gIFx0XHRcdFx0ZG9tX19kaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICBcdFx0XHRcdHBhcmVudE5vZGUgPSBkb21fX2RpdjtcbiAgXHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblxuICBcdFx0XHRcdGRvbV9fZGl2LmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gPT09IG5vZGUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZShub2RlKSB7XG4gIFx0aWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUucGFyZW50Tm9kZSAhPT0gXCJ1bmtub3duXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlVG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS50b1N0cmluZyA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBsZWdhY3kgPSBudWxsO1xuXG4gIHZhciBjcmVhdGUsIGRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdGlmIChpc0NsaWVudCkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cbiAgXHQvLyBvbmx5IHVzZSBpdCB3aXRoIERPTSBvYmplY3RzICh3aGF0IHdlcmUgeW91IHNtb2tpbmcsIE1TRlQ/KVxuICBcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzYykge1xuICBcdFx0b2JqW3Byb3BdID0gZGVzYy52YWx1ZTtcbiAgXHR9O1xuICB9XG5cbiAgdHJ5IHtcbiAgXHR0cnkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG4gIFx0XHR0aHJvdyBlcnI7XG4gIFx0fVxuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcykge1xuICBcdFx0dmFyIHByb3A7XG5cbiAgXHRcdGZvciAocHJvcCBpbiBwcm9wcykge1xuICBcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgXHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHQvLyBzaWdoXG4gIFx0Y3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8sIHByb3BzKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKHByb3RvID09PSBudWxsKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHt9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcbiAgXHRcdFx0b2JqID0gbmV3IEYoKTtcblxuICBcdFx0XHRpZiAocHJvcHMpIHtcbiAgXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHByb3BzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGlsc19vYmplY3RfX2V4dGVuZCh0YXJnZXQpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdHZhciBwcm9wLCBzb3VyY2U7XG5cbiAgXHR3aGlsZSAoc291cmNlID0gc291cmNlcy5zaGlmdCgpKSB7XG4gIFx0XHRmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gIFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxHYXBzKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0c291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gcykge1xuICBcdFx0XHRpZiAocy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG4gIHZhciBpc19fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgYXJyYXlMaWtlUGF0dGVybiA9IC9eXFxbb2JqZWN0ICg/OkFycmF5fEZpbGVMaXN0KVxcXSQvO1xuICBmdW5jdGlvbiBpc0FycmF5KHRoaW5nKSB7XG4gIFx0cmV0dXJuIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XG4gIFx0cmV0dXJuIGFycmF5TGlrZVBhdHRlcm4udGVzdChpc19fdG9TdHJpbmcuY2FsbChvYmopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICBcdGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNfX2lzTnVtZXJpYyh0aGluZykge1xuICBcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh0aGluZykpICYmIGlzRmluaXRlKHRoaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIFx0cmV0dXJuIHRoaW5nICYmIGlzX190b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgfVxuXG4gIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgdmFyIGFscmVhZHlXYXJuZWQgPSB7fSxcbiAgICAgIGxvZyxcbiAgICAgIHByaW50V2FybmluZyxcbiAgICAgIHdlbGNvbWU7XG5cbiAgaWYgKGhhc0NvbnNvbGUpIHtcbiAgXHQoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdlbGNvbWVJbnRybyA9IFtcIiVjUmFjdGl2ZS5qcyAlYzAuNy4zICVjaW4gZGVidWcgbW9kZSwgJWNtb3JlLi4uXCIsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDgyLCAxNDAsIDIyNCk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1wiXTtcbiAgXHRcdHZhciB3ZWxjb21lTWVzc2FnZSA9IFwiWW91J3JlIHJ1bm5pbmcgUmFjdGl2ZSAwLjcuMyBpbiBkZWJ1ZyBtb2RlIC0gbWVzc2FnZXMgd2lsbCBiZSBwcmludGVkIHRvIHRoZSBjb25zb2xlIHRvIGhlbHAgeW91IGZpeCBwcm9ibGVtcyBhbmQgb3B0aW1pc2UgeW91ciBhcHBsaWNhdGlvbi5cXG5cXG5UbyBkaXNhYmxlIGRlYnVnIG1vZGUsIGFkZCB0aGlzIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgYXBwOlxcbiAgUmFjdGl2ZS5ERUJVRyA9IGZhbHNlO1xcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSB3aGVuIHlvdXIgYXBwIGlzIG1pbmlmaWVkLCBhZGQgdGhpcyBzbmlwcGV0OlxcbiAgUmFjdGl2ZS5ERUJVRyA9IC91bm1pbmlmaWVkLy50ZXN0KGZ1bmN0aW9uKCl7Lyp1bm1pbmlmaWVkKi99KTtcXG5cXG5HZXQgaGVscCBhbmQgc3VwcG9ydDpcXG4gIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmdcXG4gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvdGFnZ2VkL3JhY3RpdmVqc1xcbiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhZm9ydW0vcmFjdGl2ZS1qc1xcbiAgaHR0cDovL3R3aXR0ZXIuY29tL3JhY3RpdmVqc1xcblxcbkZvdW5kIGEgYnVnPyBSYWlzZSBhbiBpc3N1ZTpcXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXNcXG5cXG5cIjtcblxuICBcdFx0d2VsY29tZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGhhc0dyb3VwID0gISFjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICBcdFx0XHRjb25zb2xlW2hhc0dyb3VwID8gXCJncm91cENvbGxhcHNlZFwiIDogXCJsb2dcIl0uYXBwbHkoY29uc29sZSwgd2VsY29tZUludHJvKTtcbiAgXHRcdFx0Y29uc29sZS5sb2cod2VsY29tZU1lc3NhZ2UpO1xuICBcdFx0XHRpZiAoaGFzR3JvdXApIHtcbiAgXHRcdFx0XHRjb25zb2xlLmdyb3VwRW5kKHdlbGNvbWVJbnRybyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3ZWxjb21lID0gbm9vcDtcbiAgXHRcdH07XG5cbiAgXHRcdHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0XHRcdHdlbGNvbWUoKTtcblxuICBcdFx0XHQvLyBleHRyYWN0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnN0YW5jZSB0aGlzIG1lc3NhZ2UgcGVydGFpbnMgdG8sIGlmIGFwcGxpY2FibGVcbiAgXHRcdFx0aWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gIFx0XHRcdFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zID8gb3B0aW9ucy5yYWN0aXZlIDogbnVsbDtcblxuICBcdFx0XHRcdGlmIChyYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHRoYXQgd2Uga25vdyB0aGUgbmFtZSBvZiwgYWRkXG4gIFx0XHRcdFx0XHQvLyBpdCB0byB0aGUgbWVzc2FnZVxuICBcdFx0XHRcdFx0dmFyIF9uYW1lID0gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0aWYgKHJhY3RpdmUuY29tcG9uZW50ICYmIChfbmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRcdG1lc3NhZ2UgPSBcIjxcIiArIF9uYW1lICsgXCI+IFwiICsgbWVzc2FnZTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAobm9kZSA9IG9wdGlvbnMubm9kZSB8fCByYWN0aXZlLmZyYWdtZW50ICYmIHJhY3RpdmUuZnJhZ21lbnQucmVuZGVyZWQgJiYgcmFjdGl2ZS5maW5kKFwiKlwiKSkge1xuICBcdFx0XHRcdFx0XHRhcmdzLnB1c2gobm9kZSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIFtcIiVjUmFjdGl2ZS5qczogJWNcIiArIG1lc3NhZ2UsIFwiY29sb3I6IHJnYigxMTQsIDE1NywgNTIpO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7XCJdLmNvbmNhdChhcmdzKSk7XG4gIFx0XHR9O1xuXG4gIFx0XHRsb2cgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIFx0XHR9O1xuICBcdH0pKCk7XG4gIH0gZWxzZSB7XG4gIFx0cHJpbnRXYXJuaW5nID0gbG9nID0gd2VsY29tZSA9IG5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgYXJncykge1xuICBcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhcmdzLnNoaWZ0KCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBmYXRhbChtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuICBcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0lmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHRsb2cuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcblxuICBcdGlmIChhbHJlYWR5V2FybmVkW21lc3NhZ2VdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0YWxyZWFkeVdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIFx0cHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybklmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2VJZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2Fybk9uY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICAvLyBFcnJvciBtZXNzYWdlcyB0aGF0IGFyZSB1c2VkIChvciBjb3VsZCBiZSkgaW4gbXVsdGlwbGUgcGxhY2VzXG4gIHZhciBiYWRBcmd1bWVudHMgPSBcIkJhZCBhcmd1bWVudHNcIjtcbiAgdmFyIG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiA9IFwiQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcXFwiJXNcXFwiICVzLCBidXQgbm8gJXMgd2FzIHJldHVybmVkXCI7XG4gIHZhciBtaXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICByZXR1cm4gXCJNaXNzaW5nIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgXCIgKyB0eXBlICsgXCIgcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMjXCIgKyB0eXBlICsgXCJzXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZEluVmlld0hpZXJhcmNoeShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZVtyZWdpc3RyeU5hbWVdW25hbWVdIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpIHtcbiAgXHR3aGlsZSAocmFjdGl2ZSkge1xuICBcdFx0aWYgKG5hbWUgaW4gcmFjdGl2ZVtyZWdpc3RyeU5hbWVdKSB7XG4gIFx0XHRcdHJldHVybiByYWN0aXZlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZSA9IHJhY3RpdmUucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgcmFjdGl2ZSwgdHlwZSkge1xuICBcdGlmIChmcm9tID09PSB0bykge1xuICBcdFx0cmV0dXJuIHNuYXAodG8pO1xuICBcdH1cblxuICBcdGlmICh0eXBlKSB7XG5cbiAgXHRcdHZhciBpbnRlcnBvbCA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJpbnRlcnBvbGF0b3JzXCIsIHJhY3RpdmUsIHR5cGUpO1xuICBcdFx0aWYgKGludGVycG9sKSB7XG4gIFx0XHRcdHJldHVybiBpbnRlcnBvbChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIFx0XHR9XG5cbiAgXHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4odHlwZSwgXCJpbnRlcnBvbGF0b3JcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBzdGF0aWNfaW50ZXJwb2xhdG9ycy5udW1iZXIoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLmFycmF5KGZyb20sIHRvKSB8fCBzdGF0aWNfaW50ZXJwb2xhdG9ycy5vYmplY3QoZnJvbSwgdG8pIHx8IHNuYXAodG8pO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblxuICBmdW5jdGlvbiBzbmFwKHRvKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0bztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRvcnMgPSB7XG4gIFx0bnVtYmVyOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBkZWx0YTtcblxuICBcdFx0aWYgKCFpc19faXNOdW1lcmljKGZyb20pIHx8ICFpc19faXNOdW1lcmljKHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0ZnJvbSA9ICtmcm9tO1xuICBcdFx0dG8gPSArdG87XG5cbiAgXHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZyb207XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdGFycmF5OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblxuICBcdFx0aWYgKCFpc0FycmF5KGZyb20pIHx8ICFpc0FycmF5KHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aW50ZXJtZWRpYXRlID0gW107XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cbiAgXHRcdGkgPSBsZW4gPSBNYXRoLm1pbihmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoKTtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aW50ZXJwb2xhdG9yc1tpXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW2ldLCB0b1tpXSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG4gIFx0XHRmb3IgKGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGZyb21baV07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IHRvW2ldO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW47XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGludGVycG9sYXRvcnNbaV0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0b2JqZWN0OiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgXHRcdHZhciBwcm9wZXJ0aWVzLCBsZW4sIGludGVycG9sYXRvcnMsIGludGVybWVkaWF0ZSwgcHJvcDtcblxuICBcdFx0aWYgKCFpc09iamVjdChmcm9tKSB8fCAhaXNPYmplY3QodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9wZXJ0aWVzID0gW107XG4gIFx0XHRpbnRlcm1lZGlhdGUgPSB7fTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSB7fTtcblxuICBcdFx0Zm9yIChwcm9wIGluIGZyb20pIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKHRvLCBwcm9wKSkge1xuICBcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKHByb3ApO1xuICBcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1twcm9wXSA9IHNoYXJlZF9pbnRlcnBvbGF0ZShmcm9tW3Byb3BdLCB0b1twcm9wXSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGZyb21bcHJvcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAocHJvcCBpbiB0bykge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApICYmICFoYXNPd24uY2FsbChmcm9tLCBwcm9wKSkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IHRvW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0dmFyIGkgPSBsZW4sXG4gIFx0XHRcdCAgICBwcm9wO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1tpXTtcblxuICBcdFx0XHRcdGludGVybWVkaWF0ZVtwcm9wXSA9IGludGVycG9sYXRvcnNbcHJvcF0odCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHN0YXRpY19pbnRlcnBvbGF0b3JzID0gaW50ZXJwb2xhdG9ycztcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG4gIC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG4gIC8vIG9mIGEga2V5LCBzdWNoIGFzICdmb28uYmFyLionLCAnZm9vLiouYmF6JywgJ2Zvby4qLionIGFuZCBzbyBvbi5cbiAgLy8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcbiAgLy8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuICAvLyB0aGVzZSB3aWxkY2FyZCBrZXlwYXRocyAoZS5nLiAnZm9vLmJhci4qLnN0YXR1cycpXG4gIHZhciB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgdmFyIHN0YXJNYXBzID0ge307XG4gIGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyhrZXlwYXRoKSB7XG4gIFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgaSwgcmVzdWx0LCB3aWxkY2FyZEtleXBhdGg7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zcGxpdChcIi5cIik7XG4gIFx0aWYgKCEoc3Rhck1hcCA9IHN0YXJNYXBzW2tleXMubGVuZ3RoXSkpIHtcbiAgXHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKGtleXMubGVuZ3RoKTtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSBbXTtcblxuICBcdG1hcHBlciA9IGZ1bmN0aW9uIChzdGFyLCBpKSB7XG4gIFx0XHRyZXR1cm4gc3RhciA/IFwiKlwiIDoga2V5c1tpXTtcbiAgXHR9O1xuXG4gIFx0aSA9IHN0YXJNYXAubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHdpbGRjYXJkS2V5cGF0aCA9IHN0YXJNYXBbaV0ubWFwKG1hcHBlcikuam9pbihcIi5cIik7XG5cbiAgXHRcdGlmICghcmVzdWx0Lmhhc093blByb3BlcnR5KHdpbGRjYXJkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2god2lsZGNhcmRLZXlwYXRoKTtcbiAgXHRcdFx0cmVzdWx0W3dpbGRjYXJkS2V5cGF0aF0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHRoZSBwb3NzaWJsZSB0cnVlL2ZhbHNlIGNvbWJpbmF0aW9ucyBmb3JcbiAgLy8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG4gIC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cbiAgLy8gSXQgZG9lcyBzbyBieSBnZXR0aW5nIGFsbCB0aGUgYmluYXJ5IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGUuZy4gMTFcbiAgZnVuY3Rpb24gZ2V0U3Rhck1hcChudW0pIHtcbiAgXHR2YXIgb25lcyA9IFwiXCIsXG4gIFx0ICAgIG1heCxcbiAgXHQgICAgYmluYXJ5LFxuICBcdCAgICBzdGFyTWFwLFxuICBcdCAgICBtYXBwZXIsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGosXG4gIFx0ICAgIGwsXG4gIFx0ICAgIG1hcDtcblxuICBcdGlmICghc3Rhck1hcHNbbnVtXSkge1xuICBcdFx0c3Rhck1hcCA9IFtdO1xuXG4gIFx0XHR3aGlsZSAob25lcy5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0b25lcyArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRtYXggPSBwYXJzZUludChvbmVzLCAyKTtcblxuICBcdFx0bWFwcGVyID0gZnVuY3Rpb24gKGRpZ2l0KSB7XG4gIFx0XHRcdHJldHVybiBkaWdpdCA9PT0gXCIxXCI7XG4gIFx0XHR9O1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDw9IG1heDsgaSArPSAxKSB7XG4gIFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoMik7XG4gIFx0XHRcdHdoaWxlIChiaW5hcnkubGVuZ3RoIDwgbnVtKSB7XG4gIFx0XHRcdFx0YmluYXJ5ID0gXCIwXCIgKyBiaW5hcnk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRtYXAgPSBbXTtcbiAgXHRcdFx0bCA9IGJpbmFyeS5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgXHRcdFx0XHRtYXAucHVzaChtYXBwZXIoYmluYXJ5W2pdKSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3Rhck1hcFtpXSA9IG1hcDtcbiAgXHRcdH1cblxuICBcdFx0c3Rhck1hcHNbbnVtXSA9IHN0YXJNYXA7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXJNYXBzW251bV07XG4gIH1cblxuICB2YXIgcmVmUGF0dGVybiA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG4gIHZhciBwYXR0ZXJuUGF0dGVybiA9IC9cXCovO1xuICB2YXIga2V5cGF0aENhY2hlID0ge307XG5cbiAgdmFyIEtleXBhdGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGtleXMgPSBzdHIuc3BsaXQoXCIuXCIpO1xuXG4gIFx0dGhpcy5zdHIgPSBzdHI7XG5cbiAgXHRpZiAoc3RyWzBdID09PSBcIkBcIikge1xuICBcdFx0dGhpcy5pc1NwZWNpYWwgPSB0cnVlO1xuICBcdFx0dGhpcy52YWx1ZSA9IGRlY29kZUtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZpcnN0S2V5ID0ga2V5c1swXTtcbiAgXHR0aGlzLmxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXG4gIFx0dGhpcy5pc1BhdHRlcm4gPSBwYXR0ZXJuUGF0dGVybi50ZXN0KHN0cik7XG5cbiAgXHR0aGlzLnBhcmVudCA9IHN0ciA9PT0gXCJcIiA/IG51bGwgOiBnZXRLZXlwYXRoKGtleXMuam9pbihcIi5cIikpO1xuICBcdHRoaXMuaXNSb290ID0gIXN0cjtcbiAgfTtcblxuICBLZXlwYXRoLnByb3RvdHlwZSA9IHtcbiAgXHRlcXVhbHNPclN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aCA9PT0gdGhpcyB8fCB0aGlzLnN0YXJ0c1dpdGgoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGpvaW46IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHRoaXMuaXNSb290ID8gU3RyaW5nKHN0cikgOiB0aGlzLnN0ciArIFwiLlwiICsgc3RyKTtcbiAgXHR9LFxuXG4gIFx0cmVwbGFjZTogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzID09PSBvbGRLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zdGFydHNXaXRoKG9sZEtleXBhdGgpKSB7XG4gIFx0XHRcdHJldHVybiBuZXdLZXlwYXRoID09PSBudWxsID8gbmV3S2V5cGF0aCA6IGdldEtleXBhdGgodGhpcy5zdHIucmVwbGFjZShvbGRLZXlwYXRoLnN0ciArIFwiLlwiLCBuZXdLZXlwYXRoLnN0ciArIFwiLlwiKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAoIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gVE9ETyB1bmRlciB3aGF0IGNpcmN1bXN0YW5jZXMgZG9lcyB0aGlzIGhhcHBlbj9cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aCAmJiB0aGlzLnN0ci5zdWJzdHIoMCwga2V5cGF0aC5zdHIubGVuZ3RoICsgMSkgPT09IGtleXBhdGguc3RyICsgXCIuXCI7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgY29lcmNpb25cIik7XG4gIFx0fSxcblxuICBcdHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0d2lsZGNhcmRNYXRjaGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fd2lsZGNhcmRNYXRjaGVzIHx8ICh0aGlzLl93aWxkY2FyZE1hdGNoZXMgPSB1dGlsc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXModGhpcy5zdHIpKTtcbiAgXHR9XG4gIH07XG4gIGZ1bmN0aW9uIGFzc2lnbk5ld0tleXBhdGgodGFyZ2V0LCBwcm9wZXJ0eSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBleGlzdGluZ0tleXBhdGggPSB0YXJnZXRbcHJvcGVydHldO1xuXG4gIFx0aWYgKGV4aXN0aW5nS2V5cGF0aCAmJiAoZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChuZXdLZXlwYXRoKSB8fCAhZXhpc3RpbmdLZXlwYXRoLmVxdWFsc09yU3RhcnRzV2l0aChvbGRLZXlwYXRoKSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0YXJnZXRbcHJvcGVydHldID0gZXhpc3RpbmdLZXlwYXRoID8gZXhpc3RpbmdLZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkgOiBuZXdLZXlwYXRoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlS2V5cGF0aChrZXlwYXRoKSB7XG4gIFx0dmFyIHZhbHVlID0ga2V5cGF0aC5zbGljZSgyKTtcblxuICBcdGlmIChrZXlwYXRoWzFdID09PSBcImlcIikge1xuICBcdFx0cmV0dXJuIGlzX19pc051bWVyaWModmFsdWUpID8gK3ZhbHVlIDogdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlwYXRoKHN0cikge1xuICBcdGlmIChzdHIgPT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHN0cjtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIGl0ICptYXkqIGJlIHdvcnRoIGhhdmluZyB0d28gdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiAtIG9uZSB3aGVyZVxuICBcdC8vIGtleXBhdGhDYWNoZSBpbmhlcml0cyBmcm9tIG51bGwsIGFuZCBvbmUgZm9yIElFOC4gRGVwZW5kcyBvbiBob3dcbiAgXHQvLyBtdWNoIG9mIGFuIG92ZXJoZWFkIGhhc093blByb3BlcnR5IGlzIC0gcHJvYmFibHkgbmVnbGlnaWJsZVxuICBcdGlmICgha2V5cGF0aENhY2hlLmhhc093blByb3BlcnR5KHN0cikpIHtcbiAgXHRcdGtleXBhdGhDYWNoZVtzdHJdID0gbmV3IEtleXBhdGgoc3RyKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aENhY2hlW3N0cl07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywga2V5LCBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0a2V5cyA9IGtleXBhdGguc3RyLnNwbGl0KFwiLlwiKTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gW3Jvb3RLZXlwYXRoXTtcblxuICBcdHdoaWxlIChrZXkgPSBrZXlzLnNoaWZ0KCkpIHtcbiAgXHRcdGlmIChrZXkgPT09IFwiKlwiKSB7XG4gIFx0XHRcdC8vIGV4cGFuZCB0byBmaW5kIGFsbCB2YWxpZCBjaGlsZCBrZXlwYXRoc1xuICBcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoZXhwYW5kLCBbXSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAobWF0Y2hpbmdLZXlwYXRoc1swXSA9PT0gcm9vdEtleXBhdGgpIHtcbiAgXHRcdFx0XHQvLyBmaXJzdCBrZXlcbiAgXHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWzBdID0gZ2V0S2V5cGF0aChrZXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcChjb25jYXRlbmF0ZShrZXkpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG4gIFx0ZnVuY3Rpb24gZXhwYW5kKG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGgpIHtcbiAgXHRcdHZhciB3cmFwcGVyLCB2YWx1ZSwga2V5cztcblxuICBcdFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGtleXMgPSBbXS5jb25jYXQoT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuZGF0YSksIE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLm1hcHBpbmdzKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zKSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3cmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnN0cl07XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlciA/IHdyYXBwZXIuZ2V0KCkgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0a2V5cyA9IHZhbHVlID8gT2JqZWN0LmtleXModmFsdWUpIDogbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXMpIHtcbiAgXHRcdFx0a2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0XHRpZiAoa2V5ICE9PSBcIl9yYWN0aXZlXCIgfHwgIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzLnB1c2goa2V5cGF0aC5qb2luKGtleSkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdGVuYXRlKGtleSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGguam9pbihrZXkpO1xuICBcdH07XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlKHJlZikge1xuICBcdHJldHVybiByZWYgPyByZWYucmVwbGFjZShyZWZQYXR0ZXJuLCBcIi4kMVwiKSA6IFwiXCI7XG4gIH1cblxuICB2YXIgcm9vdEtleXBhdGggPSBnZXRLZXlwYXRoKFwiXCIpO1xuXG4gIHZhciBzaGFyZWRfYWRkID0gYWRkO1xuICB2YXIgc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlID0gXCJDYW5ub3QgYWRkIHRvIGEgbm9uLW51bWVyaWMgdmFsdWVcIjtcbiAgZnVuY3Rpb24gYWRkKHJvb3QsIGtleXBhdGgsIGQpIHtcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggIT09IFwic3RyaW5nXCIgfHwgIWlzX19pc051bWVyaWMoZCkpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBhcmd1bWVudHNcIik7XG4gIFx0fVxuXG4gIFx0dmFyIHZhbHVlID0gdW5kZWZpbmVkLFxuICBcdCAgICBjaGFuZ2VzID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKC9cXCovLnRlc3Qoa2V5cGF0aCkpIHtcbiAgXHRcdGNoYW5nZXMgPSB7fTtcblxuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyhyb290LCBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdGlmICghaXNfX2lzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoYW5nZXNba2V5cGF0aC5zdHJdID0gdmFsdWUgKyBkO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiByb290LnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZSA9IHJvb3QuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJvb3Quc2V0KGtleXBhdGgsICt2YWx1ZSArIGQpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9hZGQgPSBSYWN0aXZlJGFkZDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhZGQoa2V5cGF0aCwgZCkge1xuICBcdHJldHVybiBzaGFyZWRfYWRkKHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCk7XG4gIH1cblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIC8vIElmIHdpbmRvdyBkb2Vzbid0IGV4aXN0LCB3ZSBkb24ndCBuZWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcbiAgXHQoZnVuY3Rpb24gKHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cpIHtcblxuICBcdFx0dmFyIHgsIHNldFRpbWVvdXQ7XG5cbiAgXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICBcdFx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cbiAgXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBcdFx0XHRcdHZhciBjdXJyVGltZSwgdGltZVRvQ2FsbCwgaWQ7XG5cbiAgXHRcdFx0XHRjdXJyVGltZSA9IERhdGUubm93KCk7XG4gIFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgXHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0Y2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgXHRcdFx0XHR9LCB0aW1lVG9DYWxsKTtcblxuICBcdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICBcdFx0XHRcdHJldHVybiBpZDtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9KSh2ZW5kb3JzLCAwLCB3aW5kb3cpO1xuXG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIHZhciByQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgdmFyIGdldFRpbWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRnZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX2dldFRpbWUgPSBnZXRUaW1lO1xuXG4gIHZhciBkZXByZWNhdGlvbnMgPSB7XG4gIFx0Y29uc3RydWN0OiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImJlZm9yZUluaXRcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29uc3RydWN0XCJcbiAgXHR9LFxuICBcdHJlbmRlcjoge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJpbml0XCIsXG4gIFx0XHRtZXNzYWdlOiBcIlRoZSBcXFwiaW5pdFxcXCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgXCIgKyBcImFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFwiICsgXCJZb3UgY2FuIGVpdGhlciB1c2UgdGhlIFxcXCJvbmluaXRcXFwiIG1ldGhvZCB3aGljaCB3aWxsIGZpcmUgXCIgKyBcIm9ubHkgb25jZSBwcmlvciB0bywgYW5kIHJlZ2FyZGxlc3Mgb2YsIGFueSBldmVudHVhbCByYWN0aXZlIFwiICsgXCJpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBcIiArIFwicmVuZGVyZWQgRE9NLCB1c2UgXFxcIm9ucmVuZGVyXFxcIiBpbnN0ZWFkLiBcIiArIFwiU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICBcdH0sXG4gIFx0Y29tcGxldGU6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiY29tcGxldGVcIixcbiAgXHRcdHJlcGxhY2VtZW50OiBcIm9uY29tcGxldGVcIlxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBIb29rKGV2ZW50KSB7XG4gIFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuICBcdHRoaXMubWV0aG9kID0gXCJvblwiICsgZXZlbnQ7XG4gIFx0dGhpcy5kZXByZWNhdGUgPSBkZXByZWNhdGlvbnNbZXZlbnRdO1xuICB9XG5cbiAgSG9vay5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcmcpIHtcbiAgXHRmdW5jdGlvbiBjYWxsKG1ldGhvZCkge1xuICBcdFx0aWYgKHJhY3RpdmVbbWV0aG9kXSkge1xuICBcdFx0XHRhcmcgPyByYWN0aXZlW21ldGhvZF0oYXJnKSA6IHJhY3RpdmVbbWV0aG9kXSgpO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjYWxsKHRoaXMubWV0aG9kKTtcblxuICBcdGlmICghcmFjdGl2ZVt0aGlzLm1ldGhvZF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgY2FsbCh0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkKSkge1xuICBcdFx0aWYgKHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UpIHtcbiAgXHRcdFx0d2FybklmRGVidWcodGhpcy5kZXByZWNhdGUubWVzc2FnZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSBtZXRob2QgXFxcIiVzXFxcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIFxcXCIlc1xcXCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiwgdGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCwgdGhpcy5kZXByZWNhdGUucmVwbGFjZW1lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGFyZyA/IHJhY3RpdmUuZmlyZSh0aGlzLmV2ZW50LCBhcmcpIDogcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQpO1xuICB9O1xuXG4gIHZhciBob29rc19Ib29rID0gSG9vaztcblxuICBmdW5jdGlvbiBhZGRUb0FycmF5KGFycmF5LCB2YWx1ZSkge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0YXJyYXkucHVzaCh2YWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnJheSwgdmFsdWUpIHtcbiAgXHRmb3IgKHZhciBpID0gMCwgYyA9IGFycmF5Lmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICBcdFx0aWYgKGFycmF5W2ldID09IHZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q29udGVudHNNYXRjaChhLCBiKSB7XG4gIFx0dmFyIGk7XG5cbiAgXHRpZiAoIWlzQXJyYXkoYSkgfHwgIWlzQXJyYXkoYikpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aSA9IGEubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChhW2ldICE9PSBiW2ldKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUFycmF5KHgpIHtcbiAgXHRpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBbeF07XG4gIFx0fVxuXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gbGFzdEl0ZW0oYXJyYXkpIHtcbiAgXHRyZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyYXksIG1lbWJlcikge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YobWVtYmVyKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgXHR2YXIgYXJyYXkgPSBbXSxcbiAgXHQgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0YXJyYXlbaV0gPSBhcnJheUxpa2VbaV07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdmFyIF9Qcm9taXNlLFxuICAgICAgUEVORElORyA9IHt9LFxuICAgICAgRlVMRklMTEVEID0ge30sXG4gICAgICBSRUpFQ1RFRCA9IHt9O1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG4gIFx0X1Byb21pc2UgPSBQcm9taXNlO1xuICB9IGVsc2Uge1xuICBcdF9Qcm9taXNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICByZWplY3RlZEhhbmRsZXJzID0gW10sXG4gIFx0XHQgICAgc3RhdGUgPSBQRU5ESU5HLFxuICBcdFx0ICAgIHJlc3VsdCxcbiAgXHRcdCAgICBkaXNwYXRjaEhhbmRsZXJzLFxuICBcdFx0ICAgIG1ha2VSZXNvbHZlcixcbiAgXHRcdCAgICBmdWxmaWwsXG4gIFx0XHQgICAgcmVqZWN0LFxuICBcdFx0ICAgIHByb21pc2U7XG5cbiAgXHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0aWYgKHN0YXRlICE9PSBQRU5ESU5HKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG4gIFx0XHRcdFx0c3RhdGUgPSBuZXdTdGF0ZTtcblxuICBcdFx0XHRcdGRpc3BhdGNoSGFuZGxlcnMgPSBtYWtlRGlzcGF0Y2hlcihzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQpO1xuXG4gIFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHR9O1xuICBcdFx0fTtcblxuICBcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKEZVTEZJTExFRCk7XG4gIFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoUkVKRUNURUQpO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRjYWxsYmFjayhmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB7XG4gIFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcbiAgXHRcdFx0dGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuXG4gIFx0XHRcdFx0XHR2YXIgcHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGhhbmRsZXJzLCBmb3J3YXJkKSB7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuICBcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKHAxcmVzdWx0KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHR2YXIgeDtcblxuICBcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIocDFyZXN1bHQpO1xuICBcdFx0XHRcdFx0XHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycik7XG4gIFx0XHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG4gIFx0XHRcdFx0XHRcdFx0Ly8gYXJlIG5vdCBnaXZlblxuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goZm9yd2FyZCk7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH07XG5cbiAgXHRcdFx0XHRcdC8vIDIuMlxuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsKTtcbiAgXHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlcihvblJlamVjdGVkLCByZWplY3RlZEhhbmRsZXJzLCByZWplY3QpO1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdFx0XHR3YWl0KGRpc3BhdGNoSGFuZGxlcnMpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRwcm9taXNlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0XHQgICAgcGVuZGluZyxcbiAgXHRcdFx0ICAgIGksXG4gIFx0XHRcdCAgICBwcm9jZXNzUHJvbWlzZTtcblxuICBcdFx0XHRpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHByb2Nlc3NQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgXHRcdFx0XHRpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHRcdH0sIHJlamVjdCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc3VsdFtpXSA9IHByb21pc2U7XG4gIFx0XHRcdFx0XHQtLXBlbmRpbmcgfHwgZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UocHJvbWlzZXNbaV0sIGkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsKSB7XG4gIFx0XHRcdGZ1bGZpbCh2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgXHRcdFx0cmVqZWN0KHJlYXNvbik7XG4gIFx0XHR9KTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHV0aWxzX1Byb21pc2UgPSBfUHJvbWlzZTtcblxuICAvLyBUT0RPIHVzZSBNdXRhdGlvbk9ic2VydmVycyBvciBzb21ldGhpbmcgdG8gc2ltdWxhdGUgc2V0SW1tZWRpYXRlXG4gIGZ1bmN0aW9uIHdhaXQoY2FsbGJhY2spIHtcbiAgXHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKGhhbmRsZXJzLCByZXN1bHQpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGhhbmRsZXI7XG5cbiAgXHRcdHdoaWxlIChoYW5kbGVyID0gaGFuZGxlcnMuc2hpZnQoKSkge1xuICBcdFx0XHRoYW5kbGVyKHJlc3VsdCk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeCwgZnVsZmlsLCByZWplY3QpIHtcbiAgXHQvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXG4gIFx0dmFyIHRoZW47XG5cbiAgXHQvLyAyLjMuMVxuICBcdGlmICh4ID09PSBwcm9taXNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2VcIik7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjJcbiAgXHRpZiAoeCBpbnN0YW5jZW9mIF9Qcm9taXNlKSB7XG4gIFx0XHR4LnRoZW4oZnVsZmlsLCByZWplY3QpO1xuICBcdH1cblxuICBcdC8vIDIuMy4zXG4gIFx0ZWxzZSBpZiAoeCAmJiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgXHRcdHRyeSB7XG4gIFx0XHRcdHRoZW4gPSB4LnRoZW47IC8vIDIuMy4zLjFcbiAgXHRcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4yXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gMi4zLjMuM1xuICBcdFx0aWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dmFyIGNhbGxlZCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2U7XG5cbiAgXHRcdFx0cmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiAoeSkge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHR1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0XHRpZiAoY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmVqZWN0KHIpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0dGhlbi5jYWxsKHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgXHRcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRcdGlmICghY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMVxuICBcdFx0XHRcdFx0cmVqZWN0KGUpOyAvLyAyLjMuMy4zLjQuMlxuICBcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZ1bGZpbCh4KTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0ZnVsZmlsKHgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiByb290S2V5cGF0aDtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3Jlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWYocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCkge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0cmVmID0gbm9ybWFsaXNlKHJlZik7XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2VcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAyKSA9PT0gXCJ+L1wiKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChyZWYuc3Vic3RyaW5nKDIpKTtcbiAgXHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG4gIFx0Ly8gYW4gYW5jZXN0b3IgcmVmZXJlbmNlLi4uXG4gIFx0ZWxzZSBpZiAocmVmWzBdID09PSBcIi5cIikge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbmNlc3RvclJlZihnZXRJbm5lckNvbnRleHQoZnJhZ21lbnQpLCByZWYpO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5cGF0aC5maXJzdEtleSwgZnJhZ21lbnQpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIGtleXBhdGggYmFzZWQgb24gY29udGV4dFxuICBcdGVsc2Uge1xuICBcdFx0a2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgZ2V0S2V5cGF0aChyZWYpLCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGtleXBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWYoYmFzZUNvbnRleHQsIHJlZikge1xuICBcdHZhciBjb250ZXh0S2V5cztcblxuICBcdC8vIFRPRE8uLi5cbiAgXHRpZiAoYmFzZUNvbnRleHQgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBiYXNlQ29udGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0YmFzZUNvbnRleHQgPSBiYXNlQ29udGV4dC5zdHI7XG4gIFx0fVxuXG4gIFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcbiAgXHRpZiAocmVmID09PSBcIi5cIikgcmV0dXJuIGdldEtleXBhdGgoYmFzZUNvbnRleHQpO1xuXG4gIFx0Y29udGV4dEtleXMgPSBiYXNlQ29udGV4dCA/IGJhc2VDb250ZXh0LnNwbGl0KFwiLlwiKSA6IFtdO1xuXG4gIFx0Ly8gYW5jZXN0b3IgcmVmZXJlbmNlcyAoc3RhcnRpbmcgXCIuLi9cIikgZ28gdXAgdGhlIHRyZWVcbiAgXHRpZiAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0d2hpbGUgKHJlZi5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIpIHtcbiAgXHRcdFx0aWYgKCFjb250ZXh0S2V5cy5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcXFwiLi4vXFxcIiBwcmVmaXhlc1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuICBcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKDMpO1xuICBcdFx0fVxuXG4gIFx0XHRjb250ZXh0S2V5cy5wdXNoKHJlZik7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aChjb250ZXh0S2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuICBcdGlmICghYmFzZUNvbnRleHQpIHtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKHJlZi5yZXBsYWNlKC9eXFwuXFwvPy8sIFwiXCIpKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKC9eXFwuXFwvLywgXCIuXCIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZSwgcmVmLCBmcmFnbWVudCwgaXNQYXJlbnRMb29rdXApIHtcbiAgXHR2YXIgY29udGV4dCwga2V5LCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlwYXRoO1xuXG4gIFx0aWYgKHJlZi5pc1Jvb3QpIHtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuXG4gIFx0a2V5ID0gcmVmLmZpcnN0S2V5O1xuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRjb250ZXh0ID0gZnJhZ21lbnQuY29udGV4dDtcbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXG4gIFx0XHRpZiAoIWNvbnRleHQpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChjb250ZXh0KTtcblxuICBcdFx0aWYgKHBhcmVudFZhbHVlICYmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIGtleSBpbiBwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gY29udGV4dC5qb2luKHJlZi5zdHIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFJvb3QvY29tcHV0ZWQvbWFwcGVkIHByb3BlcnR5P1xuICBcdGlmIChpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2VcbiAgXHQvLyBjYW4gdHJ5IGdvaW5nIHVwIHRoZSBzY29wZSBjaGFpblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCkge1xuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdGZyYWdtZW50ID0gcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdFx0aWYgKHBhcmVudEtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUucGFyZW50LCBrZXksIGZyYWdtZW50LCB0cnVlKSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnRlci1jb21wb25lbnQgYmluZGluZ1xuICBcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdFx0a2V5cGF0aDogcGFyZW50S2V5cGF0aFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3JcbiAgXHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG4gIFx0aWYgKCFpc1BhcmVudExvb2t1cCAmJiAhaGFzQ29udGV4dENoYWluKSB7XG4gIFx0XHQvLyB0aGUgZGF0YSBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSxcbiAgXHRcdC8vIHRvIHByZXZlbnQgZnV0dXJlIGZhaWxlZCBsb29rdXBzXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQocmVmLCB1bmRlZmluZWQpO1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5KSB7XG4gIFx0dmFyIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAoIXJhY3RpdmUucGFyZW50IHx8IHJhY3RpdmUuaXNvbGF0ZWQgfHwgaXNSb290UHJvcGVydHkocmFjdGl2ZS52aWV3bW9kZWwsIGtleSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRrZXkgPSBnZXRLZXlwYXRoKGtleSk7XG5cbiAgXHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgcmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXAoa2V5LCB7XG4gIFx0XHRcdG9yaWdpbjogcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLFxuICBcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3RQcm9wZXJ0eSh2aWV3bW9kZWwsIGtleSkge1xuICBcdC8vIHNwZWNpYWwgY2FzZSBmb3IgcmVmZXJlbmNlIHRvIHJvb3RcbiAgXHRyZXR1cm4ga2V5ID09PSBcIlwiIHx8IGtleSBpbiB2aWV3bW9kZWwuZGF0YSB8fCBrZXkgaW4gdmlld21vZGVsLmNvbXB1dGF0aW9ucyB8fCBrZXkgaW4gdmlld21vZGVsLm1hcHBpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oeCkge1xuICAgIHgudGVhcmRvd24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VuYmluZCh4KSB7XG4gICAgeC51bmJpbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxlcnNfX3VucmVuZGVyKHgpIHtcbiAgICB4LnVucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoeCkge1xuICAgIHguY2FuY2VsKCk7XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHBhcmVudCkge1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBcdHRoaXMuaW50cm9zID0gW107XG4gIFx0dGhpcy5vdXRyb3MgPSBbXTtcblxuICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgXHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXG4gIFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuICBcdHRoaXMuZGVjb3JhdG9yUXVldWUgPSBbXTtcbiAgXHR0aGlzLm91dHJvc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgXHRhZGRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuICBcdH0sXG5cbiAgXHRkZWNyZW1lbnRPdXRyb3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudFRvdGFsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG4gIFx0XHRsaXN0LnB1c2godHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdGFkZERlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5wdXNoKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdHJlbW92ZTogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdHJlbW92ZUZyb21BcnJheShsaXN0LCB0cmFuc2l0aW9uKTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRkZXRhY2hOb2RlczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kZWNvcmF0b3JRdWV1ZS5mb3JFYWNoKHRlYXJkb3duKTtcbiAgXHRcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaChkZXRhY2gpO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGRldGFjaE5vZGVzKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZGV0YWNoKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZXModG0pIHtcbiAgXHR0bS5kZXRhY2hOb2RlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2sodG0pIHtcbiAgXHRpZiAoIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbikgcmV0dXJuO1xuXG4gIFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuICBcdC8vIHdlIG5vdGlmeSB0aGUgcGFyZW50IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlXG4gIFx0Ly8gc3RhcnQgZGV0YWNoaW5nIG5vZGVzXG4gIFx0aWYgKCF0bS5vdXRyb3NDb21wbGV0ZSkge1xuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKHRtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRtLm91dHJvc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuICBcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIFx0aWYgKCF0bS5pbnRyb3MubGVuZ3RoICYmICF0bS50b3RhbENoaWxkcmVuKSB7XG4gIFx0XHRpZiAodHlwZW9mIHRtLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0dG0uY2FsbGJhY2soKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRtLnBhcmVudCkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50VG90YWwoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyID0gVHJhbnNpdGlvbk1hbmFnZXI7XG5cbiAgdmFyIGJhdGNoLFxuICAgICAgcnVubG9vcCxcbiAgICAgIHVucmVzb2x2ZWQgPSBbXSxcbiAgICAgIGNoYW5nZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNoYW5nZVwiKTtcblxuICBydW5sb29wID0ge1xuICBcdHN0YXJ0OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHJldHVyblByb21pc2UpIHtcbiAgXHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRpZiAocmV0dXJuUHJvbWlzZSkge1xuICBcdFx0XHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRiYXRjaCA9IHtcbiAgXHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG4gIFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgZ2xvYmFsX1RyYW5zaXRpb25NYW5hZ2VyKGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyKSxcbiAgXHRcdFx0dmlld3M6IFtdLFxuICBcdFx0XHR0YXNrczogW10sXG4gIFx0XHRcdHJhY3RpdmVzOiBbXSxcbiAgXHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdFx0YmF0Y2gucmFjdGl2ZXMucHVzaChpbnN0YW5jZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZsdXNoQ2hhbmdlcygpO1xuXG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5pbml0KCk7XG4gIFx0XHRpZiAoIWJhdGNoLnByZXZpb3VzQmF0Y2ggJiYgISFiYXRjaC5pbnN0YW5jZSkgYmF0Y2guaW5zdGFuY2Uudmlld21vZGVsLmNoYW5nZXMgPSBbXTtcbiAgXHRcdGJhdGNoID0gYmF0Y2gucHJldmlvdXNCYXRjaDtcbiAgXHR9LFxuXG4gIFx0YWRkUmFjdGl2ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChiYXRjaCkge1xuICBcdFx0XHRhZGRUb0FycmF5KGJhdGNoLnJhY3RpdmVzLCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKHRyYW5zaXRpb24pO1xuICBcdH0sXG5cbiAgXHRyZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkRGVjb3JhdG9yKGRlY29yYXRvcik7XG4gIFx0fSxcblxuICBcdGFkZFZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XG4gIFx0XHRiYXRjaC52aWV3cy5wdXNoKHZpZXcpO1xuICBcdH0sXG5cbiAgXHRhZGRVbnJlc29sdmVkOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdHVucmVzb2x2ZWQucHVzaCh0aGluZyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHVucmVzb2x2ZWQsIHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0Ly8gc3luY2hyb25pc2Ugbm9kZSBkZXRhY2htZW50cyB3aXRoIHRyYW5zaXRpb24gZW5kc1xuICBcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0c2NoZWR1bGVUYXNrOiBmdW5jdGlvbiAodGFzaywgcG9zdFJlbmRlcikge1xuICBcdFx0dmFyIF9iYXRjaDtcblxuICBcdFx0aWYgKCFiYXRjaCkge1xuICBcdFx0XHR0YXNrKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcbiAgXHRcdFx0d2hpbGUgKHBvc3RSZW5kZXIgJiYgX2JhdGNoLnByZXZpb3VzQmF0Y2gpIHtcbiAgXHRcdFx0XHQvLyB0aGlzIGNhbid0IGhhcHBlbiB1bnRpbCB0aGUgRE9NIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWRcbiAgXHRcdFx0XHQvLyBvdGhlcndpc2UgaW4gc29tZSBzaXR1YXRpb25zICh3aXRoIGNvbXBvbmVudHMgaW5zaWRlIGVsZW1lbnRzKVxuICBcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGFuZCBkZWNvcmF0b3JzIHdpbGwgaW5pdGlhbGlzZSBwcmVtYXR1cmVseVxuICBcdFx0XHRcdF9iYXRjaCA9IF9iYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0X2JhdGNoLnRhc2tzLnB1c2godGFzayk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBnbG9iYWxfcnVubG9vcCA9IHJ1bmxvb3A7XG5cbiAgZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuICBcdHZhciBpLCB0aGluZywgY2hhbmdlSGFzaDtcblxuICBcdHdoaWxlIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHtcbiAgXHRcdHRoaW5nID0gYmF0Y2gucmFjdGl2ZXMucG9wKCk7XG4gIFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcudmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXG4gIFx0XHRpZiAoY2hhbmdlSGFzaCkge1xuICBcdFx0XHRjaGFuZ2VIb29rLmZpcmUodGhpbmcsIGNoYW5nZUhhc2gpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXG4gIFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG4gIFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC52aWV3c1tpXS51cGRhdGUoKTtcbiAgXHR9XG4gIFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0YmF0Y2gudGFza3NbaV0oKTtcbiAgXHR9XG4gIFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblxuICBcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuICBcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuICBcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuICBcdGlmIChiYXRjaC5yYWN0aXZlcy5sZW5ndGgpIHJldHVybiBmbHVzaENoYW5nZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcbiAgXHR2YXIgaSwgaXRlbSwga2V5cGF0aCwgcmVzb2x2ZWQ7XG5cbiAgXHRpID0gdW5yZXNvbHZlZC5sZW5ndGg7XG5cbiAgXHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSB1bnJlc29sdmVkW2ldO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoKSB7XG4gIFx0XHRcdC8vIGl0IHJlc29sdmVkIHNvbWUgb3RoZXIgd2F5LiBUT0RPIGhvdz8gdHdvLXdheSBiaW5kaW5nPyBTZWVtc1xuICBcdFx0XHQvLyB3ZWlyZCB0aGF0IHdlJ2Qgc3RpbGwgZW5kIHVwIGhlcmVcbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdGNvbnRpbnVlOyAvLyBhdm9pZCByZW1vdmluZyB0aGUgd3JvbmcgdGhpbmcgc2hvdWxkIHRoZSBuZXh0IGNvbmRpdGlvbiBiZSB0cnVlXG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYoaXRlbS5yb290LCBpdGVtLnJlZiwgaXRlbS5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0KHJlc29sdmVkIHx8IChyZXNvbHZlZCA9IFtdKSkucHVzaCh7XG4gIFx0XHRcdFx0aXRlbTogaXRlbSxcbiAgXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChyZXNvbHZlZCkge1xuICBcdFx0cmVzb2x2ZWQuZm9yRWFjaChnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsX3J1bmxvb3BfX3Jlc29sdmUocmVzb2x2ZWQpIHtcbiAgXHRyZXNvbHZlZC5pdGVtLnJlc29sdmUocmVzb2x2ZWQua2V5cGF0aCk7XG4gIH1cblxuICB2YXIgcXVldWUgPSBbXTtcblxuICB2YXIgYW5pbWF0aW9ucyA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaSwgYW5pbWF0aW9uLCBub3c7XG5cbiAgXHRcdG5vdyA9IHV0aWxzX2dldFRpbWUoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmICghYW5pbWF0aW9uLnRpY2sobm93KSkge1xuICBcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcbiAgXHRcdFx0XHRxdWV1ZS5zcGxpY2UoaS0tLCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCkge1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhZGQ6IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgXHRcdHF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcblxuICBcdFx0aWYgKCFhbmltYXRpb25zLnJ1bm5pbmcpIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRcdFx0ckFGKGFuaW1hdGlvbnMudGljayk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuICBcdGFib3J0OiBmdW5jdGlvbiAoa2V5cGF0aCwgcm9vdCkge1xuICBcdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGgsXG4gIFx0XHQgICAgYW5pbWF0aW9uO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlW2ldO1xuXG4gIFx0XHRcdGlmIChhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblxuICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIga2V5O1xuXG4gIFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIFx0Ly8gZnJvbSBhbmQgdG9cbiAgXHRmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLmludGVycG9sYXRvciA9IHNoYXJlZF9pbnRlcnBvbGF0ZSh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IpO1xuICBcdHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgXHR0aGlzLnRpY2soKTtcbiAgfTtcblxuICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgXHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG4gIFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgXHRcdFx0aWYgKGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbikge1xuICBcdFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdGhpcy50byk7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnN0ZXAoMSwgdGhpcy50byk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5jb21wbGV0ZSh0aGlzLnRvKTtcblxuICBcdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvcih0KTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAodCwgdmFsdWUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7IC8vIGtlZXAgaW4gdGhlIHN0YWNrXG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrXG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpbmRleDtcblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgXHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgXHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuaW1hdGlvbiB3YXMgbm90IGZvdW5kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGFuaW1hdGVfQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuXG4gIHZhciBwcm90b3R5cGVfYW5pbWF0ZSA9IFJhY3RpdmUkYW5pbWF0ZTtcblxuICB2YXIgbm9BbmltYXRpb24gPSB7IHN0b3A6IG5vb3AgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlKGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXG4gIFx0cHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuICBcdH0pO1xuXG4gIFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0b3B0aW9ucyA9IHRvIHx8IHt9O1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHRcdGFuaW1hdGlvbnMgPSBbXTtcblxuICBcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZSBgc3RlcGAgYW5kIGBjb21wbGV0ZWAgaGFuZGxlcnMsIGFzIHRoZXkgd2lsbFxuICBcdFx0Ly8gcnVuIGZvciBlYWNoIGFuaW1hdGlvbiEgU28gaW5zdGVhZCB3ZSdsbCBzdG9yZSB0aGUgaGFuZGxlcnMgYW5kIGNyZWF0ZVxuICBcdFx0Ly8gb3VyIG93bi4uLlxuICBcdFx0c3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgXHRcdGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblxuICBcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0Y3VycmVudFZhbHVlcyA9IHt9O1xuXG4gIFx0XHRcdG9wdGlvbnMuc3RlcCA9IG51bGw7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuXG4gIFx0XHRcdG1ha2VWYWx1ZUNvbGxlY3RvciA9IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0LCB2YWx1ZSkge1xuICBcdFx0XHRcdFx0Y3VycmVudFZhbHVlc1trZXlwYXRoXSA9IHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoayBpbiBrZXlwYXRoKSB7XG4gIFx0XHRcdGlmIChrZXlwYXRoLmhhc093blByb3BlcnR5KGspKSB7XG4gIFx0XHRcdFx0aWYgKHN0ZXAgfHwgY29tcGxldGUpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3RWYWx1ZSA9IG1ha2VWYWx1ZUNvbGxlY3RvcihrKTtcbiAgXHRcdFx0XHRcdG9wdGlvbnMgPSB7IGVhc2luZzogZWFzaW5nLCBkdXJhdGlvbjogZHVyYXRpb24gfTtcblxuICBcdFx0XHRcdFx0aWYgKHN0ZXApIHtcbiAgXHRcdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gY29sbGVjdFZhbHVlO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG4gIFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGUodGhpcywgaywga2V5cGF0aFtrXSwgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiwgdG8gZmFjaWxpdGF0ZSBzdGVwL2NvbXBsZXRlXG4gIFx0XHQvLyBjYWxsYmFja3MsIGFuZCBQcm9taXNlIGZ1bGZpbG1lbnRcbiAgXHRcdGR1bW15T3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHN0ZXAodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjb21wbGV0ZSkge1xuICBcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gY29tcGxldGUodCwgY3VycmVudFZhbHVlcyk7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRkdW1teU9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRkdW1teSA9IGFuaW1hdGUodGhpcywgbnVsbCwgbnVsbCwgZHVtbXlPcHRpb25zKTtcbiAgXHRcdGFuaW1hdGlvbnMucHVzaChkdW1teSk7XG5cbiAgXHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGFuaW1hdGlvbjtcblxuICBcdFx0XHR3aGlsZSAoYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSkge1xuICBcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoZHVtbXkpIHtcbiAgXHRcdFx0XHRkdW1teS5zdG9wKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH1cblxuICBcdC8vIGFuaW1hdGUgYSBzaW5nbGUga2V5cGF0aFxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdHByb21pc2UudGhlbihvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcbiAgXHRhbmltYXRpb24gPSBhbmltYXRlKHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zKTtcblxuICBcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBhbmltYXRpb24uc3RvcCgpO1xuICBcdH07XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKHJvb3QsIGtleXBhdGgsIHRvLCBvcHRpb25zKSB7XG4gIFx0dmFyIGVhc2luZywgZHVyYXRpb24sIGFuaW1hdGlvbiwgZnJvbTtcblxuICBcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoICE9PSBudWxsKSB7XG4gIFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG4gIFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWJvcnQoa2V5cGF0aCwgcm9vdCk7XG5cbiAgXHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcbiAgXHRpZiAoaXNFcXVhbChmcm9tLCB0bykpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gIFx0XHRcdG9wdGlvbnMuY29tcGxldGUob3B0aW9ucy50byk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub0FuaW1hdGlvbjtcbiAgXHR9XG5cbiAgXHQvLyBlYXNpbmcgZnVuY3Rpb25cbiAgXHRpZiAob3B0aW9ucy5lYXNpbmcpIHtcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nW29wdGlvbnMuZWFzaW5nXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBlYXNpbmcgIT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRlYXNpbmcgPSBudWxsO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGR1cmF0aW9uXG4gIFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXG4gIFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuICBcdGFuaW1hdGlvbiA9IG5ldyBhbmltYXRlX0FuaW1hdGlvbih7XG4gIFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuICBcdFx0ZnJvbTogZnJvbSxcbiAgXHRcdHRvOiB0byxcbiAgXHRcdHJvb3Q6IHJvb3QsXG4gIFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG4gIFx0XHRlYXNpbmc6IGVhc2luZyxcbiAgXHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cbiAgXHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuICBcdFx0c3RlcDogb3B0aW9ucy5zdGVwLFxuICBcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcbiAgXHR9KTtcblxuICBcdHNoYXJlZF9hbmltYXRpb25zLmFkZChhbmltYXRpb24pO1xuICBcdHJvb3QuX2FuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG4gIFx0cmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZGV0YWNoID0gUmFjdGl2ZSRkZXRhY2g7XG4gIHZhciBwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rID0gbmV3IGhvb2tzX0hvb2soXCJkZXRhY2hcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuICBcdGlmICh0aGlzLmRldGFjaGVkKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5lbCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcbiAgXHR9XG4gIFx0dGhpcy5kZXRhY2hlZCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0cHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vay5maXJlKHRoaXMpO1xuICBcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kID0gUmFjdGl2ZSRmaW5kO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgdGVzdCA9IFF1ZXJ5JHRlc3Q7XG4gIGZ1bmN0aW9uIFF1ZXJ5JHRlc3QoaXRlbSwgbm9EaXJ0eSkge1xuICBcdHZhciBpdGVtTWF0Y2hlcztcblxuICBcdGlmICh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9ICF0aGlzLnNlbGVjdG9yIHx8IGl0ZW0ubmFtZSA9PT0gdGhpcy5zZWxlY3RvcjtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aXRlbU1hdGNoZXMgPSBpdGVtLm5vZGUgPyBtYXRjaGVzKGl0ZW0ubm9kZSwgdGhpcy5zZWxlY3RvcikgOiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpdGVtTWF0Y2hlcykge1xuICBcdFx0dGhpcy5wdXNoKGl0ZW0ubm9kZSB8fCBpdGVtLmluc3RhbmNlKTtcblxuICBcdFx0aWYgKCFub0RpcnR5KSB7XG4gIFx0XHRcdHRoaXMuX21ha2VEaXJ0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgbWFrZVF1ZXJ5X2NhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblxuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fcm9vdFt0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gXCJsaXZlQ29tcG9uZW50UXVlcmllc1wiIDogXCJsaXZlUXVlcmllc1wiXTtcbiAgXHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cbiAgXHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2Yoc2VsZWN0b3IpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdGxpdmVRdWVyaWVzW3NlbGVjdG9yXSA9IG51bGw7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzb3J0QnlJdGVtUG9zaXRpb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICBcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXG4gIFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoYS5jb21wb25lbnQgfHwgYS5fcmFjdGl2ZS5wcm94eSk7XG4gIFx0YW5jZXN0cnlCID0gZ2V0QW5jZXN0cnkoYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSk7XG5cbiAgXHRvbGRlc3RBID0gbGFzdEl0ZW0oYW5jZXN0cnlBKTtcbiAgXHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcblxuICBcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG4gIFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG4gIFx0d2hpbGUgKG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0Qikge1xuICBcdFx0YW5jZXN0cnlBLnBvcCgpO1xuICBcdFx0YW5jZXN0cnlCLnBvcCgpO1xuXG4gIFx0XHRtdXR1YWxBbmNlc3RvciA9IG9sZGVzdEE7XG5cbiAgXHRcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdFx0b2xkZXN0QiA9IGxhc3RJdGVtKGFuY2VzdHJ5Qik7XG4gIFx0fVxuXG4gIFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuICBcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuICBcdG9sZGVzdEIgPSBvbGRlc3RCLmNvbXBvbmVudCB8fCBvbGRlc3RCO1xuXG4gIFx0ZnJhZ21lbnRBID0gb2xkZXN0QS5wYXJlbnRGcmFnbWVudDtcbiAgXHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG4gIFx0aWYgKGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZihvbGRlc3RBKTtcbiAgXHRcdGluZGV4QiA9IGZyYWdtZW50Qi5pdGVtcy5pbmRleE9mKG9sZGVzdEIpO1xuXG4gIFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuICBcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG4gIFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3RcbiAgXHRpZiAoZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzKSB7XG4gIFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnRCKTtcblxuICBcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGNvbmRpdGlvbiB3YXMgbWV0IHdoaWxlIGNvbXBhcmluZyB0aGUgcG9zaXRpb24gb2YgdHdvIGNvbXBvbmVudHMuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFBhcmVudChpdGVtKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0aWYgKHBhcmVudEZyYWdtZW50ID0gaXRlbS5wYXJlbnRGcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cblxuICBcdGlmIChpdGVtLmNvbXBvbmVudCAmJiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmNlc3RyeShpdGVtKSB7XG4gIFx0dmFyIGFuY2VzdHJ5LCBhbmNlc3RvcjtcblxuICBcdGFuY2VzdHJ5ID0gW2l0ZW1dO1xuXG4gIFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoaXRlbSk7XG5cbiAgXHR3aGlsZSAoYW5jZXN0b3IpIHtcbiAgXHRcdGFuY2VzdHJ5LnB1c2goYW5jZXN0b3IpO1xuICBcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoYW5jZXN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBhbmNlc3RyeTtcbiAgfVxuXG4gIHZhciBzb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG90aGVyTm9kZSkge1xuICBcdHZhciBiaXRtYXNrO1xuXG4gIFx0aWYgKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgXHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSk7XG4gIFx0XHRyZXR1cm4gYml0bWFzayAmIDIgPyAxIDogLTE7XG4gIFx0fVxuXG4gIFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuICBcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG4gIFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbihub2RlLCBvdGhlck5vZGUpO1xuICB9O1xuXG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMuc29ydCh0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gc29ydEJ5SXRlbVBvc2l0aW9uIDogc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gIFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgbWFrZVF1ZXJ5X2RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuX2RpcnR5KSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG4gIFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0X3RoaXMuX3NvcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKG5vZGVPckNvbXBvbmVudCkge1xuICBcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZih0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gbm9kZU9yQ29tcG9uZW50Lmluc3RhbmNlIDogbm9kZU9yQ29tcG9uZW50KTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9tYWtlUXVlcnkgPSBtYWtlUXVlcnk7XG4gIGZ1bmN0aW9uIG1ha2VRdWVyeShyYWN0aXZlLCBzZWxlY3RvciwgbGl2ZSwgaXNDb21wb25lbnRRdWVyeSkge1xuICBcdHZhciBxdWVyeSA9IFtdO1xuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhxdWVyeSwge1xuICBcdFx0c2VsZWN0b3I6IHsgdmFsdWU6IHNlbGVjdG9yIH0sXG4gIFx0XHRsaXZlOiB7IHZhbHVlOiBsaXZlIH0sXG5cbiAgXHRcdF9pc0NvbXBvbmVudFF1ZXJ5OiB7IHZhbHVlOiBpc0NvbXBvbmVudFF1ZXJ5IH0sXG4gIFx0XHRfdGVzdDogeyB2YWx1ZTogdGVzdCB9XG4gIFx0fSk7XG5cbiAgXHRpZiAoIWxpdmUpIHtcbiAgXHRcdHJldHVybiBxdWVyeTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRjYW5jZWw6IHsgdmFsdWU6IG1ha2VRdWVyeV9jYW5jZWwgfSxcblxuICBcdFx0X3Jvb3Q6IHsgdmFsdWU6IHJhY3RpdmUgfSxcbiAgXHRcdF9zb3J0OiB7IHZhbHVlOiBzb3J0IH0sXG4gIFx0XHRfbWFrZURpcnR5OiB7IHZhbHVlOiBtYWtlUXVlcnlfZGlydHkgfSxcbiAgXHRcdF9yZW1vdmU6IHsgdmFsdWU6IHJlbW92ZSB9LFxuXG4gIFx0XHRfZGlydHk6IHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRBbGwgPSBSYWN0aXZlJGZpbmRBbGw7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbChzZWxlY3Rvciwgb3B0aW9ucykge1xuICBcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cbiAgXHRpZiAoIXRoaXMuZWwpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0aWYgKHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbc2VsZWN0b3JdKSB7XG5cbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gX21ha2VRdWVyeSh0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnB1c2goc2VsZWN0b3IpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl0gPSBxdWVyeTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gUmFjdGl2ZSRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIGZpbmRDb250YWluZXIgPSBSYWN0aXZlJGZpbmRDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29udGFpbmVyKHNlbGVjdG9yKSB7XG4gIFx0aWYgKHRoaXMuY29udGFpbmVyKSB7XG4gIFx0XHRpZiAodGhpcy5jb250YWluZXIuY29tcG9uZW50ICYmIHRoaXMuY29udGFpbmVyLmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuZmluZENvbnRhaW5lcihzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZFBhcmVudCA9IFJhY3RpdmUkZmluZFBhcmVudDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRQYXJlbnQoc2VsZWN0b3IpIHtcblxuICBcdGlmICh0aGlzLnBhcmVudCkge1xuICBcdFx0aWYgKHRoaXMucGFyZW50LmNvbXBvbmVudCAmJiB0aGlzLnBhcmVudC5jb21wb25lbnQubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LmZpbmRQYXJlbnQoc2VsZWN0b3IpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50U3RhY2sgPSB7XG4gIFx0ZW5xdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUsIGV2ZW50KSB7XG4gIFx0XHRpZiAocmFjdGl2ZS5ldmVudCkge1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZSB8fCBbXTtcbiAgXHRcdFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZS5wdXNoKHJhY3RpdmUuZXZlbnQpO1xuICBcdFx0fVxuICBcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuICBcdH0sXG4gIFx0ZGVxdWV1ZTogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChyYWN0aXZlLl9ldmVudFF1ZXVlICYmIHJhY3RpdmUuX2V2ZW50UXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJhY3RpdmUuZXZlbnQgPSByYWN0aXZlLl9ldmVudFF1ZXVlLnBvcCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHJhY3RpdmUuZXZlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfZXZlbnRTdGFjayA9IGV2ZW50U3RhY2s7XG5cbiAgdmFyIHNoYXJlZF9maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KHJhY3RpdmUsIGV2ZW50TmFtZSkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdGlmICghZXZlbnROYW1lKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLmV2ZW50KSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50ID0ge1xuICBcdFx0XHRuYW1lOiBldmVudE5hbWUsXG4gIFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG4gIFx0XHRcdF9ub0FyZzogdHJ1ZVxuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuICBcdH1cblxuICBcdHZhciBldmVudE5hbWVzID0gZ2V0S2V5cGF0aChldmVudE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuICBcdGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRBcyhyYWN0aXZlLCBldmVudE5hbWVzLCBldmVudCwgYXJncykge1xuICBcdHZhciBpbml0aWFsRmlyZSA9IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNF07XG5cbiAgXHR2YXIgc3Vic2NyaWJlcnMsXG4gIFx0ICAgIGksXG4gIFx0ICAgIGJ1YmJsZSA9IHRydWU7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGZvciAoaSA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICBcdFx0c3Vic2NyaWJlcnMgPSByYWN0aXZlLl9zdWJzW2V2ZW50TmFtZXNbaV1dO1xuXG4gIFx0XHRpZiAoc3Vic2NyaWJlcnMpIHtcbiAgXHRcdFx0YnViYmxlID0gbm90aWZ5U3Vic2NyaWJlcnMocmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzKSAmJiBidWJibGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZGVxdWV1ZShyYWN0aXZlKTtcblxuICBcdGlmIChyYWN0aXZlLnBhcmVudCAmJiBidWJibGUpIHtcblxuICBcdFx0aWYgKGluaXRpYWxGaXJlICYmIHJhY3RpdmUuY29tcG9uZW50KSB7XG4gIFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyBcIi5cIiArIGV2ZW50TmFtZXNbZXZlbnROYW1lcy5sZW5ndGggLSAxXTtcbiAgXHRcdFx0ZXZlbnROYW1lcyA9IGdldEtleXBhdGgoZnVsbE5hbWUpLndpbGRjYXJkTWF0Y2hlcygpO1xuXG4gIFx0XHRcdGlmIChldmVudCkge1xuICBcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZmlyZUV2ZW50QXMocmFjdGl2ZS5wYXJlbnQsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpIHtcbiAgXHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsXG4gIFx0ICAgIHN0b3BFdmVudCA9IGZhbHNlO1xuXG4gIFx0aWYgKGV2ZW50ICYmICFldmVudC5fbm9BcmcpIHtcbiAgXHRcdGFyZ3MgPSBbZXZlbnRdLmNvbmNhdChhcmdzKTtcbiAgXHR9XG5cbiAgXHQvLyBzdWJzY3JpYmVycyBjYW4gYmUgbW9kaWZpZWQgaW5mbGlnaHQsIGUuZy4gXCJvbmNlXCIgZnVuY3Rpb25hbGl0eVxuICBcdC8vIHNvIHdlIG5lZWQgdG8gY29weSB0byBtYWtlIHN1cmUgZXZlcnlvbmUgZ2V0cyBjYWxsZWRcbiAgXHRzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG5cbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChzdWJzY3JpYmVyc1tpXS5hcHBseShyYWN0aXZlLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyAmJiBzdG9wRXZlbnQgJiYgKG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbCkpIHtcbiAgXHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcdFx0b3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gJiYgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyZSA9IFJhY3RpdmUkZmlyZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaXJlKGV2ZW50TmFtZSkge1xuXG4gIFx0dmFyIG9wdGlvbnMgPSB7XG4gIFx0XHRhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIFx0fTtcblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcywgZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0ID0gUmFjdGl2ZSRnZXQ7XG4gIHZhciBvcHRpb25zID0ge1xuICBcdGNhcHR1cmU6IHRydWUsIC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcbiAgXHRub1Vud3JhcDogdHJ1ZSwgLy8gd3JhcHBlZCB2YWx1ZXMgc2hvdWxkIE5PVCBiZSB1bndyYXBwZWRcbiAgXHRmdWxsUm9vdEdldDogdHJ1ZSAvLyByb290IGdldCBzaG91bGQgcmV0dXJuIG1hcHBpbmdzXG4gIH07XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gQ3JlYXRlIGludGVyLWNvbXBvbmVudCBiaW5kaW5nLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmVudCAmJiAhdGhpcy5pc29sYXRlZCkge1xuICBcdFx0aWYgKHNoYXJlZF9yZXNvbHZlUmVmKHRoaXMsIGtleXBhdGguc3RyLCB0aGlzLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0Ly8gY3JlYXRlcyBiaW5kaW5nIGFzIHNpZGUtZWZmZWN0LCBpZiBhcHByb3ByaWF0ZVxuICBcdFx0XHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgaW5zZXJ0ID0gUmFjdGl2ZSRpbnNlcnQ7XG5cbiAgdmFyIGluc2VydEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImluc2VydFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQodGFyZ2V0LCBhbmNob3IpIHtcbiAgXHRpZiAoIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdC8vIFRPRE8gY3JlYXRlLCBhbmQgbGluayB0bywgZG9jdW1lbnRhdGlvbiBleHBsYWluaW5nIHRoaXNcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBBUEkgaGFzIGNoYW5nZWQgLSB5b3UgbXVzdCBjYWxsIGByYWN0aXZlLnJlbmRlcih0YXJnZXRbLCBhbmNob3JdKWAgdG8gcmVuZGVyIHlvdXIgUmFjdGl2ZSBpbnN0YW5jZS4gT25jZSByZW5kZXJlZCB5b3UgY2FuIHVzZSBgcmFjdGl2ZS5pbnNlcnQoKWAuXCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KGFuY2hvcikgfHwgbnVsbDtcblxuICBcdGlmICghdGFyZ2V0KSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzcGVjaWZ5IGEgdmFsaWQgdGFyZ2V0IHRvIGluc2VydCBpbnRvXCIpO1xuICBcdH1cblxuICBcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kZXRhY2goKSwgYW5jaG9yKTtcbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuXG4gIFx0KHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gfHwgKHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSkpLnB1c2godGhpcyk7XG4gIFx0dGhpcy5kZXRhY2hlZCA9IG51bGw7XG5cbiAgXHRmaXJlSW5zZXJ0SG9vayh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVJbnNlcnRIb29rKHJhY3RpdmUpIHtcbiAgXHRpbnNlcnRIb29rLmZpcmUocmFjdGl2ZSk7XG5cbiAgXHRyYWN0aXZlLmZpbmRBbGxDb21wb25lbnRzKFwiKlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICBcdFx0ZmlyZUluc2VydEhvb2soY2hpbGQuaW5zdGFuY2UpO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9tZXJnZSA9IFJhY3RpdmUkbWVyZ2U7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2Uoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHQvLyBJZiBlaXRoZXIgdGhlIGV4aXN0aW5nIHZhbHVlIG9yIHRoZSBuZXcgdmFsdWUgaXNuJ3QgYW5cbiAgXHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG4gIFx0aWYgKCFpc0FycmF5KGN1cnJlbnRBcnJheSkgfHwgIWlzQXJyYXkoYXJyYXkpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdHRoaXMudmlld21vZGVsLm1lcmdlKGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXG4gIFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuICB9O1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LmdldCh0aGlzLmtleXBhdGguc3RyKTtcblxuICBcdFx0aWYgKGltbWVkaWF0ZSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0XHRpZiAodGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuY29udGV4dCwgdGhpcy52YWx1ZSwgdGhpcy5vbGRWYWx1ZSwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgb2JzZXJ2ZV9PYnNlcnZlciA9IE9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldFBhdHRlcm4gPSBnZXRQYXR0ZXJuO1xuICBmdW5jdGlvbiBnZXRQYXR0ZXJuKHJhY3RpdmUsIHBhdHRlcm4pIHtcbiAgXHR2YXIgbWF0Y2hpbmdLZXlwYXRocywgdmFsdWVzO1xuXG4gIFx0bWF0Y2hpbmdLZXlwYXRocyA9IGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwgcGF0dGVybik7XG5cbiAgXHR2YWx1ZXMgPSB7fTtcbiAgXHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhbHVlc1trZXlwYXRoLnN0cl0gPSByYWN0aXZlLmdldChrZXlwYXRoLnN0cik7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIFBhdHRlcm5PYnNlcnZlcixcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsga2V5cGF0aC5zdHIucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIikucmVwbGFjZSgvXFwqL2csIFwiKFteXFxcXC5dKylcIikgKyBcIiRcIik7XG4gIFx0dGhpcy52YWx1ZXMgPSB7fTtcblxuICBcdGlmICh0aGlzLmRlZmVyKSB7XG4gIFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcbiAgXHR9XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgUGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXG4gIFx0XHR2YWx1ZXMgPSBvYnNlcnZlX2dldFBhdHRlcm4odGhpcy5yb290LCB0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHRmb3IgKGtleXBhdGggaW4gdmFsdWVzKSB7XG4gIFx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoZ2V0S2V5cGF0aChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlcztcblxuICBcdFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIGtleXBhdGgpO1xuXG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcbiAgXHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXIgd2l0aCBgYXJyYXkubGVuZ3RoYFxuICBcdFx0aWYgKHRoaXMucm9vdC52aWV3bW9kZWwuaW1wbGljaXRDaGFuZ2VzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuZ2V0UHJveHkoa2V5cGF0aCkudXBkYXRlKCk7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIga2V5cGF0aFN0ciwgdmFsdWUsIGtleXMsIGFyZ3M7XG5cbiAgXHRcdGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgXHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0pIHx8ICF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdGtleXMgPSBzbGljZS5jYWxsKHRoaXMucmVnZXguZXhlYyhrZXlwYXRoU3RyKSwgMSk7XG4gIFx0XHRcdGFyZ3MgPSBbdmFsdWUsIHRoaXMudmFsdWVzW2tleXBhdGhTdHJdLCBrZXlwYXRoU3RyXS5jb25jYXQoa2V5cyk7XG5cbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3MpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdGdldFByb3h5OiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCF0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHRoaXMucHJveGllc1trZXlwYXRoLnN0cl0gPSB7XG4gIFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMucmVhbGx5VXBkYXRlKGtleXBhdGgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMucHJveGllc1trZXlwYXRoLnN0cl07XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IFBhdHRlcm5PYnNlcnZlcjtcblxuICB2YXIgb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSA9IGdldE9ic2VydmVyRmFjYWRlO1xuICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR2YXIgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyLCBjYW5jZWxsZWQ7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXG4gIFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcbiAgXHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfUGF0dGVybk9ic2VydmVyKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gIFx0XHRpc1BhdHRlcm5PYnNlcnZlciA9IHRydWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9ic2VydmVyID0gbmV3IG9ic2VydmVfT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdG9ic2VydmVyLmluaXQob3B0aW9ucy5pbml0KTtcbiAgXHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIgPyBcInBhdHRlcm5PYnNlcnZlcnNcIiA6IFwib2JzZXJ2ZXJzXCIpO1xuXG4gIFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuICBcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblxuICBcdHZhciBmYWNhZGUgPSB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHRcdGlmIChjYW5jZWxsZWQpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXNQYXR0ZXJuT2JzZXJ2ZXIpIHtcbiAgXHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG5cbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJwYXR0ZXJuT2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNhbmNlbGxlZCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJhY3RpdmUuX29ic2VydmVycy5wdXNoKGZhY2FkZSk7XG4gIFx0cmV0dXJuIGZhY2FkZTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlID0gUmFjdGl2ZSRvYnNlcnZlO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmUoa2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlcnMsIG1hcCwga2V5cGF0aHMsIGk7XG5cbiAgXHQvLyBBbGxvdyBhIG1hcCBvZiBrZXlwYXRocyB0byBoYW5kbGVyc1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0b2JzZXJ2ZXJzID0gW107XG5cbiAgXHRcdGZvciAoa2V5cGF0aCBpbiBtYXApIHtcbiAgXHRcdFx0aWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdGNhbGxiYWNrID0gbWFwW2tleXBhdGhdO1xuICBcdFx0XHRcdG9ic2VydmVycy5wdXNoKHRoaXMub2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG4gIFx0XHRrZXlwYXRoID0gXCJcIjtcblxuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdChcIiBcIik7XG5cbiAgXHQvLyBTaW5nbGUga2V5cGF0aFxuICBcdGlmIChrZXlwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBNdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQga2V5cGF0aHNcbiAgXHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzW2ldO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCkge1xuICBcdFx0XHRvYnNlcnZlcnMucHVzaChvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb2JzZXJ2ZU9uY2UgPSBSYWN0aXZlJG9ic2VydmVPbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZU9uY2UocHJvcGVydHksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmUocHJvcGVydHksIGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRvYnNlcnZlci5jYW5jZWwoKTtcbiAgXHR9LCB7IGluaXQ6IGZhbHNlLCBkZWZlcjogb3B0aW9ucyAmJiBvcHRpb25zLmRlZmVyIH0pO1xuXG4gIFx0cmV0dXJuIG9ic2VydmVyO1xuICB9XG5cbiAgdmFyIHNoYXJlZF90cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICB9O1xuXG4gIHZhciBub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyICE9PSBcIlwiO1xuICB9O1xuXG4gIHZhciBvZmYgPSBSYWN0aXZlJG9mZjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvZmYoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZXZlbnROYW1lcztcblxuICBcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdC8vIFRPRE8gdXNlIHRoaXMgY29kZSBpbnN0ZWFkLCBvbmNlIHRoZSBmb2xsb3dpbmcgaXNzdWUgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgXHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExODU2XG4gIFx0XHQvLyBkZWZpbmVQcm9wZXJ0eSggdGhpcywgJ19zdWJzJywgeyB2YWx1ZTogY3JlYXRlKCBudWxsICksIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgXHRcdGZvciAoZXZlbnROYW1lIGluIHRoaXMuX3N1YnMpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbZXZlbnROYW1lXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIiBcIikubWFwKHNoYXJlZF90cmltKS5maWx0ZXIobm90RW1wdHlTdHJpbmcpO1xuXG4gIFx0XHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXG4gIFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cbiAgXHRcdFx0aWYgKHN1YnNjcmliZXJzID0gX3RoaXMuX3N1YnNbZXZlbnROYW1lXSkge1xuICBcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuICBcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuICBcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgXHRcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRcdFx0XHRlbHNlIHtcbiAgXHRcdFx0XHRcdF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG9uID0gUmFjdGl2ZSRvbjtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cbiAgXHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG4gIFx0aWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGxpc3RlbmVycyA9IFtdO1xuXG4gIFx0XHRmb3IgKG4gaW4gZXZlbnROYW1lKSB7XG4gIFx0XHRcdGlmIChldmVudE5hbWUuaGFzT3duUHJvcGVydHkobikpIHtcbiAgXHRcdFx0XHRsaXN0ZW5lcnMucHVzaCh0aGlzLm9uKG4sIGV2ZW50TmFtZVtuXSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblxuICBcdFx0XHRcdHdoaWxlIChsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKSkge1xuICBcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcbiAgXHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBcdFx0KF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gfHwgKF90aGlzLl9zdWJzW2V2ZW50TmFtZV0gPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgb25jZSA9IFJhY3RpdmUkb25jZTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG5cbiAgXHR2YXIgbGlzdGVuZXIgPSB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0aGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBzbyB3ZSBjYW4gc3RpbGwgZG8gbGlzdGVuZXIuY2FuY2VsKCkgbWFudWFsbHlcbiAgXHRyZXR1cm4gbGlzdGVuZXI7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5LCB0aGUgbmFtZSBvZiBhIG11dGF0b3IgbWV0aG9kLCBhbmQgdGhlXG4gIC8vIGFyZ3VtZW50cyB0byBjYWxsIHRoYXQgbXV0YXRvciBtZXRob2Qgd2l0aCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdFxuICAvLyBtYXBzIHRoZSBvbGQgaW5kaWNlcyB0byB0aGVpciBuZXcgaW5kaWNlcy5cblxuICAvLyBTbyBpZiB5b3UgaGFkIHNvbWV0aGluZyBsaWtlIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcbiAgLy8gICAgIGFycmF5LnB1c2goICdlJyApO1xuICAvL1xuICAvLyAuLi55b3UnZCBnZXQgYFsgMCwgMSwgMiwgMyBdYCAtIGluIG90aGVyIHdvcmRzLCBub25lIG9mIHRoZSBvbGQgaW5kaWNlc1xuICAvLyBoYXZlIGNoYW5nZWQuIElmIHlvdSB0aGVuIGRpZCB0aGlzLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheS51bnNoaWZ0KCAneicgKTtcbiAgLy9cbiAgLy8gLi4udGhlIGluZGljZXMgd291bGQgYmUgYFsgMSwgMiwgMywgNCwgNSBdYCAtIGV2ZXJ5IGl0ZW0gaGFzIGJlZW4gbW92ZWRcbiAgLy8gb25lIGhpZ2hlciB0byBtYWtlIHJvb20gZm9yIHRoZSAneicuIElmIHlvdSByZW1vdmVkIGFuIGl0ZW0sIHRoZSBuZXcgaW5kZXhcbiAgLy8gd291bGQgYmUgLTEuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnNwbGljZSggMiwgMiApO1xuICAvL1xuICAvLyAuLi50aGlzIHdvdWxkIHJlc3VsdCBpbiBbIDAsIDEsIC0xLCAtMSwgMiwgMyBdLlxuICAvL1xuICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5hYmxlIGZhc3QsIG5vbi1kZXN0cnVjdGl2ZSBzaHVmZmxpbmcgb2YgbGlzdFxuICAvLyBzZWN0aW9ucyB3aGVuIHlvdSBkbyBlLmcuIGByYWN0aXZlLnNwbGljZSggJ2l0ZW1zJywgMiwgMiApO1xuXG4gIHZhciBzaGFyZWRfZ2V0TmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXM7XG5cbiAgZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHZhciBzcGxpY2VBcmd1bWVudHMsXG4gIFx0ICAgIGxlbixcbiAgXHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdCAgICByZW1vdmVTdGFydCxcbiAgXHQgICAgcmVtb3ZlRW5kLFxuICBcdCAgICBiYWxhbmNlLFxuICBcdCAgICBpO1xuXG4gIFx0c3BsaWNlQXJndW1lbnRzID0gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRpZiAoIXNwbGljZUFyZ3VtZW50cykge1xuICBcdFx0cmV0dXJuIG51bGw7IC8vIFRPRE8gc3VwcG9ydCByZXZlcnNlIGFuZCBzb3J0P1xuICBcdH1cblxuICBcdGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgXHRiYWxhbmNlID0gc3BsaWNlQXJndW1lbnRzLmxlbmd0aCAtIDIgLSBzcGxpY2VBcmd1bWVudHNbMV07XG5cbiAgXHRyZW1vdmVTdGFydCA9IE1hdGgubWluKGxlbiwgc3BsaWNlQXJndW1lbnRzWzBdKTtcbiAgXHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVTdGFydDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSk7XG4gIFx0fVxuXG4gIFx0Zm9yICg7IGkgPCByZW1vdmVFbmQ7IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKC0xKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goaSArIGJhbGFuY2UpO1xuICBcdH1cblxuICBcdC8vIHRoZXJlIGlzIGEgbmV0IHNoaWZ0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgd2l0aCBpbmRleCArIGJhbGFuY2VcbiAgXHRpZiAoYmFsYW5jZSAhPT0gMCkge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IHNwbGljZUFyZ3VtZW50c1swXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0bmV3SW5kaWNlcy50b3VjaGVkRnJvbSA9IGFycmF5Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfVxuXG4gIC8vIFRoZSBwb3AsIHB1c2gsIHNoaWZ0IGFuIHVuc2hpZnQgbWV0aG9kcyBjYW4gYWxsIGJlIHJlcHJlc2VudGVkXG4gIC8vIGFzIGFuIGVxdWl2YWxlbnQgc3BsaWNlXG4gIGZ1bmN0aW9uIGdldFNwbGljZUVxdWl2YWxlbnQoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgXHRzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgXHRcdGNhc2UgXCJzcGxpY2VcIjpcbiAgXHRcdFx0aWYgKGFyZ3NbMF0gIT09IHVuZGVmaW5lZCAmJiBhcmdzWzBdIDwgMCkge1xuICBcdFx0XHRcdGFyZ3NbMF0gPSBhcnJheS5sZW5ndGggKyBNYXRoLm1heChhcmdzWzBdLCAtYXJyYXkubGVuZ3RoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdoaWxlIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgXHRcdFx0XHRhcmdzLnB1c2goMCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBlbnN1cmUgd2Ugb25seSByZW1vdmUgZWxlbWVudHMgdGhhdCBleGlzdFxuICBcdFx0XHRhcmdzWzFdID0gTWF0aC5taW4oYXJnc1sxXSwgYXJyYXkubGVuZ3RoIC0gYXJnc1swXSk7XG5cbiAgXHRcdFx0cmV0dXJuIGFyZ3M7XG5cbiAgXHRcdGNhc2UgXCJzb3J0XCI6XG4gIFx0XHRjYXNlIFwicmV2ZXJzZVwiOlxuICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICBcdFx0Y2FzZSBcInBvcFwiOlxuICBcdFx0XHRpZiAoYXJyYXkubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIFthcnJheS5sZW5ndGggLSAxLCAxXTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gWzAsIDBdO1xuXG4gIFx0XHRjYXNlIFwicHVzaFwiOlxuICBcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCwgMF0uY29uY2F0KGFyZ3MpO1xuXG4gIFx0XHRjYXNlIFwic2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCBhcnJheS5sZW5ndGggPyAxIDogMF07XG5cbiAgXHRcdGNhc2UgXCJ1bnNoaWZ0XCI6XG4gIFx0XHRcdHJldHVybiBbMCwgMF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4gIHZhciBtYWtlQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgYXJyYXksXG4gIFx0XHQgICAgbmV3SW5kaWNlcyA9IFtdLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBwcm9taXNlLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgXHRcdGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIHJhY3RpdmUuXCIgKyBtZXRob2ROYW1lICsgXCIoJ1wiICsga2V5cGF0aC5zdHIgKyBcIicpLCBidXQgJ1wiICsga2V5cGF0aC5zdHIgKyBcIicgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXlcIik7XG4gIFx0XHR9XG5cbiAgXHRcdG5ld0luZGljZXMgPSBzaGFyZWRfZ2V0TmV3SW5kaWNlcyhhcnJheSwgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRcdHJlc3VsdCA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0uYXBwbHkoYXJyYXksIGFyZ3MpO1xuICBcdFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIHBvcCA9IG1ha2VBcnJheU1ldGhvZChcInBvcFwiKTtcblxuICB2YXIgcHVzaCA9IG1ha2VBcnJheU1ldGhvZChcInB1c2hcIik7XG5cbiAgdmFyIGNzcyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHN0eWxlRWxlbWVudCxcbiAgICAgIGhlYWQsXG4gICAgICBzdHlsZVNoZWV0LFxuICAgICAgaW5Eb20sXG4gICAgICBnbG9iYWxfY3NzX19wcmVmaXggPSBcIi8qIFJhY3RpdmUuanMgY29tcG9uZW50IHN0eWxlcyAqL1xcblwiLFxuICAgICAgc3R5bGVzID0gW10sXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHQvLyBUT0RPIGhhbmRsZSBlbmNhcHN1bGF0ZWQgQ1NTIGluIHNlcnZlci1yZW5kZXJlZCBIVE1MIVxuICBcdGNzcyA9IHtcbiAgXHRcdGFkZDogbm9vcCxcbiAgXHRcdGFwcGx5OiBub29wXG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIFx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgXHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXG4gIFx0aW5Eb20gPSBmYWxzZTtcblxuICBcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuICBcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuICBcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblxuICBcdHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjc3MgPSBnbG9iYWxfY3NzX19wcmVmaXggKyBzdHlsZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHJldHVybiBcIlxcbi8qIHtcIiArIHMuaWQgKyBcIn0gKi9cXG5cIiArIHMuc3R5bGVzO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdFx0aWYgKHN0eWxlU2hlZXQpIHtcbiAgXHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpbkRvbSkge1xuICBcdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIFx0XHRcdGluRG9tID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBmdW5jdGlvbiAocykge1xuICBcdFx0XHRzdHlsZXMucHVzaChzKTtcbiAgXHRcdFx0ZGlydHkgPSB0cnVlO1xuICBcdFx0fSxcblxuICBcdFx0YXBwbHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKGRpcnR5KSB7XG4gIFx0XHRcdFx0dXBkYXRlKCk7XG4gIFx0XHRcdFx0ZGlydHkgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgZ2xvYmFsX2NzcyA9IGNzcztcblxuICB2YXIgcHJvdG90eXBlX3JlbmRlciA9IFJhY3RpdmUkcmVuZGVyO1xuXG4gIHZhciByZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZW5kZXJcIiksXG4gICAgICBjb21wbGV0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbXBsZXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlcih0YXJnZXQsIGFuY2hvcikge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0aWYgKHRoaXMubm9JbnRybykge1xuICBcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiByZW5kZXJIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0sIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0XCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KSB8fCB0aGlzLmVsO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCB0aGlzLmFuY2hvcjtcblxuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG4gIFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cbiAgXHRpZiAoIXRoaXMuYXBwZW5kICYmIHRhcmdldCkge1xuICBcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cbiAgXHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3NcbiAgXHRcdHZhciBvdGhlcnMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fO1xuICBcdFx0aWYgKG90aGVycyAmJiBvdGhlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBhcmUgdGhlIG9ubHkgb2NjdXBhbnRzXG4gIFx0XHR0YXJnZXQuaW5uZXJIVE1MID0gXCJcIjsgLy8gVE9ETyBpcyB0aGlzIHF1aWNrZXIgdGhhbiByZW1vdmVDaGlsZD8gSW5pdGlhbCByZXNlYXJjaCBpbmNvbmNsdXNpdmVcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jc3NJZCkge1xuICBcdFx0Ly8gZW5zdXJlIGVuY2Fwc3VsYXRlZCBDU1MgaXMgdXAtdG8tZGF0ZVxuICBcdFx0Z2xvYmFsX2Nzcy5hcHBseSgpO1xuICBcdH1cblxuICBcdGlmICh0YXJnZXQpIHtcbiAgXHRcdGlmICghKGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pKSB7XG4gIFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbdGhpc107XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFuY2hvcikge1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvcik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKF90aGlzKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycykge1xuICBcdG90aGVycy5zcGxpY2UoMCwgb3RoZXJzLmxlbmd0aCkuZm9yRWFjaCh0ZWFyZG93bik7XG4gIH1cblxuICB2YXIgYWRhcHRDb25maWd1cmF0b3IgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cHJvdG8uYWRhcHQgPSBjdXN0b21fYWRhcHRfX2NvbWJpbmUocHJvdG8uYWRhcHQsIGVuc3VyZUFycmF5KG9wdGlvbnMuYWRhcHQpKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3VzdG9tX2FkYXB0ID0gYWRhcHRDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2FkYXB0X19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtQ3NzO1xuXG4gIHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuICAgICAgY29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuICAgICAgc2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XFwoXSsoPzpcXChbXlxcKV0rXFwpKT8pP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuICAgICAgbWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG4gICAgICBkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1yYWN0aXZlLWNzc349XCJcXHtbYS16MC05LV0rXFx9XCJdL2c7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyhjc3MsIGlkKSB7XG4gIFx0dmFyIHRyYW5zZm9ybWVkLCBkYXRhQXR0ciwgYWRkR3VpZDtcblxuICBcdGRhdGFBdHRyID0gXCJbZGF0YS1yYWN0aXZlLWNzc349XFxcIntcIiArIGlkICsgXCJ9XFxcIl1cIjtcblxuICBcdGFkZEd1aWQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHZhciBzZWxlY3RvclVuaXRzLFxuICBcdFx0ICAgIG1hdGNoLFxuICBcdFx0ICAgIHVuaXQsXG4gIFx0XHQgICAgYmFzZSxcbiAgXHRcdCAgICBwcmVwZW5kZWQsXG4gIFx0XHQgICAgYXBwZW5kZWQsXG4gIFx0XHQgICAgaSxcbiAgXHRcdCAgICB0cmFuc2Zvcm1lZCA9IFtdO1xuXG4gIFx0XHRzZWxlY3RvclVuaXRzID0gW107XG5cbiAgXHRcdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyhzZWxlY3RvcikpIHtcbiAgXHRcdFx0c2VsZWN0b3JVbml0cy5wdXNoKHtcbiAgXHRcdFx0XHRzdHI6IG1hdGNoWzBdLFxuICBcdFx0XHRcdGJhc2U6IG1hdGNoWzFdLFxuICBcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbMl1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEZvciBlYWNoIHNpbXBsZSBzZWxlY3RvciB3aXRoaW4gdGhlIHNlbGVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZlcnNpb25cbiAgXHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgaWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGlkXG4gIFx0XHRiYXNlID0gc2VsZWN0b3JVbml0cy5tYXAoZXh0cmFjdFN0cmluZyk7XG5cbiAgXHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cbiAgXHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuICBcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1tpXTtcbiAgXHRcdFx0YXBwZW5kZWRbaV0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8IFwiXCI7XG5cbiAgXHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuICBcdFx0XHRwcmVwZW5kZWRbaV0gPSBkYXRhQXR0ciArIFwiIFwiICsgcHJlcGVuZGVkW2ldO1xuXG4gIFx0XHRcdHRyYW5zZm9ybWVkLnB1c2goYXBwZW5kZWQuam9pbihcIiBcIiksIHByZXBlbmRlZC5qb2luKFwiIFwiKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKFwiLCBcIik7XG4gIFx0fTtcblxuICBcdGlmIChkYXRhUnZjR3VpZFBhdHRlcm4udGVzdChjc3MpKSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGRhdGFSdmNHdWlkUGF0dGVybiwgZGF0YUF0dHIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGNvbW1lbnRzUGF0dGVybiwgXCJcIikucmVwbGFjZShzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXG4gIFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuICBcdFx0XHRpZiAobWVkaWFRdWVyeVBhdHRlcm4udGVzdCgkMSkpIHJldHVybiBtYXRjaDtcblxuICBcdFx0XHRzZWxlY3RvcnMgPSAkMS5zcGxpdChcIixcIikubWFwKHRyaW0pO1xuICBcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoYWRkR3VpZCkuam9pbihcIiwgXCIpICsgXCIgXCI7XG5cbiAgXHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoJDEsIHRyYW5zZm9ybWVkKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIFx0aWYgKHN0ci50cmltKSB7XG4gIFx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcodW5pdCkge1xuICBcdHJldHVybiB1bml0LnN0cjtcbiAgfVxuXG4gIHZhciBjc3NfY3NzX191aWQgPSAxO1xuXG4gIHZhciBjc3NDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJjc3NcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNzcykge1xuICBcdFx0XHR2YXIgaWQgPSBjc3NfY3NzX191aWQrKztcbiAgXHRcdFx0dmFyIHN0eWxlcyA9IG9wdGlvbnMubm9Dc3NUcmFuc2Zvcm0gPyBvcHRpb25zLmNzcyA6IHRyYW5zZm9ybShvcHRpb25zLmNzcywgaWQpO1xuXG4gIFx0XHRcdHByb3RvLmNzc0lkID0gaWQ7XG4gIFx0XHRcdGdsb2JhbF9jc3MuYWRkKHsgaWQ6IGlkLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3NzX2NzcyA9IGNzc0NvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gIFx0Ly8gV2FybiBpZiB1c2VyT3B0aW9ucy5kYXRhIGlzIGEgbm9uLVBPSk9cbiAgXHRpZiAoZGF0YSAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7fSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRmYXRhbChcImRhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGBcIiArIGRhdGEgKyBcImAgaXMgbm90IHZhbGlkXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJJZiBzdXBwbGllZCwgb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IC0gdXNpbmcgYSBub24tUE9KTyBhcyB0aGUgcm9vdCBvYmplY3QgbWF5IHdvcmssIGJ1dCBpcyBkaXNjb3VyYWdlZFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZGF0YUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImRhdGFcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBrZXkgPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdC8vIGNoZWNrIGZvciBub24tcHJpbWl0aXZlcywgd2hpY2ggY291bGQgY2F1c2UgbXV0YXRpb24tcmVsYXRlZCBidWdzXG4gIFx0XHRpZiAob3B0aW9ucy5kYXRhICYmIGlzT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gb3B0aW9ucy5kYXRhKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLmRhdGFba2V5XTtcblxuICBcdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJQYXNzaW5nIGEgYGRhdGFgIG9wdGlvbiB3aXRoIG9iamVjdCBhbmQgYXJyYXkgcHJvcGVydGllcyB0byBSYWN0aXZlLmV4dGVuZCgpIGlzIGRpc2NvdXJhZ2VkLCBhcyBtdXRhdGluZyB0aGVtIGlzIGxpa2VseSB0byBjYXVzZSBidWdzLiBDb25zaWRlciB1c2luZyBhIGRhdGEgZnVuY3Rpb24gaW5zdGVhZDpcXG5cXG4gIC8vIHRoaXMuLi5cXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBteU9iamVjdDoge31cXG4gICAgfTtcXG4gIH0pXFxuXFxuICAvLyBpbnN0ZWFkIG9mIHRoaXM6XFxuICBkYXRhOiB7XFxuICAgIG15T2JqZWN0OiB7fVxcbiAgfVwiKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cHJvdG8uZGF0YSA9IGN1c3RvbV9kYXRhX19jb21iaW5lKHByb3RvLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBjdXN0b21fZGF0YV9fY29tYmluZShQYXJlbnQucHJvdG90eXBlLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQgfHwge307XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlLnZpZXdtb2RlbCk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnJlc2V0KHJlc3VsdCk7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9kYXRhID0gZGF0YUNvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fZGF0YV9fY29tYmluZShwYXJlbnRWYWx1ZSwgY2hpbGRWYWx1ZSkge1xuICBcdHZhbGlkYXRlKGNoaWxkVmFsdWUpO1xuXG4gIFx0dmFyIHBhcmVudElzRm4gPSB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgXHR2YXIgY2hpbGRJc0ZuID0gdHlwZW9mIGNoaWxkVmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuICBcdC8vIFZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UgY2hpbGQgaW5zdGFuY2UgY2FuIGJlY29tZVxuICBcdC8vIHRoZSBkZWZhdWx0IGRhdGEgb2JqZWN0IG9uIFJhY3RpdmUgb3IgYSBjb21wb25lbnQuXG4gIFx0Ly8gdGhlbiByYWN0aXZlLnNldCgpIGVuZHMgdXAgc2V0dGluZyBvbiB0aGUgcHJvdG90eXBlIVxuICBcdGlmICghY2hpbGRWYWx1ZSAmJiAhcGFyZW50SXNGbikge1xuICBcdFx0Y2hpbGRWYWx1ZSA9IHt9O1xuICBcdH1cblxuICBcdC8vIEZhc3QgcGF0aCwgd2hlcmUgd2UganVzdCBuZWVkIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gIFx0Ly8gcGFyZW50IHRvIGNoaWxkXG4gIFx0aWYgKCFwYXJlbnRJc0ZuICYmICFjaGlsZElzRm4pIHtcbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjaGlsZCA9IGNoaWxkSXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oY2hpbGRWYWx1ZSwgdGhpcykgOiBjaGlsZFZhbHVlO1xuICBcdFx0dmFyIHBhcmVudCA9IHBhcmVudElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKHBhcmVudFZhbHVlLCB0aGlzKSA6IHBhcmVudFZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGQsIHBhcmVudCk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRhRnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgXHR2YXIgZGF0YSA9IGZuLmNhbGwoY29udGV4dCk7XG5cbiAgXHRpZiAoIWRhdGEpIHJldHVybjtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0ZmF0YWwoXCJEYXRhIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcoXCJEYXRhIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QuIFRoaXMgbWlnaHQgd29yaywgYnV0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gIFx0aWYgKHByaW1hcnkgJiYgc2Vjb25kYXJ5KSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gc2Vjb25kYXJ5KSB7XG4gIFx0XHRcdGlmICghKGtleSBpbiBwcmltYXJ5KSkge1xuICBcdFx0XHRcdHByaW1hcnlba2V5XSA9IHNlY29uZGFyeVtrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmltYXJ5O1xuICBcdH1cblxuICBcdHJldHVybiBwcmltYXJ5IHx8IHNlY29uZGFyeTtcbiAgfVxuXG4gIC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdXBwb3J0IHRoaXMgaW4gdGhlIG5ldyBSYWN0aXZlKCkgY2FzZT9cblxuICB2YXIgUGFyc2VyLFxuICAgICAgUGFyc2VFcnJvcixcbiAgICAgIHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuXG4gIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICBcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIFx0dHJ5IHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgUGFyc2VyID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdHZhciBpdGVtcyxcbiAgXHQgICAgaXRlbSxcbiAgXHQgICAgbGluZVN0YXJ0ID0gMDtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuICBcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0dGhpcy5wb3MgPSAwO1xuXG4gIFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KFwiXFxuXCIpO1xuICBcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7IC8vICsxIGZvciB0aGUgbmV3bGluZVxuXG4gIFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICBcdFx0cmV0dXJuIGxpbmVFbmQ7XG4gIFx0fSwgMCk7XG5cbiAgXHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuICBcdGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdChzdHIsIG9wdGlvbnMpO1xuXG4gIFx0aXRlbXMgPSBbXTtcblxuICBcdHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoaXRlbSA9IHRoaXMucmVhZCgpKSkge1xuICBcdFx0aXRlbXMucHVzaChpdGVtKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcbiAgXHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKGl0ZW1zLCBvcHRpb25zKSA6IGl0ZW1zO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVhZDogZnVuY3Rpb24gKGNvbnZlcnRlcnMpIHtcbiAgXHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblxuICBcdFx0aWYgKCFjb252ZXJ0ZXJzKSBjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXG4gIFx0XHRwb3MgPSB0aGlzLnBvcztcblxuICBcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5wb3MgPSBwb3M7IC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblxuICBcdFx0XHRpZiAoaXRlbSA9IGNvbnZlcnRlcnNbaV0odGhpcykpIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LFxuXG4gIFx0Z2V0TGluZVBvczogZnVuY3Rpb24gKGNoYXIpIHtcbiAgXHRcdHZhciBsaW5lTnVtID0gMCxcbiAgXHRcdCAgICBsaW5lU3RhcnQgPSAwLFxuICBcdFx0ICAgIGNvbHVtbk51bTtcblxuICBcdFx0d2hpbGUgKGNoYXIgPj0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXSkge1xuICBcdFx0XHRsaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dO1xuICBcdFx0XHRsaW5lTnVtICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbHVtbk51bSA9IGNoYXIgLSBsaW5lU3RhcnQ7XG4gIFx0XHRyZXR1cm4gW2xpbmVOdW0gKyAxLCBjb2x1bW5OdW0gKyAxLCBjaGFyXTsgLy8gbGluZS9jb2wgc2hvdWxkIGJlIG9uZS1iYXNlZCwgbm90IHplcm8tYmFzZWQhXG4gIFx0fSxcblxuICBcdGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuZ2V0TGluZVBvcyh0aGlzLnBvcyk7XG4gIFx0XHR2YXIgbGluZU51bSA9IHBvc1swXTtcbiAgXHRcdHZhciBjb2x1bW5OdW0gPSBwb3NbMV07XG5cbiAgXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1twb3NbMF0gLSAxXTtcbiAgXHRcdHZhciBudW1UYWJzID0gMDtcbiAgXHRcdHZhciBhbm5vdGF0aW9uID0gbGluZS5yZXBsYWNlKC9cXHQvZywgZnVuY3Rpb24gKG1hdGNoLCBjaGFyKSB7XG4gIFx0XHRcdGlmIChjaGFyIDwgcG9zWzFdKSB7XG4gIFx0XHRcdFx0bnVtVGFicyArPSAxO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIFwiICBcIjtcbiAgXHRcdH0pICsgXCJcXG5cIiArIG5ldyBBcnJheShwb3NbMV0gKyBudW1UYWJzKS5qb2luKFwiIFwiKSArIFwiXi0tLS1cIjtcblxuICBcdFx0dmFyIGVycm9yID0gbmV3IFBhcnNlRXJyb3IoXCJcIiArIG1lc3NhZ2UgKyBcIiBhdCBsaW5lIFwiICsgbGluZU51bSArIFwiIGNoYXJhY3RlciBcIiArIGNvbHVtbk51bSArIFwiOlxcblwiICsgYW5ub3RhdGlvbik7XG5cbiAgXHRcdGVycm9yLmxpbmUgPSBwb3NbMF07XG4gIFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbMV07XG4gIFx0XHRlcnJvci5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIFx0XHR0aHJvdyBlcnJvcjtcbiAgXHR9LFxuXG4gIFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgXHRcdGlmICh0aGlzLnN0ci5zdWJzdHIodGhpcy5wb3MsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmcpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiAocGF0dGVybikge1xuICBcdFx0dmFyIG1hdGNoO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5yZW1haW5pbmcoKSkpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tYXRjaFBhdHRlcm4ocGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSk7XG4gIFx0fSxcblxuICBcdHJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gIFx0fSxcblxuICBcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMucG9zKTtcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBDaGlsZCxcbiAgXHQgICAga2V5O1xuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHRQYXJzZXIuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cbiAgXHRmb3IgKGtleSBpbiBwcm90bykge1xuICBcdFx0aWYgKGhhc093bi5jYWxsKHByb3RvLCBrZXkpKSB7XG4gIFx0XHRcdENoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuICBcdHJldHVybiBDaGlsZDtcbiAgfTtcblxuICB2YXIgcGFyc2VfUGFyc2VyID0gUGFyc2VyO1xuXG4gIHZhciBURVhUID0gMTtcbiAgdmFyIElOVEVSUE9MQVRPUiA9IDI7XG4gIHZhciBUUklQTEUgPSAzO1xuICB2YXIgU0VDVElPTiA9IDQ7XG4gIHZhciBJTlZFUlRFRCA9IDU7XG4gIHZhciBDTE9TSU5HID0gNjtcbiAgdmFyIEVMRU1FTlQgPSA3O1xuICB2YXIgUEFSVElBTCA9IDg7XG4gIHZhciBDT01NRU5UID0gOTtcbiAgdmFyIERFTElNQ0hBTkdFID0gMTA7XG4gIHZhciBBVFRSSUJVVEUgPSAxMztcbiAgdmFyIENMT1NJTkdfVEFHID0gMTQ7XG4gIHZhciBDT01QT05FTlQgPSAxNTtcbiAgdmFyIFlJRUxERVIgPSAxNjtcbiAgdmFyIElOTElORV9QQVJUSUFMID0gMTc7XG4gIHZhciBET0NUWVBFID0gMTg7XG5cbiAgdmFyIE5VTUJFUl9MSVRFUkFMID0gMjA7XG4gIHZhciBTVFJJTkdfTElURVJBTCA9IDIxO1xuICB2YXIgQVJSQVlfTElURVJBTCA9IDIyO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSAyMztcbiAgdmFyIEJPT0xFQU5fTElURVJBTCA9IDI0O1xuICB2YXIgUkVHRVhQX0xJVEVSQUwgPSAyNTtcblxuICB2YXIgR0xPQkFMID0gMjY7XG4gIHZhciBLRVlfVkFMVUVfUEFJUiA9IDI3O1xuXG4gIHZhciBSRUZFUkVOQ0UgPSAzMDtcbiAgdmFyIFJFRklORU1FTlQgPSAzMTtcbiAgdmFyIE1FTUJFUiA9IDMyO1xuICB2YXIgUFJFRklYX09QRVJBVE9SID0gMzM7XG4gIHZhciBCUkFDS0VURUQgPSAzNDtcbiAgdmFyIENPTkRJVElPTkFMID0gMzU7XG4gIHZhciBJTkZJWF9PUEVSQVRPUiA9IDM2O1xuXG4gIHZhciBJTlZPQ0FUSU9OID0gNDA7XG5cbiAgdmFyIFNFQ1RJT05fSUYgPSA1MDtcbiAgdmFyIFNFQ1RJT05fVU5MRVNTID0gNTE7XG4gIHZhciBTRUNUSU9OX0VBQ0ggPSA1MjtcbiAgdmFyIFNFQ1RJT05fV0lUSCA9IDUzO1xuICB2YXIgU0VDVElPTl9JRl9XSVRIID0gNTQ7XG5cbiAgdmFyIEVMU0UgPSA2MDtcbiAgdmFyIEVMU0VJRiA9IDYxO1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlID0gcmVhZERlbGltaXRlckNoYW5nZTtcbiAgdmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcbiAgICAgIHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcbiAgZnVuY3Rpb24gcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG9wZW5pbmcsIGNsb3Npbmc7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghb3BlbmluZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHdoaXRlc3BhY2VQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Y2xvc2luZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFjbG9zaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIFtvcGVuaW5nLCBjbG9zaW5nXTtcbiAgfVxuXG4gIHZhciByZWFkUmVnZXhwTGl0ZXJhbCA9IHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIHJlZ2V4cFBhdHRlcm4gPSAvXihcXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5L1xcXFxbXXxcXFxcLnxcXFsoPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XFxdXFxcXF18XFxcXC4pKl0pK1xcLyg/OihbZ2ltdXldKSg/IVthLXpdKlxcMikpKig/IVthLXpBLVpfJDAtOV0pKS87XG4gIGZ1bmN0aW9uIHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocmVnZXhwUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFR0VYUF9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkTXVzdGFjaGUgPSByZWFkTXVzdGFjaGU7XG5cbiAgdmFyIGRlbGltaXRlckNoYW5nZVRva2VuID0geyB0OiBERUxJTUNIQU5HRSwgZXhjbHVkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiByZWFkTXVzdGFjaGUocGFyc2VyKSB7XG4gIFx0dmFyIG11c3RhY2hlLCBpO1xuXG4gIFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3RcbiAgXHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG4gIFx0aWYgKHBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSA9PT0gZmFsc2UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBwYXJzZXIudGFncy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgcGFyc2VyLnRhZ3NbaV0pKSB7XG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG11c3RhY2hlLCByZWFkZXIsIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcXFwiICsgdGFnLm9wZW4pKSB7XG4gIFx0XHRpZiAoc3RhcnQgPT09IDAgfHwgcGFyc2VyLnN0cltzdGFydCAtIDFdICE9PSBcIlxcXFxcIikge1xuICBcdFx0XHRyZXR1cm4gdGFnLm9wZW47XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cbiAgXHRpZiAobXVzdGFjaGUgPSBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikpIHtcbiAgXHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG4gIFx0XHR0YWcub3BlbiA9IG11c3RhY2hlWzBdO1xuICBcdFx0dGFnLmNsb3NlID0gbXVzdGFjaGVbMV07XG4gIFx0XHRwYXJzZXIuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWxsZWdhbCBzZWN0aW9uIGNsb3NlclxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR2YXIgcmV3aW5kID0gcGFyc2VyLnBvcztcbiAgXHRcdGlmICghcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kIC0gdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc24ndCBvcGVuXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgdGFnLnJlYWRlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdHJlYWRlciA9IHRhZy5yZWFkZXJzW2ldO1xuXG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkZXIocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmICh0YWcuaXNTdGF0aWMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTsgLy8gVE9ETyBtYWtlIHRoaXMgYDFgIGluc3RlYWQgLSBtb3JlIGNvbXBhY3RcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleHBlY3RlZEV4cHJlc3Npb24gPSBcIkV4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uXCI7XG4gIHZhciBleHBlY3RlZFBhcmVuID0gXCJFeHBlY3RlZCBjbG9zaW5nIHBhcmVuXCI7XG5cbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwgPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KTAqKD86KD86KD86WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBmdW5jdGlvbiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IE5VTUJFUl9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwgPSByZWFkQm9vbGVhbkxpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNCkgPT09IFwidHJ1ZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDQ7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwidHJ1ZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDUpID09PSBcImZhbHNlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNTtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJmYWxzZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cbiAgLy8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuICAvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuICBzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblxuICAvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cbiAgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblxuICAvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuICBsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuICB2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbiAob2tRdW90ZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cbiAgXHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRcdGxpdGVyYWwgPSBcIlxcXCJcIjtcbiAgXHRcdGRvbmUgPSBmYWxzZTtcblxuICBcdFx0d2hpbGUgKCFkb25lKSB7XG4gIFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0cmluZ01pZGRsZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oZXNjYXBlU2VxdWVuY2VQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcob2tRdW90ZSk7XG4gIFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0aWYgKG5leHQgPT09IFwiXFxcIlwiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXFxcXCJcIjtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXCdcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIidcIjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaW5lQ29udGludWF0aW9uUGF0dGVybik7XG4gIFx0XHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXHVcIiArIChcIjAwMFwiICsgbmV4dC5jaGFyQ29kZUF0KDEpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGl0ZXJhbCArPSBcIlxcXCJcIjtcblxuICBcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcbiAgXHRcdHJldHVybiBKU09OLnBhcnNlKGxpdGVyYWwpO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIGdldFNpbmdsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiXFxcIlwiKTtcbiAgdmFyIGdldERvdWJsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiJ1wiKTtcblxuICB2YXIgcmVhZFN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIHBhdHRlcm5zX19uYW1lID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovO1xuXG4gIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuICAvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuICB2YXIgc2hhcmVkX3JlYWRLZXkgPSByZWFkS2V5O1xuICB2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG4gIGZ1bmN0aW9uIHJlYWRLZXkocGFyc2VyKSB7XG4gIFx0dmFyIHRva2VuO1xuXG4gIFx0aWYgKHRva2VuID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCh0b2tlbi52KSA/IHRva2VuLnYgOiBcIlxcXCJcIiArIHRva2VuLnYucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKSArIFwiXFxcIlwiO1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIHRva2VuLnY7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdHJldHVybiB0b2tlbjtcbiAgXHR9XG4gIH1cblxuICB2YXIga2V5VmFsdWVQYWlyID0gcmVhZEtleVZhbHVlUGFpcjtcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRrZXkgPSBzaGFyZWRfcmVhZEtleShwYXJzZXIpO1xuICBcdGlmIChrZXkgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuICBcdHZhbHVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEtFWV9WQUxVRV9QQUlSLFxuICBcdFx0azoga2V5LFxuICBcdFx0djogdmFsdWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFpciA9IGtleVZhbHVlUGFpcihwYXJzZXIpO1xuICBcdGlmIChwYWlyID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlycyA9IFtwYWlyXTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdFx0aWYgKCFrZXlWYWx1ZVBhaXJzKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwYWlycy5jb25jYXQoa2V5VmFsdWVQYWlycyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgdmFyIHJlYWRPYmplY3RMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2VcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGtleVZhbHVlUGFpcnMgPSBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogT0JKRUNUX0xJVEVSQUwsXG4gIFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG4gIFx0fTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdCA9IHJlYWRFeHByZXNzaW9uTGlzdDtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKGV4cHIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRuZXh0ID0gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG4gIFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0bmV4dC5mb3JFYWNoKGFwcGVuZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYXBwZW5kKGV4cHJlc3Npb24pIHtcbiAgXHRcdGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG5cbiAgdmFyIHJlYWRBcnJheUxpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBBUlJBWV9MSVRFUkFMLFxuICBcdFx0bTogZXhwcmVzc2lvbkxpc3RcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwcmltYXJ5X3JlYWRMaXRlcmFsID0gcmVhZExpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRMaXRlcmFsKHBhcnNlcikge1xuICBcdHJldHVybiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikgfHwgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB8fCByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRPYmplY3RMaXRlcmFsKHBhcnNlcikgfHwgcmVhZEFycmF5TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkUmVmZXJlbmNlID0gcmVhZFJlZmVyZW5jZTtcbiAgdmFyIHByZWZpeFBhdHRlcm4gPSAvXig/On5cXC98KD86XFwuXFwuXFwvKSt8XFwuXFwvKD86XFwuXFwuXFwvKSp8XFwuKS8sXG4gICAgICBnbG9iYWxzLFxuICAgICAga2V5d29yZHM7XG5cbiAgLy8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICBnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGwpXFxiLztcblxuICAvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2BcbiAga2V5d29yZHMgPSAvXig/OmJyZWFrfGNhc2V8Y2F0Y2h8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aCkkLztcblxuICB2YXIgbGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KD86XFwuW2EtekEtWiRfMC05XSspfCg/OlxcW1swLTldK1xcXSkpKi87XG4gIHZhciByZWxheGVkTmFtZSA9IC9eW2EtekEtWl8kXVstYS16QS1aXyQwLTldKi87XG4gIGZ1bmN0aW9uIHJlYWRSZWZlcmVuY2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0UG9zLCBwcmVmaXgsIG5hbWUsIGdsb2JhbCwgcmVmZXJlbmNlLCBsYXN0RG90SW5kZXg7XG5cbiAgXHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXkAoPzprZXlwYXRofGluZGV4fGtleSkvKTtcblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cHJlZml4ID0gcGFyc2VyLm1hdGNoUGF0dGVybihwcmVmaXhQYXR0ZXJuKSB8fCBcIlwiO1xuICBcdFx0bmFtZSA9ICFwcmVmaXggJiYgcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlbGF4ZWROYW1lKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxlZ2FsUmVmZXJlbmNlKTtcblxuICBcdFx0aWYgKCFuYW1lICYmIHByZWZpeCA9PT0gXCIuXCIpIHtcbiAgXHRcdFx0cHJlZml4ID0gXCJcIjtcbiAgXHRcdFx0bmFtZSA9IFwiLlwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZCAoZXhjZXB0aW9uIGZvciBhbmNlc3Rvci9yZXN0cmljdGVkIHJlZnMgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy8xNDk3KVxuICBcdGlmICghcHJlZml4ICYmICFwYXJzZXIucmVsYXhlZE5hbWVzICYmIGtleXdvcmRzLnRlc3QobmFtZSkpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG4gIFx0aWYgKCFwcmVmaXggJiYgZ2xvYmFscy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRnbG9iYWwgPSBnbG9iYWxzLmV4ZWMobmFtZSlbMF07XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBnbG9iYWwubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBHTE9CQUwsXG4gIFx0XHRcdHY6IGdsb2JhbFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZWZlcmVuY2UgPSAocHJlZml4IHx8IFwiXCIpICsgbm9ybWFsaXNlKG5hbWUpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG4gIFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG4gIFx0XHQvLyB3aWxsIGJlIHdyb25nXG4gIFx0XHRsYXN0RG90SW5kZXggPSByZWZlcmVuY2UubGFzdEluZGV4T2YoXCIuXCIpO1xuICBcdFx0aWYgKGxhc3REb3RJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVmZXJlbmNlID0gcmVmZXJlbmNlLnN1YnN0cigwLCBsYXN0RG90SW5kZXgpO1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyByZWZlcmVuY2UubGVuZ3RoO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBSRUZFUkVOQ0UsXG4gIFx0XHRuOiByZWZlcmVuY2UucmVwbGFjZSgvXnRoaXNcXC4vLCBcIi4vXCIpLnJlcGxhY2UoL150aGlzJC8sIFwiLlwiKVxuICBcdH07XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbiA9IHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFleHByKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwclxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZFByaW1hcnkgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZExpdGVyYWwocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkUmVmaW5lbWVudCA9IHJlYWRSZWZpbmVtZW50O1xuICBmdW5jdGlvbiByZWFkUmVmaW5lbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBcIi5cIiBuYW1lXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi5cIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdFx0bjogbmFtZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHIpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkICddJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0eDogZXhwclxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWFkTWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblxuICBcdGV4cHJlc3Npb24gPSByZWFkUHJpbWFyeShwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbikge1xuICBcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50ID0gc2hhcmVkX3JlYWRSZWZpbmVtZW50KHBhcnNlcikpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBNRU1CRVIsXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvbixcbiAgXHRcdFx0XHRyOiByZWZpbmVtZW50XG4gIFx0XHRcdH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0XHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBJTlZPQ0FUSU9OLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb25cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRpZiAoZXhwcmVzc2lvbkxpc3QpIHtcbiAgXHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIH07XG5cbiAgdmFyIHJlYWRUeXBlT2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBleHByZXNzaW9uO1xuXG4gIFx0XHRpZiAoZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKHBhcnNlcikpIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRvOiBleHByZXNzaW9uLFxuICBcdFx0XHR0OiBQUkVGSVhfT1BFUkFUT1JcbiAgXHRcdH07XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIHJlYWRUeXBlT2ZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0cHJlZml4T3BlcmF0b3JzID0gXCIhIH4gKyAtIHR5cGVvZlwiLnNwbGl0KFwiIFwiKTtcblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZE1lbWJlck9ySW52b2NhdGlvbjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKHByZWZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcbiAgXHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG4gIFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcbiAgXHRyZWFkVHlwZU9mID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJlYWRUeXBlb2YgPSByZWFkVHlwZU9mO1xuXG4gIHZhciByZWFkTG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblxuICBcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRpZiAoIWxlZnQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG4gIFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuICBcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuICBcdFx0d2hpbGUgKHRydWUpIHtcbiAgXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuICBcdFx0XHRpZiAoc3ltYm9sID09PSBcImluXCIgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QocGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCgwKSkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRcdGlmICghcmlnaHQpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRsZWZ0ID0ge1xuICBcdFx0XHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0XHRvOiBbbGVmdCwgcmlnaHRdXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gTG9vcCBiYWNrIGFyb3VuZC4gIElmIHdlIGRvbid0IHNlZSBhbm90aGVyIG9jY3VycmVuY2Ugb2YgdGhlIHN5bWJvbCxcbiAgXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIGxlZnQuXG4gIFx0XHR9XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIHJlYWRMb2dpY2FsT3JcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG4gIFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2VcbiAgXHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG4gIFx0aW5maXhPcGVyYXRvcnMgPSBcIiogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fFwiLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRUeXBlb2Y7XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoaW5maXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcbiAgXHRyZWFkTG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IgPSByZWFkTG9naWNhbE9yO1xuXG4gIC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IsIHNvIHdlIHN0YXJ0IGhlcmVcbiAgdmFyIHJlYWRDb25kaXRpb25hbCA9IGdldENvbmRpdGlvbmFsO1xuICBmdW5jdGlvbiBnZXRDb25kaXRpb25hbChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblxuICBcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yKHBhcnNlcik7XG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmVHJ1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmVHJ1ZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcXFwiOlxcXCJcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZGYWxzZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmRmFsc2UpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBDT05ESVRJT05BTCxcbiAgXHRcdG86IFtleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2VdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcbiAgXHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2VcbiAgXHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcbiAgXHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cbiAgXHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG4gIFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cbiAgXHRyZXR1cm4gcmVhZENvbmRpdGlvbmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24gPSBmbGF0dGVuRXhwcmVzc2lvbjtcblxuICBmdW5jdGlvbiBmbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIHJlZnM7XG5cbiAgXHRleHRyYWN0UmVmcyhleHByZXNzaW9uLCByZWZzID0gW10pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IHJlZnMsXG4gIFx0XHRzOiBzdHJpbmdpZnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgXHRcdHN3aXRjaCAobm9kZS50KSB7XG4gIFx0XHRcdGNhc2UgQk9PTEVBTl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIEdMT0JBTDpcbiAgXHRcdFx0Y2FzZSBOVU1CRVJfTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBSRUdFWFBfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXG4gIFx0XHRcdGNhc2UgU1RSSU5HX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyhub2RlLnYpKTtcblxuICBcdFx0XHRjYXNlIEFSUkFZX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwiW1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJ7XCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIn1cIjtcblxuICBcdFx0XHRjYXNlIEtFWV9WQUxVRV9QQUlSOlxuICBcdFx0XHRcdHJldHVybiBub2RlLmsgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLnYpO1xuXG4gIFx0XHRcdGNhc2UgUFJFRklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiAobm9kZS5zID09PSBcInR5cGVvZlwiID8gXCJ0eXBlb2YgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUubyk7XG5cbiAgXHRcdFx0Y2FzZSBJTkZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyAobm9kZS5zLnN1YnN0cigwLCAyKSA9PT0gXCJpblwiID8gXCIgXCIgKyBub2RlLnMgKyBcIiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vWzFdKTtcblxuICBcdFx0XHRjYXNlIElOVk9DQVRJT046XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgXCIoXCIgKyAobm9kZS5vID8gbm9kZS5vLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIEJSQUNLRVRFRDpcbiAgXHRcdFx0XHRyZXR1cm4gXCIoXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgTUVNQkVSOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIHN0cmluZ2lmeShub2RlLnIpO1xuXG4gIFx0XHRcdGNhc2UgUkVGSU5FTUVOVDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5uID8gXCIuXCIgKyBub2RlLm4gOiBcIltcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBDT05ESVRJT05BTDpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyBcIj9cIiArIHN0cmluZ2lmeShub2RlLm9bMV0pICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS5vWzJdKTtcblxuICBcdFx0XHRjYXNlIFJFRkVSRU5DRTpcbiAgXHRcdFx0XHRyZXR1cm4gXCJfXCIgKyByZWZzLmluZGV4T2Yobm9kZS5uKTtcblxuICBcdFx0XHRkZWZhdWx0OlxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyBtYXliZSByZWZhY3RvciB0aGlzP1xuICBmdW5jdGlvbiBleHRyYWN0UmVmcyhub2RlLCByZWZzKSB7XG4gIFx0dmFyIGksIGxpc3Q7XG5cbiAgXHRpZiAobm9kZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdGlmIChyZWZzLmluZGV4T2Yobm9kZS5uKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmVmcy51bnNoaWZ0KG5vZGUubik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG4gIFx0aWYgKGxpc3QpIHtcbiAgXHRcdGlmIChpc09iamVjdChsaXN0KSkge1xuICBcdFx0XHRleHRyYWN0UmVmcyhsaXN0LCByZWZzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGV4dHJhY3RSZWZzKGxpc3RbaV0sIHJlZnMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUueCkge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS54LCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5yKSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnIsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnYpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUudiwgcmVmcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHV0aWxzX3JlZmluZUV4cHJlc3Npb24gPSByZWZpbmVFeHByZXNzaW9uO1xuXG4gIHZhciBhcnJheU1lbWJlclBhdHRlcm4gPSAvXlswLTldWzEtOV0qJC87XG4gIGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbXVzdGFjaGUpIHtcbiAgXHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICBcdGlmIChleHByZXNzaW9uKSB7XG4gIFx0XHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBCUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54KSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuICBcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBOVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdChleHByZXNzaW9uLnYpKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcbiAgXHRcdFx0fSBlbHNlIGlmIChyZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS54ID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgbWVtYmVycyA9IFtdLFxuICBcdCAgICByZWZpbmVtZW50O1xuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSBSRUZJTkVNRU5UKSB7XG4gIFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudC54KSB7XG4gIFx0XHRcdGlmIChyZWZpbmVtZW50LngudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQueCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKHJlZmluZW1lbnQueCkpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC5uKTtcbiAgXHRcdH1cblxuICBcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHR9XG5cbiAgXHRpZiAoZXhwcmVzc2lvbi50ICE9PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiBleHByZXNzaW9uLm4sXG4gIFx0XHRtOiBtZW1iZXJzXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVHJpcGxlID0gcmVhZFRyaXBsZTtcbiAgZnVuY3Rpb24gcmVhZFRyaXBsZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpLFxuICBcdCAgICB0cmlwbGU7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkID0gcmVhZFVuZXNjYXBlZDtcbiAgZnVuY3Rpb24gcmVhZFVuZXNjYXBlZChwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uLCB0cmlwbGU7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiZcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkUGFydGlhbCA9IHJlYWRQYXJ0aWFsO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbChwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZVN0YXJ0LCBleHByZXNzaW9uLCBjb250ZXh0LCBwYXJ0aWFsO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0bmFtZVN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFBhcnRpYWwgbmFtZXMgY2FuIGluY2x1ZGUgaHlwaGVucywgc28gd2UgY2FuJ3QgdXNlIHJlYWRFeHByZXNzaW9uXG4gIFx0Ly8gYmxpbmRseS4gSW5zdGVhZCwgd2UgdXNlIHRoZSBgcmVsYXhlZE5hbWVzYCBmbGFnIHRvIGluZGljYXRlIHRoYXRcbiAgXHQvLyBgZm9vLWJhcmAgc2hvdWxkIGJlIHJlYWQgYXMgYSBzaW5nbGUgbmFtZSwgcmF0aGVyIHRoYW4gJ3N1YnRyYWN0XG4gIFx0Ly8gYmFyIGZyb20gZm9vJ1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSB0cnVlO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IGZhbHNlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGNvbnRleHQgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0geyB0OiBQQVJUSUFMIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJ0aWFsKTsgLy8gVE9ETy4uLlxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWYgd2UgaGF2ZSBhbm90aGVyIGV4cHJlc3Npb24gLSBlLmcuIGB7ez5mb28gYmFyfX1gIC0gdGhlblxuICBcdC8vIHdlIHR1cm4gaXQgaW50byBge3sjd2l0aCBiYXJ9fXt7PmZvb319e3svd2l0aH19YFxuICBcdGlmIChjb250ZXh0KSB7XG4gIFx0XHRwYXJ0aWFsID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1dJVEgsXG4gIFx0XHRcdGY6IFtwYXJ0aWFsXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihjb250ZXh0LCBwYXJ0aWFsKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWw7XG4gIH1cblxuICB2YXIgcmVhZE11c3RhY2hlQ29tbWVudCA9IHJlYWRDb21tZW50O1xuICBmdW5jdGlvbiByZWFkQ29tbWVudChwYXJzZXIsIHRhZykge1xuICBcdHZhciBpbmRleDtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleCArIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRyZXR1cm4geyB0OiBDT01NRU5UIH07XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZSA9IHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2U7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBleHBlY3RlZEZvbGxvd2Vycykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWRGb2xsb3dlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChwYXJzZXIucmVtYWluaW5nKCkuc3Vic3RyKDAsIGV4cGVjdGVkRm9sbG93ZXJzW2ldLmxlbmd0aCkgPT09IGV4cGVjdGVkRm9sbG93ZXJzW2ldKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcik7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciA9IHJlYWRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIHJlYWRJbnRlcnBvbGF0b3IocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGludGVycG9sYXRvciwgZXJyO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gVE9ETyB3b3VsZCBiZSBnb29kIGZvciBwZXJmIGlmIHdlIGNvdWxkIGRvIGF3YXkgd2l0aCB0aGUgdHJ5LWNhdGNoXG4gIFx0dHJ5IHtcbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBbdGFnLmNsb3NlXSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0ZXJyID0gZTtcbiAgXHR9XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdGlmIChwYXJzZXIuc3RyLmNoYXJBdChzdGFydCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInIGFmdGVyIHJlZmVyZW5jZVwiKTtcblxuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIiFcIikge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBvciBsZWdhbCByZWZlcmVuY2VcIik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aW50ZXJwb2xhdG9yID0geyB0OiBJTlRFUlBPTEFUT1IgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGludGVycG9sYXRvcik7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiBpbnRlcnBvbGF0b3I7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFlpZWxkZXIgPSByZWFkWWllbGRlcjtcbiAgdmFyIHlpZWxkUGF0dGVybiA9IC9eeWllbGRcXHMqLztcbiAgZnVuY3Rpb24gcmVhZFlpZWxkZXIocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIHlpZWxkZXI7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oeWllbGRQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0eWllbGRlciA9IHsgdDogWUlFTERFUiB9O1xuXG4gIFx0aWYgKG5hbWUpIHtcbiAgXHRcdHlpZWxkZXIubiA9IG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHlpZWxkZXI7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkQ2xvc2luZyA9IHJlYWRDbG9zaW5nO1xuICBmdW5jdGlvbiByZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgcmVtYWluaW5nLCBpbmRleCwgY2xvc2luZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0Y2xvc2luZyA9IHtcbiAgXHRcdFx0dDogQ0xPU0lORyxcbiAgXHRcdFx0cjogcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkuc3BsaXQoXCIgXCIpWzBdXG4gIFx0XHR9O1xuXG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNsb3Npbmc7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2UgPSBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZTtcbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZVxccyovO1xuICBmdW5jdGlvbiBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRVxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZEVsc2VJZiA9IHJlYWRFbHNlSWZfX3JlYWRFbHNlO1xuICB2YXIgcmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlaWZcXHMrLztcbiAgZnVuY3Rpb24gcmVhZEVsc2VJZl9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zLFxuICBcdCAgICBleHByZXNzaW9uO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFSUYsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IHtcbiAgXHRlYWNoOiBTRUNUSU9OX0VBQ0gsXG4gIFx0XCJpZlwiOiBTRUNUSU9OX0lGLFxuICBcdFwiaWYtd2l0aFwiOiBTRUNUSU9OX0lGX1dJVEgsXG4gIFx0XCJ3aXRoXCI6IFNFQ1RJT05fV0lUSCxcbiAgXHR1bmxlc3M6IFNFQ1RJT05fVU5MRVNTXG4gIH07XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRTZWN0aW9uID0gcmVhZFNlY3Rpb247XG5cbiAgdmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAga2V5SW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqLFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBPYmplY3Qua2V5cyhoYW5kbGViYXJzQmxvY2tDb2Rlcykuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcbiAgZnVuY3Rpb24gcmVhZFNlY3Rpb24ocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIHNlY3Rpb24sIGNoaWxkLCBjaGlsZHJlbiwgaGFzRWxzZSwgYmxvY2ssIHVubGVzc0Jsb2NrLCBjb25kaXRpb25zLCBjbG9zZWQsIGksIGV4cGVjdGVkQ2xvc2U7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXlwiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10sIG46IFNFQ1RJT05fVU5MRVNTIH07XG4gIFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIjXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSB9O1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwicGFydGlhbFwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgLSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiUGFydGlhbCBkZWZpbml0aW9ucyBjYW4gb25seSBiZSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSB0ZW1wbGF0ZSwgb3IgaW1tZWRpYXRlbHkgaW5zaWRlIGNvbXBvbmVudHNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaGFuZGxlYmFyc0Jsb2NrUGF0dGVybikpIHtcbiAgXHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IGJsb2NrO1xuICBcdFx0XHRzZWN0aW9uLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1tibG9ja107XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb25cIik7XG4gIFx0fVxuXG4gIFx0Ly8gb3B0aW9uYWwgaW5kZXggYW5kIGtleSByZWZlcmVuY2VzXG4gIFx0aWYgKGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdHZhciBleHRyYSA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKGV4dHJhID0gcGFyc2VyLm1hdGNoUGF0dGVybihrZXlJbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGkgKyBcIixcIiArIGV4dHJhO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuICBcdGNoaWxkcmVuID0gc2VjdGlvbi5mO1xuXG4gIFx0Y29uZGl0aW9ucyA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgdGFnLm9wZW4gKyBcIi9cIiArIGV4cGVjdGVkQ2xvc2UgKyBcIlwiICsgdGFnLmNsb3NlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSByZWFkRWxzZUlmKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJpbGxlZ2FsIHt7ZWxzZWlmLi4ufX0gYWZ0ZXIge3tlbHNlfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucy5jb25jYXQoY2hpbGQueCkpKSxcbiAgXHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdGNvbmRpdGlvbnMucHVzaChpbnZlcnQoY2hpbGQueCkpO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZEVsc2UocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInRoZXJlIGNhbiBvbmx5IGJlIG9uZSB7e2Vsc2V9fSBibG9jaywgYXQgdGhlIGVuZCBvZiBhIHNlY3Rpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRoYXNFbHNlID0gdHJ1ZTtcblxuICBcdFx0XHQvLyB1c2UgYW4gdW5sZXNzIGJsb2NrIGlmIHRoZXJlJ3Mgbm8gZWxzZWlmXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdFx0Y2hpbGRyZW4gPSB1bmxlc3NCbG9jay5mO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMpKSxcbiAgXHRcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdGlmICh1bmxlc3NCbG9jaykge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYHdpdGhgIHNob3VsZCBiZWNvbWUgYGlmLXdpdGhgIChUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHQvLyBzZWVtcyB0byBtZSB0aGF0IGB3aXRoYCBvdWdodCB0byBiZWhhdmUgY29uc2lzdGVudGx5LCByZWdhcmRsZXNzXG4gIFx0XHQvLyBvZiB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiBgZWxzZWAuIEluIG90aGVyIHdvcmRzIHNob3VsZCBhbHdheXNcbiAgXHRcdC8vIGJlIGBpZi13aXRoYFxuICBcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IFNFQ1RJT05fSUZfV0lUSDtcbiAgXHRcdH1cblxuICBcdFx0c2VjdGlvbi5sID0gdW5sZXNzQmxvY2s7XG4gIFx0fVxuXG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBzZWN0aW9uKTtcblxuICBcdC8vIFRPRE8gaWYgYSBzZWN0aW9uIGlzIGVtcHR5IGl0IHNob3VsZCBiZSBkaXNjYXJkZWQuIERvbid0IGRvXG4gIFx0Ly8gdGhhdCBoZXJlIHRob3VnaCAtIHdlIG5lZWQgdG8gY2xlYW4gZXZlcnl0aGluZyB1cCBmaXJzdCwgYXNcbiAgXHQvLyBpdCBtYXkgY29udGFpbiByZW1vdmVhYmxlIHdoaXRlc3BhY2UuIEFzIGEgdGVtcG9yYXJ5IG1lYXN1cmUsXG4gIFx0Ly8gdG8gcGFzcyB0aGUgZXhpc3RpbmcgdGVzdHMsIHJlbW92ZSBlbXB0eSBgZmAgYXJyYXlzXG4gIFx0aWYgKCFzZWN0aW9uLmYubGVuZ3RoKSB7XG4gIFx0XHRkZWxldGUgc2VjdGlvbi5mO1xuICBcdH1cblxuICBcdHJldHVybiBzZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvblR5cGUpIHtcbiAgXHR2YXIgdW5sZXNzQmxvY2s7XG5cbiAgXHRpZiAoc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYSBge3sjd2l0aCBmb299fWAgc2VjdGlvbiB3aWxsIHJlbmRlciBpZiBgZm9vYCBpc1xuICBcdFx0Ly8gdHJ1dGh5LCBzbyB0aGUgYHt7ZWxzZX19YCBzZWN0aW9uIG5lZWRzIHRvIHJlbmRlciBpZiBgZm9vYCBpcyBmYWxzeSxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFkaGVyaW5nIHRvIHRoZSBub3JtYWwgYHt7I3VubGVzcyBmb299fWAgbG9naWMgKHdoaWNoXG4gIFx0XHQvLyB0cmVhdHMgZW1wdHkgYXJyYXlzL29iamVjdHMgYXMgZmFsc3kpXG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oaW52ZXJ0KGV4cHJlc3Npb24pLCB1bmxlc3NCbG9jayk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1VOTEVTUyxcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdW5sZXNzQmxvY2spO1xuICBcdH1cblxuICBcdHJldHVybiB1bmxlc3NCbG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChleHByZXNzaW9uKSB7XG4gIFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUFJFRklYX09QRVJBVE9SICYmIGV4cHJlc3Npb24ucyA9PT0gXCIhXCIpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uLm87XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFBSRUZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiIVwiLFxuICBcdFx0bzogcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gbXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMpIHtcbiAgXHRpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0czogXCImJlwiLFxuICBcdFx0bzogW3BhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb25zWzBdKSwgcGFyZW5zSWZOZWNlc3NhcnkobXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMuc2xpY2UoMSkpKV1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbikge1xuICBcdC8vIFRPRE8gb25seSB3cmFwIGlmIG5lY2Vzc2FyeVxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRIdG1sQ29tbWVudCA9IHJlYWRIdG1sQ29tbWVudDtcbiAgdmFyIE9QRU5fQ09NTUVOVCA9IFwiPCEtLVwiLFxuICAgICAgQ0xPU0VfQ09NTUVOVCA9IFwiLS0+XCI7XG4gIGZ1bmN0aW9uIHJlYWRIdG1sQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhPUEVOX0NPTU1FTlQpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihDTE9TRV9DT01NRU5UKTtcblxuICBcdGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoJy0tPicpXCIpO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKDAsIGVuZEluZGV4KTtcbiAgXHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblxuICBcdGNvbW1lbnQgPSB7XG4gIFx0XHR0OiBDT01NRU5ULFxuICBcdFx0YzogY29udGVudFxuICBcdH07XG5cbiAgXHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICB2YXIgYm9vbGVhbkF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50TmFtZXMsIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm4sIGxlc3NUaGFuLCBncmVhdGVyVGhhbiwgYW1wO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG4gIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG4gIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXG4gIGh0bWxFbnRpdGllcyA9IHsgcXVvdDogMzQsIGFtcDogMzgsIGFwb3M6IDM5LCBsdDogNjAsIGd0OiA2MiwgbmJzcDogMTYwLCBpZXhjbDogMTYxLCBjZW50OiAxNjIsIHBvdW5kOiAxNjMsIGN1cnJlbjogMTY0LCB5ZW46IDE2NSwgYnJ2YmFyOiAxNjYsIHNlY3Q6IDE2NywgdW1sOiAxNjgsIGNvcHk6IDE2OSwgb3JkZjogMTcwLCBsYXF1bzogMTcxLCBub3Q6IDE3Miwgc2h5OiAxNzMsIHJlZzogMTc0LCBtYWNyOiAxNzUsIGRlZzogMTc2LCBwbHVzbW46IDE3Nywgc3VwMjogMTc4LCBzdXAzOiAxNzksIGFjdXRlOiAxODAsIG1pY3JvOiAxODEsIHBhcmE6IDE4MiwgbWlkZG90OiAxODMsIGNlZGlsOiAxODQsIHN1cDE6IDE4NSwgb3JkbTogMTg2LCByYXF1bzogMTg3LCBmcmFjMTQ6IDE4OCwgZnJhYzEyOiAxODksIGZyYWMzNDogMTkwLCBpcXVlc3Q6IDE5MSwgQWdyYXZlOiAxOTIsIEFhY3V0ZTogMTkzLCBBY2lyYzogMTk0LCBBdGlsZGU6IDE5NSwgQXVtbDogMTk2LCBBcmluZzogMTk3LCBBRWxpZzogMTk4LCBDY2VkaWw6IDE5OSwgRWdyYXZlOiAyMDAsIEVhY3V0ZTogMjAxLCBFY2lyYzogMjAyLCBFdW1sOiAyMDMsIElncmF2ZTogMjA0LCBJYWN1dGU6IDIwNSwgSWNpcmM6IDIwNiwgSXVtbDogMjA3LCBFVEg6IDIwOCwgTnRpbGRlOiAyMDksIE9ncmF2ZTogMjEwLCBPYWN1dGU6IDIxMSwgT2NpcmM6IDIxMiwgT3RpbGRlOiAyMTMsIE91bWw6IDIxNCwgdGltZXM6IDIxNSwgT3NsYXNoOiAyMTYsIFVncmF2ZTogMjE3LCBVYWN1dGU6IDIxOCwgVWNpcmM6IDIxOSwgVXVtbDogMjIwLCBZYWN1dGU6IDIyMSwgVEhPUk46IDIyMiwgc3psaWc6IDIyMywgYWdyYXZlOiAyMjQsIGFhY3V0ZTogMjI1LCBhY2lyYzogMjI2LCBhdGlsZGU6IDIyNywgYXVtbDogMjI4LCBhcmluZzogMjI5LCBhZWxpZzogMjMwLCBjY2VkaWw6IDIzMSwgZWdyYXZlOiAyMzIsIGVhY3V0ZTogMjMzLCBlY2lyYzogMjM0LCBldW1sOiAyMzUsIGlncmF2ZTogMjM2LCBpYWN1dGU6IDIzNywgaWNpcmM6IDIzOCwgaXVtbDogMjM5LCBldGg6IDI0MCwgbnRpbGRlOiAyNDEsIG9ncmF2ZTogMjQyLCBvYWN1dGU6IDI0Mywgb2NpcmM6IDI0NCwgb3RpbGRlOiAyNDUsIG91bWw6IDI0NiwgZGl2aWRlOiAyNDcsIG9zbGFzaDogMjQ4LCB1Z3JhdmU6IDI0OSwgdWFjdXRlOiAyNTAsIHVjaXJjOiAyNTEsIHV1bWw6IDI1MiwgeWFjdXRlOiAyNTMsIHRob3JuOiAyNTQsIHl1bWw6IDI1NSwgT0VsaWc6IDMzOCwgb2VsaWc6IDMzOSwgU2Nhcm9uOiAzNTIsIHNjYXJvbjogMzUzLCBZdW1sOiAzNzYsIGZub2Y6IDQwMiwgY2lyYzogNzEwLCB0aWxkZTogNzMyLCBBbHBoYTogOTEzLCBCZXRhOiA5MTQsIEdhbW1hOiA5MTUsIERlbHRhOiA5MTYsIEVwc2lsb246IDkxNywgWmV0YTogOTE4LCBFdGE6IDkxOSwgVGhldGE6IDkyMCwgSW90YTogOTIxLCBLYXBwYTogOTIyLCBMYW1iZGE6IDkyMywgTXU6IDkyNCwgTnU6IDkyNSwgWGk6IDkyNiwgT21pY3JvbjogOTI3LCBQaTogOTI4LCBSaG86IDkyOSwgU2lnbWE6IDkzMSwgVGF1OiA5MzIsIFVwc2lsb246IDkzMywgUGhpOiA5MzQsIENoaTogOTM1LCBQc2k6IDkzNiwgT21lZ2E6IDkzNywgYWxwaGE6IDk0NSwgYmV0YTogOTQ2LCBnYW1tYTogOTQ3LCBkZWx0YTogOTQ4LCBlcHNpbG9uOiA5NDksIHpldGE6IDk1MCwgZXRhOiA5NTEsIHRoZXRhOiA5NTIsIGlvdGE6IDk1Mywga2FwcGE6IDk1NCwgbGFtYmRhOiA5NTUsIG11OiA5NTYsIG51OiA5NTcsIHhpOiA5NTgsIG9taWNyb246IDk1OSwgcGk6IDk2MCwgcmhvOiA5NjEsIHNpZ21hZjogOTYyLCBzaWdtYTogOTYzLCB0YXU6IDk2NCwgdXBzaWxvbjogOTY1LCBwaGk6IDk2NiwgY2hpOiA5NjcsIHBzaTogOTY4LCBvbWVnYTogOTY5LCB0aGV0YXN5bTogOTc3LCB1cHNpaDogOTc4LCBwaXY6IDk4MiwgZW5zcDogODE5NCwgZW1zcDogODE5NSwgdGhpbnNwOiA4MjAxLCB6d25qOiA4MjA0LCB6d2o6IDgyMDUsIGxybTogODIwNiwgcmxtOiA4MjA3LCBuZGFzaDogODIxMSwgbWRhc2g6IDgyMTIsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBidWxsOiA4MjI2LCBoZWxsaXA6IDgyMzAsIHBlcm1pbDogODI0MCwgcHJpbWU6IDgyNDIsIFByaW1lOiA4MjQzLCBsc2FxdW86IDgyNDksIHJzYXF1bzogODI1MCwgb2xpbmU6IDgyNTQsIGZyYXNsOiA4MjYwLCBldXJvOiA4MzY0LCBpbWFnZTogODQ2NSwgd2VpZXJwOiA4NDcyLCByZWFsOiA4NDc2LCB0cmFkZTogODQ4MiwgYWxlZnN5bTogODUwMSwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGFycjogODU5NiwgY3JhcnI6IDg2MjksIGxBcnI6IDg2NTYsIHVBcnI6IDg2NTcsIHJBcnI6IDg2NTgsIGRBcnI6IDg2NTksIGhBcnI6IDg2NjAsIGZvcmFsbDogODcwNCwgcGFydDogODcwNiwgZXhpc3Q6IDg3MDcsIGVtcHR5OiA4NzA5LCBuYWJsYTogODcxMSwgaXNpbjogODcxMiwgbm90aW46IDg3MTMsIG5pOiA4NzE1LCBwcm9kOiA4NzE5LCBzdW06IDg3MjEsIG1pbnVzOiA4NzIyLCBsb3dhc3Q6IDg3MjcsIHJhZGljOiA4NzMwLCBwcm9wOiA4NzMzLCBpbmZpbjogODczNCwgYW5nOiA4NzM2LCBhbmQ6IDg3NDMsIG9yOiA4NzQ0LCBjYXA6IDg3NDUsIGN1cDogODc0NiwgaW50OiA4NzQ3LCB0aGVyZTQ6IDg3NTYsIHNpbTogODc2NCwgY29uZzogODc3MywgYXN5bXA6IDg3NzYsIG5lOiA4ODAwLCBlcXVpdjogODgwMSwgbGU6IDg4MDQsIGdlOiA4ODA1LCBzdWI6IDg4MzQsIHN1cDogODgzNSwgbnN1YjogODgzNiwgc3ViZTogODgzOCwgc3VwZTogODgzOSwgb3BsdXM6IDg4NTMsIG90aW1lczogODg1NSwgcGVycDogODg2OSwgc2RvdDogODkwMSwgbGNlaWw6IDg5NjgsIHJjZWlsOiA4OTY5LCBsZmxvb3I6IDg5NzAsIHJmbG9vcjogODk3MSwgbGFuZzogOTAwMSwgcmFuZzogOTAwMiwgbG96OiA5Njc0LCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwIH07XG4gIGNvbnRyb2xDaGFyYWN0ZXJzID0gWzgzNjQsIDEyOSwgODIxOCwgNDAyLCA4MjIyLCA4MjMwLCA4MjI0LCA4MjI1LCA3MTAsIDgyNDAsIDM1MiwgODI0OSwgMzM4LCAxNDEsIDM4MSwgMTQzLCAxNDQsIDgyMTYsIDgyMTcsIDgyMjAsIDgyMjEsIDgyMjYsIDgyMTEsIDgyMTIsIDczMiwgODQ4MiwgMzUzLCA4MjUwLCAzMzksIDE1NywgMzgyLCAzNzZdO1xuICBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIiYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8XCIgKyBPYmplY3Qua2V5cyhodG1sRW50aXRpZXMpLmpvaW4oXCJ8XCIpICsgXCIpKTs/XCIsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKGh0bWwpIHtcbiAgXHRyZXR1cm4gaHRtbC5yZXBsYWNlKGVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgZW50aXR5KSB7XG4gIFx0XHR2YXIgY29kZTtcblxuICBcdFx0Ly8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG4gIFx0XHRpZiAoZW50aXR5WzBdICE9PSBcIiNcIikge1xuICBcdFx0XHRjb2RlID0gaHRtbEVudGl0aWVzW2VudGl0eV07XG4gIFx0XHR9IGVsc2UgaWYgKGVudGl0eVsxXSA9PT0gXCJ4XCIpIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDEpLCAxMCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghY29kZSkge1xuICBcdFx0XHRyZXR1cm4gbWF0Y2g7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbGlkYXRlQ29kZShjb2RlKSk7XG4gIFx0fSk7XG4gIH1cblxuICAvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuICAvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG4gIC8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcbiAgLy9cbiAgLy8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcbiAgZnVuY3Rpb24gdmFsaWRhdGVDb2RlKGNvZGUpIHtcbiAgXHRpZiAoIWNvZGUpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2VcbiAgXHRpZiAoY29kZSA9PT0gMTApIHtcbiAgXHRcdHJldHVybiAzMjtcbiAgXHR9XG5cbiAgXHQvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuICBcdGlmIChjb2RlIDwgMTI4KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gIFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgXHRpZiAoY29kZSA8PSAxNTkpIHtcbiAgXHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1tjb2RlIC0gMTI4XTtcbiAgXHR9XG5cbiAgXHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8IDU1Mjk2KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICBcdGlmIChjb2RlIDw9IDU3MzQzKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzdCBvZiB0aGUgYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdHJldHVybiA2NTUzMztcbiAgfVxuXG4gIGxlc3NUaGFuID0gLzwvZztcbiAgZ3JlYXRlclRoYW4gPSAvPi9nO1xuICBhbXAgPSAvJi9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKGFtcCwgXCImYW1wO1wiKS5yZXBsYWNlKGxlc3NUaGFuLCBcIiZsdDtcIikucmVwbGFjZShncmVhdGVyVGhhbiwgXCImZ3Q7XCIpO1xuICB9XG5cbiAgdmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcbiAgICAgIHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cbiAgdmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXG4gIFx0Zm9yIChpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRjdXJyZW50ID0gaXRlbXNbaV07XG4gIFx0XHRiYWNrT25lID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0YmFja1R3byA9IGl0ZW1zW2kgLSAyXTtcblxuICBcdFx0Ly8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiBhIFt0ZXh0XVtjb21tZW50XVt0ZXh0XSBzZXF1ZW5jZS4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzQ29tbWVudChiYWNrT25lKSAmJiBpc1N0cmluZyhiYWNrVHdvKSkge1xuXG4gIFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrVHdvKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcblxuICBcdFx0XHRcdC8vIC4uLiB0aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBmaXJzdCBsaW5lIGJyZWFrXG4gIFx0XHRcdFx0aXRlbXNbaSAtIDJdID0gYmFja1R3by5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcblxuICBcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgcHJlY2VkZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1NlY3Rpb24oY3VycmVudCkgJiYgaXNTdHJpbmcoYmFja09uZSkpIHtcbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja09uZSkgJiYgaXNTdHJpbmcoY3VycmVudC5mWzBdKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudC5mWzBdKSkge1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAxXSA9IGJhY2tPbmUucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0Y3VycmVudC5mWzBdID0gY3VycmVudC5mWzBdLnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzU2VjdGlvbihiYWNrT25lKSkge1xuICBcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBsYXN0SXRlbShiYWNrT25lLmYpO1xuXG4gIFx0XHRcdGlmIChpc1N0cmluZyhsYXN0U2VjdGlvbkl0ZW0pICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QobGFzdFNlY3Rpb25JdGVtKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcbiAgXHRcdFx0XHRiYWNrT25lLmZbYmFja09uZS5mLmxlbmd0aCAtIDFdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbW1lbnQoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnQgPT09IENPTU1FTlQgfHwgaXRlbS50ID09PSBERUxJTUNIQU5HRTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VjdGlvbihpdGVtKSB7XG4gIFx0cmV0dXJuIChpdGVtLnQgPT09IFNFQ1RJT04gfHwgaXRlbS50ID09PSBJTlZFUlRFRCkgJiYgaXRlbS5mO1xuICB9XG5cbiAgdmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24gKGl0ZW1zLCBsZWFkaW5nUGF0dGVybiwgdHJhaWxpbmdQYXR0ZXJuKSB7XG4gIFx0dmFyIGl0ZW07XG5cbiAgXHRpZiAobGVhZGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1swXTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKGxlYWRpbmdQYXR0ZXJuLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zWzBdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0cmFpbGluZ1BhdHRlcm4pIHtcbiAgXHRcdGl0ZW0gPSBsYXN0SXRlbShpdGVtcyk7XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSh0cmFpbGluZ1BhdHRlcm4sIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgdXRpbHNfY2xlYW51cCA9IGNsZWFudXA7XG4gIHZhciBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2c7XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2k7XG4gIHZhciB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy87XG4gIHZhciB0cmFpbGluZ1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKyQvO1xuICB2YXIgbGVhZGluZ05ld0xpbmUgPSAvXig/OlxcclxcbnxcXHJ8XFxuKS87XG4gIHZhciB0cmFpbGluZ05ld0xpbmUgPSAvKD86XFxyXFxufFxccnxcXG4pJC87XG4gIGZ1bmN0aW9uIGNsZWFudXAoaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSkge1xuICBcdHZhciBpLCBpdGVtLCBwcmV2aW91c0l0ZW0sIG5leHRJdGVtLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIGtleTtcblxuICBcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuICBcdHN0cmlwU3RhbmRhbG9uZXMoaXRlbXMpO1xuXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuICBcdFx0aWYgKGl0ZW0uZXhjbHVkZSkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFJlbW92ZSBjb21tZW50cywgdW5sZXNzIHdlIHdhbnQgdG8ga2VlcCB0aGVtXG4gIFx0XHRlbHNlIGlmIChzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gQ09NTUVOVCkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBcdHRyaW1XaGl0ZXNwYWNlKGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSA/IHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlIDogbnVsbCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlID8gdHJhaWxpbmdXaGl0ZXNwYWNlIDogbnVsbCk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVjdXJzZVxuICBcdFx0aWYgKGl0ZW0uZikge1xuICBcdFx0XHR2YXIgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50ID0gaXRlbS50ID09PSBFTEVNRU5UICYmIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzLnRlc3QoaXRlbS5lKTtcbiAgXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50O1xuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlICYmIGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudCkge1xuICBcdFx0XHRcdHRyaW1XaGl0ZXNwYWNlKGl0ZW0uZiwgbGVhZGluZ05ld0xpbmUsIHRyYWlsaW5nTmV3TGluZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbaSArIDFdO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gd2FzIGEgdGV4dCBpdGVtIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSxcbiAgXHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcbiAgXHRcdFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSBcInN0cmluZ1wiICYmIHRyYWlsaW5nV2hpdGVzcGFjZS50ZXN0KHByZXZpb3VzSXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG4gIFx0XHRcdFx0aWYgKCFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09IFwic3RyaW5nXCIgJiYgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UudGVzdChuZXh0SXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKGl0ZW0uZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuICBcdFx0aWYgKGl0ZW0ubCkge1xuICBcdFx0XHRjbGVhbnVwKGl0ZW0ubC5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcblxuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSArIDEsIDAsIGl0ZW0ubCk7XG4gIFx0XHRcdGRlbGV0ZSBpdGVtLmw7IC8vIFRPRE8gd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgYSB3YXkgYXJvdW5kIHRoaXNcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5hKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIGl0ZW0uYSkge1xuICBcdFx0XHRcdGlmIChpdGVtLmEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgaXRlbS5hW2tleV0gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRcdGNsZWFudXAoaXRlbS5hW2tleV0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBjb25kaXRpb25hbCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5tKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5tLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZXZlbnQgaGFuZGxlcnNcbiAgXHRcdGlmIChpdGVtLnYpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS52KSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0udi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBuYW1lc1xuICBcdFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS52W2tleV0ubikpIHtcbiAgXHRcdFx0XHRcdFx0Y2xlYW51cChpdGVtLnZba2V5XS5uLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Ly8gY2xlYW4gdXAgcGFyYW1zXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5kKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLmQsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbXNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aWYgKHR5cGVvZiBpdGVtc1tpICsgMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldICsgaXRlbXNbaSArIDFdO1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZSkge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0ucmVwbGFjZShjb250aWd1b3VzV2hpdGVzcGFjZSwgXCIgXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGl0ZW1zW2ldID09PSBcIlwiKSB7XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGVsZW1lbnRfcmVhZENsb3NpbmdUYWcgPSByZWFkQ2xvc2luZ1RhZztcbiAgdmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nVGFnKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGFnO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjwvXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAodGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybihjbG9zaW5nVGFnUGF0dGVybikpIHtcbiAgXHRcdGlmIChwYXJzZXIuaW5zaWRlICYmIHRhZyAhPT0gcGFyc2VyLmluc2lkZSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBDTE9TSU5HX1RBRyxcbiAgXHRcdFx0ZTogdGFnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG4gIFx0cGFyc2VyLnBvcyAtPSAyO1xuICBcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgY2xvc2luZyB0YWdcIik7XG4gIH1cblxuICB2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZXMpIHtcbiAgXHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblxuICBcdGkgPSBuZWVkbGVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlc1tpXSk7XG5cbiAgXHRcdC8vIHNob3J0IGNpcmN1aXRcbiAgXHRcdGlmICghaW5kZXgpIHtcbiAgXHRcdFx0cmV0dXJuIDA7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0KSB7XG4gIFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBsb3dlc3QgfHwgLTE7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRfcmVhZEF0dHJpYnV0ZSA9IHJlYWRBdHRyaWJ1dGU7XG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuICAgICAgdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGUocGFyc2VyKSB7XG4gIFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oYXR0cmlidXRlTmFtZVBhdHRlcm4pO1xuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0YXR0ciA9IHsgbmFtZTogbmFtZSB9O1xuXG4gIFx0dmFsdWUgPSByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgIT0gbnVsbCkge1xuICBcdFx0Ly8gbm90IG51bGwvdW5kZWZpbmVkXG4gIFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXG4gIFx0aWYgKCEvWz1cXC8+XFxzXS8udGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlU3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXG4gIFx0dmFsdWUgPSByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIidcIikgfHwgcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgXCJcXFwiXCIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcik7XG5cbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIHZhbGlkIGF0dHJpYnV0ZSB2YWx1ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3NcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyh2YWx1ZVswXSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHRleHQsIGhheXN0YWNrLCBuZWVkbGVzLCBpbmRleDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybik7XG5cbiAgXHRpZiAoIXRleHQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGhheXN0YWNrID0gdGV4dDtcbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdH0pOyAvLyBUT0RPIHJlZmFjdG9yLi4uIHdlIGRvIHRoaXMgaW4gcmVhZFRleHQuanMgYXMgd2VsbFxuXG4gIFx0aWYgKChpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKSkgIT09IC0xKSB7XG4gIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaW5kZXgpO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW5zLCB0b2tlbjtcblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghdG9rZW5zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyayk7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhxdW90ZU1hcmspKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspIHtcbiAgXHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG4gIFx0bmVlZGxlcy5wdXNoKHF1b3RlTWFyayk7XG5cbiAgXHRpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIlF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuICBcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoMCwgaW5kZXgpO1xuICB9XG5cbiAgdmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblxuICBzcGVjaWFscyA9IHtcbiAgXHRcInRydWVcIjogdHJ1ZSxcbiAgXHRcImZhbHNlXCI6IGZhbHNlLFxuICBcdHVuZGVmaW5lZDogdW5kZWZpbmVkLFxuICBcdFwibnVsbFwiOiBudWxsXG4gIH07XG5cbiAgc3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9iamVjdC5rZXlzKHNwZWNpYWxzKS5qb2luKFwifFwiKSArIFwiKVwiKTtcbiAgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgcGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuICBvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXG4gIEpzb25QYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICBcdFx0dGhpcy5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdGlmIChyZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KHRoaXMubGVmdG92ZXIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4geyB2YWx1ZTogcmVzdWx0WzBdLnYgfTtcbiAgXHR9LFxuXG4gIFx0Y29udmVydGVyczogW2Z1bmN0aW9uIGdldFBsYWNlaG9sZGVyKHBhcnNlcikge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci52YWx1ZXMpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybihwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuKTtcblxuICBcdFx0aWYgKHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkocGxhY2Vob2xkZXIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHBhcnNlci52YWx1ZXNbcGxhY2Vob2xkZXJdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3BlY2lhbChwYXJzZXIpIHtcbiAgXHRcdHZhciBzcGVjaWFsO1xuXG4gIFx0XHRpZiAoc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3BlY2lhbHNQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiBzcGVjaWFsc1tzcGVjaWFsXSB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldE51bWJlcihwYXJzZXIpIHtcbiAgXHRcdHZhciBudW1iZXI7XG5cbiAgXHRcdGlmIChudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogK251bWJlciB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldFN0cmluZyhwYXJzZXIpIHtcbiAgXHRcdHZhciBzdHJpbmdMaXRlcmFsID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSxcbiAgXHRcdCAgICB2YWx1ZXM7XG5cbiAgXHRcdGlmIChzdHJpbmdMaXRlcmFsICYmICh2YWx1ZXMgPSBwYXJzZXIudmFsdWVzKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1skMV0gOiAkMTtcbiAgXHRcdFx0XHR9KVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRPYmplY3QocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IHt9O1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAocGFpciA9IGdldEtleVZhbHVlUGFpcihwYXJzZXIpKSB7XG4gIFx0XHRcdHJlc3VsdFtwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSwgZnVuY3Rpb24gZ2V0QXJyYXkocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IFtdO1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAodmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2godmFsdWVUb2tlbi52KTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWtleSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpciA9IHsga2V5OiBrZXkgfTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcbiAgXHRpZiAoIXZhbHVlVG9rZW4pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cbiAgXHRyZXR1cm4gcGFpcjtcbiAgfVxuXG4gIHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiAoc3RyLCB2YWx1ZXMpIHtcbiAgXHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoc3RyLCB7XG4gIFx0XHR2YWx1ZXM6IHZhbHVlc1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG4gIH07XG5cbiAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG4gIHZhciBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlO1xuICB2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcbiAgICAgIG1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuID0gL1xcKVxccyokLyxcbiAgICAgIEV4cHJlc3Npb25QYXJzZXI7XG5cbiAgRXhwcmVzc2lvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uXVxuICB9KTtcbiAgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdGl2ZSh0b2tlbnMsIHBhcmVudFBhcnNlcikge1xuICBcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cbiAgXHRpZiAodHlwZW9mIHRva2VucyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyh0b2tlbnMpKSB7XG4gIFx0XHRcdHZhciBlbmQgPSB0b2tlbnMubGFzdEluZGV4T2YoXCIpXCIpO1xuXG4gIFx0XHRcdC8vIGNoZWNrIGZvciBpbnZhbGlkIG1ldGhvZCBjYWxsc1xuICBcdFx0XHRpZiAoIW1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuLnRlc3QodG9rZW5zKSkge1xuICBcdFx0XHRcdHBhcmVudFBhcnNlci5lcnJvcihcIkludmFsaWQgaW5wdXQgYWZ0ZXIgbWV0aG9kIGNhbGwgZXhwcmVzc2lvbiAnXCIgKyB0b2tlbnMuc2xpY2UoZW5kICsgMSkgKyBcIidcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXN1bHQgPSB7IG06IG1hdGNoWzFdIH07XG4gIFx0XHRcdGFyZ3MgPSBcIltcIiArIHRva2Vucy5zbGljZShyZXN1bHQubS5sZW5ndGggKyAxLCBlbmQpICsgXCJdXCI7XG5cbiAgXHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYXJncyk7XG4gIFx0XHRcdHJlc3VsdC5hID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocGFyc2VyLnJlc3VsdFswXSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRva2Vucy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmV0dXJuIHRva2Vucy50cmltKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRva2VucyA9IFt0b2tlbnNdO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IHt9O1xuXG4gIFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuICBcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICBcdGlmICh0b2tlbnMpIHtcbiAgXHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKFwiOlwiKTtcblxuICBcdFx0XHRcdGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gIFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cbiAgXHRcdFx0XHRcdGlmIChjb2xvbkluZGV4KSB7XG4gIFx0XHRcdFx0XHRcdC8vIG5vXG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbi5zdWJzdHIoMCwgY29sb25JbmRleCkpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcbiAgXHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuICBcdFx0XHRcdFx0aWYgKHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxKSB7XG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbMF0gPSB0b2tlbi5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQodG9rZW5zKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWRpcmVjdGl2ZU5hbWUubGVuZ3RoKSB7XG4gIFx0XHRyZXN1bHQgPSBcIlwiO1xuICBcdH0gZWxzZSBpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggfHwgdHlwZW9mIGRpcmVjdGl2ZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlc3VsdCA9IHtcbiAgXHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IGp1c3QgdXNlIHRoZSBhcnJheVxuICBcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVswXSA9PT0gXCJzdHJpbmdcIiA/IGRpcmVjdGl2ZU5hbWVbMF0gOiBkaXJlY3RpdmVOYW1lXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgZGlyZWN0aXZlQXJnc1swXSArIFwiXVwiKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBkaXJlY3RpdmVBcmdzWzBdLnRyaW0oKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdC5kID0gZGlyZWN0aXZlQXJncztcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZGlyZWN0aXZlTmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG4gICAgICB2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcbiAgICAgIG9uUGF0dGVybiA9IC9eb24vLFxuICAgICAgcHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcbiAgICAgIHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG4gICAgICBkaXJlY3RpdmVzID0geyBcImludHJvLW91dHJvXCI6IFwidDBcIiwgaW50cm86IFwidDFcIiwgb3V0cm86IFwidDJcIiwgZGVjb3JhdG9yOiBcIm9cIiB9LFxuICAgICAgZXhjbHVkZSA9IHsgZXhjbHVkZTogdHJ1ZSB9LFxuICAgICAgZGlzYWxsb3dlZENvbnRlbnRzO1xuXG4gIC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuICBkaXNhbGxvd2VkQ29udGVudHMgPSB7XG4gIFx0bGk6IFtcImxpXCJdLFxuICBcdGR0OiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdGRkOiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdHA6IFwiYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsXCIuc3BsaXQoXCIgXCIpLFxuICBcdHJ0OiBbXCJydFwiLCBcInJwXCJdLFxuICBcdHJwOiBbXCJydFwiLCBcInJwXCJdLFxuICBcdG9wdGdyb3VwOiBbXCJvcHRncm91cFwiXSxcbiAgXHRvcHRpb246IFtcIm9wdGlvblwiLCBcIm9wdGdyb3VwXCJdLFxuICBcdHRoZWFkOiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRib2R5OiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRmb290OiBbXCJ0Ym9keVwiXSxcbiAgXHR0cjogW1widHJcIiwgXCJ0Ym9keVwiXSxcbiAgXHR0ZDogW1widGRcIiwgXCJ0aFwiLCBcInRyXCJdLFxuICBcdHRoOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl1cbiAgfTtcblxuICB2YXIgY29udmVydGVyc19yZWFkRWxlbWVudCA9IHJlYWRFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHJlYWRFbGVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZWxlbWVudCwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIHBhcnRpYWxzLCBoYXNQYXJ0aWFscywgY2hpbGQsIGNsb3NlZCwgcG9zLCByZW1haW5pbmcsIGNsb3NpbmdUYWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSB8fCBwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG4gIFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIi9cIikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudCA9IHt9O1xuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGVsZW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0ZWxlbWVudC50ID0gRE9DVFlQRTtcbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybigvXmRvY3R5cGUvaSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgRE9DVFlQRSBkZWNsYXJhdGlvblwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC5hID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXiguKz8pPi8pO1xuICBcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudC50ID0gRUxFTUVOVDtcblxuICBcdC8vIGVsZW1lbnQgbmFtZVxuICBcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4odGFnTmFtZVBhdHRlcm4pO1xuICBcdGlmICghZWxlbWVudC5lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcbiAgXHRpZiAoIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QocGFyc2VyLm5leHRDaGFyKCkpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIHRhZyBuYW1lXCIpO1xuICBcdH1cblxuICBcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGlyZWN0aXZlKSB7XG4gIFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblxuICBcdFx0aWYgKHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KGRpcmVjdGl2ZU5hbWUpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkNhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydClcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQudltuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgXHR9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuICBcdHdoaWxlIChhdHRyaWJ1dGUgPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IGVsZW1lbnRfcmVhZEF0dHJpYnV0ZShwYXJzZXIpKSB7XG4gIFx0XHQvLyByZWd1bGFyIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChhdHRyaWJ1dGUubmFtZSkge1xuICBcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuICBcdFx0XHRpZiAoZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gIFx0XHRcdFx0ZWxlbWVudFtkaXJlY3RpdmVOYW1lXSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvbi1jbGljayBldGNcbiAgXHRcdFx0ZWxzZSBpZiAobWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdGlmICghZWxlbWVudC52KSBlbGVtZW50LnYgPSB7fTtcbiAgXHRcdFx0XHRkaXJlY3RpdmUgPSBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUoYXR0cmlidXRlLnZhbHVlLCBwYXJzZXIpO1xuICBcdFx0XHRcdGFkZFByb3h5RXZlbnQobWF0Y2hbMV0sIGRpcmVjdGl2ZSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdFx0aWYgKCFlbGVtZW50LmEpIGVsZW1lbnQuYSA9IHt9O1xuICBcdFx0XHRcdFx0ZWxlbWVudC5hW2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAoYXR0cmlidXRlLnZhbHVlID09PSBcIlwiID8gXCJcIiA6IDApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB7eyNpZiBmb299fWNsYXNzPSdmb28ne3svaWZ9fVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGlmICghZWxlbWVudC5tKSBlbGVtZW50Lm0gPSBbXTtcbiAgXHRcdFx0ZWxlbWVudC5tLnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuICBcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBwYXJzZXIucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gIFx0aWYgKCFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KGVsZW1lbnQuZSkpIHtcbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucHVzaChsb3dlckNhc2VOYW1lKTtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG4gIFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuICBcdFx0aWYgKGxvd2VyQ2FzZU5hbWUgPT09IFwic2NyaXB0XCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHRjaGlsZHJlbiA9IFtdO1xuICBcdFx0cGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0cG9zID0gcGFyc2VyLnBvcztcbiAgXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0XHRcdC8vIGlmIGZvciBleGFtcGxlIHdlJ3JlIGluIGFuIDxsaT4gZWxlbWVudCwgYW5kIHdlIHNlZSBhbm90aGVyXG4gIFx0XHRcdC8vIDxsaT4gdGFnLCBjbG9zZSB0aGUgZmlyc3Qgc28gdGhleSBiZWNvbWUgc2libGluZ3NcbiAgXHRcdFx0aWYgKCFjYW5Db250YWluKGxvd2VyQ2FzZU5hbWUsIHJlbWFpbmluZykpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY2xvc2luZyB0YWdcbiAgXHRcdFx0ZWxzZSBpZiAoY2xvc2luZ1RhZyA9IGVsZW1lbnRfcmVhZENsb3NpbmdUYWcocGFyc2VyKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHR2YXIgY2xvc2luZ1RhZ05hbWUgPSBjbG9zaW5nVGFnLmUudG9Mb3dlckNhc2UoKTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMgKmlzbid0KiB0aGUgY2xvc2luZyB0YWcgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgXHRcdFx0XHRpZiAoY2xvc2luZ1RhZ05hbWUgIT09IGxvd2VyQ2FzZU5hbWUpIHtcbiAgXHRcdFx0XHRcdC8vIHJld2luZCBwYXJzZXJcbiAgXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cbiAgXHRcdFx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgY2xvc2UgYSBwYXJlbnQgdGFnLCBlcnJvclxuICBcdFx0XHRcdFx0aWYgKCEgfnBhcnNlci5lbGVtZW50U3RhY2suaW5kZXhPZihjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZ1wiO1xuXG4gIFx0XHRcdFx0XHRcdC8vIGFkZCBhZGRpdGlvbmFsIGhlbHAgZm9yIHZvaWQgZWxlbWVudHMsIHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICBcdFx0XHRcdFx0XHQvLyBtaWdodCBjbGFzaCB3aXRoIHRoZW1cbiAgXHRcdFx0XHRcdFx0aWYgKHZvaWRFbGVtZW50TmFtZXMudGVzdChjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgKz0gXCIgKDxcIiArIGNsb3NpbmdUYWdOYW1lICsgXCI+IGlzIGEgdm9pZCBlbGVtZW50IC0gaXQgY2Fubm90IGNvbnRhaW4gY2hpbGRyZW4pXCI7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpbXBsaWNpdCBjbG9zZSBieSBjbG9zaW5nIHNlY3Rpb24gdGFnLiBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdFx0ZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRpZiAocGFydGlhbHNbY2hpbGQubl0pIHtcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dXRpbHNfY2xlYW51cChjaGlsZC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRcdFx0cGFydGlhbHNbY2hpbGQubl0gPSBjaGlsZC5mO1xuICBcdFx0XHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICBcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRcdGVsZW1lbnQucCA9IHBhcnRpYWxzO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZWxlbWVudFN0YWNrLnBvcCgpO1xuICBcdH1cblxuICBcdHBhcnNlci5pbnNpZGUgPSBudWxsO1xuXG4gIFx0aWYgKHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YobG93ZXJDYXNlTmFtZSkgIT09IC0xKSB7XG4gIFx0XHRyZXR1cm4gZXhjbHVkZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkNvbnRhaW4obmFtZSwgcmVtYWluaW5nKSB7XG4gIFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXG4gIFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKHJlbWFpbmluZyk7XG4gIFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1tuYW1lXTtcblxuICBcdGlmICghbWF0Y2ggfHwgIWRpc2FsbG93ZWQpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdHJldHVybiAhIH5kaXNhbGxvd2VkLmluZGV4T2YobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGV4dCA9IHJlYWRUZXh0O1xuICBmdW5jdGlvbiByZWFkVGV4dChwYXJzZXIpIHtcbiAgXHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gXCI8L1wiICsgcGFyc2VyLmluc2lkZSA6IFwiPFwiO1xuXG4gIFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSkge1xuICBcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihiYXJyaWVyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGlzYWxsb3dlZCA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdFx0fSk7XG4gIFx0XHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZC5jb25jYXQocGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBcIlxcXFxcIiArIHQub3BlbjtcbiAgXHRcdH0pKTtcblxuICBcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuICBcdFx0aWYgKHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChcIlxcXCJcIiwgXCInXCIsIFwiPVwiLCBcIjxcIiwgXCI+XCIsIFwiYFwiKTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLmluQXR0cmlidXRlKSB7XG4gIFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKHBhcnNlci5pbkF0dHJpYnV0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2goYmFycmllcik7XG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgocmVtYWluaW5nLCBkaXNhbGxvd2VkKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdHJldHVybiBwYXJzZXIuaW5zaWRlID8gcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpKTtcbiAgfVxuXG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4gPSAvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZztcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZSh1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4sIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQ7XG5cbiAgdmFyIHN0YXJ0UGF0dGVybiA9IC9ePCEtLVxccyovLFxuICAgICAgbmFtZVBhdHRlcm4gPSAvcyo+XFxzKihbYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qKVxccyovLFxuICAgICAgZmluaXNoUGF0dGVybiA9IC9cXHMqLS0+LyxcbiAgICAgIGNoaWxkO1xuXG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIGZpcnN0UG9zID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgb3BlbiA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sXG4gIFx0ICAgIGNsb3NlID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSxcbiAgXHQgICAgY29udGVudCA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2xvc2VkID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0YXJ0UGF0dGVybikgfHwgIXBhcnNlci5tYXRjaFN0cmluZyhvcGVuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IGZpcnN0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKG5hbWVQYXR0ZXJuKTtcblxuICBcdHdhcm5PbmNlSWZEZWJ1ZyhcIklubGluZSBwYXJ0aWFsIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLlxcblVzZSB0aGlzLi4uXFxuICB7eyNwYXJ0aWFsIFwiICsgbmFtZSArIFwifX0gLi4uIHt7L3BhcnRpYWx9fVxcblxcbi4uLmluc3RlYWQgb2YgdGhpczpcXG4gIDwhLS0ge3s+XCIgKyBuYW1lICsgXCJ9fSAtLT4gLi4uIDwhLS0ge3svXCIgKyBuYW1lICsgXCJ9fSAtLT4nXCIpO1xuXG4gIFx0Ly8gbWFrZSBzdXJlIHRoZSByZXN0IG9mIHRoZSBjb21tZW50IGlzIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoY2xvc2UpIHx8ICFwYXJzZXIubWF0Y2hQYXR0ZXJuKGZpbmlzaFBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHR2YXIgZW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJePCEtLVxcXFxzKlwiICsgdXRpbHNfZXNjYXBlUmVnRXhwKG9wZW4pICsgXCJcXFxccypcXFxcL1xcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAoY2xvc2UpICsgXCJcXFxccyotLT5cIik7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoUGF0dGVybihlbmRQYXR0ZXJuKSkge1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCAoJzwhLS0gXCIgKyBvcGVuICsgXCIvXCIgKyBuYW1lICsgXCJcIiArIGNsb3NlICsgXCIgLS0+JylcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0ZjogY29udGVudCxcbiAgXHRcdG46IG5hbWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbiA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb247XG4gIHZhciBwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuID0gL14jXFxzKnBhcnRpYWxcXHMrLztcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGNvbnRlbnQsIGNoaWxkLCBjbG9zZWQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR2YXIgZGVsaW1pdGVycyA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnM7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzBdKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoZGVsaW1pdGVyc1sxXSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIGRlbGltaXRlcnNbMV0gKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwXG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRpZiAoIWNoaWxkLnIgPT09IFwicGFydGlhbFwiKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0bjogbmFtZSxcbiAgXHRcdGY6IGNvbnRlbnRcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFRlbXBsYXRlID0gcmVhZFRlbXBsYXRlO1xuICBmdW5jdGlvbiByZWFkVGVtcGxhdGUocGFyc2VyKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gW107XG4gIFx0dmFyIHBhcnRpYWxzID0gY3JlYXRlKG51bGwpO1xuICBcdHZhciBoYXNQYXJ0aWFscyA9IGZhbHNlO1xuXG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHR3aGlsZSAocGFyc2VyLnBvcyA8IHBhcnNlci5zdHIubGVuZ3RoKSB7XG4gIFx0XHR2YXIgcG9zID0gcGFyc2VyLnBvcyxcbiAgXHRcdCAgICBpdGVtID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHBhcnRpYWwgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChwYXJ0aWFsID0gcGFyc2VyLnJlYWQoUEFSVElBTF9SRUFERVJTKSkge1xuICBcdFx0XHRpZiAocGFydGlhbHNbcGFydGlhbC5uXSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlZCBwYXJ0aWFsIGRlZmluaXRpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1dGlsc19jbGVhbnVwKHBhcnRpYWwuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdFx0cGFydGlhbHNbcGFydGlhbC5uXSA9IHBhcnRpYWwuZjtcbiAgXHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChpdGVtID0gcGFyc2VyLnJlYWQoUkVBREVSUykpIHtcbiAgXHRcdFx0ZnJhZ21lbnQucHVzaChpdGVtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlVuZXhwZWN0ZWQgdGVtcGxhdGUgY29udGVudFwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YXIgcmVzdWx0ID0ge1xuICBcdFx0djogVEVNUExBVEVfVkVSU0lPTixcbiAgXHRcdHQ6IGZyYWdtZW50XG4gIFx0fTtcblxuICBcdGlmIChoYXNQYXJ0aWFscykge1xuICBcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9wYXJzZSA9IHBhcnNlO1xuXG4gIHZhciBTVEFOREFSRF9SRUFERVJTID0gW211c3RhY2hlX3JlYWRQYXJ0aWFsLCBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZFlpZWxkZXIsIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IsIHJlYWRNdXN0YWNoZUNvbW1lbnRdO1xuICB2YXIgVFJJUExFX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFRyaXBsZV07XG4gIHZhciBTVEFUSUNfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvcl07IC8vIFRPRE8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGhhdmUgYSBzdGF0aWMgc2VjdGlvbj9cblxuICB2YXIgU3RhbmRhcmRQYXJzZXIgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTdGFuZGFyZFBhcnNlcih0ZW1wbGF0ZSwgb3B0aW9ucyB8fCB7fSkucmVzdWx0O1xuICB9XG5cbiAgdmFyIFJFQURFUlMgPSBbY29udmVydGVyc19yZWFkTXVzdGFjaGUsIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50LCBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50LCBjb252ZXJ0ZXJzX3JlYWRUZXh0XTtcbiAgdmFyIFBBUlRJQUxfUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbl07XG5cbiAgU3RhbmRhcmRQYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMudHJpcGxlRGVsaW1pdGVycyB8fCBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0XHQgICAgc3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbXCJbW1wiLCBcIl1dXCJdLFxuICBcdFx0ICAgIHN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1wiW1tbXCIsIFwiXV1dXCJdO1xuXG4gIFx0XHR0aGlzLnN0YW5kYXJkRGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBbXCJ7e1wiLCBcIn19XCJdO1xuXG4gIFx0XHR0aGlzLnRhZ3MgPSBbeyBpc1N0YXRpYzogZmFsc2UsIGlzVHJpcGxlOiBmYWxzZSwgb3BlbjogdGhpcy5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogU1RBTkRBUkRfUkVBREVSUyB9LCB7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IHRydWUsIG9wZW46IHRyaXBsZURlbGltaXRlcnNbMF0sIGNsb3NlOiB0cmlwbGVEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBUUklQTEVfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHN0YXRpY0RlbGltaXRlcnNbMF0sIGNsb3NlOiBzdGF0aWNEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFUSUNfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogdHJ1ZSwgb3Blbjogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH1dO1xuXG4gIFx0XHR0aGlzLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuICBcdFx0dGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcblxuICBcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcbiAgXHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG4gIFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUpIHtcbiAgXHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcbiAgXHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cbiAgXHRcdFx0XHRlbGVtZW50czogXCJhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlXCIuc3BsaXQoXCIgXCIpLFxuICBcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnN0cmlwQ29tbWVudHMgPSBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlO1xuICBcdFx0dGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZTtcbiAgXHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcbiAgXHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuICBcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG4gIFx0fSxcblxuICBcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBlbXB0eSBzdHJpbmdcbiAgXHRcdGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4geyB0OiBbXSwgdjogVEVNUExBVEVfVkVSU0lPTiB9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zZWN0aW9uRGVwdGggPiAwKSB7XG4gIFx0XHRcdHRoaXMuZXJyb3IoXCJBIHNlY3Rpb24gd2FzIGxlZnQgb3BlblwiKTtcbiAgXHRcdH1cblxuICBcdFx0dXRpbHNfY2xlYW51cChyZXN1bHRbMF0udCwgdGhpcy5zdHJpcENvbW1lbnRzLCB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSwgIXRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRyZXR1cm4gcmVzdWx0WzBdO1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbY29udmVydGVyc19yZWFkVGVtcGxhdGVdLFxuXG4gIFx0c29ydE11c3RhY2hlVGFnczogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcbiAgXHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG4gIFx0XHR0aGlzLnRhZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYi5vcGVuLmxlbmd0aCAtIGEub3Blbi5sZW5ndGg7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBwYXJzZU9wdGlvbnMgPSBbXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIiwgXCJzYW5pdGl6ZVwiLCBcInN0cmlwQ29tbWVudHNcIiwgXCJkZWxpbWl0ZXJzXCIsIFwidHJpcGxlRGVsaW1pdGVyc1wiLCBcImludGVycG9sYXRlXCJdO1xuXG4gIHZhciBwYXJzZXIgPSB7XG4gIFx0ZnJvbUlkOiBmcm9tSWQsIGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsIGlzUGFyc2VkOiBpc1BhcnNlZCwgZ2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsIGNyZWF0ZUhlbHBlcjogdGVtcGxhdGVfcGFyc2VyX19jcmVhdGVIZWxwZXIsXG4gIFx0cGFyc2U6IGRvUGFyc2VcbiAgfTtcblxuICBmdW5jdGlvbiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHBhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gZG9QYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMpO1xuICBcdH07XG4gIFx0cmV0dXJuIGhlbHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvUGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucykge1xuICBcdGlmICghX3BhcnNlKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBfcGFyc2UodGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUlkKGlkLCBvcHRpb25zKSB7XG4gIFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0aWYgKCFpc0NsaWVudCkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjXCIgKyBpZCArIFwiIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLlwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNIYXNoZWRJZChpZCkpIHtcbiAgXHRcdGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICBcdH1cblxuICBcdGlmICghKHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSkge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJTQ1JJUFRcIikge1xuICBcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjXCIgKyBpZCArIFwiLCBtdXN0IGJlIGEgPHNjcmlwdD4gZWxlbWVudFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gXCJ0ZXh0Q29udGVudFwiIGluIHRlbXBsYXRlID8gdGVtcGxhdGUudGV4dENvbnRlbnQgOiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hlZElkKGlkKSB7XG4gIFx0cmV0dXJuIGlkICYmIGlkWzBdID09PSBcIiNcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyc2VkKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuICEodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSB7XG4gIFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuICBcdGlmIChyYWN0aXZlLmRlZmF1bHRzKSB7XG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgXHRcdHZhbFtrZXldID0gcmFjdGl2ZVtrZXldO1xuICBcdFx0cmV0dXJuIHZhbDtcbiAgXHR9LCB7fSk7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfcGFyc2VyID0gcGFyc2VyO1xuXG4gIHZhciB0ZW1wbGF0ZUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcInRlbXBsYXRlXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuICBcdFx0aWYgKFwidGVtcGxhdGVcIiBpbiBvcHRpb25zKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcHJvdG8pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIGluaXQoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXG4gIFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuICBcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG4gIFx0XHR0ZW1wbGF0ZSA9IFwidGVtcGxhdGVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cbiAgXHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRmbiA9IHRlbXBsYXRlO1xuICBcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbik7XG5cbiAgXHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuICBcdFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSk7XG5cbiAgXHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuICBcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuICBcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuICBcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cbiAgXHRcdGlmICh0ZW1wbGF0ZS5wKSB7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKHJhY3RpdmUpLFxuICBcdFx0ICAgIHBhcnNlZDtcblxuICBcdFx0aWYgKHJlc3VsdCkge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG5cbiAgXHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0VmFsdWUocmFjdGl2ZSkge1xuICBcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuICBcdCAgICByZXN1bHQ7XG5cbiAgXHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIFx0aWYgKCFpbml0aWFsIHx8ICFpbml0aWFsLmZuKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGluaXRpYWwuZm4pO1xuXG4gIFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG4gIFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG4gIFx0aWYgKHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQpIHtcbiAgXHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuICBcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pIHtcbiAgXHR2YXIgaGVscGVyID0gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcih0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHRyZXR1cm4gZm4uY2FsbChyYWN0aXZlLCBoZWxwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSkge1xuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG4gIFx0XHRpZiAodGVtcGxhdGVbMF0gPT09IFwiI1wiKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZCh0ZW1wbGF0ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gX3BhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB0aGF0IHRoZSB0ZW1wbGF0ZSBldmVuIGV4aXN0c1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlID09IHVuZGVmaW5lZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIGNhbm5vdCBiZSBcIiArIHRlbXBsYXRlICsgXCIuXCIpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHRoZSBwYXJzZWQgdGVtcGxhdGUgaGFzIGEgdmVyc2lvbiBhdCBhbGxcbiAgXHRlbHNlIGlmICh0eXBlb2YgdGVtcGxhdGUudiAhPT0gXCJudW1iZXJcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbXBsYXRlIHBhcnNlciB3YXMgcGFzc2VkIGEgbm9uLXN0cmluZyB0ZW1wbGF0ZSwgYnV0IHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IGhhdmUgYSB2ZXJzaW9uLiAgTWFrZSBzdXJlIHlvdSdyZSBwYXNzaW5nIGluIHRoZSB0ZW1wbGF0ZSB5b3UgdGhpbmsgeW91IGFyZS5cIik7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgdmVyc2lvblxuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnYgIT09IFRFTVBMQVRFX1ZFUlNJT04pIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiAoZXhwZWN0ZWQgXCIgKyBURU1QTEFURV9WRVJTSU9OICsgXCIsIGdvdCBcIiArIHRlbXBsYXRlLnYgKyBcIikgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUpIHtcbiAgXHRpZiAoIW5ld1BhcnRpYWxzKSByZXR1cm47XG5cbiAgXHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG4gIFx0Ly8gY2FzZSwgYnV0IG5vdCBpbml0aWFsbHkuLi5cblxuICBcdGZvciAodmFyIGtleSBpbiBuZXdQYXJ0aWFscykge1xuICBcdFx0aWYgKG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdGV4aXN0aW5nUGFydGlhbHNba2V5XSA9IG5ld1BhcnRpYWxzW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHRlbXBsYXRlX3RlbXBsYXRlID0gdGVtcGxhdGVDb25maWd1cmF0b3I7XG5cbiAgdmFyIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzLCBSZWdpc3RyeSwgcmVnaXN0cmllcztcblxuICBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcyA9IFtcImFkYXB0b3JzXCIsIFwiY29tcG9uZW50c1wiLCBcImNvbXB1dGVkXCIsIFwiZGVjb3JhdG9yc1wiLCBcImVhc2luZ1wiLCBcImV2ZW50c1wiLCBcImludGVycG9sYXRvcnNcIiwgXCJwYXJ0aWFsc1wiLCBcInRyYW5zaXRpb25zXCJdO1xuXG4gIFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKG5hbWUsIHVzZURlZmF1bHRzKSB7XG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcbiAgXHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlID0ge1xuICBcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuY29uZmlndXJlKHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsIHRoaXMudXNlRGVmYXVsdHMgPyBwcm90byA6IHByb3RvLmNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRjb25maWd1cmU6IGZ1bmN0aW9uIChQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gIFx0XHQgICAgb3B0aW9uID0gb3B0aW9uc1tuYW1lXSxcbiAgXHRcdCAgICByZWdpc3RyeTtcblxuICBcdFx0cmVnaXN0cnkgPSBjcmVhdGUoUGFyZW50W25hbWVdKTtcblxuICBcdFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbikge1xuICBcdFx0XHRyZWdpc3RyeVtrZXldID0gb3B0aW9uW2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHRhcmdldFtuYW1lXSA9IHJlZ2lzdHJ5O1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbdGhpcy5uYW1lXTtcbiAgXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0aWYgKGl0ZW0uX2ZuKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uX2ZuLmlzT3duZXIpIHtcbiAgXHRcdFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBpdGVtLl9mbjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5W2tleV07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHRcdHJldHVybiBjaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICByZWdpc3RyaWVzID0gY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWdpc3RyeShuYW1lLCBuYW1lID09PSBcImNvbXB1dGVkXCIpO1xuICB9KTtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXMgPSByZWdpc3RyaWVzO1xuXG4gIC8qdGhpcy5jb25maWd1cmUoXG4gIFx0dGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCxcbiAgXHRyYWN0aXZlLFxuICBcdG9wdGlvbnMgKTsqL1xuXG4gIHZhciB3cmFwUHJvdG90eXBlID0gd3JhcDtcblxuICBmdW5jdGlvbiB3cmFwKHBhcmVudCwgbmFtZSwgbWV0aG9kKSB7XG4gIFx0aWYgKCEvX3N1cGVyLy50ZXN0KG1ldGhvZCkpIHtcbiAgXHRcdHJldHVybiBtZXRob2Q7XG4gIFx0fVxuXG4gIFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG4gIFx0XHR2YXIgc3VwZXJNZXRob2QgPSBnZXRTdXBlck1ldGhvZCh3cmFwcGVyLl9wYXJlbnQsIG5hbWUpLFxuICBcdFx0ICAgIGhhc1N1cGVyID0gKFwiX3N1cGVyXCIgaW4gdGhpcyksXG4gIFx0XHQgICAgb2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcbiAgXHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHRpZiAoaGFzU3VwZXIpIHtcbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0d3JhcHBlci5fcGFyZW50ID0gcGFyZW50O1xuICBcdHdyYXBwZXIuX21ldGhvZCA9IG1ldGhvZDtcblxuICBcdHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QocGFyZW50LCBuYW1lKSB7XG4gIFx0dmFyIHZhbHVlLCBtZXRob2Q7XG5cbiAgXHRpZiAobmFtZSBpbiBwYXJlbnQpIHtcbiAgXHRcdHZhbHVlID0gcGFyZW50W25hbWVdO1xuXG4gIFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0bWV0aG9kID0gdmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZXRob2QgPSBmdW5jdGlvbiByZXR1cm5WYWx1ZSgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG1ldGhvZCA9IG5vb3A7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIHZhciBjb25maWdfZGVwcmVjYXRlID0gZGVwcmVjYXRlO1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IpIHtcbiAgXHRyZXR1cm4gXCJvcHRpb25zLlwiICsgZGVwcmVjYXRlZCArIFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCIgKyAoaXNFcnJvciA/IFwiIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiA6IFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QpIHtcbiAgXHRpZiAoZGVwcmVjYXRlZE9wdGlvbiBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIShjb3JyZWN0IGluIG9wdGlvbnMpKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkpO1xuICBcdFx0XHRvcHRpb25zW2NvcnJlY3RdID0gb3B0aW9uc1tkZXByZWNhdGVkT3B0aW9uXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihnZXRNZXNzYWdlKGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QsIHRydWUpKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKG9wdGlvbnMpIHtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJiZWZvcmVJbml0XCIsIFwib25jb25zdHJ1Y3RcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiaW5pdFwiLCBcIm9ucmVuZGVyXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImNvbXBsZXRlXCIsIFwib25jb21wbGV0ZVwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJldmVudERlZmluaXRpb25zXCIsIFwiZXZlbnRzXCIpO1xuXG4gIFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcbiAgXHQvLyBsaWtlIEh1bWFuLmV4dGVuZCggU3BpZGVyICkgbWVhbnMgYWRhcHRvcnMgYXMgYSByZWdpc3RyeVxuICBcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcbiAgXHRpZiAoaXNBcnJheShvcHRpb25zLmFkYXB0b3JzKSkge1xuICBcdFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiYWRhcHRvcnNcIiwgXCJhZGFwdFwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY29uZmlnLCBvcmRlciwgZGVmYXVsdEtleXMsIGN1c3RvbSwgaXNCbGFja2xpc3RlZCwgaXNTdGFuZGFyZEtleTtcblxuICBjdXN0b20gPSB7XG4gIFx0YWRhcHQ6IGN1c3RvbV9hZGFwdCxcbiAgXHRjc3M6IGNzc19jc3MsXG4gIFx0ZGF0YTogY3VzdG9tX2RhdGEsXG4gIFx0dGVtcGxhdGU6IHRlbXBsYXRlX3RlbXBsYXRlXG4gIH07XG5cbiAgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhjb25maWdfZGVmYXVsdHMpO1xuXG4gIGlzU3RhbmRhcmRLZXkgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjdXN0b21ba2V5XTtcbiAgfSkpO1xuXG4gIC8vIGJsYWNrbGlzdGVkIGtleXMgdGhhdCB3ZSBkb24ndCBkb3VibGUgZXh0ZW5kXG4gIGlzQmxhY2tsaXN0ZWQgPSBtYWtlT2JqKGRlZmF1bHRLZXlzLmNvbmNhdChjb25maWdfcmVnaXN0cmllcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgXHRyZXR1cm4gci5uYW1lO1xuICB9KSkpO1xuXG4gIG9yZGVyID0gW10uY29uY2F0KGRlZmF1bHRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuICFjb25maWdfcmVnaXN0cmllc1trZXldICYmICFjdXN0b21ba2V5XTtcbiAgfSksIGNvbmZpZ19yZWdpc3RyaWVzLCBjdXN0b20uZGF0YSwgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzKTtcblxuICBjb25maWcgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImV4dGVuZFwiLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGNvbmZpZ3VyZShcImluaXRcIiwgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRyZXR1cm4gb3JkZXIuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gIFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQocmFjdGl2ZSk7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMubmFtZTtcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyLiBUT0RPIHRoaXMgaXNuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgY29kZWJhc2UsXG4gIFx0Ly8gb25seSBpbiB0aGUgdGVzdCBzdWl0ZSAtIHNob3VsZCBnZXQgcmlkIG9mIGl0XG4gIFx0b3JkZXI6IG9yZGVyIH07XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKG1ldGhvZCwgUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRjb25maWdfZGVwcmVjYXRlKG9wdGlvbnMpO1xuXG4gIFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChpc1N0YW5kYXJkS2V5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuXG4gIFx0XHRcdC8vIHdhcm4gdGhlIGRldmVsb3BlciBpZiB0aGV5IHBhc3NlZCBhIGZ1bmN0aW9uIGFuZCBpZ25vcmUgaXRzIHZhbHVlXG5cbiAgXHRcdFx0Ly8gTk9URTogd2UgYWxsb3cgc29tZSBmdW5jdGlvbnMgb24gXCJlbFwiIGJlY2F1c2Ugd2UgZHVjayB0eXBlIGVsZW1lbnQgbGlzdHNcbiAgXHRcdFx0Ly8gYW5kIHNvbWUgbGlicmFyaWVzIG9yIGVmJ2VkLXVwIHZpcnR1YWwgYnJvd3NlcnMgKHBoYW50b21KUykgcmV0dXJuIGFcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSByZXN1bHQgb2YgcXVlcnlTZWxlY3RvciBtZXRob2RzXG4gIFx0XHRcdGlmIChrZXkgIT09IFwiZWxcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiXCIgKyBrZXkgKyBcIiBpcyBhIFJhY3RpdmUgb3B0aW9uIHRoYXQgZG9lcyBub3QgZXhwZWN0IGEgZnVuY3Rpb24gYW5kIHdpbGwgYmUgaWdub3JlZFwiLCBtZXRob2QgPT09IFwiaW5pdFwiID8gdGFyZ2V0IDogbnVsbCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gIFx0XHRyZWdpc3RyeVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR9KTtcblxuICBcdGN1c3RvbV9hZGFwdFttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZVttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgXHRjc3NfY3NzW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIFx0ZXh0ZW5kT3RoZXJNZXRob2RzKFBhcmVudC5wcm90b3R5cGUsIHRhcmdldCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPdGhlck1ldGhvZHMocGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKCFpc0JsYWNrbGlzdGVkW2tleV0gJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG4gIFx0XHRcdGlmICh0eXBlb2YgbWVtYmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKHBhcmVudCwga2V5LCBtZW1iZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGFyZ2V0W2tleV0gPSBtZW1iZXI7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU9iaihhcnJheSkge1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRyZXR1cm4gb2JqW3hdID0gdHJ1ZTtcbiAgXHR9KTtcbiAgXHRyZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19jb25maWcgPSBjb25maWc7XG5cbiAgdmFyIHByb3RvdHlwZV9idWJibGUgPSBGcmFnbWVudCRidWJibGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkYnViYmxlKCkge1xuICBcdHRoaXMuZGlydHlWYWx1ZSA9IHRoaXMuZGlydHlBcmdzID0gdHJ1ZTtcblxuICBcdGlmICh0aGlzLmJvdW5kICYmIHR5cGVvZiB0aGlzLm93bmVyLmJ1YmJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoID0gRnJhZ21lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0dmFyIG5vZGUgPSBpdGVtLmRldGFjaCgpO1xuXG4gIFx0XHQvLyBUT0RPIFRoZSBpZiB7Li4ufSB3YXNuJ3QgcHJldmlvdXNseSByZXF1aXJlZCAtIGl0IGlzIG5vdywgYmVjYXVzZSB3ZSdyZVxuICBcdFx0Ly8gZm9yY2libHkgZGV0YWNoaW5nIGV2ZXJ5dGhpbmcgdG8gcmVvcmRlciBzZWN0aW9ucyBhZnRlciBhbiB1cGRhdGUuIFRoYXQnc1xuICBcdFx0Ly8gYSBub24taWRlYWwgYnJ1dGUgZm9yY2UgYXBwcm9hY2gsIGltcGxlbWVudGVkIHRvIGdldCBhbGwgdGhlIHRlc3RzIHRvIHBhc3NcbiAgXHRcdC8vIC0gYXMgc29vbiBhcyBpdCdzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZWxlZ2FudCwgdGhpcyBzaG91bGRcbiAgXHRcdC8vIHJldmVydCB0byBgZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApYFxuICBcdFx0aWYgKG5vZGUpIHtcbiAgXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kID0gRnJhZ21lbnQkZmluZDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBGcmFnbWVudCRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbiwgaXRlbTtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQWxsQ29tcG9uZW50cykge1xuICBcdFx0XHRcdGl0ZW0uZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IEZyYWdtZW50JGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRDb21wb25lbnQgJiYgKHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBGcmFnbWVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZE5leHROb2RlKGl0ZW0pIHtcbiAgXHR2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuICBcdCAgICBub2RlO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXNbaW5kZXggKyAxXSkge1xuICBcdFx0bm9kZSA9IHRoaXMuaXRlbXNbaW5kZXggKyAxXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIHRoZSByb290IGZyYWdtZW50LCBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMsXG4gIFx0Ly8gaXQgbWVhbnMgd2UncmUgYXQgdGhlIGVuZC4uLlxuICBcdGVsc2UgaWYgKHRoaXMub3duZXIgPT09IHRoaXMucm9vdCkge1xuICBcdFx0aWYgKCF0aGlzLm93bmVyLmNvbXBvbmVudCkge1xuICBcdFx0XHQvLyBUT0RPIGJ1dCBzb21ldGhpbmcgZWxzZSBjb3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQgdG9cbiAgXHRcdFx0Ly8gdGhpcy5yb290LmVsLCBubz9cbiAgXHRcdFx0bm9kZSA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnVubGVzcyB0aGlzIGlzIGEgY29tcG9uZW50XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEZyYWdtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2hhcmVkX3Byb2Nlc3NJdGVtcyA9IHByb2Nlc3NJdGVtcztcblxuICBmdW5jdGlvbiBwcm9jZXNzSXRlbXMoaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlcikge1xuICBcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cbiAgXHRyZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXJJZCwgd3JhcHBlZCwgdmFsdWU7XG5cbiAgXHRcdGlmIChpdGVtLnRleHQpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0udGV4dDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGl0ZW0uZnJhZ21lbnRzKSB7XG4gIFx0XHRcdHJldHVybiBpdGVtLmZyYWdtZW50cy5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyhmcmFnbWVudC5pdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKTtcbiAgXHRcdFx0fSkuam9pbihcIlwiKTtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXJJZCA9IGd1aWQgKyBcIi1cIiArIGNvdW50ZXIrKztcblxuICBcdFx0aWYgKGl0ZW0ua2V5cGF0aCAmJiAod3JhcHBlZCA9IGl0ZW0ucm9vdC52aWV3bW9kZWwud3JhcHBlZFtpdGVtLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSBpdGVtLmdldFZhbHVlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlc1twbGFjZWhvbGRlcklkXSA9IHZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gXCIke1wiICsgcGxhY2Vob2xkZXJJZCArIFwifVwiO1xuICBcdH0pLmpvaW4oXCJcIik7XG4gIH1cblxuICB2YXIgZ2V0QXJnc0xpc3QgPSBGcmFnbWVudCRnZXRBcmdzTGlzdDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0QXJnc0xpc3QoKSB7XG4gIFx0dmFyIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLmRpcnR5QXJncykge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihcIltcIiArIHNvdXJjZSArIFwiXVwiLCB2YWx1ZXMpO1xuXG4gIFx0XHRpZiAoIXBhcnNlZCkge1xuICBcdFx0XHRyZXN1bHQgPSBbdGhpcy50b1N0cmluZygpXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5hcmdzTGlzdCA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlBcmdzID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXJnc0xpc3Q7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZSA9IEZyYWdtZW50JGdldE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGZyYWdtZW50LnBFbGVtZW50KSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50KTtcblxuICBcdHJldHVybiB0aGlzLnJvb3QuZGV0YWNoZWQgfHwgdGhpcy5yb290LmVsO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRWYWx1ZSA9IEZyYWdtZW50JGdldFZhbHVlO1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRWYWx1ZSgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlWYWx1ZSkge1xuICBcdFx0c291cmNlID0gc2hhcmVkX3Byb2Nlc3NJdGVtcyh0aGlzLml0ZW1zLCB2YWx1ZXMgPSB7fSwgdGhpcy5yb290Ll9ndWlkKTtcbiAgXHRcdHBhcnNlZCA9IHBhcnNlSlNPTihzb3VyY2UsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHJlc3VsdDtcbiAgXHRcdHRoaXMuZGlydHlWYWx1ZSA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIFx0cmV0dXJuIGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgfTtcblxuICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVEVYVDtcbiAgXHR0aGlzLnRleHQgPSBvcHRpb25zLnRlbXBsYXRlO1xuICB9O1xuXG4gIFRleHQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwodGhpcy50ZXh0KSA6IHRoaXMudGV4dDtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX1RleHQgPSBUZXh0O1xuXG4gIHZhciBzaGFyZWRfdW5iaW5kID0gc2hhcmVkX3VuYmluZF9fdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIHNoYXJlZF91bmJpbmRfX3VuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gIFx0XHQvLyB0aGlzIHdhcyByZWdpc3RlcmVkIGFzIGEgZGVwZW5kYW50XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfZ2V0VmFsdWUgPSBNdXN0YWNoZSRnZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRnZXRWYWx1ZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBrZXlwYXRoO1xuXG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5yb290ID0gb3duZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0a2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKG93bmVyLnJvb3QsIHJlZiwgb3duZXIucGFyZW50RnJhZ21lbnQpO1xuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgIWtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgd2FzIHJlc29sdmVkLCBhbmQgbm93IGl0J3Mgbm90LiBDYW4gaGFwcGVuIGlmIGUuZy4gYGJhcmAgaW5cbiAgXHRcdFx0Ly8gYHt7Zm9vW2Jhcl19fWAgYmVjb21lcyB1bmRlZmluZWRcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZShnZXRLZXlwYXRoKHRoaXMucmVmKSk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdC8vIHdhcyBhIG5ldyBrZXlwYXRoIGNyZWF0ZWQ/XG4gIFx0XHRcdGlmIChrZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHQvLyByZXNvbHZlIGl0XG4gIFx0XHRcdFx0dGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIgPSBSZWZlcmVuY2VSZXNvbHZlcjtcblxuICB2YXIgU3BlY2lhbFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgdmFyIHByb3BzID0ge1xuICBcdFwiQGtleXBhdGhcIjogeyBwcmVmaXg6IFwiY1wiLCBwcm9wOiBbXCJjb250ZXh0XCJdIH0sXG4gIFx0XCJAaW5kZXhcIjogeyBwcmVmaXg6IFwiaVwiLCBwcm9wOiBbXCJpbmRleFwiXSB9LFxuICBcdFwiQGtleVwiOiB7IHByZWZpeDogXCJrXCIsIHByb3A6IFtcImtleVwiLCBcImluZGV4XCJdIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQcm9wKHRhcmdldCwgcHJvcCkge1xuICBcdHZhciB2YWx1ZTtcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3AucHJvcC5sZW5ndGg7IGkrKykge1xuICBcdFx0aWYgKCh2YWx1ZSA9IHRhcmdldFtwcm9wLnByb3BbaV1dKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBTcGVjaWFsUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuICBcdFx0ICAgIGZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCxcbiAgXHRcdCAgICBwcm9wID0gcHJvcHNbcmVmXSxcbiAgXHRcdCAgICB2YWx1ZTtcblxuICBcdFx0aWYgKCFwcm9wKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3BlY2lhbCByZWZlcmVuY2UgXFxcIlwiICsgcmVmICsgXCJcXFwiIC0gdmFsaWQgcmVmZXJlbmNlcyBhcmUgQGluZGV4LCBAa2V5IGFuZCBAa2V5cGF0aFwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaGF2ZSB3ZSBhbHJlYWR5IGZvdW5kIHRoZSBuZWFyZXN0IHBhcmVudD9cbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyBnZXRQcm9wKHRoaXMuY2FjaGVkLCBwcm9wKSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGluZGljZXMsIHdoaWNoIG1heSBjcm9zcyBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKHByb3AucHJvcC5pbmRleE9mKFwiaW5kZXhcIikgIT09IC0xIHx8IHByb3AucHJvcC5pbmRleE9mKFwia2V5XCIpICE9PSAtMSkge1xuICBcdFx0XHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRpZiAoZnJhZ21lbnQub3duZXIuY3VycmVudFN1YnR5cGUgPT09IFNFQ1RJT05fRUFDSCAmJiAodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0dGhpcy5jYWNoZWQgPSBmcmFnbWVudDtcblxuICBcdFx0XHRcdFx0ZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdFx0XHRpZiAoIWZyYWdtZW50LnBhcmVudCAmJiBmcmFnbWVudC5vd25lciAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICYmICFmcmFnbWVudC5vd25lci5jb21wb25lbnQuaW5zdGFuY2UuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmICgodmFsdWUgPSBnZXRQcm9wKGZyYWdtZW50LCBwcm9wKSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgdmFsdWUuc3RyKSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5jYWNoZWQpIHtcbiAgXHRcdFx0dGhpcy5jYWNoZWQudW5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlciA9IFNwZWNpYWxSZXNvbHZlcjtcblxuICB2YXIgSW5kZXhSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRyZWYucmVmLmZyYWdtZW50LnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG5cbiAgXHR0aGlzLnJlYmluZCgpO1xuICB9O1xuXG4gIEluZGV4UmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4LFxuICBcdFx0ICAgIHJlZiA9IHRoaXMucmVmLnJlZjtcblxuICBcdFx0aWYgKHJlZi5yZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0aW5kZXggPSBcImtcIiArIHJlZi5mcmFnbWVudC5rZXk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbmRleCA9IFwiaVwiICsgcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBpbmRleCkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVmLnJlZi5mcmFnbWVudC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlciA9IEluZGV4UmVzb2x2ZXI7XG5cbiAgdmFyIFJlc29sdmVyc19maW5kSW5kZXhSZWZzID0gZmluZEluZGV4UmVmcztcblxuICBmdW5jdGlvbiBmaW5kSW5kZXhSZWZzKGZyYWdtZW50LCByZWZOYW1lKSB7XG4gIFx0dmFyIHJlc3VsdCA9IHt9LFxuICBcdCAgICByZWZzLFxuICBcdCAgICBmcmFnUmVmcyxcbiAgXHQgICAgcmVmLFxuICBcdCAgICBpLFxuICBcdCAgICBvd25lcixcbiAgXHQgICAgaGl0ID0gZmFsc2U7XG5cbiAgXHRpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdHJlc3VsdC5yZWZzID0gcmVmcyA9IHt9O1xuICBcdH1cblxuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0aWYgKChvd25lciA9IGZyYWdtZW50Lm93bmVyKSAmJiAoZnJhZ1JlZnMgPSBvd25lci5pbmRleFJlZnMpKSB7XG5cbiAgXHRcdFx0Ly8gd2UncmUgbG9va2luZyBmb3IgYSBwYXJ0aWN1bGFyIHJlZiwgYW5kIGl0J3MgaGVyZVxuICBcdFx0XHRpZiAocmVmTmFtZSAmJiAocmVmID0gb3duZXIuZ2V0SW5kZXhSZWYocmVmTmFtZSkpKSB7XG4gIFx0XHRcdFx0cmVzdWx0LnJlZiA9IHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gd2UncmUgY29sbGVjdGluZyByZWZzIHVwLXRyZWVcbiAgXHRcdFx0ZWxzZSBpZiAoIXJlZk5hbWUpIHtcbiAgXHRcdFx0XHRmb3IgKGkgaW4gZnJhZ1JlZnMpIHtcbiAgXHRcdFx0XHRcdHJlZiA9IGZyYWdSZWZzW2ldO1xuXG4gIFx0XHRcdFx0XHQvLyBkb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgcmVmcyAtIHRoZXkgc2hvdWxkIHNoYWRvdyBwYXJlbnRzXG4gIFx0XHRcdFx0XHRpZiAoIXJlZnNbcmVmLm5dKSB7XG4gIFx0XHRcdFx0XHRcdGhpdCA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdHJlZnNbcmVmLm5dID0ge1xuICBcdFx0XHRcdFx0XHRcdGZyYWdtZW50OiBmcmFnbWVudCxcbiAgXHRcdFx0XHRcdFx0XHRyZWY6IHJlZlxuICBcdFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB3YXRjaCBmb3IgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRyZXN1bHQuY29tcG9uZW50Qm91bmRhcnkgPSB0cnVlO1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghaGl0KSB7XG4gIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH1cbiAgfVxuXG4gIGZpbmRJbmRleFJlZnMucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoaW5kaWNlcykge1xuICBcdHZhciByZWZzID0ge30sXG4gIFx0ICAgIGssXG4gIFx0ICAgIHJlZjtcblxuICBcdGZvciAoayBpbiBpbmRpY2VzLnJlZnMpIHtcbiAgXHRcdHJlZiA9IGluZGljZXMucmVmc1trXTtcbiAgXHRcdHJlZnNbcmVmLnJlZi5uXSA9IHJlZi5yZWYudCA9PT0gXCJrXCIgPyByZWYuZnJhZ21lbnQua2V5IDogcmVmLmZyYWdtZW50LmluZGV4O1xuICBcdH1cblxuICBcdHJldHVybiByZWZzO1xuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIgPSBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcjtcbiAgZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgaW5kZXhSZWY7XG5cbiAgXHRpZiAocmVmLmNoYXJBdCgwKSA9PT0gXCJAXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX1NwZWNpYWxSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0aWYgKGluZGV4UmVmID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMob3duZXIucGFyZW50RnJhZ21lbnQsIHJlZikpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVzb2x2ZXJzX0luZGV4UmVzb2x2ZXIob3duZXIsIGluZGV4UmVmLCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcgPSBnZXRGdW5jdGlvbkZyb21TdHJpbmc7XG4gIHZhciBjYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoc3RyLCBpKSB7XG4gIFx0dmFyIGZuLCBhcmdzO1xuXG4gIFx0aWYgKGNhY2hlW3N0cl0pIHtcbiAgXHRcdHJldHVybiBjYWNoZVtzdHJdO1xuICBcdH1cblxuICBcdGFyZ3MgPSBbXTtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcmdzW2ldID0gXCJfXCIgKyBpO1xuICBcdH1cblxuICBcdGZuID0gbmV3IEZ1bmN0aW9uKGFyZ3Muam9pbihcIixcIiksIFwicmV0dXJuKFwiICsgc3RyICsgXCIpXCIpO1xuXG4gIFx0Y2FjaGVbc3RyXSA9IGZuO1xuICBcdHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciBFeHByZXNzaW9uUmVzb2x2ZXIsXG4gICAgICBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJhY3RpdmU7XG5cbiAgXHRyYWN0aXZlID0gb3duZXIucm9vdDtcblxuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLm93bmVyID0gb3duZXI7XG4gIFx0dGhpcy5zdHIgPSBleHByZXNzaW9uLnM7XG4gIFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuXG4gIFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHR0aGlzLnBlbmRpbmcgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuICBcdHRoaXMucmVmUmVzb2x2ZXJzID0gZXhwcmVzc2lvbi5yLm1hcChmdW5jdGlvbiAocmVmLCBpKSB7XG4gIFx0XHRyZXR1cm4gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKF90aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7XG4gIH07XG5cbiAgRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudW5pcXVlU3RyaW5nID0gZ2V0VW5pcXVlU3RyaW5nKHRoaXMuc3RyLCB0aGlzLmtleXBhdGhzKTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHRoaXMudW5pcXVlU3RyaW5nKTtcblxuICBcdFx0dGhpcy5jcmVhdGVFdmFsdWF0b3IoKTtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRcdHdoaWxlIChyZXNvbHZlciA9IHRoaXMucmVmUmVzb2x2ZXJzLnBvcCgpKSB7XG4gIFx0XHRcdHJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHRcdHRoaXMua2V5cGF0aHNbaW5kZXhdID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGNyZWF0ZUV2YWx1YXRvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIGNvbXB1dGF0aW9uLCB2YWx1ZUdldHRlcnMsIHNpZ25hdHVyZSwga2V5cGF0aCwgZm47XG5cbiAgXHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcblxuICBcdFx0Ly8gb25seSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCFcbiAgXHRcdGlmICghY29tcHV0YXRpb24pIHtcbiAgXHRcdFx0Zm4gPSBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHRoaXMuc3RyLCB0aGlzLnJlZlJlc29sdmVycy5sZW5ndGgpO1xuXG4gIFx0XHRcdHZhbHVlR2V0dGVycyA9IHRoaXMua2V5cGF0aHMubWFwKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0dmFyIHZhbHVlO1xuXG4gIFx0XHRcdFx0aWYgKGtleXBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vICdzcGVjaWFsJyBrZXlwYXRocyBlbmNvZGUgYSB2YWx1ZVxuICBcdFx0XHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIHZhbHVlID0gX3RoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgsIHsgbm9VbndyYXA6IHRydWUsIGZ1bGxSb290R2V0OiB0cnVlIH0pO1xuICBcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gd3JhcEZ1bmN0aW9uKHZhbHVlLCBfdGhpcy5yb290KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9KTtcblxuICBcdFx0XHRzaWduYXR1cmUgPSB7XG4gIFx0XHRcdFx0ZGVwczogdGhpcy5rZXlwYXRocy5maWx0ZXIoaXNWYWxpZERlcGVuZGVuY3kpLFxuICBcdFx0XHRcdGdldHRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dmFyIGFyZ3MgPSB2YWx1ZUdldHRlcnMubWFwKGNhbGwpO1xuICBcdFx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0ZShrZXlwYXRoLCBzaWduYXR1cmUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHQvLyBUT0RPIG9ubHkgYnViYmxlIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSByZWZlcmVuY2VzIGFyZSBhZmZlY3RlZCBieSB0aGUgcmViaW5kXG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRcdHJldHVybiByLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlciA9IEV4cHJlc3Npb25SZXNvbHZlcjtcblxuICBmdW5jdGlvbiBjYWxsKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlLmNhbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyhzdHIsIGtleXBhdGhzKSB7XG4gIFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL18oWzAtOV0rKS9nLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHR2YXIga2V5cGF0aCwgdmFsdWU7XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBub3QgcmVwbGFjaW5nIGEgbm9uLWtleXBhdGggX1swLTldXG4gIFx0XHRpZiAoKyQxID49IGtleXBhdGhzLmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4gXCJfXCIgKyAkMTtcbiAgXHRcdH1cblxuICBcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyQxXTtcblxuICBcdFx0aWYgKGtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHZhbHVlID0ga2V5cGF0aC52YWx1ZTtcbiAgXHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5zdHI7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uS2V5cGF0aCh1bmlxdWVTdHJpbmcpIHtcbiAgXHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuICBcdC8vIHdlIGNhbid0IHNwbGl0IHRoZSBrZXlwYXRoIGludG8ga2V5cyFcbiAgXHQvLyBSZW1vdmUgYXN0ZXJpc2tzIHRvbywgc2luY2UgdGhleSBtZXNzIHdpdGggcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRyZXR1cm4gZ2V0S2V5cGF0aChcIiR7XCIgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSgvW1xcLlxcW1xcXV0vZywgXCItXCIpLnJlcGxhY2UoL1xcKi8sIFwiI01VTCNcIikgKyBcIn1cIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkRGVwZW5kZW5jeShrZXlwYXRoKSB7XG4gIFx0cmV0dXJuIGtleXBhdGggIT09IHVuZGVmaW5lZCAmJiBrZXlwYXRoWzBdICE9PSBcIkBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmbiwgcmFjdGl2ZSkge1xuICBcdHZhciB3cmFwcGVkLCBwcm9wLCBrZXk7XG5cbiAgXHRpZiAoZm4uX19yYWN0aXZlX25vd3JhcCkge1xuICBcdFx0cmV0dXJuIGZuO1xuICBcdH1cblxuICBcdHByb3AgPSBcIl9fcmFjdGl2ZV9cIiArIHJhY3RpdmUuX2d1aWQ7XG4gIFx0d3JhcHBlZCA9IGZuW3Byb3BdO1xuXG4gIFx0aWYgKHdyYXBwZWQpIHtcbiAgXHRcdHJldHVybiB3cmFwcGVkO1xuICBcdH0gZWxzZSBpZiAoL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkpIHtcbiAgXHRcdGRlZmluZVByb3BlcnR5KGZuLCBwcm9wLCB7XG4gIFx0XHRcdHZhbHVlOiBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyX19iaW5kLmNhbGwoZm4sIHJhY3RpdmUpLFxuICBcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdH0pO1xuXG4gIFx0XHQvLyBBZGQgcHJvcGVydGllcy9tZXRob2RzIHRvIHdyYXBwZWQgZnVuY3Rpb25cbiAgXHRcdGZvciAoa2V5IGluIGZuKSB7XG4gIFx0XHRcdGlmIChmbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0Zm5bcHJvcF1ba2V5XSA9IGZuW2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5fYm91bmRGdW5jdGlvbnMucHVzaCh7XG4gIFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0cHJvcDogcHJvcFxuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiBmbltwcm9wXTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eShmbiwgXCJfX3JhY3RpdmVfbm93cmFwXCIsIHtcbiAgXHRcdHZhbHVlOiBmblxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG4gIH1cblxuICB2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gIFx0dGhpcy5yb290ID0gcmVzb2x2ZXIucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblxuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0ZW1wbGF0ZTtcbiAgXHR9XG5cbiAgXHQvLyBTaW1wbGUgcmVmZXJlbmNlP1xuICBcdGVsc2UgaWYgKHRlbXBsYXRlLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcih0aGlzLCB0ZW1wbGF0ZS5uLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHdlIGhhdmUgYW4gZXhwcmVzc2lvbiBpbiBpdHMgb3duIHJpZ2h0XG4gIFx0ZWxzZSB7XG4gIFx0XHRuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihyZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLmJpbmQoKTtcblxuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0YmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlciA9IE1lbWJlclJlc29sdmVyO1xuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAobXVzdGFjaGUsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZSwgcmVmLCBrZXlwYXRoLCBwYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuICBcdHRoaXMubXVzdGFjaGUgPSBtdXN0YWNoZTtcblxuICBcdHRoaXMucmVmID0gcmVmID0gdGVtcGxhdGUucjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdC8vIEZpbmQgYmFzZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0dGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMuYmFzZSA9IGtleXBhdGg7XG4gIFx0XHRcdF90aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHRcdF90aGlzLmJ1YmJsZSgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRmluZCB2YWx1ZXMgZm9yIG1lbWJlcnMsIG9yIG1hcmsgdGhlbSBhcyB1bnJlc29sdmVkXG4gIFx0dGhpcy5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9NZW1iZXJSZXNvbHZlcih0ZW1wbGF0ZSwgX3RoaXMsIHBhcmVudEZyYWdtZW50KTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdHRoaXMuYnViYmxlKCk7IC8vIHRyaWdnZXIgaW5pdGlhbCByZXNvbHV0aW9uIGlmIHBvc3NpYmxlXG4gIH07XG5cbiAgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRnZXRLZXlwYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVzID0gdGhpcy5tZW1iZXJzLm1hcChSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZSk7XG5cbiAgXHRcdGlmICghdmFsdWVzLmV2ZXJ5KGlzRGVmaW5lZCkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmJhc2Uuam9pbih2YWx1ZXMuam9pbihcIi5cIikpO1xuICBcdH0sXG5cbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5nZXRLZXlwYXRoKCkpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBjaGFuZ2VkO1xuXG4gIFx0XHRpZiAodGhpcy5iYXNlKSB7XG4gIFx0XHRcdHZhciBuZXdCYXNlID0gdGhpcy5iYXNlLnJlcGxhY2Uob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdGlmIChuZXdCYXNlICYmIG5ld0Jhc2UgIT09IHRoaXMuYmFzZSkge1xuICBcdFx0XHRcdHRoaXMuYmFzZSA9IG5ld0Jhc2U7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcnMpIHtcbiAgXHRcdFx0aWYgKG1lbWJlcnMucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoY2hhbmdlZCkge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLmJhc2UgPSBnZXRLZXlwYXRoKHRoaXMucmVmKTtcblxuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmb3JjZVJlc29sdXRpb24pO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9fZ2V0VmFsdWUobWVtYmVyKSB7XG4gIFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZVJlc29sdXRpb24obWVtYmVyKSB7XG4gIFx0bWVtYmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cbiAgdmFyIE11c3RhY2hlX2luaXRpYWxpc2UgPSBNdXN0YWNoZSRpbml0O1xuICBmdW5jdGlvbiBNdXN0YWNoZSRpbml0KG11c3RhY2hlLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgcmVmLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0bXVzdGFjaGUucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0bXVzdGFjaGUucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXG4gIFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICBcdG11c3RhY2hlLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuICBcdG11c3RhY2hlLmlzU3RhdGljID0gb3B0aW9ucy50ZW1wbGF0ZS5zO1xuXG4gIFx0bXVzdGFjaGUudHlwZSA9IG9wdGlvbnMudGVtcGxhdGUudDtcblxuICBcdG11c3RhY2hlLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICBcdC8vIGlmIHRoaXMgaXMgYSBzaW1wbGUgbXVzdGFjaGUsIHdpdGggYSByZWZlcmVuY2UsIHdlIGp1c3QgbmVlZCB0byByZXNvbHZlXG4gIFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcbiAgXHRpZiAocmVmID0gdGVtcGxhdGUucikge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIobXVzdGFjaGUsIHJlZiwgcmVzb2x2ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUucngpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIobXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbik7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcbiAgXHRpZiAobXVzdGFjaGUudGVtcGxhdGUubiA9PT0gU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgXHRcdG11c3RhY2hlLnNldFZhbHVlKHVuZGVmaW5lZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZShrZXlwYXRoKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlKGtleXBhdGgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbihuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgb2xkS2V5cGF0aCA9IG11c3RhY2hlLmtleXBhdGg7XG5cbiAgXHRcdGlmIChuZXdLZXlwYXRoICE9IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0bXVzdGFjaGUucmVzb2x2ZShuZXdLZXlwYXRoKTtcblxuICBcdFx0XHRpZiAob2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRmLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZXNvbHZlID0gTXVzdGFjaGUkcmVzb2x2ZTtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRyZXNvbHZlKGtleXBhdGgpIHtcbiAgXHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXG4gIFx0Ly8gJ1NwZWNpYWwnIGtleXBhdGhzLCBlLmcuIEBmb28gb3IgQDcsIGVuY29kZSBhIHZhbHVlXG4gIFx0aWYgKGtleXBhdGggJiYga2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldFZhbHVlKGtleXBhdGgudmFsdWUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblxuICBcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcbiAgXHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcbiAgXHRpZiAoa2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG4gIFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzKTtcblxuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcbiAgXHQvLyB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3Mgbm8ga2V5cGF0aClcbiAgXHR0aGlzLnNldFZhbHVlKHZhbHVlKTtcblxuICBcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcbiAgXHRpZiAod2FzUmVzb2x2ZWQgJiYgKHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcpKSB7XG4gIFx0XHR0d293YXlCaW5kaW5nLnJlYm91bmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfcmViaW5kID0gTXVzdGFjaGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0Ly8gQ2hpbGRyZW4gZmlyc3RcbiAgXHRpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0cmV0dXJuIGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cbiAgXHRpZiAodGhpcy5yZXNvbHZlcikge1xuICBcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlID0ge1xuICBcdGdldFZhbHVlOiBNdXN0YWNoZV9nZXRWYWx1ZSxcbiAgXHRpbml0OiBNdXN0YWNoZV9pbml0aWFsaXNlLFxuICBcdHJlc29sdmU6IE11c3RhY2hlX3Jlc29sdmUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZV9yZWJpbmRcbiAgfTtcblxuICB2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBJTlRFUlBPTEFUT1I7XG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB0aGlzLnZhbHVlO1xuICBcdH0sXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHR1bmJpbmQ6IHNoYXJlZF91bmJpbmQsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHRkZXRhY2hOb2RlKHRoaXMubm9kZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblxuICBcdC8vIFRFTVBcbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgd3JhcHBlcjtcblxuICBcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggJiYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cbiAgXHRcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKGVzY2FwZSkge1xuICBcdFx0dmFyIHN0cmluZyA9IFwiXCIgKyBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKHN0cmluZykgOiBzdHJpbmc7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19JbnRlcnBvbGF0b3IgPSBJbnRlcnBvbGF0b3I7XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSA9IFNlY3Rpb24kYnViYmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH1cblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoID0gU2VjdGlvbiRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG4gIFx0dmFyIGRvY0ZyYWc7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbMF0uZGV0YWNoKCk7XG4gIFx0fVxuXG4gIFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoaXRlbS5kZXRhY2goKSk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfVxuXG4gIHZhciBmaW5kID0gU2VjdGlvbiRmaW5kO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmRBbGwgPSBTZWN0aW9uJGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRBbGxDb21wb25lbnRzID0gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW47XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBmaW5kQ29tcG9uZW50ID0gU2VjdGlvbiRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbaV0uZmluZENvbXBvbmVudChzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmROZXh0Tm9kZSA9IFNlY3Rpb24kZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZE5leHROb2RlKGZyYWdtZW50KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0pIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnbWVudC5pbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBmaXJzdE5vZGUgPSBTZWN0aW9uJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcbiAgXHR2YXIgbGVuLCBpLCBub2RlO1xuXG4gIFx0aWYgKGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGlmIChub2RlID0gdGhpcy5mcmFnbWVudHNbaV0uZmlyc3ROb2RlKCkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBzaHVmZmxlID0gU2VjdGlvbiRzaHVmZmxlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kc2h1ZmZsZShuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudDtcblxuICBcdC8vIHNob3J0IGNpcmN1aXQgYW55IGRvdWJsZS11cGRhdGVzLCBhbmQgZW5zdXJlIHRoYXQgdGhpcyBpc24ndCBhcHBsaWVkIHRvXG4gIFx0Ly8gbm9uLWxpc3Qgc2VjdGlvbnNcbiAgXHRpZiAodGhpcy5zaHVmZmxpbmcgfHwgdGhpcy51bmJvdW5kIHx8IHRoaXMuY3VycmVudFN1YnR5cGUgIT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuc2h1ZmZsaW5nID0gdHJ1ZTtcbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIF90aGlzLnNodWZmbGluZyA9IGZhbHNlO1xuICBcdH0pO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0Ly8gVE9ETzogbmVlZCB0byB1cGRhdGUgdGhpc1xuICBcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG4gIFx0bmV3SW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgXHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGgsIGRlcHM7XG5cbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gb2xkSW5kZXgpIHtcbiAgXHRcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gX3RoaXMuZnJhZ21lbnRzW29sZEluZGV4XTtcblxuICBcdFx0aWYgKGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuICBcdFx0aWYgKG5ld0luZGV4ID09PSAtMSkge1xuICBcdFx0XHRfdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcbiAgXHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcbiAgXHRcdG9sZEtleXBhdGggPSBfdGhpcy5rZXlwYXRoLmpvaW4ob2xkSW5kZXgpO1xuICBcdFx0bmV3S2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihuZXdJbmRleCk7XG5cbiAgXHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgXHRcdC8vIG5vdGlmeSBhbnkgcmVnaXN0ZXJlZCBpbmRleCByZWZzIGRpcmVjdGx5XG4gIFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0ZGVwcy5mb3JFYWNoKHNodWZmbGVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0cmVib3VuZEZyYWdtZW50c1tuZXdJbmRleF0gPSBmcmFnbWVudDtcbiAgXHR9KTtcblxuICBcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkubGVuZ3RoO1xuXG4gIFx0Ly8gSWYgbm90aGluZyBjaGFuZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGZyYWdtZW50cywgdGhlbiB3ZSBzdGFydCBhZGRpbmdcbiAgXHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cbiAgXHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuICBcdFx0aWYgKHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuICBcdH1cblxuICBcdHRoaXMubGVuZ3RoID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gUHJlcGFyZSBuZXcgZnJhZ21lbnQgb3B0aW9uc1xuICBcdGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG4gIFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH07XG5cbiAgXHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG4gIFx0Ly8gKGRldGFjaGVkKSBmcmFnbWVudHNcbiAgXHRmb3IgKGkgPSBmaXJzdENoYW5nZTsgaSA8IG5ld0xlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5wdXNoKGkpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNodWZmbGVfX2JsaW5kUmViaW5kKGRlcCkge1xuICBcdC8vIHRoZSBrZXlwYXRoIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUgYXMgaXQgd29uJ3QgaGF2ZSBjaGFuZ2VkXG4gIFx0ZGVwLnJlYmluZChcIlwiLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfcmViaW5kID0gZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRNdXN0YWNoZS5yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgfTtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyID0gU2VjdGlvbiRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGYucmVuZGVyKCkpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBzZXRWYWx1ZSA9IFNlY3Rpb24kc2V0VmFsdWU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgd3JhcHBlciwgZnJhZ21lbnRPcHRpb25zO1xuXG4gIFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cbiAgXHRcdC8vIGV4cHJlc3Npb24gcmVmZXJzIHRvIGEgZnVuY3Rpb24gdGhhdCBtdXRhdGVzIHRoZSBhcnJheSB0aGF0IHRoaXNcbiAgXHRcdC8vIHNlY3Rpb24gZGVwZW5kcyBvbiAtIHdlJ2xsIGVuZCB1cCB3aXRoIGEgZG91YmxlIHJlbmRlcmluZyBidWcgKHNlZVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0Ly8gd2l0aCBzZWN0aW9ucywgd2UgbmVlZCB0byBnZXQgdGhlIGZha2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHdyYXBwZWQgb2JqZWN0XG4gIFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhbnkgZnJhZ21lbnRzIGFyZSBhd2FpdGluZyBjcmVhdGlvbiBhZnRlciBhIHNwbGljZSxcbiAgXHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuICBcdGlmICh0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCkge1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mIHx8IFtdLFxuICBcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuICBcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0fTtcblxuICBcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICBcdFx0XHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBfdGhpcy5rZXlwYXRoLmpvaW4oaW5kZXgpO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goX3RoaXMuZnJhZ21lbnRzW2luZGV4XSA9IGZyYWdtZW50KTtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCA9IDA7XG4gIFx0fSBlbHNlIGlmIChyZWV2YWx1YXRlU2VjdGlvbih0aGlzLCB2YWx1ZSkpIHtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHZhbHVlLCBvYmopIHtcbiAgXHRpZiAodmFsdWUgPT09IFNFQ1RJT05fRUFDSCkge1xuICBcdFx0Ly8gbWFrZSBzdXJlIHJlZiB0eXBlIGlzIHVwIHRvIGRhdGUgZm9yIGtleSBvciB2YWx1ZSBpbmRpY2VzXG4gIFx0XHRpZiAoc2VjdGlvbi5pbmRleFJlZnMgJiYgc2VjdGlvbi5pbmRleFJlZnNbMF0pIHtcbiAgXHRcdFx0dmFyIHJlZiA9IHNlY3Rpb24uaW5kZXhSZWZzWzBdO1xuXG4gIFx0XHRcdC8vIHdoZW4gc3dpdGNoaW5nIGZsYXZvcnMsIG1ha2Ugc3VyZSB0aGUgc2VjdGlvbiBnZXRzIHVwZGF0ZWRcbiAgXHRcdFx0aWYgKG9iaiAmJiByZWYudCA9PT0gXCJpXCIgfHwgIW9iaiAmJiByZWYudCA9PT0gXCJrXCIpIHtcbiAgXHRcdFx0XHQvLyBpZiBzd2l0Y2hpbmcgZnJvbSBvYmplY3QgdG8gbGlzdCwgdW5iaW5kIGFsbCBvZiB0aGUgb2xkIGZyYWdtZW50c1xuICBcdFx0XHRcdGlmICghb2JqKSB7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDA7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zbGljZSgwKTtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiBmLnVuYmluZCgpO1xuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmVmLnQgPSBvYmogPyBcImtcIiA6IFwiaVwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24uY3VycmVudFN1YnR5cGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVTZWN0aW9uKHNlY3Rpb24sIHZhbHVlKSB7XG4gIFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdHRlbXBsYXRlOiBzZWN0aW9uLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRyb290OiBzZWN0aW9uLnJvb3QsXG4gIFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcbiAgXHRcdG93bmVyOiBzZWN0aW9uXG4gIFx0fTtcblxuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IHRydWU7XG5cbiAgXHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcbiAgXHQvLyBUT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD8gaS5lLiBwaWNrIGFuIHJlZXZhbHVhdGVTZWN0aW9uIGZ1bmN0aW9uIGR1cmluZyBpbml0XG4gIFx0Ly8gYW5kIGF2b2lkIGRvaW5nIHRoaXMgZWFjaCB0aW1lP1xuICBcdGlmIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdHN3aXRjaCAoc2VjdGlvbi5zdWJ0eXBlKSB7XG4gIFx0XHRcdGNhc2UgU0VDVElPTl9JRjpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX1VOTEVTUzpcbiAgXHRcdFx0XHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGX1dJVEg6XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9FQUNIOlxuICBcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIHNlY3Rpb24uc3VidHlwZSwgdHJ1ZSk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIEZhbGx0aHJvdWdoIC0gaWYgaXQncyBhIGNvbmRpdGlvbmFsIG9yIGFuIGFycmF5IHdlIG5lZWQgdG8gY29udGludWVcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcbiAgXHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXlMaWtlKHZhbHVlKTtcblxuICBcdC8vIE9yZGVyZWQgbGlzdCBzZWN0aW9uXG4gIFx0aWYgKHNlY3Rpb24ub3JkZXJlZCkge1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9FQUNILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG4gIFx0aWYgKGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuICBcdFx0aWYgKHNlY3Rpb24udGVtcGxhdGUuaSkge1xuICBcdFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIHRydWUpO1xuICBcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBPdGhlcndpc2UsIG9iamVjdCBwcm92aWRlcyBjb250ZXh0IGZvciBjb250ZW50c1xuICBcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9XSVRILCBmYWxzZSk7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gQ29uZGl0aW9uYWwgc2VjdGlvblxuICBcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fSUYsIGZhbHNlKTtcbiAgXHRzZWN0aW9uLmhhc0NvbnRleHQgPSBmYWxzZTtcbiAgXHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpLCBsZW5ndGgsIGZyYWdtZW50O1xuXG4gIFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIFx0aWYgKGxlbmd0aCA9PT0gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdC8vIE5vdGhpbmcgdG8gZG9cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcbiAgXHRpZiAobGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZShsZW5ndGgsIHNlY3Rpb24ubGVuZ3RoIC0gbGVuZ3RoKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlLi4uXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAobGVuZ3RoID4gc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdFx0Ly8gYWRkIGFueSBuZXcgb25lc1xuICBcdFx0XHRmb3IgKGkgPSBzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdFx0Ly8gYXBwZW5kIGxpc3QgaXRlbSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpKTtcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpO1xuXG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1tpXSA9IGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24ubGVuZ3RoID0gbGVuZ3RoO1xuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQsIGRlcHM7XG5cbiAgXHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoc2VjdGlvbi5oYXNLZXkgPSB7fSk7XG5cbiAgXHQvLyByZW1vdmUgYW55IGZyYWdtZW50cyB0aGF0IHNob3VsZCBubyBsb25nZXIgZXhpc3RcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmICghKGZyYWdtZW50LmtleSBpbiB2YWx1ZSkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGksIDEpO1xuXG4gIFx0XHRcdGhhc0tleVtmcmFnbWVudC5rZXldID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gbm90aWZ5IGFueSBkZXBlbmRlbnRzIGFib3V0IGNoYW5nZWQgaW5kaWNlc1xuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKGZyYWdtZW50LmluZGV4ICE9PSBpKSB7XG4gIFx0XHRcdGZyYWdtZW50LmluZGV4ID0gaTtcbiAgXHRcdFx0aWYgKGRlcHMgPSBmcmFnbWVudC5yZWdpc3RlcmVkSW5kZXhSZWZzKSB7XG4gIFx0XHRcdFx0ZGVwcy5mb3JFYWNoKHNldFZhbHVlX19ibGluZFJlYmluZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBhZGQgYW55IHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0XG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGlkIGluIHZhbHVlKSB7XG4gIFx0XHRpZiAoIWhhc0tleVtpZF0pIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGguam9pbihpZCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5rZXkgPSBpZDtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaSsrO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0aGFzS2V5W2lkXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0cmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHQvLyAuLi50aGVuIGlmIGl0IGlzbid0IHJlbmRlcmVkLCByZW5kZXIgaXQsIGFkZGluZyBzZWN0aW9uLmtleXBhdGggdG8gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyAoaWYgaXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgdGhlbiBhbnkgY2hpbGRyZW4gZGVwZW5kZW50IG9uIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG4gIFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGg7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1swXSA9IGZyYWdtZW50KTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgaW52ZXJ0ZWQsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBkb1JlbmRlciwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZyYWdtZW50LCBuYW1lO1xuXG4gIFx0ZW1wdHlBcnJheSA9IGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gIFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcbiAgXHRpZiAoIWlzQXJyYXlMaWtlKHZhbHVlKSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgXHRcdGVtcHR5T2JqZWN0ID0gdHJ1ZTtcbiAgXHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICBcdFx0XHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaW52ZXJ0ZWQpIHtcbiAgXHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCBlbXB0eU9iamVjdCB8fCAhdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXkgJiYgIWVtcHR5T2JqZWN0O1xuICBcdH1cblxuICBcdGlmIChkb1JlbmRlcikge1xuICBcdFx0aWYgKCFzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBubyBjaGFuZ2UgdG8gY29udGV4dCBzdGFja1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChzZWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDEpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pIHtcbiAgXHRpZiAoc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSgwLCBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGgpLmZpbHRlcihpc1JlbmRlcmVkKTtcbiAgXHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIubGVuZ3RoID0gMDtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVuZGVyZWQoZnJhZ21lbnQpIHtcbiAgXHRyZXR1cm4gZnJhZ21lbnQucmVuZGVyZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV90b1N0cmluZyA9IFNlY3Rpb24kdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR0b1N0cmluZyhlc2NhcGUpIHtcbiAgXHR2YXIgc3RyLCBpLCBsZW47XG5cbiAgXHRzdHIgPSBcIlwiO1xuXG4gIFx0aSA9IDA7XG4gIFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1tpXS50b1N0cmluZyhlc2NhcGUpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VuYmluZCA9IFNlY3Rpb24kdW5iaW5kO1xuICBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIHJlbW92ZUZyb21BcnJheShfdGhpcy5mcmFnbWVudHMsIGYpO1xuICBcdH0pO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG5cbiAgXHR0aGlzLmxlbmd0aCA9IDA7XG4gIFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5yZW5kZXIgPSBTZWN0aW9uJHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIpO1xuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3RvdHlwZV91bnJlbmRlcl9fdW5yZW5kZXIoZnJhZ21lbnQpIHtcbiAgXHRmcmFnbWVudC51bnJlbmRlcihmYWxzZSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZSA9IFNlY3Rpb24kdXBkYXRlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuICBcdHZhciBmcmFnbWVudCwgcmVuZGVySW5kZXgsIHJlbmRlcmVkRnJhZ21lbnRzLCBhbmNob3IsIHRhcmdldCwgaSwgbGVuO1xuXG4gIFx0Ly8gYHRoaXMucmVuZGVyZWRGcmFnbWVudHNgIGlzIGluIHRoZSBvcmRlciBvZiB0aGUgcHJldmlvdXMgcmVuZGVyLlxuICBcdC8vIElmIGZyYWdtZW50cyBoYXZlIHNodWZmbGVkIGFib3V0LCB0aGlzIGFsbG93cyB1cyB0byBxdWlja2x5XG4gIFx0Ly8gcmVpbnNlcnQgdGhlbSBpbiB0aGUgY29ycmVjdCBwbGFjZVxuICBcdHJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5yZW5kZXJlZEZyYWdtZW50cztcblxuICBcdC8vIFJlbW92ZSBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciBkZXN0cnVjdGlvblxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSkge1xuICBcdFx0ZnJhZ21lbnQudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCksIDEpO1xuICBcdH1cblxuICBcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIChidXQgZG9uJ3QgaW5zZXJ0IHRoZW0geWV0KVxuICBcdHdoaWxlIChmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSkge1xuICBcdFx0ZnJhZ21lbnQucmVuZGVyKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuICBcdH1cblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNbaV07XG4gIFx0XHRyZW5kZXJJbmRleCA9IHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnQsIGkpOyAvLyBzZWFyY2ggZnJvbSBjdXJyZW50IGluZGV4IC0gaXQncyBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIG9yIGhpZ2hlclxuXG4gIFx0XHRpZiAocmVuZGVySW5kZXggPT09IGkpIHtcbiAgXHRcdFx0Ly8gYWxyZWFkeSBpbiB0aGUgcmlnaHQgcGxhY2UuIGluc2VydCBhY2N1bXVsYXRlZCBub2RlcyAoaWYgYW55KSBhbmQgY2Fycnkgb25cbiAgXHRcdFx0aWYgKHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0XHRcdGFuY2hvciA9IGZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZChmcmFnbWVudC5kZXRhY2goKSk7XG5cbiAgXHRcdC8vIHVwZGF0ZSByZW5kZXJlZEZyYWdtZW50c1xuICBcdFx0aWYgKHJlbmRlckluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UocmVuZGVySW5kZXgsIDEpO1xuICBcdFx0fVxuICBcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKGksIDAsIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgXHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0fVxuXG4gIFx0Ly8gU2F2ZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGZvciBuZXh0IHRpbWVcbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBTRUNUSU9OO1xuICBcdHRoaXMuc3VidHlwZSA9IHRoaXMuY3VycmVudFN1YnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG4gIFx0dGhpcy5pbnZlcnRlZCA9IHRoaXMuc3VidHlwZSA9PT0gU0VDVElPTl9VTkxFU1M7XG5cbiAgXHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnRzID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBbXTtcblxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLmkpIHtcbiAgXHRcdHRoaXMuaW5kZXhSZWZzID0gb3B0aW9ucy50ZW1wbGF0ZS5pLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKGssIGkpIHtcbiAgXHRcdFx0cmV0dXJuIHsgbjogaywgdDogaSA9PT0gMCA/IFwia1wiIDogXCJpXCIgfTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIHRpbWVzIHRoaXMgc2VjdGlvbiBpcyByZW5kZXJlZFxuXG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBTZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IFNlY3Rpb25fcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IFNlY3Rpb25fcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBmaW5kLFxuICBcdGZpbmRBbGw6IGZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG4gIFx0Z2V0SW5kZXhSZWY6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAodGhpcy5pbmRleFJlZnMpIHtcbiAgXHRcdFx0dmFyIGkgPSB0aGlzLmluZGV4UmVmcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5pbmRleFJlZnNbaV07XG4gIFx0XHRcdFx0aWYgKHJlZi5uID09PSBuYW1lKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHNodWZmbGU6IHNodWZmbGUsXG4gIFx0cmViaW5kOiBwcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogU2VjdGlvbl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBwcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBwcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBwcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dXBkYXRlOiBwcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9TZWN0aW9uID0gU2VjdGlvbjtcblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9kZXRhY2ggPSBUcmlwbGUkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRkZXRhY2goKSB7XG4gIFx0dmFyIGxlbiwgaTtcblxuICBcdGlmICh0aGlzLmRvY0ZyYWcpIHtcbiAgXHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maW5kID0gVHJpcGxlJGZpbmQ7XG4gIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwgPSBUcmlwbGUkZmluZEFsbDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0KSB7XG4gIFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXG4gIFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuICBcdFx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocXVlcnlBbGxSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSkge1xuICBcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gocXVlcnlBbGxSZXN1bHRbal0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmlyc3ROb2RlID0gVHJpcGxlJGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBUcmlwbGUkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbMF0pIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50Q2FjaGUgPSB7fSxcbiAgICAgIGllQnVnLFxuICAgICAgaWVCbGFja2xpc3Q7XG5cbiAgdHJ5IHtcbiAgXHRjcmVhdGVFbGVtZW50KFwidGFibGVcIikuaW5uZXJIVE1MID0gXCJmb29cIjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0aWVCdWcgPSB0cnVlO1xuXG4gIFx0aWVCbGFja2xpc3QgPSB7XG4gIFx0XHRUQUJMRTogW1wiPHRhYmxlIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgXHRcdFRIRUFEOiBbXCI8dGFibGU+PHRoZWFkIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RoZWFkPjwvdGFibGU+XCJdLFxuICBcdFx0VEJPRFk6IFtcIjx0YWJsZT48dGJvZHkgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gIFx0XHRUUjogW1wiPHRhYmxlPjx0ciBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90cj48L3RhYmxlPlwiXSxcbiAgXHRcdFNFTEVDVDogW1wiPHNlbGVjdCBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC9zZWxlY3Q+XCJdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24gKGh0bWwsIG5vZGUsIGRvY0ZyYWcpIHtcbiAgXHR2YXIgY29udGFpbmVyLFxuICBcdCAgICBub2RlcyA9IFtdLFxuICBcdCAgICB3cmFwcGVyLFxuICBcdCAgICBzZWxlY3RlZE9wdGlvbixcbiAgXHQgICAgY2hpbGQsXG4gIFx0ICAgIGk7XG5cbiAgXHQvLyByZW5kZXIgMCBhbmQgZmFsc2VcbiAgXHRpZiAoaHRtbCAhPSBudWxsICYmIGh0bWwgIT09IFwiXCIpIHtcbiAgXHRcdGlmIChpZUJ1ZyAmJiAod3JhcHBlciA9IGllQmxhY2tsaXN0W25vZGUudGFnTmFtZV0pKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cmFwcGVyWzBdICsgaHRtbCArIHdyYXBwZXJbMV07XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoXCJESVZcIik7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmcgY2xhc3M9XFxcInhcXFwiPlwiICsgaHRtbCArIFwiPC9zdmc+XCI7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnhcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KG5vZGUudGFnTmFtZSk7XG4gIFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXG4gIFx0XHRcdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbY29udGFpbmVyLnNlbGVjdGVkSW5kZXhdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChjaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gIFx0XHRcdG5vZGVzLnB1c2goY2hpbGQpO1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcbiAgXHRcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuICBcdFx0Ly8gYmVjb21lIHNlbGVjdGVkLiBTbyBub3cgd2UgaGF2ZSB0byBkZXNlbGVjdCB0aGVtLiBJRTgsIHlvdVxuICBcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cbiAgXHRcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuICBcdFx0aWYgKG5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aWYgKG5vZGVzW2ldICE9PSBzZWxlY3RlZE9wdGlvbikge1xuICBcdFx0XHRcdFx0bm9kZXNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZWxlbWVudCh0YWdOYW1lKSB7XG4gIFx0cmV0dXJuIGVsZW1lbnRDYWNoZVt0YWdOYW1lXSB8fCAoZWxlbWVudENhY2hlW3RhZ05hbWVdID0gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gIH1cblxuICB2YXIgaGVscGVyc191cGRhdGVTZWxlY3QgPSB1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0KHBhcmVudEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXG4gIFx0aWYgKCFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gXCJzZWxlY3RcIiB8fCAhcGFyZW50RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheShwYXJlbnRFbGVtZW50Lm5vZGUub3B0aW9ucykuZmlsdGVyKGlzU2VsZWN0ZWQpO1xuXG4gIFx0Ly8gSWYgb25lIG9mIHRoZW0gaGFkIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIHdlIG5lZWQgdG8gc3luY1xuICBcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuICBcdGlmIChwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gIFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgXHRcdFx0cmV0dXJuIG8udmFsdWU7XG4gIFx0XHR9KTtcbiAgXHR9IGVsc2UgaWYgKG9wdGlvbiA9IHNlbGVjdGVkT3B0aW9uc1swXSkge1xuICBcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0cGFyZW50RWxlbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VsZWN0ZWQob3B0aW9uKSB7XG4gIFx0cmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3JlbmRlciA9IFRyaXBsZSRyZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSRyZW5kZXIoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZW5kZXIgYW4gaXRlbSB0aGF0IHdhcyBhbHJlYWR5IHJlbmRlcmVkXCIpO1xuICBcdH1cblxuICBcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCh0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0VmFsdWUgPSBUcmlwbGUkc2V0VmFsdWU7XG4gIGZ1bmN0aW9uIFRyaXBsZSRzZXRWYWx1ZSh2YWx1ZSkge1xuICBcdHZhciB3cmFwcGVyO1xuXG4gIFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cbiAgXHRpZiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV90b1N0cmluZyA9IFRyaXBsZSR0b1N0cmluZztcbiAgZnVuY3Rpb24gVHJpcGxlJHRvU3RyaW5nKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoXCJcIiArIHRoaXMudmFsdWUpIDogXCJcIjtcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyID0gVHJpcGxlJHVucmVuZGVyO1xuICBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdHRoaXMubm9kZXMuZm9yRWFjaChkZXRhY2hOb2RlKTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBUT0RPIHVwZGF0ZSBsaXZlIHF1ZXJpZXNcbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3VwZGF0ZSA9IFRyaXBsZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1cGRhdGUoKSB7XG4gIFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcbiAgXHR3aGlsZSAodGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0fVxuXG4gIFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuICBcdHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblxuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyk7XG4gIFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cbiAgXHRoZWxwZXJzX3VwZGF0ZVNlbGVjdCh0aGlzLnBFbGVtZW50KTtcbiAgfVxuXG4gIHZhciBUcmlwbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFRSSVBMRTtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFRyaXBsZS5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogVHJpcGxlX3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpcnN0Tm9kZTogVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdHJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogcHJvdG90eXBlX3NldFZhbHVlLFxuICBcdHRvU3RyaW5nOiBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogVHJpcGxlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9UcmlwbGUgPSBUcmlwbGU7XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2J1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBFbGVtZW50JGRldGFjaDtcblxuICBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgcGFyZW50Tm9kZTtcblxuICBcdGlmIChub2RlKSB7XG4gIFx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBwYXJlbnQgbm9kZSAtIERPTSBtYXkgaGF2ZSBiZWVuIGFsdGVyZWRcbiAgXHRcdC8vIGJ5IHNvbWV0aGluZyBvdGhlciB0aGFuIFJhY3RpdmUhIGUuZy4galF1ZXJ5IFVJLi4uXG4gIFx0XHRpZiAocGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICBcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbm9kZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHQvLyB0aGlzIGVsZW1lbnQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAobWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LmZpbmQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHQvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBxdWVyeSwgaWYgYXBwbGljYWJsZSwgYW5kIHJlZ2lzdGVyIHRoZVxuICBcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuICBcdGlmIChxdWVyeS5fdGVzdCh0aGlzLCB0cnVlKSAmJiBxdWVyeS5saXZlKSB7XG4gIFx0XHQodGhpcy5saXZlUXVlcmllcyB8fCAodGhpcy5saXZlUXVlcmllcyA9IFtdKSkucHVzaChxdWVyeSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBFbGVtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpbmROZXh0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maXJzdE5vZGUgPSBFbGVtZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgdmFyIGdldEF0dHJpYnV0ZSA9IEVsZW1lbnQkZ2V0QXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgXHRpZiAoIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzW25hbWVdKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZTtcbiAgfVxuXG4gIHZhciB0cnV0aHkgPSAvXnRydWV8b258eWVzfDEkL2k7XG4gIHZhciBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXNfX2lzTnVtZXJpYyA9IC9eWzAtOV0rJC87XG5cbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciB2YWwsIGF0dHJzLCBhdHRyaWJ1dGVzO1xuXG4gIFx0YXR0cmlidXRlcyA9IHRlbXBsYXRlLmEgfHwge307XG4gIFx0YXR0cnMgPSB7fTtcblxuICBcdC8vIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJlc2VudCBidXQgZG9uJ3QgaGF2ZSBhIHZhbHVlICg9KVxuICBcdC8vIHdpbGwgYmUgc2V0IHRvIHRoZSBudW1iZXIgMCwgd2hpY2ggd2UgY29uZGlkZXIgdG8gYmUgdHJ1ZVxuICBcdC8vIHRoZSBzdHJpbmcgJzAnLCBob3dldmVyIGlzIGZhbHNlXG5cbiAgXHR2YWwgPSBhdHRyaWJ1dGVzLnR3b3dheTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGF0dHJzLnR3b3dheSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdH1cblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMubGF6eTtcbiAgXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIGNoZWNrIGZvciB0aW1lb3V0IHZhbHVlXG4gIFx0XHRpZiAodmFsICE9PSAwICYmIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljLnRlc3QodmFsKSkge1xuICBcdFx0XHRhdHRycy5sYXp5ID0gcGFyc2VJbnQodmFsKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSB2YWwgPT09IDAgfHwgdHJ1dGh5LnRlc3QodmFsKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cnM7XG4gIH07XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlID0gQXR0cmlidXRlJGJ1YmJsZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGJ1YmJsZSgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnVzZVByb3BlcnR5IHx8ICF0aGlzLnJlbmRlcmVkID8gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpIDogdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXG4gIFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3RcbiAgXHQvLyAnQXR0cmlidXRlIHdpdGggbmVzdGVkIG11c3RhY2hlcycpXG4gIFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuXG4gIFx0XHQvLyBOZWVkIHRvIGNsZWFyIG9sZCBpZCBmcm9tIHJhY3RpdmUubm9kZXNcbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIiAmJiB0aGlzLnZhbHVlKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbdGhpcy52YWx1ZV07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMubm9kZSkge1xuICBcdFx0XHQvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSB2YWx1ZSBvbiB0aGUgRE9NIGxpa2UgdGhpcyBzbyB3ZVxuICBcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG4gIFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBzdmdDYW1lbENhc2VFbGVtZW50cywgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcywgY3JlYXRlTWFwLCBtYXA7XG4gIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzID0gXCJhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuXCIuc3BsaXQoXCIgXCIpO1xuICBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzID0gXCJhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuXCIuc3BsaXQoXCIgXCIpO1xuXG4gIGNyZWF0ZU1hcCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBcdHZhciBtYXAgPSB7fSxcbiAgXHQgICAgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRtYXBbaXRlbXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpdGVtc1tpXTtcbiAgXHR9XG4gIFx0cmV0dXJuIG1hcDtcbiAgfTtcblxuICBtYXAgPSBjcmVhdGVNYXAoc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMpKTtcblxuICB2YXIgZW5mb3JjZUNhc2UgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHtcbiAgXHR2YXIgbG93ZXJDYXNlRWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBcdHJldHVybiBtYXBbbG93ZXJDYXNlRWxlbWVudE5hbWVdIHx8IGxvd2VyQ2FzZUVsZW1lbnROYW1lO1xuICB9O1xuXG4gIHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgbmFtZSkge1xuICBcdHZhciBjb2xvbkluZGV4LCBuYW1lc3BhY2VQcmVmaXg7XG5cbiAgXHQvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZXNwYWNlZCBhdHRyaWJ1dGUsIGUuZy4geGxpbms6aHJlZj9cbiAgXHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgXHRpZiAoY29sb25JbmRleCAhPT0gLTEpIHtcblxuICBcdFx0Ly8gbG9va3MgbGlrZSB3ZSBhcmUsIHllcy4uLlxuICBcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoMCwgY29sb25JbmRleCk7XG5cbiAgXHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cbiAgXHRcdC8vIHRoYXQgb25seSB2YWxpZCBuYW1lc3BhY2VzIHdpbGwgYmUgdXNlZClcbiAgXHRcdGlmIChuYW1lc3BhY2VQcmVmaXggIT09IFwieG1sbnNcIikge1xuICBcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuXG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gZW5mb3JjZUNhc2UobmFtZSk7XG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpXTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZVByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcblxuICBcdFx0XHRpZiAoIWF0dHJpYnV0ZS5uYW1lc3BhY2UpIHtcbiAgXHRcdFx0XHR0aHJvdyBcIlVua25vd24gbmFtZXNwYWNlIChcXFwiXCIgKyBuYW1lc3BhY2VQcmVmaXggKyBcIlxcXCIpXCI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmVcbiAgXHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UobmFtZSkgOiBuYW1lO1xuICB9O1xuXG4gIHZhciBoZWxwZXJzX2dldEludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvcjtcbiAgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKGF0dHJpYnV0ZSkge1xuICBcdHZhciBpdGVtcyA9IGF0dHJpYnV0ZS5mcmFnbWVudC5pdGVtcztcblxuICBcdGlmIChpdGVtcy5sZW5ndGggIT09IDEpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbXNbMF0udHlwZSA9PT0gSU5URVJQT0xBVE9SKSB7XG4gIFx0XHRyZXR1cm4gaXRlbXNbMF07XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9pbml0ID0gQXR0cmlidXRlJGluaXQ7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBBVFRSSUJVVEU7XG4gIFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcblxuICBcdGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UodGhpcywgb3B0aW9ucy5uYW1lKTtcbiAgXHR0aGlzLmlzQm9vbGVhbiA9IGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QodGhpcy5uYW1lKTtcblxuICBcdC8vIGlmIGl0J3MgYW4gZW1wdHkgYXR0cmlidXRlLCBvciBqdXN0IGEgc3RyYWlnaHQga2V5LXZhbHVlIHBhaXIsIHdpdGggbm9cbiAgXHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcbiAgXHRpZiAoIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLmlzQm9vbGVhbiA/IHRydWUgOiBvcHRpb25zLnZhbHVlIHx8IFwiXCI7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZG8gc29tZSB3b3JrXG5cbiAgXHQvLyBzaGFyZSBwYXJlbnRGcmFnbWVudCB3aXRoIHBhcmVudCBlbGVtZW50XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogb3B0aW9ucy52YWx1ZSxcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHQvLyBUT0RPIGNhbiB3ZSB1c2UgdGhpcy5mcmFnbWVudC50b1N0cmluZygpIGluIHNvbWUgY2FzZXM/IEl0J3MgcXVpY2tlclxuICBcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cbiAgXHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG4gIFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuICBcdC8vIGZvciBjb3JyZWN0bHkgcmVuZGVyaW5nIEhUTUwgbGF0ZXJcbiAgXHR0aGlzLmludGVycG9sYXRvciA9IGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yKHRoaXMpO1xuICBcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3IgJiYgIXRoaXMuaW50ZXJwb2xhdG9yLmlzU3RhdGljO1xuXG4gIFx0Ly8gbWFyayBhcyByZWFkeVxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kID0gQXR0cmlidXRlJHJlYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfcmVuZGVyID0gQXR0cmlidXRlJHJlbmRlcjtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSB7XG4gIFx0XCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgXHRhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXG4gIFx0Ymdjb2xvcjogXCJiZ0NvbG9yXCIsXG4gIFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICBcdGNvZGViYXNlOiBcImNvZGVCYXNlXCIsXG4gIFx0Y29sc3BhbjogXCJjb2xTcGFuXCIsXG4gIFx0Y29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICBcdGRhdGV0aW1lOiBcImRhdGVUaW1lXCIsXG4gIFx0ZGlybmFtZTogXCJkaXJOYW1lXCIsXG4gIFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG4gIFx0XCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gIFx0aXNtYXA6IFwiaXNNYXBcIixcbiAgXHRtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gIFx0bm92YWxpZGF0ZTogXCJub1ZhbGlkYXRlXCIsXG4gIFx0cHViZGF0ZTogXCJwdWJEYXRlXCIsXG4gIFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcbiAgXHRyb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgXHR0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICBcdHVzZW1hcDogXCJ1c2VNYXBcIlxuICB9O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKG5vZGUpIHtcbiAgXHR2YXIgcHJvcGVydHlOYW1lO1xuXG4gIFx0dGhpcy5ub2RlID0gbm9kZTtcblxuICBcdC8vIHNob3VsZCB3ZSB1c2UgZGlyZWN0IHByb3BlcnR5IGFjY2Vzcywgb3Igc2V0QXR0cmlidXRlP1xuICBcdGlmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1t0aGlzLm5hbWVdIHx8IHRoaXMubmFtZTtcblxuICBcdFx0aWYgKG5vZGVbcHJvcGVydHlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cbiAgXHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG4gIFx0XHRpZiAodGhpcy5pc0Jvb2xlYW4gfHwgdGhpcy5pc1R3b3dheSkge1xuICBcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHByb3BlcnR5TmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyA9IEF0dHJpYnV0ZSR0b1N0cmluZztcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IF9yZWYubmFtZXNwYWNlUHJlZml4O1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGludGVycG9sYXRvciA9IF9yZWYuaW50ZXJwb2xhdG9yO1xuICBcdHZhciBmcmFnbWVudCA9IF9yZWYuZnJhZ21lbnQ7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgYW5kIHRleHRhcmVhIHZhbHVlcyAoc2hvdWxkIG5vdCBiZSBzdHJpbmdpZmllZClcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmICh0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiB8fCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnQgZWRpdGFibGVcbiAgXHRpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWVzXG4gIFx0aWYgKG5hbWUgPT09IFwibmFtZVwiICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIgJiYgaW50ZXJwb2xhdG9yKSB7XG4gIFx0XHRyZXR1cm4gXCJuYW1lPXt7XCIgKyAoaW50ZXJwb2xhdG9yLmtleXBhdGguc3RyIHx8IGludGVycG9sYXRvci5yZWYpICsgXCJ9fVwiO1xuICBcdH1cblxuICBcdC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmlzQm9vbGVhbikge1xuICBcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKGZyYWdtZW50KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGlzIGNhdGNoZXMgdW5kZWZpbmVkL251bGwgdmFsdWVzICgjMTIxMSlcbiAgXHRcdGlmIChmcmFnbWVudC5pdGVtcy5sZW5ndGggPT09IDEgJiYgZnJhZ21lbnQuaXRlbXNbMF0udmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRyZXR1cm4gXCJcIjtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cblxuICBcdGlmIChuYW1lc3BhY2VQcmVmaXgpIHtcbiAgXHRcdG5hbWUgPSBuYW1lc3BhY2VQcmVmaXggKyBcIjpcIiArIG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlID8gbmFtZSArIFwiPVxcXCJcIiArIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkgKyBcIlxcXCJcIiA6IG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nX19lc2NhcGUodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImIzM5O1wiKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCA9IEF0dHJpYnV0ZSR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVuYmluZCgpIHtcbiAgXHQvLyBpZ25vcmUgbm9uLWR5bmFtaWMgYXR0cmlidXRlc1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaWRcIikge1xuICBcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0O1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZSxcbiAgXHQgICAgaTtcblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblxuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gdmFsdWUpIHtcbiAgXHRcdFx0XHQvLyBkb3VibGUgZXF1YWxzIGFzIHdlIG1heSBiZSBjb21wYXJpbmcgbnVtYmVycyB3aXRoIHN0cmluZ3NcbiAgXHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gaWYgd2UncmUgc3RpbGwgaGVyZSwgaXQgbWVhbnMgdGhlIG5ldyB2YWx1ZSBkaWRuJ3QgbWF0Y2ggYW55IG9mIHRoZSBvcHRpb25zLi4uXG4gIFx0Ly8gVE9ETyBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gaW4gdGhpcyBzaXR1YXRpb25cbiAgfVxuXG4gIHZhciB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3QoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgXHQgICAgb3B0aW9ucyxcbiAgXHQgICAgaSxcbiAgXHQgICAgb3B0aW9uLFxuICBcdCAgICBvcHRpb25WYWx1ZTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdHZhbHVlID0gW3ZhbHVlXTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgXHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG4gIFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBhcnJheUNvbnRhaW5zKHZhbHVlLCBvcHRpb25WYWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVSYWRpb1ZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlKCkge1xuICBcdHZhciB3YXNDaGVja2VkLFxuICBcdCAgICBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBiaW5kaW5nLFxuICBcdCAgICBiaW5kaW5ncyxcbiAgXHQgICAgaTtcblxuICBcdHdhc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG5cbiAgXHRub2RlLnZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cbiAgXHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG4gIFx0Ly8gY2hhbmdlZCBzbyB0aGF0IGl0J3Mgbm8gbG9uZ2VyIGNoZWNrZWQsIHRoZSB0d293YXkgYmluZGluZyBpc1xuICBcdC8vIG1vc3QgbGlrZWx5IG91dCBvZiBkYXRlLiBUbyBmaXggaXQgd2UgaGF2ZSB0byBqdW1wIHRocm91Z2ggc29tZVxuICBcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuICBcdGlmICh3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cbiAgXHRcdGlmIChpID0gYmluZGluZ3MubGVuZ3RoKSB7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cbiAgXHRcdFx0XHRpZiAoIWJpbmRpbmcuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlciwgc2libGluZ3MgYXJlIHN0aWxsIHJlbmRlcmluZyFcbiAgXHRcdFx0XHRcdC8vIHdlJ2xsIGNvbWUgYmFjayBsYXRlci4uLlxuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKGJpbmRpbmcucm9vdCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIHVuZGVmaW5lZCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNoZWNrYm94TmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTt2YXIgYmluZGluZyA9IGVsZW1lbnQuYmluZGluZzt2YXIgdmFsdWVBdHRyaWJ1dGU7dmFyIGk7XG5cbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IHZhbHVlQXR0cmlidXRlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAodmFsdWVBdHRyaWJ1dGUgPT0gdmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRiaW5kaW5nLmlzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVDbGFzc05hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuICBcdHRoaXMubm9kZS5jbGFzc05hbWUgPSBzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJZEF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdHRoaXMucm9vdC5ub2Rlc1t2YWx1ZV0gPSBub2RlO1xuICBcdG5vZGUuaWQgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciB1cGRhdGVJRVN0eWxlQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUoKSB7XG4gIFx0dmFyIG5vZGUsIHZhbHVlO1xuXG4gIFx0bm9kZSA9IHRoaXMubm9kZTtcbiAgXHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKFwiY3NzVGV4dFwiLCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0dmFsdWUgPSBcIlwiO1xuICBcdH1cblxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlVmFsdWU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVZhbHVlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHQvLyBzdG9yZSBhY3R1YWwgdmFsdWUsIHNvIGl0IGRvZXNuJ3QgZ2V0IGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdG5vZGUudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUJvb2xlYW4gPSBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZSgpIHtcbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICghdGhpcy5sb2NrZWQpIHtcbiAgXHRcdHRoaXMubm9kZVt0aGlzLnByb3BlcnR5TmFtZV0gPSB0aGlzLnZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVFdmVyeXRoaW5nRWxzZSA9IEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlO1xuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdGlmIChuYW1lc3BhY2UpIHtcbiAgXHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCAoZnJhZ21lbnQgfHwgdmFsdWUpLnRvU3RyaW5nKCkpO1xuICBcdH0gZWxzZSBpZiAoIXRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIC0gdHJ1dGh5IGJlY29tZXMgJycsIGZhbHN5IG1lYW5zICdyZW1vdmUgYXR0cmlidXRlJ1xuICBcdGVsc2Uge1xuICBcdFx0aWYgKHZhbHVlKSB7XG4gIFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIGEgZmV3IHNwZWNpYWwgY2FzZXMgd2hlbiBpdCBjb21lcyB0byB1cGRhdGluZyBhdHRyaWJ1dGVzLiBGb3IgdGhpcyByZWFzb24sXG4gIC8vIHRoZSBwcm90b3R5cGUgLnVwZGF0ZSgpIG1ldGhvZCBwb2ludHMgdG8gdGhpcyBtZXRob2QsIHdoaWNoIHdhaXRzIHVudGlsIHRoZVxuICAvLyBhdHRyaWJ1dGUgaGFzIGZpbmlzaGVkIGluaXRpYWxpc2luZywgdGhlbiByZXBsYWNlcyB0aGUgcHJvdG90eXBlIG1ldGhvZCB3aXRoIGEgbW9yZVxuICAvLyBzdWl0YWJsZSBvbmUuIFRoYXQgd2F5LCB3ZSBzYXZlIG91cnNlbHZlcyBkb2luZyBhIGJ1bmNoIG9mIHRlc3RzIG9uIGVhY2ggY2FsbFxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGUgPSBBdHRyaWJ1dGUkdXBkYXRlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO3ZhciB0eXBlO3ZhciB1cGRhdGVNZXRob2Q7XG5cbiAgXHRpZiAobmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcbiAgXHR9IGVsc2UgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gc2VsZWN0c1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT0gbnVsbCkge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0PlxuICBcdFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIpIHtcbiAgXHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblxuICBcdFx0XHQvLyB0eXBlPSdmaWxlJyB2YWx1ZT0ne3tmaWxlTGlzdH19Jz5cbiAgXHRcdFx0aWYgKHR5cGUgPT09IFwiZmlsZVwiKSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDsgLy8gcmVhZC1vbmx5XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB0eXBlPSdyYWRpbycgbmFtZT0ne3t0d293YXl9fSdcbiAgXHRcdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRpb1wiICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb1ZhbHVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19JyB2YWx1ZT0nZm9vJz5cbiAgXHRlbHNlIGlmICh0aGlzLmlzVHdvd2F5ICYmIG5hbWUgPT09IFwibmFtZVwiKSB7XG4gIFx0XHRpZiAobm9kZS50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9OYW1lO1xuICBcdFx0fSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDaGVja2JveE5hbWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gc3R5bGUgYXR0cmlidXRlcyBpbiBJbnRlcm5ldCBFeHBsb2RlclxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIiAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBjbGFzcyBuYW1lcy4gSUUgZnVja3MgdGhpbmdzIHVwLCBhZ2FpblxuICBcdGVsc2UgaWYgKG5hbWUgPT09IFwiY2xhc3NcIiAmJiAoIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwpKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG4gIFx0fSBlbHNlIGlmICh0aGlzLnVzZVByb3BlcnR5KSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuICBcdH1cblxuICBcdGlmICghdXBkYXRlTWV0aG9kKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0ZSA9IHVwZGF0ZU1ldGhvZDtcbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBBdHRyaWJ1dGVfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRpbml0OiBwcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1cGRhdGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdXBkYXRlXG4gIH07XG5cbiAgdmFyIF9BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG5cbiAgdmFyIGNyZWF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBcdHZhciBuYW1lLFxuICBcdCAgICBhdHRyaWJ1dGUsXG4gIFx0ICAgIHJlc3VsdCA9IFtdO1xuXG4gIFx0Zm9yIChuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgXHRcdC8vIHNraXAgYmluZGluZyBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJ0d293YXlcIiB8fCBuYW1lID09PSBcImxhenlcIikge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgXHRcdFx0YXR0cmlidXRlID0gbmV3IF9BdHRyaWJ1dGUoe1xuICBcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG4gIFx0XHRcdFx0bmFtZTogbmFtZSxcbiAgXHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1tuYW1lXSxcbiAgXHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3RcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0cmVzdWx0W25hbWVdID0gYXR0cmlidXRlO1xuXG4gIFx0XHRcdGlmIChuYW1lICE9PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gdmFsdWUgYXR0cmlidXRlIGdvZXMgbGFzdC4gVGhpcyBpcyBiZWNhdXNlIGl0XG4gIFx0Ly8gbWF5IGdldCBjbGFtcGVkIG9uIHJlbmRlciBvdGhlcndpc2UsIGUuZy4gaW5cbiAgXHQvLyBgPGlucHV0IHR5cGU9J3JhbmdlJyB2YWx1ZT0nOTk5JyBtaW49JzAnIG1heD0nMTAwMCc+YFxuICBcdC8vIHNpbmNlIGRlZmF1bHQgbWF4IGlzIDEwMFxuICBcdGlmIChhdHRyaWJ1dGUgPSByZXN1bHQudmFsdWUpIHtcbiAgXHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXY7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBcdF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgfVxuXG4gIHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5hdHRyaWJ1dGVzID0gW107XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0cm9vdDogZWxlbWVudC5yb290LFxuICBcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHR0ZW1wbGF0ZTogW3RlbXBsYXRlXVxuICBcdH0pO1xuICB9O1xuXG4gIENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5lbGVtZW50LmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICBcdFx0dGhpcy5ub2RlID0gbm9kZTtcbiAgXHRcdHRoaXMuaXNTdmcgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmc7XG5cbiAgXHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgc3RyLCBhdHRycztcblxuICBcdFx0c3RyID0gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoc3RyLCB0aGlzLmlzU3ZnKTtcblxuICBcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuICBcdFx0Ly8gbXVzdCBiZSByZW1vdmVkXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdHJldHVybiBub3RJbihhdHRycywgYSk7XG4gIFx0XHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGEubmFtZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0YXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRfdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLm5hbWUsIGEudmFsdWUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJzO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9Db25kaXRpb25hbEF0dHJpYnV0ZSA9IENvbmRpdGlvbmFsQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhzdHIsIGlzU3ZnKSB7XG4gIFx0dmFyIHRhZyA9IGlzU3ZnID8gXCJzdmdcIiA6IFwiZGl2XCI7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuaW5uZXJIVE1MID0gXCI8XCIgKyB0YWcgKyBcIiBcIiArIHN0ciArIFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcblxuICBcdHJldHVybiB0b0FycmF5KF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2LmNoaWxkTm9kZXNbMF0uYXR0cmlidXRlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gIFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoaGF5c3RhY2tbaV0ubmFtZSA9PT0gbmVlZGxlLm5hbWUpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0aWYgKCFhdHRyaWJ1dGVzKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Db25kaXRpb25hbEF0dHJpYnV0ZShlbGVtZW50LCBhKTtcbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgQmluZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWUsIHBhcmVudEZvcm07XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1t0aGlzLm5hbWUgfHwgXCJ2YWx1ZVwiXTtcblxuICBcdGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcbiAgXHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cbiAgXHRpZiAoa2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoKSB7XG4gIFx0XHRpZiAoa2V5cGF0aC5zdHIuc2xpY2UoLTEpID09PSBcIn1cIikge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoIGV4cHJlc3Npb25zIChgJXNgIG9uIDwlcz4pXCIsIGludGVycG9sYXRvci5yZXNvbHZlci51bmlxdWVTdHJpbmcsIGVsZW1lbnQubmFtZSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggJXNcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gQSBtdXN0YWNoZSBtYXkgYmUgKmFtYmlndW91cyouIExldCdzIHNheSB3ZSB3ZXJlIGdpdmVuXG4gIFx0XHQvLyBgdmFsdWU9XCJ7e2Jhcn19XCJgLiBJZiB0aGUgY29udGV4dCB3YXMgYGZvb2AsIGFuZCBgZm9vLmJhcmBcbiAgXHRcdC8vICp3YXNuJ3QqIGB1bmRlZmluZWRgLCB0aGUga2V5cGF0aCB3b3VsZCBiZSBgZm9vLmJhcmAuXG4gIFx0XHQvLyBUaGVuLCBhbnkgdXNlciBpbnB1dCB3b3VsZCByZXN1bHQgaW4gYGZvby5iYXJgIGJlaW5nIHVwZGF0ZWQuXG4gIFx0XHQvL1xuICBcdFx0Ly8gSWYsIGhvd2V2ZXIsIGBmb28uYmFyYCAqd2FzKiB1bmRlZmluZWQsIGFuZCBzbyB3YXMgYGJhcmAsIHdlIHdvdWxkIGJlXG4gIFx0XHQvLyBsZWZ0IHdpdGggYW4gdW5yZXNvbHZlZCBwYXJ0aWFsIGtleXBhdGggLSBzbyB3ZSBhcmUgZm9yY2VkIHRvIG1ha2UgYW5cbiAgXHRcdC8vIGFzc3VtcHRpb24uIFRoYXQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBpbnB1dCBpbiBxdWVzdGlvbiBzaG91bGRcbiAgXHRcdC8vIGJlIGZvcmNlZCB0byByZXNvbHZlIHRvIGBiYXJgLCBhbmQgYW55IHVzZXIgaW5wdXQgd291bGQgYWZmZWN0IGBiYXJgXG4gIFx0XHQvLyBhbmQgbm90IGBmb28uYmFyYC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBEaWQgdGhhdCBtYWtlIGFueSBzZW5zZT8gTm8/IE9oLiBTb3JyeS4gV2VsbCB0aGUgbW9yYWwgb2YgdGhlIHN0b3J5IGlzXG4gIFx0XHQvLyBiZSBleHBsaWNpdCB3aGVuIHVzaW5nIHR3by13YXkgZGF0YS1iaW5kaW5nIGFib3V0IHdoYXQga2V5cGF0aCB5b3UncmVcbiAgXHRcdC8vIHVwZGF0aW5nLiBVc2luZyBpdCBpbiBsaXN0cyBpcyBwcm9iYWJseSBhIHJlY2lwZSBmb3IgY29uZnVzaW9uLi4uXG4gIFx0XHR2YXIgcmVmID0gaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgPyBcIidcIiArIGludGVycG9sYXRvci50ZW1wbGF0ZS5yICsgXCInIHJlZmVyZW5jZVwiIDogXCJleHByZXNzaW9uXCI7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSAlcyBiZWluZyB1c2VkIGZvciB0d28td2F5IGJpbmRpbmcgaXMgYW1iaWd1b3VzLCBhbmQgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgcmVzdWx0cy4gQ29uc2lkZXIgaW5pdGlhbGlzaW5nIHlvdXIgZGF0YSB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eVwiLCByZWYsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0a2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlLmlzVHdvd2F5ID0gdHJ1ZTtcbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcbiAgXHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsVmFsdWUpIHtcbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChwYXJlbnRGb3JtID0gZmluZFBhcmVudEZvcm0oZWxlbWVudCkpIHtcbiAgXHRcdHRoaXMucmVzZXRWYWx1ZSA9IHZhbHVlO1xuICBcdFx0cGFyZW50Rm9ybS5mb3JtQmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUgPSB7XG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHR9KTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYmluZGluZ3MsIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cbiAgXHRcdG9sZEtleXBhdGggPSB0aGlzLmtleXBhdGg7XG4gIFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cbiAgXHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG4gIFx0XHRpZiAob2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW29sZEtleXBhdGguc3RyXSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gfHwgKHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbbmV3S2V5cGF0aC5zdHJdID0gW10pO1xuICBcdFx0YmluZGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIEJpbmRpbmcuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcyxcbiAgXHQgICAgU3BlY2lhbGlzZWRCaW5kaW5nO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHRcdEJpbmRpbmcuY2FsbCh0aGlzLCBlbGVtZW50KTtcblxuICBcdFx0aWYgKHRoaXMuaW5pdCkge1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblxuICBcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG4gIH07XG5cbiAgdmFyIEJpbmRpbmdfQmluZGluZyA9IEJpbmRpbmc7XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudEZvcm0oZWxlbWVudCkge1xuICBcdHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpIHtcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHRcdHJldHVybiBlbGVtZW50O1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgdW5ib3VuZC5cbiAgLy8gU3BlY2lhbGlzZWQgYmluZGluZ3MgY2FuIG92ZXJyaWRlIGl0XG5cbiAgLy8gVGhpcyBpcyB0aGUgaGFuZGxlciBmb3IgRE9NIGV2ZW50cyB0aGF0IHdvdWxkIGxlYWQgdG8gYSBjaGFuZ2UgaW4gdGhlIG1vZGVsXG4gIC8vIChpLmUuIGNoYW5nZSwgc29tZXRpbWVzLCBpbnB1dCwgYW5kIG9jY2FzaW9uYWxseSBjbGljayBhbmQga2V5dXApXG4gIHZhciBoYW5kbGVEb21FdmVudCA9IGhhbmRsZUNoYW5nZTtcblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gIFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICB9XG5cbiAgdmFyIEdlbmVyaWNCaW5kaW5nO1xuXG4gIEdlbmVyaWNCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuICBcdFx0ICAgIGxhenksXG4gIFx0XHQgICAgdGltZW91dCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFueSBsYXp5IHNldHRpbmcgZm9yIHRoaXMgZWxlbWVudCBvdmVycmlkZXMgdGhlIHJvb3RcbiAgXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQncyBhIHRpbWVvdXRcbiAgXHRcdGxhenkgPSB0aGlzLnJvb3QubGF6eTtcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRsYXp5ID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyh0aGlzLmVsZW1lbnQubGF6eSkpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0XHR0aW1lb3V0ID0gK3RoaXMuZWxlbWVudC5sYXp5O1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKGxhenkgfHwgXCJcIikpIHtcbiAgXHRcdFx0dGltZW91dCA9ICtsYXp5O1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG5cbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB0aW1lb3V0IGlzIGF2YWlsYWJsZSB0byB0aGUgaGFuZGxlclxuICBcdFx0XHR0aGlzLmVsZW1lbnQubGF6eSA9IHRpbWVvdXQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaGFuZGxlciA9IHRpbWVvdXQgPyBoYW5kbGVEZWxheSA6IGhhbmRsZURvbUV2ZW50O1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKCFsYXp5KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nID0gR2VuZXJpY0JpbmRpbmc7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRoYW5kbGVEb21FdmVudC5jYWxsKHRoaXMpO1xuXG4gIFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCk7XG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGF5KCkge1xuICBcdHZhciBiaW5kaW5nID0gdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLFxuICBcdCAgICBlbCA9IHRoaXM7XG5cbiAgXHRpZiAoISFiaW5kaW5nLl90aW1lb3V0KSBjbGVhclRpbWVvdXQoYmluZGluZy5fdGltZW91dCk7XG5cbiAgXHRiaW5kaW5nLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYmluZGluZy5yZW5kZXJlZCkgaGFuZGxlRG9tRXZlbnQuY2FsbChlbCk7XG4gIFx0XHRiaW5kaW5nLl90aW1lb3V0ID0gdW5kZWZpbmVkO1xuICBcdH0sIGJpbmRpbmcuZWxlbWVudC5sYXp5KTtcbiAgfVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5pbm5lckhUTUw7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblxuICB2YXIgc2hhcmVkX2dldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG4gIHZhciBzZXRzID0ge307XG4gIGZ1bmN0aW9uIGdldFNpYmxpbmdzKGlkLCBncm91cCwga2V5cGF0aCkge1xuICBcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG4gIFx0cmV0dXJuIHNldHNbaGFzaF0gfHwgKHNldHNbaGFzaF0gPSBbXSk7XG4gIH1cblxuICB2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb1wiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcblxuICBcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5nZXRWYWx1ZSgpKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvQmluZGluZyA9IFJhZGlvQmluZGluZztcblxuICB2YXIgUmFkaW9OYW1lQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwibmFtZVwiLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwicmFkaW9uYW1lXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG4gIFx0fSxcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcbiAgXHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBub2RlO1xuXG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcblxuICBcdFx0aWYgKG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgPSBSYWRpb05hbWVCaW5kaW5nO1xuXG4gIHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcbiAgXHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuICBcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG4gIFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG4gIFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcbiAgXHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcbiAgXHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcbiAgXHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXG4gIFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cbiAgXHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuICBcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG4gIFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwiY2hlY2tib3hlc1wiLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMubm9Jbml0aWFsVmFsdWUpIHtcbiAgXHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2VcbiAgXHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcbiAgXHRcdGlmICh0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKGJpbmRpbmdWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgZXhpc3RpbmdWYWx1ZSxcbiAgXHRcdCAgICBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRpZiAoaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKGlzQ2hlY2tlZCkubWFwKEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUpO1xuICBcdH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNDaGVja2VkKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmdfX2dldFZhbHVlKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICB9XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZyA9IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwiY2hlY2tlZFwiLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nID0gQ2hlY2tib3hCaW5kaW5nO1xuXG4gIHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHZhbHVlLFxuICBcdFx0ICAgIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0d2hpbGUgKCsraSA8IGxlbikge1xuICBcdFx0XHRcdGlmICghb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuICBcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IEJpbmRpbmdfU2VsZWN0QmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIik7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuICBcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG4gIFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaChvcHRpb25WYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXG4gIFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgXHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAocHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2godmFsdWUsIHByZXZpb3VzVmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmdfU2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXG4gIHZhciBOdW1lcmljQmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlKTtcbiAgXHRcdHJldHVybiBpc05hTih2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuICBcdCAgICB0eXBlLFxuICBcdCAgICBCaW5kaW5nLFxuICBcdCAgICBiaW5kTmFtZSxcbiAgXHQgICAgYmluZENoZWNrZWQsXG4gIFx0ICAgIGJpbmRpbmc7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcbiAgXHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cbiAgXHRpZiAoZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcbiAgXHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gY29udGVudGVkaXRhYmxlXG4gIFx0aWYgKFxuICBcdC8vIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWUgb3IgaXMgYmluZGFibGUgYW5kIG1heSB0aHVzIGJlY29tZSB0cnVlXG4gIFx0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSkpICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPGlucHV0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5uYW1lKTtcbiAgXHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY2hlY2tlZCk7XG5cbiAgXHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcbiAgXHRcdFx0aWYgKGJpbmROYW1lICYmIGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXCIsIHsgcmFjdGl2ZTogZWxlbWVudC5yb290IH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGJpbmROYW1lKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZztcbiAgXHRcdFx0fSBlbHNlIGlmIChiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmlsZVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nO1xuICBcdFx0fSBlbHNlIGlmIChpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwicmFuZ2VcIiA/IE51bWVyaWNCaW5kaW5nIDogQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyA8c2VsZWN0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IEJpbmRpbmdfTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogQmluZGluZ19TZWxlY3RCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDx0ZXh0YXJlYT5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHR9XG5cbiAgXHRpZiAoQmluZGluZyAmJiAoYmluZGluZyA9IG5ldyBCaW5kaW5nKGVsZW1lbnQpKSAmJiBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBiaW5kaW5nO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmluZGFibGUoYXR0cmlidXRlKSB7XG4gIFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcbiAgfVxuXG4gIC8vIGFuZCB0aGlzIGVsZW1lbnQgYWxzbyBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgdG8gYmluZFxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSA9IEV2ZW50SGFuZGxlciRidWJibGU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGJ1YmJsZSgpIHtcbiAgXHR2YXIgaGFzQWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblxuICBcdGlmIChoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fSBlbHNlIGlmICghaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcbiAgXHR9XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBvdmVyd3JpdHRlbiwgaWYgdGhlIGV2ZW50IGRpcmVjdGl2ZVxuICAvLyBpbmNsdWRlcyBwYXJhbWV0ZXJzXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUgPSBFdmVudEhhbmRsZXIkZmlyZTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQgfSk7XG4gIH1cblxuICB2YXIgZ2V0QWN0aW9uID0gRXZlbnRIYW5kbGVyJGdldEFjdGlvbjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uKCkge1xuICBcdHJldHVybiB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQgPSBFdmVudEhhbmRsZXIkaW5pdDtcblxuICB2YXIgZXZlbnRQYXR0ZXJuID0gL15ldmVudCg/OlxcLiguKykpPy87XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKG5hbWUuaW5kZXhPZihcIipcIikgIT09IC0xKSB7XG4gIFx0XHRmYXRhbChcIk9ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcXFwiKlxcXCIgd2lsZGNhcmRzLCA8JXMgb24tJXM9XFxcIi4uLlxcXCIvPiBpcyBub3QgdmFsaWRcIiwgZWxlbWVudC5uYW1lLCBuYW1lKTtcbiAgXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLm0pIHtcbiAgXHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cbiAgXHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuICBcdFx0dGhpcy5tZXRob2QgPSB0ZW1wbGF0ZS5tO1xuICBcdFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuICBcdFx0dGhpcy5mbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCk7XG5cbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzID0gW107XG4gIFx0XHRyZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0XHR2YXIgbWF0Y2ggPSB1bmRlZmluZWQ7XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG4gIFx0XHRcdGlmIChtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKHJlZikpIHtcbiAgXHRcdFx0XHRfdGhpcy5rZXlwYXRoc1tpXSA9IHtcbiAgXHRcdFx0XHRcdGV2ZW50T2JqZWN0OiB0cnVlLFxuICBcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWzFdID8gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpIDogW11cbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdF90aGlzLnJlZlJlc29sdmVycy5wdXNoKFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHRcdFx0fSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcbiAgXHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG4gIFx0XHRpZiAodHlwZW9mIGFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhY3Rpb24gPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gIFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuICBcdFx0aWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuICBcdFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbChldmVudCkge1xuICBcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cbiAgXHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0aWYgKHR5cGVvZiByYWN0aXZlW3RoaXMubWV0aG9kXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2FsbCBhIG5vbi1leGlzdGVudCBtZXRob2QgKFxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiKVwiKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIHZhbHVlLCBsZW4sIGk7XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG4gIFx0XHRpZiAoa2V5cGF0aC5ldmVudE9iamVjdCkge1xuICBcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXG4gIFx0XHRcdGlmIChsZW4gPSBrZXlwYXRoLnJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtrZXlwYXRoLnJlZmluZW1lbnRzW2ldXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGFyZ3MgPSB0aGlzLmZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gIFx0cmFjdGl2ZVt0aGlzLm1ldGhvZF0uYXBwbHkocmFjdGl2ZSwgYXJncyk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyhldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogdGhpcy5wYXJhbXMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyhldmVudCkge1xuICBcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcbiAgXHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGFyZ3MgPSBhcmdzLnN1YnN0cigxLCBhcmdzLmxlbmd0aCAtIDIpO1xuICBcdH1cblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIgPSBnZW5lcmljSGFuZGxlcjtcbiAgZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoZXZlbnQpIHtcbiAgXHR2YXIgc3RvcmFnZSxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgaW5kaWNlcyxcbiAgXHQgICAgaW5kZXggPSB7fTtcblxuICBcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuICBcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1tldmVudC50eXBlXTtcblxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMoaGFuZGxlci5lbGVtZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdGhhbmRsZXIuZmlyZSh7XG4gIFx0XHRub2RlOiB0aGlzLFxuICBcdFx0b3JpZ2luYWw6IGV2ZW50LFxuICBcdFx0aW5kZXg6IGluZGV4LFxuICBcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLnN0cixcbiAgXHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aClcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBsaXN0ZW4gPSBFdmVudEhhbmRsZXIkbGlzdGVuO1xuXG4gIHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuICAgICAgdG91Y2hFdmVudHMgPSB7XG4gIFx0dG91Y2hzdGFydDogdHJ1ZSxcbiAgXHR0b3VjaG1vdmU6IHRydWUsXG4gIFx0dG91Y2hlbmQ6IHRydWUsXG4gIFx0dG91Y2hjYW5jZWw6IHRydWUsXG4gIFx0Ly9ub3QgdzNjLCBidXQgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnNcbiAgXHR0b3VjaGxlYXZlOiB0cnVlXG4gIH07XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRsaXN0ZW4oKSB7XG4gIFx0dmFyIGRlZmluaXRpb24sXG4gIFx0ICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgXHRpZiAodGhpcy5pbnZhbGlkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGRlZmluaXRpb24gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZXZlbnRzXCIsIHRoaXMucm9vdCwgbmFtZSkpIHtcbiAgXHRcdHRoaXMuY3VzdG9tID0gZGVmaW5pdGlvbih0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIobmFtZSkpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcbiAgXHRcdGlmICghKFwib25cIiArIG5hbWUgaW4gdGhpcy5ub2RlKSAmJiAhKHdpbmRvdyAmJiBcIm9uXCIgKyBuYW1lIGluIHdpbmRvdykgJiYgIWlzSnNkb20pIHtcblxuICBcdFx0XHQvLyBva2F5IHRvIHVzZSB0b3VjaCBldmVudHMgaWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtXG4gIFx0XHRcdGlmICghdG91Y2hFdmVudHNbbmFtZV0pIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcImV2ZW50XCIpLCB7IG5vZGU6IHRoaXMubm9kZSB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKG5hbWUpIHtcbiAgXHRpZiAoIWN1c3RvbUhhbmRsZXJzW25hbWVdKSB7XG4gIFx0XHRjdXN0b21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cbiAgXHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuICBcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoLnN0cjtcbiAgXHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aCk7XG5cbiAgXHRcdFx0c3RvcmFnZS5ldmVudHNbbmFtZV0uZmlyZShldmVudCk7XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBjdXN0b21IYW5kbGVyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCA9IEV2ZW50SGFuZGxlciRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5hY3Rpb24pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmR5bmFtaWNQYXJhbXMpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlciA9IEV2ZW50SGFuZGxlciRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcbiAgXHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG4gIFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcbiAgXHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzW3RoaXMubmFtZV0gPSB0aGlzO1xuXG4gIFx0aWYgKHRoaXMubWV0aG9kIHx8IHRoaXMuZ2V0QWN0aW9uKCkpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNvbHZlID0gRXZlbnRIYW5kbGVyJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQgPSBFdmVudEhhbmRsZXIkdW5iaW5kO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyID0gRXZlbnRIYW5kbGVyJHVucmVuZGVyO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cbiAgXHRpZiAodGhpcy5jdXN0b20pIHtcbiAgXHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMubmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGZpcmU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSxcbiAgXHRnZXRBY3Rpb246IGdldEFjdGlvbixcbiAgXHRpbml0OiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQsXG4gIFx0bGlzdGVuOiBsaXN0ZW4sXG4gIFx0cmViaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IHByb3RvdHlwZV9yZXNvbHZlLFxuICBcdHVuYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0V2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcjtcblxuICB2YXIgY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBpLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBuYW1lcyxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gdGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRoYW5kbGVyID0gbmV3IF9FdmVudEhhbmRsZXIoZWxlbWVudCwgbmFtZXNbaV0sIHRlbXBsYXRlW25hbWVdKTtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChoYW5kbGVyKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIERlY29yYXRvciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIGRlY29yYXRvclxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gdGhpcy5mcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuICBcdFx0XHRzZWxmLnBhcmFtcyA9IHRoaXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0XHRpZiAoc2VsZi5yZWFkeSkge1xuICBcdFx0XHRcdHNlbGYudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0dGhpcy5mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJkZWNvcmF0b3JzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLmZuKSB7XG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZGVjb3JhdG9yXCIpKTtcbiAgXHR9XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSwgcmVzdWx0LCBhcmdzO1xuXG4gIFx0XHRub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdGlmICh0aGlzLnBhcmFtcykge1xuICBcdFx0XHRhcmdzID0gW25vZGVdLmNvbmNhdCh0aGlzLnBhcmFtcyk7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkodGhpcy5yb290LCBhcmdzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uY2FsbCh0aGlzLnJvb3QsIG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuICBcdFx0dGhpcy5hY3R1YWwgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hY3R1YWwudXBkYXRlKSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSh0aGlzLnJvb3QsIHRoaXMucGFyYW1zKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKHRydWUpO1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAodXBkYXRpbmcpIHtcbiAgXHRcdHRoaXMudG9ybmRvd24gPSB0cnVlO1xuICBcdFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9fYnViYmxlKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRzeW5jKF90aGlzKTtcbiAgXHRcdFx0X3RoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7IC8vIGRlZmF1bHQgYmVoYXZpb3VyXG4gIH1cblxuICBmdW5jdGlvbiBzeW5jKHNlbGVjdEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblxuICBcdGlmICghc2VsZWN0Tm9kZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0b0FycmF5KHNlbGVjdE5vZGUub3B0aW9ucyk7XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIik7XG5cbiAgXHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuICBcdC8vIHRoZXNlIG9wdGlvbnNcbiAgXHRpZiAoc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXG4gIFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuICBcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cbiAgXHRcdFx0aWYgKHNob3VsZFNlbGVjdCkge1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHRpZiAob3B0aW9uc1swXSkge1xuICBcdFx0XHRcdG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHRoZSB2YWx1ZSBzaG91bGQgYmUgaW5pdGlhbGlzZWQgYWNjb3JkaW5nIHRvIHdoaWNoXG4gIFx0Ly8gPG9wdGlvbj4gZWxlbWVudCBpcyBzZWxlY3RlZCwgaWYgdHdvd2F5IGJpbmRpbmcgaXMgaW4gZWZmZWN0XG4gIFx0ZWxzZSBpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkge1xuICBcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9faW5pdChvcHRpb24sIHRlbXBsYXRlKSB7XG4gIFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3Qob3B0aW9uLnBhcmVudCk7XG5cbiAgXHQvLyB3ZSBtaWdodCBiZSBpbnNpZGUgYSA8ZGF0YWxpc3Q+IGVsZW1lbnRcbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuXG4gIFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG4gIFx0aWYgKCF0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuICBcdGlmICh0ZW1wbGF0ZS5hLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuICBcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuICBcdGlmIChcInNlbGVjdGVkXCIgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX191bmJpbmQob3B0aW9uKSB7XG4gIFx0aWYgKG9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShvcHRpb24uc2VsZWN0Lm9wdGlvbnMsIG9wdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdChlbGVtZW50KSB7XG4gIFx0aWYgKCFlbGVtZW50KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2luaXQgPSBFbGVtZW50JGluaXQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3MsIHR3b3dheSwgYmluZGluZ0F0dHJzO1xuXG4gIFx0dGhpcy50eXBlID0gRUxFTUVOVDtcblxuICBcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuXG4gIFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UodGVtcGxhdGUuZSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX19pbml0KHRoaXMsIHRlbXBsYXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5idWJibGUgPSBzZWxlY3RfX2J1YmJsZTsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPGZvcm0+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdHRoaXMuZm9ybUJpbmRpbmdzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gaGFuZGxlIGJpbmRpbmcgYXR0cmlidXRlcyBmaXJzdCAodHdvd2F5LCBsYXp5KVxuICBcdGJpbmRpbmdBdHRycyA9IHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZSk7XG5cbiAgXHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUuYSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUubSk7XG5cbiAgXHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcbiAgXHRpZiAodGVtcGxhdGUuZikge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcyxcbiAgXHRcdFx0Y3NzSWRzOiBudWxsXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyB0aGUgZWxlbWVudCBzZXR0aW5nIHNob3VsZCBvdmVycmlkZSB0aGUgcmFjdGl2ZSBzZXR0aW5nXG4gIFx0dHdvd2F5ID0gcmFjdGl2ZS50d293YXk7XG4gIFx0aWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IGZhbHNlKSB0d293YXkgPSBmYWxzZTtlbHNlIGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSB0cnVlKSB0d293YXkgPSB0cnVlO1xuXG4gIFx0dGhpcy50d293YXkgPSB0d293YXk7XG4gIFx0dGhpcy5sYXp5ID0gYmluZGluZ0F0dHJzLmxhenk7XG5cbiAgXHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcbiAgXHRpZiAodHdvd2F5ICYmIChiaW5kaW5nID0gaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nKHRoaXMsIHRlbXBsYXRlLmEpKSkge1xuICBcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblxuICBcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcbiAgXHRpZiAodGVtcGxhdGUudikge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyh0aGlzLCB0ZW1wbGF0ZS52KTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZGVjb3JhdG9yXG4gIFx0aWYgKHRlbXBsYXRlLm8pIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IF9EZWNvcmF0b3IodGhpcywgdGVtcGxhdGUubyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG4gIFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuICBcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBFbGVtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblxuICBcdGlmICh0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gcmViaW5kIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBVcGRhdGUgbGl2ZSBxdWVyaWVzLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAobGl2ZVF1ZXJpZXMgPSB0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRsaXZlUXVlcmllc1tpXS5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZSAmJiAoc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSkpIHtcblxuICBcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHN0b3JhZ2UsIFwia2V5cGF0aFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX2ltZ19fcmVuZGVyKGltZykge1xuICBcdHZhciBsb2FkSGFuZGxlcjtcblxuICBcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5IG5lZWQgdG8gcHJldmVudCBpdFxuICBcdC8vIGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuICBcdGlmIChpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQpIHtcbiAgXHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gIFx0XHRcdCAgICBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuXG4gIFx0XHRcdGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0fSwgZmFsc2UpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3JlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fdW5yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc2V0KCkge1xuICBcdHZhciBlbGVtZW50ID0gdGhpcy5fcmFjdGl2ZS5wcm94eTtcblxuICBcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG4gIFx0ZWxlbWVudC5mb3JtQmluZGluZ3MuZm9yRWFjaCh1cGRhdGVNb2RlbCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlbChiaW5kaW5nKSB7XG4gIFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLnJlc2V0VmFsdWUpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQgPSBUcmFuc2l0aW9uJGluaXQ7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdChlbGVtZW50LCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHZhciByYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmlzSW50cm8gPSBpc0ludHJvO1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyB0cmFuc2l0aW9uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuICBcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IGZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJ0cmFuc2l0aW9uc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwidHJhbnNpdGlvblwiKSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChoeXBoZW5hdGVkU3RyKSB7XG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSgvLShbYS16QS1aXSkvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4X19wcmVmaXgsIHByZWZpeENhY2hlLCBoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcmVmaXhDYWNoZSA9IHt9O1xuICBcdGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cbiAgXHRcdHByb3AgPSBjYW1lbENhc2UocHJvcCk7XG5cbiAgXHRcdGlmICghcHJlZml4Q2FjaGVbcHJvcF0pIHtcbiAgXHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gcHJvcDtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cbiAgXHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1tpXTtcbiAgXHRcdFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3ZlbmRvciArIGNhcHBlZF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHZlbmRvciArIGNhcHBlZDtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmVmaXhDYWNoZVtwcm9wXTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4ID0gaGVscGVyc19wcmVmaXhfX3ByZWZpeDtcblxuICB2YXIgZ2V0U3R5bGUsIHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Z2V0U3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgXHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXG4gIFx0XHRjb21wdXRlZFN0eWxlID0gcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcHJvcHMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3BzKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHN0eWxlcyA9IHt9O1xuXG4gIFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRwcm9wID0gcHJvcHNbaV07XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRTdHlsZSA9IGdldFN0eWxlO1xuXG4gIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgXHR2YXIgcHJvcDtcblxuICBcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChzdHlsZSldID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzdHlsZSkge1xuICBcdFx0XHRpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gc3R5bGVbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgVGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nO1xuXG4gIFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0Ly8gZWFzaW5nXG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG5cbiAgXHRcdGlmICghZWFzaW5nKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG9wdGlvbnMuZWFzaW5nLCBcImVhc2luZ1wiKSk7XG4gIFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdH1cblxuICBcdHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuXG4gIFx0dGhpcy5zdGFydCA9IHV0aWxzX2dldFRpbWUoKTtcbiAgXHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQodGhpcyk7XG4gIH07XG5cbiAgVGlja2VyLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAobm93KSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgZWFzZWQ7XG5cbiAgXHRcdGlmICghdGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG5vdyA+IHRoaXMuZW5kKSB7XG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5jb21wbGV0ZSkge1xuICBcdFx0XHRcdHRoaXMuY29tcGxldGUoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuICBcdFx0ZWFzZWQgPSB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbik7XG5cbiAgXHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0dGhpcy5zdGVwKGVhc2VkKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFib3J0KSB7XG4gIFx0XHRcdHRoaXMuYWJvcnQoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfVGlja2VyID0gVGlja2VyO1xuICBmdW5jdGlvbiBsaW5lYXIodCkge1xuICBcdHJldHVybiB0O1xuICB9XG5cbiAgdmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeLSg/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKS1cIik7XG5cbiAgdmFyIHVucHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRyZXR1cm4gcHJvcC5yZXBsYWNlKHVucHJlZml4UGF0dGVybiwgXCJcIik7XG4gIH07XG5cbiAgdmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKShbQS1aXSlcIik7XG5cbiAgdmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgaHlwaGVuYXRlZDtcblxuICBcdGlmICghc3RyKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjsgLy8gZWRnZSBjYXNlXG4gIFx0fVxuXG4gIFx0aWYgKHZlbmRvclBhdHRlcm4udGVzdChzdHIpKSB7XG4gIFx0XHRzdHIgPSBcIi1cIiArIHN0cjtcbiAgXHR9XG5cbiAgXHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICBcdFx0cmV0dXJuIFwiLVwiICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBoeXBoZW5hdGVkO1xuICB9O1xuXG4gIHZhciBjcmVhdGVUcmFuc2l0aW9ucyxcbiAgICAgIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLFxuICAgICAgVFJBTlNJVElPTixcbiAgICAgIFRSQU5TSVRJT05FTkQsXG4gICAgICBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCxcbiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT04sXG4gICAgICBUUkFOU0lUSU9OX1BST1BFUlRZLFxuICAgICAgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sXG4gICAgICBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuICAgICAgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwidHJhbnNpdGlvbmVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ3ZWJraXRUcmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9KSgpO1xuXG4gIFx0aWYgKFRSQU5TSVRJT04pIHtcbiAgXHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgXCJEdXJhdGlvblwiO1xuICBcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyBcIlByb3BlcnR5XCI7XG4gIFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyBcIlRpbWluZ0Z1bmN0aW9uXCI7XG4gIFx0fVxuXG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKSB7XG5cbiAgXHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuICBcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cbiAgXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXG4gIFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0aWYgKGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuICBcdFx0XHRcdFx0dC5yb290LmZpcmUodC5uYW1lICsgXCI6ZW5kXCIsIHQubm9kZSwgdC5pc0ludHJvKTtcbiAgXHRcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuICBcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG4gIFx0XHRcdGhhc2hQcmVmaXggPSAodC5ub2RlLm5hbWVzcGFjZVVSSSB8fCBcIlwiKSArIHQubm9kZS50YWdOYW1lO1xuXG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1BFUlRZXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcChoZWxwZXJzX3ByZWZpeCkubWFwKGh5cGhlbmF0ZSkuam9pbihcIixcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTl0gPSBoeXBoZW5hdGUob3B0aW9ucy5lYXNpbmcgfHwgXCJsaW5lYXJcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX0RVUkFUSU9OXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgXCJzXCI7XG5cbiAgXHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoY2FtZWxDYXNlKHVucHJlZml4KGV2ZW50LnByb3BlcnR5TmFtZSkpKTtcbiAgXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG4gIFx0XHRcdFx0ICAgIGhhc2gsXG4gIFx0XHRcdFx0ICAgIG9yaWdpbmFsVmFsdWUsXG4gIFx0XHRcdFx0ICAgIGluZGV4LFxuICBcdFx0XHRcdCAgICBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuICBcdFx0XHRcdCAgICBwcm9wLFxuICBcdFx0XHRcdCAgICBzdWZmaXg7XG5cbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbaV07XG4gIFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cbiAgXHRcdFx0XHRcdGlmIChDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHRvW3Byb3BdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuICBcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG4gIFx0XHRcdFx0XHRcdGlmICghY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuICBcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuICBcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gdC5nZXRTdHlsZShwcm9wKSAhPSB0b1twcm9wXTtcbiAgXHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuICBcdFx0XHRcdFx0XHRcdGlmIChjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IG9yaWdpbmFsVmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGlmICghQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcbiAgXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcbiAgXHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcbiAgXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICBcdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiLCB7IG5vZGU6IHQubm9kZSB9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cbiAgXHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKHRvW3Byb3BdKVswXTtcblxuICBcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuICBcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKHtcbiAgXHRcdFx0XHRcdFx0XHRuYW1lOiBoZWxwZXJzX3ByZWZpeChwcm9wKSxcbiAgXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IHNoYXJlZF9pbnRlcnBvbGF0ZShwYXJzZUZsb2F0KG9yaWdpbmFsVmFsdWUpLCBwYXJzZUZsb2F0KHRvW3Byb3BdKSksXG4gIFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuICBcdFx0XHRcdGlmIChwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG5ldyBzaGFyZWRfVGlja2VyKHtcbiAgXHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2Uob3B0aW9ucy5lYXNpbmcgfHwgXCJcIiksXG4gIFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblxuICBcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzW2ldO1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW3Byb3AubmFtZV0gPSBwcm9wLmludGVycG9sYXRvcihwb3MpICsgcHJvcC5zdWZmaXg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9LFxuICBcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG4gIFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuICBcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSwgMCk7XG4gIFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDApO1xuICBcdH07XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnM7XG5cbiAgdmFyIGhpZGRlbiwgdmVuZG9yLCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4LCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSwgdmlzaWJpbGl0eTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0aGlkZGVuID0gXCJoaWRkZW5cIjtcblxuICBcdHZpc2liaWxpdHkgPSB7fTtcblxuICBcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSBcIlwiO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLS0pIHtcbiAgXHRcdFx0dmVuZG9yID0gdmVuZG9yc1thbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faV07XG4gIFx0XHRcdGhpZGRlbiA9IHZlbmRvciArIFwiSGlkZGVuXCI7XG5cbiAgXHRcdFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSB2ZW5kb3I7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggKyBcInZpc2liaWxpdHljaGFuZ2VcIiwgb25DaGFuZ2UpO1xuXG4gIFx0XHQvLyBpbml0aWFsaXNlXG4gIFx0XHRvbkNoYW5nZSgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG4gIFx0XHRpZiAoXCJvbmZvY3Vzb3V0XCIgaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uSGlkZSk7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uU2hvdyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIG9uSGlkZSk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkhpZGUpO1xuXG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgb25TaG93KTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBvblNob3cpO1xuICBcdFx0fVxuXG4gIFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlOyAvLyB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLiBOb3QgaWRlYWwgYnV0IGhleVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbaGlkZGVuXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3coKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG5cbiAgdmFyIGFuaW1hdGVTdHlsZSwgX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0X2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHRvO1xuXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0LmFuaW1hdGVTdHlsZSgpIHJldHVybnMgYSBwcm9taXNlIC0gdXNlIC50aGVuKCkgaW5zdGVhZCBvZiBwYXNzaW5nIGEgY2FsbGJhY2tcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuICBcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eS5oaWRkZW4pIHtcbiAgXHRcdFx0dGhpcy5zZXRTdHlsZShzdHlsZSwgdmFsdWUpO1xuICBcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHRvID0ge307XG4gIFx0XHRcdHRvW3N0eWxlXSA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG8gPSBzdHlsZTtcblxuICBcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuICBcdFx0XHRvcHRpb25zID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuICBcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcbiAgXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblxuICBcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gIFx0XHRpZiAoIW9wdGlvbnMpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVGhlIFxcXCIlc1xcXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MFwiLCB0aGlzLm5hbWUpO1xuICBcdFx0XHRvcHRpb25zID0gdGhpcztcbiAgXHRcdH1cblxuICBcdFx0dmFyIHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICBcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cbiAgXHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG4gIFx0XHRcdGlmICghb3B0aW9ucy5kdXJhdGlvbikge1xuICBcdFx0XHRcdF90aGlzLnNldFN0eWxlKHRvKTtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcbiAgXHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHRvKTtcbiAgXHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblxuICBcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcbiAgXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUoX3RoaXMubm9kZSk7XG5cbiAgXHRcdFx0ZnJvbSA9IHt9O1xuICBcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgXHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG5cbiAgXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgIT0gdG9bcHJvcF0pIHtcbiAgXHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cbiAgXHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuICBcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG4gIFx0XHRcdFx0XHRfdGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IGN1cnJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICBcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG4gIFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyhfdGhpcywgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIF9hbmltYXRlU3R5bGUgPSBhbmltYXRlU3R5bGU7XG5cbiAgdmFyIHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkZWZhdWx0cykge1xuICBcdGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gIFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiBwYXJhbXMgfTtcbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmIChwYXJhbXMgPT09IFwic2xvd1wiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDYwMCB9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJhbXMgPT09IFwiZmFzdFwiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDIwMCB9O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNDAwIH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyYW1zKSB7XG4gIFx0XHRwYXJhbXMgPSB7fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmlsbEdhcHMoe30sIHBhcmFtcywgZGVmYXVsdHMpO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVfc3RhcnQgPSBUcmFuc2l0aW9uJHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgXHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG4gIFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG4gIFx0Ly8gYW4gYXJndW1lbnRcbiAgXHR0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKG5vUmVzZXQpIHtcbiAgXHRcdGlmIChjb21wbGV0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIW5vUmVzZXQgJiYgX3RoaXMuaXNJbnRybykge1xuICBcdFx0XHRyZXNldFN0eWxlKG5vZGUsIG9yaWdpbmFsU3R5bGUpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuICBcdFx0X3RoaXMuX21hbmFnZXIucmVtb3ZlKF90aGlzKTtcblxuICBcdFx0Y29tcGxldGVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR0aGlzLmNvbXBsZXRlKCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4uYXBwbHkodGhpcy5yb290LCBbdGhpc10uY29uY2F0KHRoaXMucGFyYW1zKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gIFx0aWYgKHN0eWxlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHN0eWxlKTtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuICBcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcbiAgXHRcdG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHRoaXMuaW5pdChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQsXG4gIFx0c3RhcnQ6IHByb3RvdHlwZV9zdGFydCxcbiAgXHRnZXRTdHlsZTogcHJvdG90eXBlX2dldFN0eWxlLFxuICBcdHNldFN0eWxlOiBzZXRTdHlsZSxcbiAgXHRhbmltYXRlU3R5bGU6IF9hbmltYXRlU3R5bGUsXG4gIFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuICB9O1xuXG4gIHZhciBfVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlciA9IEVsZW1lbnQkcmVuZGVyO1xuXG4gIHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblxuICB1cGRhdGVDc3MgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGNvbnRlbnQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcblxuICBcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3NcbiAgXHRpZiAod2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCkge1xuICBcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBcdH1cblxuICBcdGlmIChub2RlLnN0eWxlU2hlZXQpIHtcbiAgXHRcdG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgXHR9XG4gIH07XG5cbiAgdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICBcdGlmICghdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhXCIsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0Ly8gQXMgaXQgaGFwcGVucywgd2UgQVJFIGluIGEgcG9zaXRpb24gdG8gcmUtZXZhbHVhdGUgdGhlIGNvZGUgaWYgd2Ugd2FudGVkXG4gIFx0XHQvLyB0byAtIHdlIGNvdWxkIGV2YWwoKSBpdCwgb3IgaW5zZXJ0IGl0IGludG8gYSBmcmVzaCAodGVtcG9yYXJ5KSBzY3JpcHQgdGFnLlxuICBcdFx0Ly8gQnV0IHRoaXMgd291bGQgYmUgYSB0ZXJyaWJsZSBpZGVhIHdpdGggdW5wcmVkaWN0YWJsZSByZXN1bHRzLCBzbyBsZXQncyBub3QuXG4gIFx0fVxuXG4gIFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByb290ID0gdGhpcy5yb290LFxuICBcdCAgICBuYW1lc3BhY2UsXG4gIFx0ICAgIG5vZGUsXG4gIFx0ICAgIHRyYW5zaXRpb247XG5cbiAgXHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UodGhpcyk7XG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lLCBuYW1lc3BhY2UpO1xuXG4gIFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG4gIFx0Ly8gYSBkYXRhLXJhY3RpdmUtY3NzIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG4gIFx0aWYgKHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzKSB7XG4gIFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWN0aXZlLWNzc1wiLCB0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgXHRcdFx0cmV0dXJuIFwie1wiICsgeCArIFwifVwiO1xuICBcdFx0fSkuam9pbihcIiBcIikpO1xuICBcdH1cblxuICBcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuICBcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuICBcdGRlZmluZVByb3BlcnR5KHRoaXMubm9kZSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHR2YWx1ZToge1xuICBcdFx0XHRwcm94eTogdGhpcyxcbiAgXHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KHRoaXMucGFyZW50RnJhZ21lbnQpLFxuICBcdFx0XHRldmVudHM6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFx0cm9vdDogcm9vdFxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInNjcmlwdFwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuICBcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpOyAvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c3R5bGU+IGVsZW1lbnRcbiAgXHRcdGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmICh0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICBcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHByb2Nlc3NPcHRpb24odGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW1nXCIpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG4gIFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlblxuICBcdFx0Ly8gaXQgbG9hZHMgdGhlIHNyY1xuICBcdFx0c3BlY2lhbF9pbWdfX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdC8vIGZvcm1zIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVpciBiaW5kaW5ncywgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0Zm9ybV9fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgfHwgdGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdC8vIGlucHV0cyBhbmQgdGV4dGFyZWFzIHNob3VsZCBzdG9yZSB0aGVpciBpbml0aWFsIHZhbHVlIGFzXG4gIFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFZhbHVlID0gdGhpcy5ub2RlLnZhbHVlO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyBzaW1pbGFybHkgZm9yIG9wdGlvbiBub2Rlc1xuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRTZWxlY3RlZCA9IHRoaXMubm9kZS5zZWxlY3RlZDtcbiAgXHR9XG5cbiAgXHQvLyBhcHBseSBkZWNvcmF0b3IocylcbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4pIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmICghX3RoaXMuZGVjb3JhdG9yLnRvcm5kb3duKSB7XG4gIFx0XHRcdFx0X3RoaXMuZGVjb3JhdG9yLmluaXQoKTtcbiAgXHRcdFx0fVxuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG4gIFx0aWYgKHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5pbnRybywgdHJ1ZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSwgdHJ1ZSk7XG5cbiAgXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZS5hdXRvZm9jdXMpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG4gIFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuICBcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMubm9kZS5mb2N1cygpO1xuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0dXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZShlbGVtZW50KSB7XG4gIFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblxuICBcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG4gIFx0aWYgKHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkge1xuICBcdFx0bmFtZXNwYWNlID0geG1sbnM7XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3IgU1ZHIG5hbWVzcGFjZSwgaWYgdGhpcyBpcyBhbiA8c3ZnPiBlbGVtZW50XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInN2Z1wiKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2ZztcbiAgXHR9IGVsc2UgaWYgKHBhcmVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG4gIFx0XHRpZiAocGFyZW50Lm5hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4ub3IgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmFtZXNwYWNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09wdGlvbihvcHRpb24pIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlmIChzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cbiAgXHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzW2ldO1xuICBcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdO1xuXG4gIFx0XHRcdGlmIChxdWVyeS5fdGVzdChlbGVtZW50KSkge1xuICBcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG4gIFx0XHRcdFx0KGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBzdHIsIGVzY2FwZTtcblxuICBcdGlmICh0aGlzLnRlbXBsYXRlLnkpIHtcbiAgXHRcdC8vIERPQ1RZUEUgZGVjbGFyYXRpb25cbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy50ZW1wbGF0ZS5kZCArIFwiPlwiO1xuICBcdH1cblxuICBcdHN0ciA9IFwiPFwiICsgdGhpcy50ZW1wbGF0ZS5lO1xuXG4gIFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpICsgdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiICYmIG9wdGlvbklzU2VsZWN0ZWQodGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBzZWxlY3RlZFwiO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgY2hlY2tlZFwiO1xuICBcdH1cblxuICBcdHN0ciArPSBcIj5cIjtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHRleHRhcmVhXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IGVzY2FwZUh0bWwodGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0ZWxzZSBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSBcInNjcmlwdFwiICYmIHRoaXMubmFtZSAhPT0gXCJzdHlsZVwiO1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG4gIFx0aWYgKCF2b2lkRWxlbWVudE5hbWVzLnRlc3QodGhpcy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0c3RyICs9IFwiPC9cIiArIHRoaXMudGVtcGxhdGUuZSArIFwiPlwiO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZChlbGVtZW50KSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmIChlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcywgdHlwZUF0dHJpYnV0ZSwgdmFsdWVBdHRyaWJ1dGUsIG5hbWVBdHRyaWJ1dGU7XG5cbiAgXHRhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gIFx0dHlwZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudHlwZTtcbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG4gIFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblxuICBcdGlmICghdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSBcInJhZGlvXCIgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZUF0dHJpYnV0ZS52YWx1ZSA9PT0gbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IudmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG4gIFx0cmV0dXJuIHN0ciA/IFwiIFwiICsgc3RyIDogXCJcIjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBFbGVtZW50JHVuYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9fdW5iaW5kKHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRWxlbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR2YXIgYmluZGluZywgYmluZGluZ3MsIHRyYW5zaXRpb247XG5cbiAgXHRpZiAodHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuICBcdH1cblxuICBcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuICBcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcbiAgXHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuICBcdFx0dGhpcy5kZXRhY2goKTtcbiAgXHR9IGVsc2UgaWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmRldGFjaFdoZW5SZWFkeSh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG4gIFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgXHR9XG5cbiAgXHRpZiAoYmluZGluZyA9IHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXTtcbiAgXHRcdGJpbmRpbmdzLnNwbGljZShiaW5kaW5ncy5pbmRleE9mKGJpbmRpbmcpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bnJlbmRlcik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlckRlY29yYXRvcih0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5vdXRybywgZmFsc2UpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG4gIFx0aWYgKHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyh0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Zm9ybV9fdW5yZW5kZXIodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXG4gIFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1tpXTtcbiAgXHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cbiAgXHRcdHF1ZXJ5Ll9yZW1vdmUoZWxlbWVudC5ub2RlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEVsZW1lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRWxlbWVudF9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcbiAgXHRpbml0OiBFbGVtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRWxlbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0VsZW1lbnQgPSBFbGVtZW50O1xuXG4gIHZhciBkZUluZGVudF9fZW1wdHkgPSAvXlxccyokLyxcbiAgICAgIGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cbiAgdmFyIGRlSW5kZW50ID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXG4gIFx0bGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgXHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuICBcdGZpcnN0TGluZSA9IGxpbmVzWzBdO1xuICBcdGlmIChmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChmaXJzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5zaGlmdCgpO1xuICBcdH1cblxuICBcdGxhc3RMaW5lID0gbGFzdEl0ZW0obGluZXMpO1xuICBcdGlmIChsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGxhc3RMaW5lKSkge1xuICBcdFx0bGluZXMucG9wKCk7XG4gIFx0fVxuXG4gIFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKHJlZHVjZXIsIG51bGwpO1xuXG4gIFx0aWYgKG1pbkluZGVudCkge1xuICBcdFx0c3RyID0gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UobWluSW5kZW50LCBcIlwiKTtcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHByZXZpb3VzLCBsaW5lKSB7XG4gIFx0dmFyIGxpbmVJbmRlbnQgPSBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UuZXhlYyhsaW5lKVswXTtcblxuICBcdGlmIChwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZXZpb3VzO1xuICB9XG5cbiAgdmFyIFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlO1xuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBwYXJ0aWFsO1xuXG4gIFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuICBcdGlmIChwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCB8fCB7fSkpIHtcbiAgXHRcdHJldHVybiBwYXJ0aWFsO1xuICBcdH1cblxuICBcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuICBcdHBhcnRpYWwgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKG5hbWUsIHsgbm9UaHJvdzogdHJ1ZSB9KTtcblxuICBcdGlmIChwYXJ0aWFsKSB7XG4gIFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgXHRcdHBhcnRpYWwgPSBkZUluZGVudChwYXJ0aWFsKTtcblxuICBcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcblxuICBcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuICBcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbbmFtZV0gPSBwYXJzZWQudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIGZuID0gdW5kZWZpbmVkLFxuICBcdCAgICBwYXJ0aWFsID0gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50RnJhZ21lbnQub3duZXIpO1xuXG4gIFx0Ly8gaWYgdGhlcmUgd2FzIGFuIGluc3RhbmNlIHVwLWhpZXJhcmNoeSwgY29vbFxuICBcdGlmIChwYXJ0aWFsKSByZXR1cm4gcGFydGlhbDtcblxuICBcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwicGFydGlhbHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIWluc3RhbmNlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzW25hbWVdO1xuXG4gIFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuICBcdGlmICh0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRmbiA9IHBhcnRpYWwuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRwYXJ0aWFsID0gZm4uY2FsbChyYWN0aXZlLCB0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghcGFydGlhbCAmJiBwYXJ0aWFsICE9PSBcIlwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwicGFydGlhbFwiLCBcInBhcnRpYWxcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcbiAgXHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcbiAgXHRpZiAoIXRlbXBsYXRlX3BhcnNlci5pc1BhcnNlZChwYXJ0aWFsKSkge1xuXG4gIFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhpbnN0YW5jZSkpO1xuXG4gIFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG4gIFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcbiAgXHRcdGlmIChwYXJzZWQucCkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhcnRpYWxzICh7ez4lc319KSBjYW5ub3QgY29udGFpbiBuZXN0ZWQgaW5saW5lIHBhcnRpYWxzXCIsIG5hbWUsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuICBcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IGZpbmRPd25lcihpbnN0YW5jZSwgbmFtZSk7XG5cbiAgXHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcbiAgXHRcdHRhcmdldC5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSBmb3IgcmVzZXRcbiAgXHRpZiAoZm4pIHtcbiAgXHRcdHBhcnRpYWwuX2ZuID0gZm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kT3duZXIocmFjdGl2ZSwga2V5KSB7XG4gIFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IHJhY3RpdmUgOiBmaW5kQ29uc3RydWN0b3IocmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvciwga2V5KSB7XG4gIFx0aWYgKCFjb25zdHJ1Y3Rvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRyZXR1cm4gY29uc3RydWN0b3IucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbnN0cnVjdG9yIDogZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLl9QYXJlbnQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQpIHtcbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRpZiAocGFyZW50LnRlbXBsYXRlICYmIHBhcmVudC50ZW1wbGF0ZS5wICYmIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdKSB7XG4gIFx0XHRcdHJldHVybiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyZW50LnBhcmVudEZyYWdtZW50ICYmIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcikge1xuICBcdFx0XHRyZXR1cm4gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbmRlbnQpIHtcbiAgXHR2YXIgaW5kZW50ZWQ7XG5cbiAgXHRpZiAoIWluZGVudCkge1xuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9XG5cbiAgXHRpbmRlbnRlZCA9IHN0cmluZy5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24gKGxpbmUsIG5vdEZpcnN0TGluZSkge1xuICBcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuICBcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRyZXR1cm4gaW5kZW50ZWQ7XG4gIH07XG5cbiAgdmFyIG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSA9IFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIiVzXFxcIlwiO1xuXG4gIHZhciBQYXJ0aWFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy50eXBlID0gUEFSVElBTDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG5cbiAgXHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuICBcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuICBcdC8vIHdob3NlIG5hbWUgaXMgdGhlIHZhbHVlIG9mIGBmb29gJylcbiAgXHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0aWYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7IC8vIHByZXZlbnQgYW55IGZ1cnRoZXIgY2hhbmdlc1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIFBhcnRpYWwucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFBhcnRpYWxOYW1lOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5pc05hbWVkICYmIHRoaXMubmFtZSkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIG5hbWVkIHBhcnRpYWxzIGFyZW4ndCBib3VuZCwgc28gZG9uJ3QgcmViaW5kXG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHRNdXN0YWNoZV9yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0dGhpcy51cGRhdGUoKTtcblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICBcdFx0XHQvLyBub3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBubyB3b3JrIHRvIGJlIGRvbmVcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgXCJcIiArIHZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcbiAgXHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcbiAgXHRcdC8vIGFuZCBhIHBhcnRpYWwuIEluIHRob3NlIGNhc2VzLCB0aGlzIGJlY29tZXMgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0XHRpZiAoIXRlbXBsYXRlICYmIHRoaXMubmFtZSAmJiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgdGhpcy5wYXJlbnRGcmFnbWVudCkpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUgfHwgW10pO1xuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICh0b1N0cmluZykge1xuICBcdFx0dmFyIHN0cmluZywgcHJldmlvdXNJdGVtLCBsYXN0TGluZSwgbWF0Y2g7XG5cbiAgXHRcdHN0cmluZyA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodG9TdHJpbmcpO1xuXG4gIFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zW3RoaXMuaW5kZXggLSAxXTtcblxuICBcdFx0aWYgKCFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IFRFWFQpIHtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cblxuICBcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdChcIlxcblwiKS5wb3AoKTtcblxuICBcdFx0aWYgKG1hdGNoID0gL15cXHMrJC8uZXhlYyhsYXN0TGluZSkpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KHN0cmluZywgbWF0Y2hbMF0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvVW5yZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1JlbmRlcikge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9QYXJ0aWFsID0gUGFydGlhbDtcblxuICAvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cbiAgdmFyIENvbXBvbmVudF9nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQ7XG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudChyYWN0aXZlLCBuYW1lKSB7XG5cbiAgXHR2YXIgQ29tcG9uZW50LFxuICBcdCAgICBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcImNvbXBvbmVudHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdENvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgXHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcbiAgXHRcdGlmICghQ29tcG9uZW50Ll9QYXJlbnQpIHtcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcbiAgXHRcdFx0dmFyIGZuID0gQ29tcG9uZW50LmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdFx0Q29tcG9uZW50ID0gZm4oKTtcblxuICBcdFx0XHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJjb21wb25lbnRcIiwgXCJjb21wb25lbnRcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBhbGxvdyBzdHJpbmcgbG9va3VwXG4gIFx0XHRcdFx0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIENvbXBvbmVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRDb21wb25lbnQuX2ZuID0gZm47XG4gIFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV0gPSBDb21wb25lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCA9IENvbXBvbmVudCRkZXRhY2g7XG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzLmluc3RhbmNlKTtcbiAgXHRyZXR1cm4gZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kID0gQ29tcG9uZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBDb21wb25lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBDb21wb25lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gQ29tcG9uZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IENvbXBvbmVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiAod3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdDtcbiAgXHR2YXIga2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG4gIFx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cbiAgXHRcdHJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuICAgICAgbXV0YXRvck1ldGhvZHMgPSBbXCJwb3BcIiwgXCJwdXNoXCIsIFwicmV2ZXJzZVwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sXG4gICAgICB0ZXN0T2JqLFxuICAgICAgcGF0Y2hBcnJheU1ldGhvZHMsXG4gICAgICB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIG11dGF0b3JNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgXHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG4gIFx0XHRpID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHdyYXBwZXIgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzW2ldO1xuXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUod3JhcHBlci5yb290KTtcbiAgXHRcdFx0cHJvY2Vzc1dyYXBwZXIod3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdGRlZmluZVByb3BlcnR5KHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG4gIFx0XHR2YWx1ZTogbWV0aG9kXG4gIFx0fSk7XG4gIH0pO1xuXG4gIC8vIGNhbiB3ZSB1c2UgcHJvdG90eXBlIGNoYWluIGluamVjdGlvbj9cbiAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuICB0ZXN0T2JqID0ge307XG5cbiAgaWYgKHRlc3RPYmouX19wcm90b19fKSB7XG4gIFx0Ly8geWVzLCB3ZSBjYW5cbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdC8vIG5vLCB3ZSBjYW4ndFxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzW2ldO1xuICBcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgbWV0aG9kTmFtZSwge1xuICBcdFx0XHRcdHZhbHVlOiBwYXRjaGVkQXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRkZWxldGUgYXJyYXlbbXV0YXRvck1ldGhvZHNbaV1dO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBwYXRjaEFycmF5TWV0aG9kcy51bnBhdGNoID0gdW5wYXRjaEFycmF5TWV0aG9kcztcbiAgdmFyIHBhdGNoID0gcGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgdmFyIGFycmF5QWRhcHRvcixcblxuICAvLyBoZWxwZXJzXG4gIEFycmF5V3JhcHBlciwgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZTtcblxuICBhcnJheUFkYXB0b3IgPSB7XG4gIFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcbiAgXHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG4gIFx0XHRyZXR1cm4gaXNBcnJheShvYmplY3QpICYmICghb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyk7XG4gIFx0fSxcbiAgXHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnZhbHVlID0gYXJyYXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlKSB7XG5cbiAgXHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0XHR2YWx1ZToge1xuICBcdFx0XHRcdHdyYXBwZXJzOiBbXSxcbiAgXHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuICBcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdHBhdGNoKGFycmF5KTtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdKSB7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gPSAwO1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2gocmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdICs9IDE7XG4gIFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCh0aGlzKTtcbiAgfTtcblxuICBBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuICBcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuICBcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cbiAgXHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2ZcbiAgXHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cbiAgXHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcbiAgXHRcdGlmIChzdG9yYWdlLnNldHRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB0aGF0IHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdH1cblxuICBcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcbiAgXHRcdC8vIG5hdHVyYWwgc3RhdGVcbiAgXHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdFx0cGF0Y2gudW5wYXRjaCh0aGlzLnZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gIFx0XHRcdGluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdIC09IDE7XG4gIFx0XHRcdGlmICghaW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0pIHtcbiAgXHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKHRoaXMucm9vdCk7XG5cbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSA9IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5XCI7XG4gIHZhciBhcnJheV9pbmRleCA9IGFycmF5QWRhcHRvcjtcblxuICB2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblxuICB2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiBudW1lcmljLnRlc3Qoa2V5KSA/IFtdIDoge307XG4gIH07XG5cbiAgdmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdG1hZ2ljQWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHR2YXIgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cbiAgXHRcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0XHRcdGlmICgocGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG4gIFx0XHRcdGlmIChpc0FycmF5KHBhcmVudFZhbHVlKSAmJiAvXlswLTldKyQvLnRlc3Qoa2V5cGF0aC5sYXN0S2V5KSkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgXHRcdH0sXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgpIHtcbiAgXHRcdHZhciBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMucHJvcCA9IGtleXBhdGgubGFzdEtleTtcblxuICBcdFx0b2JqS2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoLmlzUm9vdCA/IHJhY3RpdmUudmlld21vZGVsLmRhdGEgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQob2JqS2V5cGF0aCk7XG5cbiAgXHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuXG4gIFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cbiAgXHRcdGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMpKSB7XG5cbiAgXHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuICBcdFx0XHRpZiAoc2libGluZ3MuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRzaWJsaW5ncy5wdXNoKHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IHdyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcbiAgXHRcdGNyZWF0ZUFjY2Vzc29ycyh0aGlzLCB2YWx1ZSwgdGVtcGxhdGUpO1xuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlOyAvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUodGhpcy5yYWN0aXZlKTtcbiAgXHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKHRoaXMua2V5cGF0aCwgeyBrZWVwRXhpc3RpbmdXcmFwcGVyOiB0cnVlIH0pO1xuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fSxcbiAgXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXRoaXMub2JqW3RoaXMucHJvcF0pIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gY3JlYXRlQnJhbmNoKGtleSk7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXVtrZXldID0gdmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG4gIFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuICBcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcbiAgXHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXG4gIFx0XHRcdGlmICghc2V0KSB7XG4gIFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cbiAgXHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuICBcdFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wXTtcblxuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG4gIFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdG1hZ2ljQWRhcHRvciA9IGZhbHNlOyAvLyBubyBtYWdpYyBpbiB0aGlzIGJyb3dzZXJcbiAgfVxuXG4gIHZhciBhZGFwdG9yc19tYWdpYyA9IG1hZ2ljQWRhcHRvcjtcblxuICBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMob3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUpIHtcblxuICBcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cbiAgXHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuICBcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cbiAgXHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cbiAgXHRpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG4gIFx0XHRpZiAocHJvcGVydHkgPT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlXCIpO1xuICBcdH1cblxuICBcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0aWYgKHRlbXBsYXRlKSB7XG4gIFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG4gIFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG4gIFx0fVxuXG4gIFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0c2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgXHRcdGlmIChvbGRTZXQpIHtcbiAgXHRcdFx0b2xkU2V0KHYpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcbiAgXHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2godXBkYXRlV3JhcHBlcik7XG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIod3JhcHBlcikge1xuICBcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cbiAgXHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHdyYXBwZXIudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuICBcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydChyYWN0aXZlKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuICBcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG4gIFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbb3JpZ2luYWxXcmFwcGVyXTtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cbiAgaWYgKGFkYXB0b3JzX21hZ2ljKSB7XG4gIFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0cmV0dXJuIGFkYXB0b3JzX21hZ2ljLmZpbHRlcihvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpICYmIGFycmF5X2luZGV4LmZpbHRlcihvYmplY3QpO1xuICBcdFx0fSxcblxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBhZGFwdG9yc19tYWdpYy53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlfaW5kZXgud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXkgPSBtYWdpY0FycmF5QWRhcHRvcjtcblxuICB2YXIgcHJvdG90eXBlX2FkYXB0ID0gVmlld21vZGVsJGFkYXB0O1xuXG4gIHZhciBwcmVmaXhlcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblxuICBcdGlmICghdGhpcy5hZGFwdG9ycykgcmV0dXJuO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdGxlbiA9IHRoaXMuYWRhcHRvcnMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0YWRhcHRvciA9IHRoaXMuYWRhcHRvcnNbaV07XG5cbiAgXHRcdGlmIChhZGFwdG9yLmZpbHRlcih2YWx1ZSwga2V5cGF0aCwgdGhpcy5yYWN0aXZlKSkge1xuICBcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhdID0gYWRhcHRvci53cmFwKHRoaXMucmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgsIGdldFByZWZpeGVyKGtleXBhdGgpKTtcbiAgXHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4S2V5cGF0aChvYmosIHByZWZpeCkge1xuICBcdHZhciBwcmVmaXhlZCA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRpZiAoIXByZWZpeCkge1xuICBcdFx0cmV0dXJuIG9iajtcbiAgXHR9XG5cbiAgXHRwcmVmaXggKz0gXCIuXCI7XG5cbiAgXHRmb3IgKGtleSBpbiBvYmopIHtcbiAgXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRwcmVmaXhlZFtwcmVmaXggKyBrZXldID0gb2JqW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZXIocm9vdEtleXBhdGgpIHtcbiAgXHR2YXIgcm9vdERvdDtcblxuICBcdGlmICghcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSkge1xuICBcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyBcIi5cIiA6IFwiXCI7XG5cbiAgXHRcdHByZWZpeGVyc1tyb290S2V5cGF0aF0gPSBmdW5jdGlvbiAocmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0b2JqID0ge307XG4gIFx0XHRcdFx0b2JqW3Jvb3REb3QgKyByZWxhdGl2ZUtleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcbiAgXHRcdFx0XHRyZXR1cm4gcm9vdERvdCA/IHByZWZpeEtleXBhdGgocmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCkgOiByZWxhdGl2ZUtleXBhdGg7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVyc1tyb290S2V5cGF0aF07XG4gIH1cblxuICAvLyBURU1QXG5cbiAgdmFyIGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzO1xuICBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcykge1xuICBcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbcm9vdEtleXBhdGhdLFxuICBcdCAgICBpLFxuICBcdCAgICBrZXlwYXRoO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBjaGFuZ2VzW2ldLnBhcmVudDtcblxuICBcdFx0d2hpbGUgKGtleXBhdGggJiYgIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0YWRkVG9BcnJheSh1cHN0cmVhbUNoYW5nZXMsIGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdXBzdHJlYW1DaGFuZ2VzO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuICBmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCkge1xuICBcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgXHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKTtcblxuICBcdGlmIChvbmx5RGlyZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0ga2V5cGF0aC53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodXBzdHJlYW1QYXR0ZXJuKSB7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpIHtcbiAgXHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXG4gIFx0Ly8gVE9ETyBzaG91bGQgYmUgb25lIG9yIHRoZSBvdGhlclxuICBcdHVwc3RyZWFtUGF0dGVybiA9IHVwc3RyZWFtUGF0dGVybi5zdHIgfHwgdXBzdHJlYW1QYXR0ZXJuO1xuXG4gIFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuICBcdG1hcCA9IGdyb3VwICYmIGdyb3VwW3Vwc3RyZWFtUGF0dGVybl07XG5cbiAgXHRpZiAoIW1hcCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEtleXBhdGgpIHtcbiAgXHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGguam9pbihjaGlsZEtleXBhdGgubGFzdEtleSk7IC8vICdmb28uYmFyLmJheidcblxuICBcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgXHRcdGlmIChvYnNlcnZlci5yZWdleC50ZXN0KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRvYnNlcnZlci51cGRhdGUoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzID0gVmlld21vZGVsJGFwcGx5Q2hhbmdlcztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIGNoYW5nZXMsXG4gIFx0ICAgIHVwc3RyZWFtQ2hhbmdlcyxcbiAgXHQgICAgaGFzaCA9IHt9LFxuICBcdCAgICBiaW5kaW5ncztcblxuICBcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cbiAgXHRpZiAoIWNoYW5nZXMubGVuZ3RoKSB7XG4gIFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBpbnZhbGlkYXRlQ29tcHV0YXRpb24oY29tcHV0YXRpb24pIHtcbiAgXHRcdHZhciBrZXkgPSBjb21wdXRhdGlvbi5rZXk7XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbi52aWV3bW9kZWwgPT09IHNlbGYpIHtcbiAgXHRcdFx0c2VsZi5jbGVhckNhY2hlKGtleS5zdHIpO1xuICBcdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cbiAgXHRcdFx0Y2hhbmdlcy5wdXNoKGtleSk7XG4gIFx0XHRcdGNhc2NhZGUoa2V5KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5tYXJrKGtleSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgbWFwLCBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdGlmIChzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRtYXAuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjaGFuZ2VzLnNsaWNlKCkuZm9yRWFjaChjYXNjYWRlKTtcblxuICBcdHVwc3RyZWFtQ2hhbmdlcyA9IGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpO1xuICBcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY29tcHV0YXRpb25zO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZG93biB0aGlzIHBhcnRpY3VsYXIga2V5cGF0aCBpbiB0aGlzIHR1cm5cbiAgXHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG5cbiAgXHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2VcbiAgXHRpZiAodGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoLCB0cnVlKTtcbiAgXHRcdH0pO1xuICBcdFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzLm9ic2VydmVycykge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgbnVsbCwga2V5cGF0aCwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHR9KTtcbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJvYnNlcnZlcnNcIik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwc1tcImRlZmF1bHRcIl0pIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBiaW5kaW5ncywga2V5cGF0aCwgXCJkZWZhdWx0XCIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0bm90aWZ5QmluZGluZ3ModGhpcywgYmluZGluZ3MsIGNoYW5nZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwiZGVmYXVsdFwiKTtcbiAgXHR9XG5cbiAgXHQvLyBSZXR1cm4gYSBoYXNoIG9mIGtleXBhdGhzIHRvIHVwZGF0ZWQgdmFsdWVzXG4gIFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRoYXNoW2tleXBhdGguc3RyXSA9IF90aGlzLmdldChrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHJldHVybiBoYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpKSB7XG4gIFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdGRlcGVuZGFudHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHQvLyBkb24ndCBcInNldFwiIHRoZSBwYXJlbnQgdmFsdWUsIHJlZmluZSBpdFxuICBcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuICBcdFx0XHRpZiAoYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSkge1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2goZCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUJpbmRpbmdzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMpIHtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdHZhciB1c2VTZXQgPSBmYWxzZSxcbiAgXHRcdCAgICBpID0gMCxcbiAgXHRcdCAgICBsZW5ndGggPSBjaGFuZ2VzLmxlbmd0aCxcbiAgXHRcdCAgICByZWZpbmVtZW50cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuICBcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbaV07XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHVzZVNldCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoa2V5cGF0aC5zbGljZSgwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoKSA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGkrKztcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVzZVNldCkge1xuICBcdFx0XHRiaW5kaW5nLnNldFZhbHVlKHZpZXdtb2RlbC5nZXQoYmluZGluZy5rZXlwYXRoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZShyZWZpbmVtZW50cyk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlBbGxEZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSkge1xuICBcdHZhciBxdWV1ZSA9IFtdO1xuXG4gIFx0YWRkS2V5cGF0aHMoa2V5cGF0aHMpO1xuICBcdHF1ZXVlLmZvckVhY2goZGlzcGF0Y2gpO1xuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aHMoa2V5cGF0aHMpIHtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goYWRkS2V5cGF0aCk7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGgoa2V5cGF0aCkge1xuICBcdFx0dmFyIGRlcHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSk7XG5cbiAgXHRcdGlmIChkZXBzKSB7XG4gIFx0XHRcdHF1ZXVlLnB1c2goe1xuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRcdFx0ZGVwczogZGVwc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjaGlsZERlcHM7XG5cbiAgXHRcdGlmIChjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cE5hbWVdW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRhZGRLZXlwYXRocyhjaGlsZERlcHMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGRpc3BhdGNoKHNldCkge1xuICBcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldChzZXQua2V5cGF0aCk7XG4gIFx0XHRzZXQuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGdyb3VwID0gdmlld21vZGVsLmRlcHNbZ3JvdXBOYW1lXTtcbiAgXHRyZXR1cm4gZ3JvdXAgPyBncm91cFtrZXlwYXRoLnN0cl0gOiBudWxsO1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBWaWV3bW9kZWwkY2FwdHVyZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaChbXSk7XG4gIH1cblxuICB2YXIgY2xlYXJDYWNoZSA9IFZpZXdtb2RlbCRjbGVhckNhY2hlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKGtleXBhdGgsIGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cbiAgXHRpZiAoIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG4gIFx0XHRpZiAod3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSkge1xuICBcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuICBcdFx0XHRpZiAod3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSkge1xuICBcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuICBcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG4gIFx0XHRcdFx0dGhpcy53cmFwcGVkW2tleXBhdGhdID0gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuY2FjaGVba2V5cGF0aF0gPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwW2tleXBhdGhdKSB7XG4gIFx0XHR3aGlsZSAoY2FjaGVNYXAubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuY2xlYXJDYWNoZShjYWNoZU1hcC5wb3AoKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFVucmVzb2x2ZWREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGNvbXB1dGF0aW9uLCByZWYpIHtcbiAgXHR0aGlzLmNvbXB1dGF0aW9uID0gY29tcHV0YXRpb247XG4gIFx0dGhpcy52aWV3bW9kZWwgPSBjb21wdXRhdGlvbi52aWV3bW9kZWw7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG5cbiAgXHQvLyBUT0RPIHRoaXMgc2VlbXMgbGlrZSBhIHJlZCBmbGFnIVxuICBcdHRoaXMucm9vdCA9IHRoaXMudmlld21vZGVsLnJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMucm9vdC5jb21wb25lbnQgJiYgdGhpcy5yb290LmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgfTtcblxuICBVbnJlc29sdmVkRGVwZW5kZW5jeS5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24uc29mdERlcHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24udW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gbnVsbDtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMuY29tcHV0YXRpb24sIFwiY29tcHV0ZWRcIik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSA9IFVucmVzb2x2ZWREZXBlbmRlbmN5O1xuXG4gIHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uIChrZXksIHNpZ25hdHVyZSkge1xuICBcdHRoaXMua2V5ID0ga2V5O1xuXG4gIFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0dGVyO1xuICBcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldHRlcjtcblxuICBcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcbiAgXHR0aGlzLnNvZnREZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkRGVwcyA9IHt9O1xuXG4gIFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblxuICBcdHRoaXMuX2RpcnR5ID0gdGhpcy5fZmlyc3RSdW4gPSB0cnVlO1xuICB9O1xuXG4gIENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaW5pdGlhbDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLmJ5cGFzcyA9IHRydWU7XG5cbiAgXHRcdGluaXRpYWwgPSB2aWV3bW9kZWwuZ2V0KHRoaXMua2V5KTtcbiAgXHRcdHZpZXdtb2RlbC5jbGVhckNhY2hlKHRoaXMua2V5LnN0cik7XG5cbiAgXHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5zZXQoaW5pdGlhbCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmhhcmREZXBzKSB7XG4gIFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHJldHVybiB2aWV3bW9kZWwucmVnaXN0ZXIoZCwgX3RoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIG5ld0RlcHMsXG4gIFx0XHQgICAgZGVwZW5kZW5jaWVzQ2hhbmdlZCxcbiAgXHRcdCAgICBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5nZXR0aW5nKSB7XG4gIFx0XHRcdC8vIHByZXZlbnQgZG91YmxlLWNvbXB1dGF0aW9uIChlLmcuIGNhdXNlZCBieSBhcnJheSBtdXRhdGlvbiBpbnNpZGUgY29tcHV0YXRpb24pXG4gIFx0XHRcdHZhciBtc2cgPSBcIlRoZSBcIiArIHRoaXMua2V5LnN0ciArIFwiIGNvbXB1dGF0aW9uIGluZGlyZWN0bHkgY2FsbGVkIGl0c2VsZi4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGNvbXB1dGF0aW9uLiBJdCBpcyBjb21tb25seSBjYXVzZWQgYnkgYGFycmF5LnNvcnQoLi4uKWAgLSBpZiB0aGF0J3MgdGhlIGNhc2UsIGNsb25lIHRoZSBhcnJheSBmaXJzdCB3aXRoIGBhcnJheS5zbGljZSgpLnNvcnQoLi4uKWBcIjtcbiAgXHRcdFx0d2Fybk9uY2UobXNnKTtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuICBcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXRzIGhhdmUgY2hhbmdlZCwgaW4gY2FzZSB0aGlzIGRlcGVuZHMgb25cbiAgXHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG4gIFx0XHRcdGlmICh0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cbiAgXHRcdFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbaV07XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRcdFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXG4gIFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldHRlcigpO1xuICBcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJGYWlsZWQgdG8gY29tcHV0ZSBcXFwiJXNcXFwiXCIsIHRoaXMua2V5LnN0cik7XG4gIFx0XHRcdFx0XHRsb2dJZkRlYnVnKGVyci5zdGFjayB8fCBlcnIpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG5ld0RlcHMgPSB0aGlzLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKG5ld0RlcHMpO1xuXG4gIFx0XHRcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICh0aGlzLnNldHRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5zZXR0ZXIpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5zZXR0ZXIodmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uIChuZXdEZXBzKSB7XG4gIFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgdW5yZXNvbHZlZDtcblxuICBcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cbiAgXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcbiAgXHRcdGkgPSBvbGREZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG9sZERlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG5ld0RlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG4gIFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBuZXdEZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChvbGREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmICghdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyBrZXlwYXRoIGlzIGN1cnJlbnRseSB1bnJlc29sdmVkLCB3ZSBuZWVkIHRvIG1hcmtcbiAgXHRcdFx0XHQvLyBpdCBhcyBzdWNoLiBUT0RPIHRoaXMgaXMgYSBiaXQgbXVkZHkuLi5cbiAgXHRcdFx0XHRpZiAoaXNVbnJlc29sdmVkKHRoaXMudmlld21vZGVsLCBrZXlwYXRoKSAmJiAhdGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0XHRcdHVucmVzb2x2ZWQgPSBuZXcgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kodGhpcywga2V5cGF0aC5zdHIpO1xuICBcdFx0XHRcdFx0bmV3RGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gdW5yZXNvbHZlZDtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodW5yZXNvbHZlZCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1VucmVzb2x2ZWQodmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleSA9IGtleXBhdGguZmlyc3RLZXk7XG5cbiAgXHRyZXR1cm4gIShrZXkgaW4gdmlld21vZGVsLmRhdGEpICYmICEoa2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMpICYmICEoa2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncyk7XG4gIH1cblxuICB2YXIgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24gPSBDb21wdXRhdGlvbjtcblxuICB2YXIgY29tcHV0ZSA9IFZpZXdtb2RlbCRjb21wdXRlO1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkY29tcHV0ZShrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBjb21wdXRhdGlvbiA9IG5ldyBDb21wdXRhdGlvbl9Db21wdXRhdGlvbihrZXksIHNpZ25hdHVyZSk7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW5pdCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5jb21wdXRhdGlvbnNba2V5LnN0cl0gPSBjb21wdXRhdGlvbjtcbiAgfVxuXG4gIHZhciBGQUlMRURfTE9PS1VQID0geyBGQUlMRURfTE9PS1VQOiB0cnVlIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0ID0gVmlld21vZGVsJGdldDtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5ID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gIFx0ICAgIHZhbHVlLFxuICBcdCAgICBjb21wdXRhdGlvbixcbiAgXHQgICAgd3JhcHBlZCxcbiAgXHQgICAgY2FwdHVyZUdyb3VwLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHIsXG4gIFx0ICAgIGtleTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eTtcblxuICBcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG4gIFx0aWYgKG9wdGlvbnMuY2FwdHVyZSAmJiAoY2FwdHVyZUdyb3VwID0gbGFzdEl0ZW0odGhpcy5jYXB0dXJlR3JvdXBzKSkpIHtcbiAgXHRcdGlmICghIH5jYXB0dXJlR3JvdXAuaW5kZXhPZihrZXlwYXRoKSkge1xuICBcdFx0XHRjYXB0dXJlR3JvdXAucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaGFzT3duLmNhbGwodGhpcy5tYXBwaW5ncywga2V5cGF0aC5maXJzdEtleSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldLmdldChrZXlwYXRoLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLnZhbHVlO1xuICBcdH1cblxuICBcdGlmIChjYWNoZVtrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgXHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cbiAgXHRcdGlmICgoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcykge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdFx0XHR0aGlzLmFkYXB0KGtleXBhdGhTdHIsIHZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgdGhpcyBhIHdyYXBwZWQgcHJvcGVydHk/XG4gIFx0XHRlbHNlIGlmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgaXQgdGhlIHJvb3Q/XG4gIFx0XHRlbHNlIGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHR0aGlzLmFkYXB0KFwiXCIsIHRoaXMuZGF0YSk7XG4gIFx0XHRcdHZhbHVlID0gdGhpcy5kYXRhO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBObz8gVGhlbiB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBvbmUga2V5IGF0IGEgdGltZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmV0cmlldmUodGhpcywga2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGNhY2hlW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHZhbHVlID0gY2FjaGVba2V5cGF0aFN0cl07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLm5vVW53cmFwICYmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCAmJiBvcHRpb25zLmZ1bGxSb290R2V0KSB7XG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLm1hcHBpbmdzKSB7XG4gIFx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLm1hcHBpbmdzW2tleV0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJpZXZlKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuXG4gIFx0dmFyIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cbiAgXHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0aWYgKHdyYXBwZWQgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudFZhbHVlID09PSBudWxsIHx8IHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyB1cGRhdGUgY2FjaGUgbWFwXG4gIFx0aWYgKCEoY2FjaGVNYXAgPSB2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSkpIHtcbiAgXHRcdHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW2tleXBhdGguc3RyXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aWYgKGNhY2hlTWFwLmluZGV4T2Yoa2V5cGF0aC5zdHIpID09PSAtMSkge1xuICBcdFx0XHRjYWNoZU1hcC5wdXNoKGtleXBhdGguc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG4gIFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRvIHF1ZXJ5IHBhcmVudCBzY29wZSAoaWYgc3VjaCB0aGVyZSBiZSlcbiAgXHRpZiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiICYmICEoa2V5cGF0aC5sYXN0S2V5IGluIHBhcmVudFZhbHVlKSkge1xuICBcdFx0cmV0dXJuIHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSBGQUlMRURfTE9PS1VQO1xuICBcdH1cblxuICBcdHZhbHVlID0gcGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XTtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHR2aWV3bW9kZWwuYWRhcHQoa2V5cGF0aC5zdHIsIHZhbHVlLCBmYWxzZSk7XG5cbiAgXHQvLyBVcGRhdGUgY2FjaGVcbiAgXHR2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCA9IFZpZXdtb2RlbCRpbml0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuICBcdHZhciBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiB0aGlzLmNvbXB1dGF0aW9ucykge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbnNba2V5XS5pbml0KHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWFwID0gVmlld21vZGVsJG1hcDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFwKGtleSwgb3B0aW9ucykge1xuICBcdHZhciBtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXkuc3RyXSA9IG5ldyBNYXBwaW5nKGtleSwgb3B0aW9ucyk7XG4gIFx0bWFwcGluZy5pbml0Vmlld21vZGVsKHRoaXMpO1xuICBcdHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgdmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAobG9jYWxLZXksIG9wdGlvbnMpIHtcbiAgXHR0aGlzLmxvY2FsS2V5ID0gbG9jYWxLZXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gb3B0aW9ucy5rZXlwYXRoO1xuICBcdHRoaXMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG5cbiAgXHR0aGlzLmRlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBNYXBwaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gd2FybiwgYXMgcGVyICMxNjkyP1xuICBcdFx0dGhpcy5rZXlwYXRoID0gdGhpcy5sb2NhbEtleTtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMubWFwKGtleXBhdGgpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGluaXRWaWV3bW9kZWw6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHRoaXMubG9jYWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdG1hcDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubG9jYWxLZXk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5yZXBsYWNlKHRoaXMubG9jYWxLZXksIHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dGhpcy5kZXBzLnB1c2goeyBrZXlwYXRoOiBrZXlwYXRoLCBkZXA6IGRlcGVuZGFudCwgZ3JvdXA6IGdyb3VwIH0pO1xuXG4gIFx0XHRpZiAodGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLm9yaWdpbi5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy51bmJpbmQodHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMubWFwKGtleXBhdGgpLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYWNjdW11bGF0ZWQgZGVwZW5kYW50cyBjYW4gbm93IGJlIHJlZ2lzdGVyZWRcbiAgXHRcdGlmICh0aGlzLmRlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSBfdGhpcy5tYXAoZC5rZXlwYXRoKTtcbiAgXHRcdFx0XHRfdGhpcy5vcmlnaW4ucmVnaXN0ZXIoa2V5cGF0aCwgZC5kZXAsIGQuZ3JvdXApO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyB0aGlzIGlzIGEgYml0IG9mIGEgcmVkIGZsYWcuLi4gYWxsIGRlcHMgc2hvdWxkIGJlIHRoZSBzYW1lP1xuICBcdFx0XHRcdGlmIChkLmRlcC5zZXRWYWx1ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuc2V0VmFsdWUoX3RoaXMub3JpZ2luLmdldChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChkLmRlcC5pbnZhbGlkYXRlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5pbnZhbGlkYXRlKCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMub3JpZ2luLm1hcmsodGhpcy5rZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBkb2VzIG5vdCBoYXZlIGtleXBhdGgsIGNhbm5vdCBzZXQgdmFsdWUuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uIChrZWVwTG9jYWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICgha2VlcExvY2FsKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLmxvY2FsLm1hcHBpbmdzW3RoaXMubG9jYWxLZXldO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRfdGhpcy5vcmlnaW4udW5yZWdpc3RlcihfdGhpcy5tYXAoZC5rZXlwYXRoKSwgZC5kZXAsIGQuZ3JvdXApO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICh0aGlzLnRyYWNrZXIpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMudHJhY2tlcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR2YXIgZGVwcywgaTtcblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZGVwcyA9IHRoaXMuZGVwcztcbiAgXHRcdGkgPSBkZXBzLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoZGVwc1tpXS5kZXAgPT09IGRlcGVuZGFudCkge1xuICBcdFx0XHRcdGRlcHMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG1hcmsgPSBWaWV3bW9kZWwkbWFyaztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyayhrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG4gIFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRpZiAob3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaW1wbGljaXQpIHtcbiAgXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMubm9DYXNjYWRlKSB7XG4gIFx0XHRcdHRoaXMubm9DYXNjYWRlW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdHRoaXMuY2hhbmdlcy5wdXNoKGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIHBhc3Mgb24ga2VlcEV4aXN0aW5nV3JhcHBlciwgaWYgd2UgY2FuXG4gIFx0dmFyIGtlZXBFeGlzdGluZ1dyYXBwZXIgPSBvcHRpb25zID8gb3B0aW9ucy5rZWVwRXhpc3RpbmdXcmFwcGVyIDogZmFsc2U7XG5cbiAgXHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aFN0ciwga2VlcEV4aXN0aW5nV3JhcHBlcik7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0dGhpcy5vbmNoYW5nZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24gKG9sZEFycmF5LCBuZXdBcnJheSkge1xuICBcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblxuICBcdHVzZWRJbmRpY2VzID0ge307XG4gIFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cbiAgXHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gIFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cbiAgXHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcbiAgXHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoaXRlbSwgc3RhcnQpO1xuXG4gIFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gLTE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcbiAgXHRcdH0gd2hpbGUgKHVzZWRJbmRpY2VzW2luZGV4XSAmJiBzdGFydCA8IGxlbik7XG5cbiAgXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG4gIFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG4gIFx0XHRpZiAoaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXgpIHtcbiAgXHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHVzZWRJbmRpY2VzW2luZGV4XSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gaW5kZXg7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfTtcblxuICB2YXIgbWVyZ2UgPSBWaWV3bW9kZWwkbWVyZ2U7XG5cbiAgdmFyIGNvbXBhcmF0b3JzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblxuICBcdHRoaXMubWFyayhrZXlwYXRoKTtcblxuICBcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSkge1xuXG4gIFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKG9wdGlvbnMuY29tcGFyZSk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcbiAgXHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIm1lcmdlKCk6IFxcXCIlc1xcXCIgY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZ1wiLCBrZXlwYXRoKTtcblxuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdH1cblxuICBcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcbiAgXHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleChvbGRBcnJheSwgbmV3QXJyYXkpO1xuXG4gIFx0dGhpcy5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gIFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgXHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuICBcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuICBcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuICBcdGlmIChjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKCFjb21wYXJhdG9yc1tjb21wYXJhdG9yXSkge1xuICBcdFx0XHRjb21wYXJhdG9yc1tjb21wYXJhdG9yXSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW1bY29tcGFyYXRvcl07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjb21wYXJhdG9yc1tjb21wYXJhdG9yXTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpXCIpO1xuICB9XG5cbiAgdmFyIHJlZ2lzdGVyID0gVmlld21vZGVsJHJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHNCeUtleXBhdGgsIGRlcHM7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47IC8vIFRPRE8gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlIGlmIGEgZGVwZW5kYW50IGlzIHN0YXRpYy4uLlxuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0bWFwcGluZy5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1tncm91cF0gfHwgKHRoaXMuZGVwc1tncm91cF0gPSB7fSk7XG4gIFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gfHwgKGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdID0gW10pO1xuXG4gIFx0XHRkZXBzLnB1c2goZGVwZW5kYW50KTtcblxuICBcdFx0aWYgKCF0aGlzLmRlcHNNYXBbZ3JvdXBdKSB7XG4gIFx0XHRcdHRoaXMuZGVwc01hcFtncm91cF0gPSB7fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRyZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudCwga2V5cGF0aFN0cjtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdIHx8IChtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtdKTtcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0XHQvLyBUT0RPIGZpbmQgYW4gYWx0ZXJuYXRpdmUgdG8gdGhpcyBuYXN0eSBhcHByb2FjaFxuICBcdFx0aWYgKHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPSAwO1xuICBcdFx0XHRwYXJlbnQucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gKz0gMTtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcmVsZWFzZSA9IFZpZXdtb2RlbCRyZWxlYXNlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuICBcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG4gIH1cblxuICB2YXIgcmVzZXQgPSBWaWV3bW9kZWwkcmVzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlc2V0KGRhdGEpIHtcbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuICBcdHRoaXMuY2xlYXJDYWNoZShcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0ID0gVmlld21vZGVsJHNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBrZWVwRXhpc3RpbmdXcmFwcGVyO1xuXG4gIFx0Ly8gdW5sZXNzIGRhdGEgaXMgYmVpbmcgc2V0IGZvciBkYXRhIHRyYWNraW5nIHB1cnBvc2VzXG4gIFx0aWYgKCFvcHRpb25zLm5vTWFwcGluZykge1xuICBcdFx0Ly8gSWYgdGhpcyBkYXRhIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgdmlld21vZGVsLFxuICBcdFx0Ly8gcGFzcyB0aGUgY2hhbmdlIGFsb25nXG4gIFx0XHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdFx0cmV0dXJuIG1hcHBpbmcuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcbiAgXHRpZiAoY29tcHV0YXRpb24pIHtcbiAgXHRcdGlmIChjb21wdXRhdGlvbi5zZXR0aW5nKSB7XG4gIFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRjb21wdXRhdGlvbi5zZXQodmFsdWUpO1xuICBcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNFcXVhbCh0aGlzLmNhY2hlW2tleXBhdGguc3RyXSwgdmFsdWUpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoLnN0cl07XG5cbiAgXHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuICBcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG4gIFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcbiAgXHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRrZWVwRXhpc3RpbmdXcmFwcGVyID0gd3JhcHBlci5yZXNldCh2YWx1ZSkgIT09IGZhbHNlO1xuXG4gIFx0XHRpZiAoa2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFjb21wdXRhdGlvbiAmJiAha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0cmVzb2x2ZVNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLnNpbGVudCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBXZSdyZSBzZXR0aW5nIGEgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB0YXJnZXQga2V5cGF0aCAoaS5lLlxuICBcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuICBcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2VcbiAgXHRcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoLnN0cik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNldCh2aWV3bW9kZWwsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXIsIHBhcmVudFZhbHVlLCB3cmFwcGVyU2V0LCB2YWx1ZVNldDtcblxuICBcdHdyYXBwZXJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAod3JhcHBlci5zZXQpIHtcbiAgXHRcdFx0d3JhcHBlci5zZXQoa2V5cGF0aC5sYXN0S2V5LCB2YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHZhbHVlU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCFwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaChrZXlwYXRoLmxhc3RLZXkpO1xuICBcdFx0XHR2aWV3bW9kZWwuc2V0KGtleXBhdGgucGFyZW50LCBwYXJlbnRWYWx1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gIFx0XHR9XG4gIFx0XHRwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldID0gdmFsdWU7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0aWYgKHdyYXBwZXIpIHtcbiAgXHRcdHdyYXBwZXJTZXQoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0Ly8gbWF5IGhhdmUgYmVlbiB3cmFwcGVkIHZpYSB0aGUgYWJvdmUgLmdldCgpXG4gIFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuICBcdFx0aWYgKHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRcdHdyYXBwZXJTZXQoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNtYXJ0VXBkYXRlID0gVmlld21vZGVsJHNtYXJ0VXBkYXRlO1xuXG4gIHZhciBpbXBsaWNpdE9wdGlvbiA9IHsgaW1wbGljaXQ6IHRydWUgfSxcbiAgICAgIG5vQ2FzY2FkZU9wdGlvbiA9IHsgbm9DYXNjYWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZGVwZW5kYW50cywgb2xkTGVuZ3RoLCBpO1xuXG4gIFx0b2xkTGVuZ3RoID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgXHQvLyBJbmRpY2VzIHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXJ0eVxuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLm1hcmsoa2V5cGF0aC5qb2luKG9sZEluZGV4KSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcbiAgXHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuICBcdHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCB7IHNpbGVudDogdHJ1ZSB9KTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gdGhpcy5kZXBzW1wiZGVmYXVsdFwiXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdGRlcGVuZGFudHMuZmlsdGVyKGNhblNodWZmbGUpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2h1ZmZsZShuZXdJbmRpY2VzLCBhcnJheSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAob2xkTGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oXCJsZW5ndGhcIiksIGltcGxpY2l0T3B0aW9uKTtcblxuICBcdFx0Zm9yIChpID0gbmV3SW5kaWNlcy50b3VjaGVkRnJvbTsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuICBcdFx0Ly8gVE9ETyBpcyB0aGlzIHN0aWxsIG5lY2Vzc2FyeSwgbm93IHRoYXQgY29tcHV0YXRpb25zIGFyZSBsYXp5P1xuICBcdFx0Zm9yIChpID0gYXJyYXkubGVuZ3RoOyBpIDwgb2xkTGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5TaHVmZmxlKGRlcGVuZGFudCkge1xuICBcdHJldHVybiB0eXBlb2YgZGVwZW5kYW50LnNodWZmbGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdGVhcmRvd24gPSBWaWV3bW9kZWwkdGVhcmRvd247XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblxuICBcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG4gIFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG4gIFx0T2JqZWN0LmtleXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIF90aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuICBcdHdoaWxlICh1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkpIHtcbiAgXHRcdHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kudGVhcmRvd24oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdW5yZWdpc3RlciA9IFZpZXdtb2RlbCR1bnJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwcywgaW5kZXg7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRyZXR1cm4gbWFwcGluZy51bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cblxuICBcdGRlcHMgPSB0aGlzLmRlcHNbZ3JvdXBdW2tleXBhdGguc3RyXTtcbiAgXHRpbmRleCA9IGRlcHMuaW5kZXhPZihkZXBlbmRhbnQpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3NcIik7XG4gIFx0fVxuXG4gIFx0ZGVwcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQ7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdIC09IDE7XG5cbiAgXHRcdGlmICghcGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuICBcdFx0XHRyZW1vdmVGcm9tQXJyYXkocGFyZW50LCBrZXlwYXRoKTtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdID0gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0ID0gb3B0aW9ucy5hZGFwdDtcbiAgXHR2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgXHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMucmFjdGl2ZTtcbiAgXHR2YXIgY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkO1xuICBcdHZhciBtYXBwaW5ncyA9IG9wdGlvbnMubWFwcGluZ3M7XG4gIFx0dmFyIGtleTtcbiAgXHR2YXIgbWFwcGluZztcblxuICBcdC8vIFRPRE8gaXMgaXQgcG9zc2libGUgdG8gcmVtb3ZlIHRoaXMgcmVmZXJlbmNlP1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmFkYXB0b3JzID0gYWRhcHQ7XG4gIFx0dGhpcy5vbmNoYW5nZSA9IG9wdGlvbnMub25jaGFuZ2U7XG5cbiAgXHR0aGlzLmNhY2hlID0ge307IC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG4gIFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuZGVwcyA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcbiAgXHR0aGlzLmRlcHNNYXAgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG5cbiAgXHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblxuICBcdHRoaXMuc3BlY2lhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLndyYXBwZWQgPSBjcmVhdGUobnVsbCk7XG4gIFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcblxuICBcdC8vIHNldCB1cCBleHBsaWNpdCBtYXBwaW5nc1xuICBcdHRoaXMubWFwcGluZ3MgPSBjcmVhdGUobnVsbCk7XG4gIFx0Zm9yIChrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdHRoaXMubWFwKGdldEtleXBhdGgoa2V5KSwgbWFwcGluZ3Nba2V5XSk7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEpIHtcbiAgXHRcdC8vIGlmIGRhdGEgZXhpc3RzIGxvY2FsbHksIGJ1dCBpcyBtaXNzaW5nIG9uIHRoZSBwYXJlbnQsXG4gIFx0XHQvLyB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgdG8gdGhlIHBhcmVudFxuICBcdFx0Zm9yIChrZXkgaW4gZGF0YSkge1xuICBcdFx0XHRpZiAoKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleV0pICYmIG1hcHBpbmcuZ2V0VmFsdWUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bWFwcGluZy5zZXRWYWx1ZShkYXRhW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdGlmIChtYXBwaW5ncyAmJiBrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdFx0ZmF0YWwoXCJDYW5ub3QgbWFwIHRvIGEgY29tcHV0ZWQgcHJvcGVydHkgKCclcycpXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY29tcHV0ZShnZXRLZXlwYXRoKGtleSksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9O1xuXG4gIFZpZXdtb2RlbC5wcm90b3R5cGUgPSB7XG4gIFx0YWRhcHQ6IHByb3RvdHlwZV9hZGFwdCxcbiAgXHRhcHBseUNoYW5nZXM6IGFwcGx5Q2hhbmdlcyxcbiAgXHRjYXB0dXJlOiBjYXB0dXJlLFxuICBcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG4gIFx0Y29tcHV0ZTogY29tcHV0ZSxcbiAgXHRnZXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0LFxuICBcdGluaXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCxcbiAgXHRtYXA6IHByb3RvdHlwZV9tYXAsXG4gIFx0bWFyazogbWFyayxcbiAgXHRtZXJnZTogbWVyZ2UsXG4gIFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICBcdHJlbGVhc2U6IHJlbGVhc2UsXG4gIFx0cmVzZXQ6IHJlc2V0LFxuICBcdHNldDogcHJvdG90eXBlX3NldCxcbiAgXHRzbWFydFVwZGF0ZTogc21hcnRVcGRhdGUsXG4gIFx0dGVhcmRvd246IHByb3RvdHlwZV90ZWFyZG93bixcbiAgXHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyXG4gIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9WaWV3bW9kZWwgPSBWaWV3bW9kZWw7XG5cbiAgZnVuY3Rpb24gSG9va1F1ZXVlKGV2ZW50KSB7XG4gIFx0dGhpcy5ob29rID0gbmV3IGhvb2tzX0hvb2soZXZlbnQpO1xuICBcdHRoaXMuaW5Qcm9jZXNzID0ge307XG4gIFx0dGhpcy5xdWV1ZSA9IHt9O1xuICB9XG5cbiAgSG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblxuICBcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cbiAgXHRiZWdpbjogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuXG4gIFx0XHR2YXIgcGFyZW50ID0gcmFjdGl2ZS5wYXJlbnQ7XG5cbiAgXHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuICBcdFx0Ly8gaXQgc2hvdWxkIGNhbGwgbWV0aG9kcyBvciBmaXJlIGF0IHRoaXMgcG9pbnRcbiAgXHRcdGlmICghcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1twYXJlbnQuX2d1aWRdKSB7XG4gIFx0XHRcdGZpcmUodGhpcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0XHQvLyBlbHNld2lzZSwgaGFuZG9mZiB0byBwYXJlbnQgdG8gZmlyZSB3aGVuIHJlYWR5XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0Z2V0Q2hpbGRRdWV1ZSh0aGlzLnF1ZXVlLCBwYXJlbnQpLnB1c2gocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRRdWV1ZShxdWV1ZSwgcmFjdGl2ZSkge1xuICBcdHJldHVybiBxdWV1ZVtyYWN0aXZlLl9ndWlkXSB8fCAocXVldWVbcmFjdGl2ZS5fZ3VpZF0gPSBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlKGhvb2tRdWV1ZSwgcmFjdGl2ZSkge1xuXG4gIFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSk7XG5cbiAgXHRob29rUXVldWUuaG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcbiAgXHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG4gIFx0d2hpbGUgKGNoaWxkUXVldWUubGVuZ3RoKSB7XG4gIFx0XHRmaXJlKGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpKTtcbiAgXHR9XG5cbiAgXHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlW3JhY3RpdmUuX2d1aWRdO1xuICB9XG5cbiAgdmFyIGhvb2tzX0hvb2tRdWV1ZSA9IEhvb2tRdWV1ZTtcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXM7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgY29tcHV0ZWQpIHtcbiAgXHR2YXIgc2lnbmF0dXJlcyA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0c2lnbmF0dXJlc1trZXldID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2lnbmF0dXJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGdldHRlciwgc2V0dGVyO1xuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLCByYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlLmdldCk7XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLmdldCwgcmFjdGl2ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmYXRhbChcImAlc2AgY29tcHV0YXRpb24gbXVzdCBoYXZlIGEgYGdldCgpYCBtZXRob2RcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0c2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLnNldCwgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgZ2V0dGVyOiBnZXR0ZXIsIHNldHRlcjogc2V0dGVyIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc3RyKSB7XG4gIFx0dmFyIGZ1bmN0aW9uQm9keSwgaGFzVGhpcywgZm47XG5cbiAgXHRmdW5jdGlvbkJvZHkgPSBcInJldHVybiAoXCIgKyBzdHIucmVwbGFjZShoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBrZXlwYXRoKSB7XG4gIFx0XHRoYXNUaGlzID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBcIl9fcmFjdGl2ZS5nZXQoXFxcIlwiICsga2V5cGF0aCArIFwiXFxcIilcIjtcbiAgXHR9KSArIFwiKTtcIjtcblxuICBcdGlmIChoYXNUaGlzKSB7XG4gIFx0XHRmdW5jdGlvbkJvZHkgPSBcInZhciBfX3JhY3RpdmUgPSB0aGlzOyBcIiArIGZ1bmN0aW9uQm9keTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihmdW5jdGlvbkJvZHkpO1xuICBcdHJldHVybiBoYXNUaGlzID8gZm4uYmluZChyYWN0aXZlKSA6IGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoZm4sIGNvbnRleHQpIHtcbiAgXHRyZXR1cm4gL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkgPyBmbi5iaW5kKGNvbnRleHQpIDogZm47XG4gIH1cblxuICB2YXIgY29uc3RydWN0SG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uc3RydWN0XCIpO1xuICB2YXIgY29uZmlnSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uZmlnXCIpO1xuICB2YXIgaW5pdEhvb2sgPSBuZXcgaG9va3NfSG9va1F1ZXVlKFwiaW5pdFwiKTtcbiAgdmFyIGluaXRpYWxpc2VfX3VpZCA9IDA7XG5cbiAgdmFyIGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgdmFyIGluaXRpYWxpc2UgPSBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UocmFjdGl2ZSkge1xuICBcdHZhciB1c2VyT3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIGVsLCB2aWV3bW9kZWw7XG5cbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdlbGNvbWUoKTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKTtcblxuICBcdC8vIFRPRE8gcmVtb3ZlIHRoaXMsIGV2ZW50dWFsbHlcbiAgXHRkZWZpbmVQcm9wZXJ0eShyYWN0aXZlLCBcImRhdGFcIiwgeyBnZXQ6IGRlcHJlY2F0ZVJhY3RpdmVEYXRhIH0pO1xuXG4gIFx0Ly8gVE9ETyBkb24ndCBhbGxvdyBgb25jb25zdHJ1Y3RgIHdpdGggYG5ldyBSYWN0aXZlKClgLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGl0XG4gIFx0Y29uc3RydWN0SG9vay5maXJlKHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdC8vIEFkZCByZWdpc3RyaWVzXG4gIFx0aW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyYWN0aXZlW25hbWVdID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3JbbmFtZV0gfHwgbnVsbCksIHVzZXJPcHRpb25zW25hbWVdKTtcbiAgXHR9KTtcblxuICBcdC8vIENyZWF0ZSBhIHZpZXdtb2RlbFxuICBcdHZpZXdtb2RlbCA9IG5ldyB2aWV3bW9kZWxfVmlld21vZGVsKHtcbiAgXHRcdGFkYXB0OiBnZXRBZGFwdG9ycyhyYWN0aXZlLCByYWN0aXZlLmFkYXB0LCB1c2VyT3B0aW9ucyksXG4gIFx0XHRkYXRhOiBjdXN0b21fZGF0YS5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGNvbXB1dGVkOiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcHV0ZWQpLCB1c2VyT3B0aW9ucy5jb21wdXRlZCkpLFxuICBcdFx0bWFwcGluZ3M6IG9wdGlvbnMubWFwcGluZ3MsXG4gIFx0XHRyYWN0aXZlOiByYWN0aXZlLFxuICBcdFx0b25jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUocmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyYWN0aXZlLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblxuICBcdC8vIFRoaXMgY2FuJ3QgaGFwcGVuIGVhcmxpZXIsIGJlY2F1c2UgY29tcHV0ZWQgcHJvcGVydGllcyBtYXkgY2FsbCBgcmFjdGl2ZS5nZXQoKWAsIGV0Y1xuICBcdHZpZXdtb2RlbC5pbml0KCk7XG5cbiAgXHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuICBcdGNvbmZpZ19jb25maWcuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHRjb25maWdIb29rLmZpcmUocmFjdGl2ZSk7XG4gIFx0aW5pdEhvb2suYmVnaW4ocmFjdGl2ZSk7XG5cbiAgXHQvLyAvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50IHdpdGggYSBmdW5jdGlvbiBgZGF0YWAgcHJvcGVydHksIGNhbGwgdGhlIGZ1bmN0aW9uXG4gIFx0Ly8gLy8gd2l0aCBgcmFjdGl2ZWAgYXMgY29udGV4dCAodW5sZXNzIHRoZSBjaGlsZCB3YXMgYWxzbyBhIGZ1bmN0aW9uKVxuICBcdC8vIGlmICggdHlwZW9mIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmRhdGEgIT09ICdmdW5jdGlvbicgKSB7XG4gIFx0Ly8gXHR2aWV3bW9kZWwucmVzZXQoIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEuY2FsbCggcmFjdGl2ZSApIHx8IGZhdGFsKCAnYGRhdGFgIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIGRhdGEgb2JqZWN0JyApICk7XG4gIFx0Ly8gfVxuXG4gIFx0Ly8gUmVuZGVyIHZpcnR1YWwgRE9NXG4gIFx0aWYgKHJhY3RpdmUudGVtcGxhdGUpIHtcbiAgXHRcdHZhciBjc3NJZHMgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChvcHRpb25zLmNzc0lkcyB8fCByYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdGNzc0lkcyA9IG9wdGlvbnMuY3NzSWRzID8gb3B0aW9ucy5jc3NJZHMuc2xpY2UoKSA6IFtdO1xuXG4gIFx0XHRcdGlmIChyYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdFx0Y3NzSWRzLnB1c2gocmFjdGl2ZS5jc3NJZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHJhY3RpdmUudGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiByYWN0aXZlLCAvLyBzYXZlcyBkb2luZyBgaWYgKCB0aGlzLnBhcmVudCApIHsgLyouLi4qLyB9YCBsYXRlciBvblxuICBcdFx0XHRjc3NJZHM6IGNzc0lkc1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5pdEhvb2suZW5kKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG4gIFx0aWYgKGVsID0gZ2V0RWxlbWVudChyYWN0aXZlLmVsKSkge1xuICBcdFx0dmFyIHByb21pc2UgPSByYWN0aXZlLnJlbmRlcihlbCwgcmFjdGl2ZS5hcHBlbmQpO1xuXG4gIFx0XHRpZiAoX1JhY3RpdmUuREVCVUdfUFJPTUlTRVMpIHtcbiAgXHRcdFx0cHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJQcm9taXNlIGRlYnVnZ2luZyBpcyBlbmFibGVkLCB0byBoZWxwIHNvbHZlIGVycm9ycyB0aGF0IGhhcHBlbiBhc3luY2hyb25vdXNseS4gU29tZSBicm93c2VycyB3aWxsIGxvZyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zLCBpbiB3aGljaCBjYXNlIHlvdSBjYW4gc2FmZWx5IGRpc2FibGUgcHJvbWlzZSBkZWJ1Z2dpbmc6XFxuICBSYWN0aXZlLkRFQlVHX1BST01JU0VTID0gZmFsc2U7XCIpO1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW4gZXJyb3IgaGFwcGVuZWQgZHVyaW5nIHJlbmRlcmluZ1wiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRcdFx0ZXJyLnN0YWNrICYmIGxvZ0lmRGVidWcoZXJyLnN0YWNrKTtcblxuICBcdFx0XHRcdHRocm93IGVycjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcHJvdG9BZGFwdCwgdXNlck9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQsIG1hZ2ljLCBtb2RpZnlBcnJheXM7XG5cbiAgXHRwcm90b0FkYXB0ID0gcHJvdG9BZGFwdC5tYXAobG9va3VwKTtcbiAgXHRhZGFwdCA9IGVuc3VyZUFycmF5KHVzZXJPcHRpb25zLmFkYXB0KS5tYXAobG9va3VwKTtcblxuICBcdGFkYXB0ID0gaW5pdGlhbGlzZV9fY29tYmluZShwcm90b0FkYXB0LCBhZGFwdCk7XG5cbiAgXHRtYWdpYyA9IFwibWFnaWNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1hZ2ljIDogcmFjdGl2ZS5tYWdpYztcbiAgXHRtb2RpZnlBcnJheXMgPSBcIm1vZGlmeUFycmF5c1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubW9kaWZ5QXJyYXlzIDogcmFjdGl2ZS5tb2RpZnlBcnJheXM7XG5cbiAgXHRpZiAobWFnaWMpIHtcbiAgXHRcdGlmICghZW52aXJvbm1lbnRfX21hZ2ljKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkdldHRlcnMgYW5kIHNldHRlcnMgKG1hZ2ljIG1vZGUpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0XHRhZGFwdC5wdXNoKG1hZ2ljQXJyYXkpO1xuICBcdFx0fVxuXG4gIFx0XHRhZGFwdC5wdXNoKGFkYXB0b3JzX21hZ2ljKTtcbiAgXHR9XG5cbiAgXHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRhZGFwdC5wdXNoKGFycmF5X2luZGV4KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYWRhcHQ7XG5cbiAgXHRmdW5jdGlvbiBsb29rdXAoYWRhcHRvcikge1xuICBcdFx0aWYgKHR5cGVvZiBhZGFwdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFkYXB0b3IgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiYWRhcHRvcnNcIiwgcmFjdGl2ZSwgYWRhcHRvcik7XG5cbiAgXHRcdFx0aWYgKCFhZGFwdG9yKSB7XG4gIFx0XHRcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihhZGFwdG9yLCBcImFkYXB0b3JcIikpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBhZGFwdG9yO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG4gIFx0Ly8gZXhpc3RlZFxuICBcdHJhY3RpdmUuX2d1aWQgPSBcInItXCIgKyBpbml0aWFsaXNlX191aWQrKztcblxuICBcdC8vIGV2ZW50c1xuICBcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuICBcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG4gIFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cbiAgXHQvLyB0d28td2F5IGJpbmRpbmdzXG4gIFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG4gIFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gbm9kZXMgcmVnaXN0cnlcbiAgXHRyYWN0aXZlLm5vZGVzID0ge307XG5cbiAgXHQvLyBsaXZlIHF1ZXJpZXNcbiAgXHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuICBcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cbiAgXHQvLyBib3VuZCBkYXRhIGZ1bmN0aW9uc1xuICBcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zID0gW107XG5cbiAgXHQvLyBvYnNlcnZlcnNcbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMgPSBbXTtcblxuICBcdC8vIHByb3BlcnRpZXMgc3BlY2lmaWMgdG8gaW5saW5lIGNvbXBvbmVudHNcbiAgXHRpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIFx0XHRyYWN0aXZlLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IG51bGw7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlLnBhcmVudC5yb290O1xuXG4gIFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50O1xuICBcdFx0b3B0aW9ucy5jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXG4gIFx0XHQvLyBmb3IgaGFja2FiaWxpdHksIHRoaXMgY291bGQgYmUgYW4gb3BlbiBvcHRpb25cbiAgXHRcdC8vIGZvciBhbnkgcmFjdGl2ZSBpbnN0YW5jZSwgYnV0IGZvciBub3csIGp1c3RcbiAgXHRcdC8vIGZvciBjb21wb25lbnRzIGFuZCBqdXN0IGZvciByYWN0aXZlLi4uXG4gIFx0XHRyYWN0aXZlLl9pbmxpbmVQYXJ0aWFscyA9IG9wdGlvbnMuaW5saW5lUGFydGlhbHM7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmU7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IHJhY3RpdmUuY29udGFpbmVyID0gbnVsbDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVSYWN0aXZlRGF0YSgpIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyBgcmFjdGl2ZS5kYXRhYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIC0geW91IG11c3QgdXNlIHRoZSBgcmFjdGl2ZS5nZXQoKWAgQVBJIGluc3RlYWRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBDb21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIgPSBDb21wbGV4UGFyYW1ldGVyO1xuXG4gIENvbXBsZXhQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpKTtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgQ29tcG9uZW50LCBhdHRyaWJ1dGVzLCB5aWVsZFRlbXBsYXRlLCBwYXJ0aWFscykge1xuICBcdHZhciBpbnN0YW5jZSxcbiAgXHQgICAgcGFyZW50RnJhZ21lbnQsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIGZyYWdtZW50LFxuICBcdCAgICBjb250YWluZXIsXG4gIFx0ICAgIGlubGluZVBhcnRpYWxzID0ge30sXG4gIFx0ICAgIGRhdGEgPSB7fSxcbiAgXHQgICAgbWFwcGluZ3MgPSB7fSxcbiAgXHQgICAgcmVhZHksXG4gIFx0ICAgIHJlc29sdmVycyA9IFtdO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0cmFjdGl2ZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0cGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChpbmxpbmVQYXJ0aWFscywgcGFydGlhbHMpO1xuXG4gIFx0Ly8gTWFrZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSB7ez5jb250ZW50fX0gcGFydGlhbFxuICBcdHBhcnRpYWxzLmNvbnRlbnQgPSB5aWVsZFRlbXBsYXRlIHx8IFtdO1xuXG4gIFx0Ly8gc2V0IGEgZGVmYXVsdCBwYXJ0aWFsIGZvciB5aWVsZHMgd2l0aCBubyBuYW1lXG4gIFx0aW5saW5lUGFydGlhbHNbXCJcIl0gPSBwYXJ0aWFscy5jb250ZW50O1xuXG4gIFx0aWYgKENvbXBvbmVudC5kZWZhdWx0cy5lbCkge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgPCVzLz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWRcIiwgY29tcG9uZW50Lm5hbWUpO1xuICBcdH1cblxuICBcdC8vIGZpbmQgY29udGFpbmVyXG4gIFx0ZnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmIChmcmFnbWVudC5vd25lci50eXBlID09PSBZSUVMREVSKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGZyYWdtZW50Lm93bmVyLmNvbnRhaW5lcjtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdH1cblxuICBcdC8vIGVhY2ggYXR0cmlidXRlIHJlcHJlc2VudHMgZWl0aGVyIGEpIGRhdGEgb3IgYikgYSBtYXBwaW5nXG4gIFx0aWYgKGF0dHJpYnV0ZXMpIHtcbiAgXHRcdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldLFxuICBcdFx0XHQgICAgcGFyc2VkLFxuICBcdFx0XHQgICAgcmVzb2x2ZXI7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBpdCdzIHN0YXRpYyBkYXRhXG4gIFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogYXR0cmlidXRlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGF0dHJpYnV0ZSA9PT0gMCkge1xuICBcdFx0XHRcdC8vIGl0IGhhZCBubyAnPScsIHNvIHdlJ2xsIGNhbGwgaXQgdHJ1ZVxuICBcdFx0XHRcdGRhdGFba2V5XSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyByZXByZXNlbnRzIGR5bmFtaWMgZGF0YVxuICBcdFx0XHRcdGlmIChpc1NpbmdsZUludGVycG9sYXRvcihhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0XHRtYXBwaW5nc1trZXldID0ge1xuICBcdFx0XHRcdFx0XHRvcmlnaW46IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aDogdW5kZWZpbmVkXG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgYXR0cmlidXRlWzBdLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIGtleXBhdGgudmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGtleXBhdGgudmFsdWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gZXJyci4uLi4gd291bGQgYmUgYmV0dGVyIGlmIHdlIGRpZG4ndCBoYXZlIHRvIGRvIHRoaXNcbiAgXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBtYXBwaW5nc1trZXldO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnZpZXdtb2RlbC5tYXBwaW5nc1trZXldLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdC8vIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gIFx0XHRcdFx0XHRcdFx0XHRtYXBwaW5nc1trZXldLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gbmV3IGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIGF0dHJpYnV0ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIHZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXNvbHZlcnMucHVzaChyZXNvbHZlcik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXJtIHd1dFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5zdGFuY2UgPSBjcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbiAgXHRpbml0aWFsaXNlKGluc3RhbmNlLCB7XG4gIFx0XHRlbDogbnVsbCxcbiAgXHRcdGFwcGVuZDogdHJ1ZSxcbiAgXHRcdGRhdGE6IGRhdGEsXG4gIFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG4gIFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG4gIFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuICBcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG4gIFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdFxuICBcdH0sIHtcbiAgXHRcdHBhcmVudDogcmFjdGl2ZSxcbiAgXHRcdGNvbXBvbmVudDogY29tcG9uZW50LFxuICBcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG4gIFx0XHRtYXBwaW5nczogbWFwcGluZ3MsXG4gIFx0XHRpbmxpbmVQYXJ0aWFsczogaW5saW5lUGFydGlhbHMsXG4gIFx0XHRjc3NJZHM6IHBhcmVudEZyYWdtZW50LmNzc0lkc1xuICBcdH0pO1xuXG4gIFx0cmVhZHkgPSB0cnVlO1xuICBcdGNvbXBvbmVudC5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XG5cbiAgXHRyZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRpZiAodGVtcGxhdGUucikge1xuICBcdFx0cmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yLCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS54KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZS54LCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5yeCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnJ4LCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc29sdmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW5nbGVJbnRlcnBvbGF0b3IodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWzBdLnQgPT09IElOVEVSUE9MQVRPUjtcbiAgfVxuXG4gIC8vIFRPRE8gaG93IHNob3VsZCBldmVudCBhcmd1bWVudHMgYmUgaGFuZGxlZD8gZS5nLlxuICAvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG4gIC8vIFRoZSBldmVudCAnYmFyJyB3aWxsIGJlIGZpcmVkIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2VcbiAgLy8gd2hlbiAnZm9vJyBmaXJlcyBvbiB0aGUgY2hpbGQsIGJ1dCB0aGUgMSwyLDMgYXJndW1lbnRzXG4gIC8vIHdpbGwgYmUgbG9zdFxuXG4gIHZhciBpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyA9IHByb3BhZ2F0ZUV2ZW50cztcblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudHMoY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0dmFyIGV2ZW50TmFtZTtcblxuICBcdGZvciAoZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHRcdGlmIChldmVudHNEZXNjcmlwdG9yLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgXHRcdFx0cHJvcGFnYXRlRXZlbnQoY29tcG9uZW50Lmluc3RhbmNlLCBjb21wb25lbnQucm9vdCwgZXZlbnROYW1lLCBldmVudHNEZXNjcmlwdG9yW2V2ZW50TmFtZV0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50KGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lKSB7XG4gIFx0aWYgKHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZmF0YWwoXCJDb21wb25lbnRzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2ltcGxlIGV2ZW50cyAtIHlvdSBjYW5ub3QgaW5jbHVkZSBhcmd1bWVudHMuIFNvcnJ5IVwiKTtcbiAgXHR9XG5cbiAgXHRjaGlsZEluc3RhbmNlLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXG4gIFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0ubm9kZSkge1xuICBcdFx0XHRldmVudCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKGFyZ3VtZW50cyk7XG4gIFx0XHR9XG5cbiAgXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIFx0XHRzaGFyZWRfZmlyZUV2ZW50KHBhcmVudEluc3RhbmNlLCBwcm94eUV2ZW50TmFtZSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG5cbiAgXHRcdC8vIGNhbmNlbCBidWJibGluZ1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gIFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblxuICBcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcbiAgXHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0aWYgKHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5LnB1c2goY29tcG9uZW50Lmluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2luaXQgPSBDb21wb25lbnQkaW5pdDtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGluaXQob3B0aW9ucywgQ29tcG9uZW50KSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290O1xuXG4gIFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICBcdH1cblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByb290O1xuICBcdHRoaXMudHlwZSA9IENPTVBPTkVOVDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG4gIFx0dGhpcy55aWVsZGVycyA9IHt9O1xuICBcdHRoaXMucmVzb2x2ZXJzID0gW107XG5cbiAgXHRjcmVhdGVJbnN0YW5jZSh0aGlzLCBDb21wb25lbnQsIG9wdGlvbnMudGVtcGxhdGUuYSwgb3B0aW9ucy50ZW1wbGF0ZS5mLCBvcHRpb25zLnRlbXBsYXRlLnApO1xuICBcdGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzKHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudik7XG5cbiAgXHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUudDAgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MSB8fCBvcHRpb25zLnRlbXBsYXRlLnQyIHx8IG9wdGlvbnMudGVtcGxhdGUubykge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgXFxcImludHJvXFxcIiwgXFxcIm91dHJvXFxcIiBhbmQgXFxcImRlY29yYXRvclxcXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzXCIsIHsgcmFjdGl2ZTogdGhpcy5pbnN0YW5jZSB9KTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kID0gQ29tcG9uZW50JHJlYmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgcXVlcnk7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRmb3IgKHZhciBrIGluIHRoaXMueWllbGRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLnlpZWxkZXJzW2tdWzBdKSB7XG4gIFx0XHRcdHJlYmluZCh0aGlzLnlpZWxkZXJzW2tdWzBdKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgdGhpcy5uYW1lXSkge1xuICBcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh4KSB7XG4gIFx0XHR4LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBDb21wb25lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdGluc3RhbmNlLnJlbmRlcih0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IENvbXBvbmVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCA9IENvbXBvbmVudCR1bmJpbmQ7XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXModGhpcyk7XG5cbiAgXHRpbnN0YW5jZS5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuICBcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0aWYgKGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UpO1xuICBcdH1cblxuICBcdENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2suZmlyZShpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoY29tcG9uZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblxuICBcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkuX3JlbW92ZShjb21wb25lbnQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gQ29tcG9uZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcbiAgXHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIENvbnN0cnVjdG9yKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMsIENvbnN0cnVjdG9yKTtcbiAgfTtcblxuICBDb21wb25lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGluaXQ6IENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIHZhciBDb21tZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBDT01NRU5UO1xuICBcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG4gIH07XG5cbiAgQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy52YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IS0tXCIgKyB0aGlzLnZhbHVlICsgXCItLT5cIjtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfQ29tbWVudCA9IENvbW1lbnQ7XG5cbiAgdmFyIFlpZWxkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBjb250YWluZXIsIGNvbXBvbmVudDtcblxuICBcdHRoaXMudHlwZSA9IFlJRUxERVI7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbnRhaW5lci5jb21wb25lbnQ7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgXHR0aGlzLmNvbnRhaW5lckZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLm4gfHwgXCJcIjtcblxuICBcdHZhciB0ZW1wbGF0ZSA9IGNvbnRhaW5lci5faW5saW5lUGFydGlhbHNbbmFtZV07XG5cbiAgXHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgeyByYWN0aXZlOiBvcHRpb25zLnJvb3QgfSk7XG4gIFx0XHR0ZW1wbGF0ZSA9IFtdO1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHJvb3Q6IGNvbnRhaW5lci5wYXJlbnQsXG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRwRWxlbWVudDogdGhpcy5jb250YWluZXJGcmFnbWVudC5wRWxlbWVudFxuICBcdH0pO1xuXG4gIFx0Ly8gZXZlbiB0aG91Z2ggb25seSBvbmUgeWllbGRlciBpcyBhbGxvd2VkLCB3ZSBuZWVkIHRvIGhhdmUgYW4gYXJyYXkgb2YgdGhlbVxuICBcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICBcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuICBcdGlmICghaXNBcnJheShjb21wb25lbnQueWllbGRlcnNbbmFtZV0pKSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0gPSBbdGhpc107XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5wdXNoKHRoaXMpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZFwiICsgKG5hbWUgPyBcIiBcIiArIG5hbWUgOiBcIlwiKSArIFwifX0gZGVjbGFyYXRpb24gYXQgYSB0aW1lXCIpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9O1xuXG4gIFlpZWxkZXIucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyRnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmNvbXBvbmVudC55aWVsZGVyc1t0aGlzLm5hbWVdLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfWWllbGRlciA9IFlpZWxkZXI7XG5cbiAgdmFyIERvY3R5cGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuZGVjbGFyYXRpb24gPSBvcHRpb25zLnRlbXBsYXRlLmE7XG4gIH07XG5cbiAgRG9jdHlwZS5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogbm9vcCxcbiAgXHRyZW5kZXI6IG5vb3AsXG4gIFx0dW5yZW5kZXI6IG5vb3AsXG4gIFx0dGVhcmRvd246IG5vb3AsXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy5kZWNsYXJhdGlvbiArIFwiPlwiO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfRG9jdHlwZSA9IERvY3R5cGU7XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9pbml0ID0gRnJhZ21lbnQkaW5pdDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7IC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG4gIFx0dGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gIFx0dGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzID0gW107XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSBcImNzc0lkc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNzc0lkcyA6IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbDtcblxuICBcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcChmdW5jdGlvbiAodGVtcGxhdGUsIGkpIHtcbiAgXHRcdHJldHVybiBjcmVhdGVJdGVtKHtcbiAgXHRcdFx0cGFyZW50RnJhZ21lbnQ6IF90aGlzLFxuICBcdFx0XHRwRWxlbWVudDogb3B0aW9ucy5wRWxlbWVudCxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRpbmRleDogaVxuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG4gIFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXG4gIFx0dGhpcy5ib3VuZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJdGVtKG9wdGlvbnMpIHtcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgaXRlbXNfVGV4dChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRzd2l0Y2ggKG9wdGlvbnMudGVtcGxhdGUudCkge1xuICBcdFx0Y2FzZSBZSUVMREVSOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1lpZWxkZXIob3B0aW9ucyk7XG4gIFx0XHRjYXNlIElOVEVSUE9MQVRPUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19JbnRlcnBvbGF0b3Iob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFNFQ1RJT046XG4gIFx0XHRcdHJldHVybiBuZXcgX1NlY3Rpb24ob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFRSSVBMRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfVHJpcGxlKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBFTEVNRU5UOlxuICBcdFx0XHR2YXIgY29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9IENvbXBvbmVudF9nZXRDb21wb25lbnQob3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5ldyBfQ29tcG9uZW50KG9wdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gbmV3IF9FbGVtZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBQQVJUSUFMOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9QYXJ0aWFsKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBDT01NRU5UOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0NvbW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIERPQ1RZUEU6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfRG9jdHlwZShvcHRpb25zKTtcblxuICBcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCA9IEZyYWdtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcblxuICBcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdGlmICghdGhpcy5vd25lciB8fCB0aGlzLm93bmVyLmhhc0NvbnRleHQpIHtcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgodGhpcywgXCJjb250ZXh0XCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aWYgKGl0ZW0ucmViaW5kKSB7XG4gIFx0XHRcdGl0ZW0ucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBGcmFnbWVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbMF0ucmVuZGVyKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZChpdGVtLnJlbmRlcigpKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gRnJhZ21lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0aWYgKCF0aGlzLml0ZW1zKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoZXNjYXBlID8gdG9Fc2NhcGVkU3RyaW5nIDogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZykuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0VzY2FwZWRTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBGcmFnbWVudCR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuICBcdGlmICghdGhpcy5ib3VuZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaCh1bmJpbmRJdGVtKTtcbiAgXHR0aGlzLmJvdW5kID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmRJdGVtKGl0ZW0pIHtcbiAgXHRpZiAoaXRlbS51bmJpbmQpIHtcbiAgXHRcdGl0ZW0udW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEZyYWdtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgXHRcdHJldHVybiBpLnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdH0pO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IHByb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBwcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBcmdzTGlzdDogZ2V0QXJnc0xpc3QsXG4gIFx0Z2V0Tm9kZTogZ2V0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogcHJvdG90eXBlX2dldFZhbHVlLFxuICBcdGluaXQ6IEZyYWdtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlmIChpZHhzLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgXHRcdFx0aWR4cy5wdXNoKGlkeCk7XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRyZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlkeHMuc3BsaWNlKGlkeHMuaW5kZXhPZihpZHgpLCAxKTtcbiAgXHR9LFxuICBcdHVucmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgdmlydHVhbGRvbV9GcmFnbWVudCA9IEZyYWdtZW50O1xuXG4gIHZhciBwcm90b3R5cGVfcmVzZXQgPSBSYWN0aXZlJHJlc2V0O1xuICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXCJ0ZW1wbGF0ZVwiLCBcInBhcnRpYWxzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJldmVudHNcIl0sXG4gICAgICByZXNldEhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlc2V0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KGRhdGEpIHtcbiAgXHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cbiAgXHRkYXRhID0gZGF0YSB8fCB7fTtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuICBcdGlmICgod3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbXCJcIl0pICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnJlc2V0KGRhdGEpID09PSBmYWxzZSkge1xuICBcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHR9XG5cbiAgXHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcbiAgXHRjaGFuZ2VzID0gY29uZmlnX2NvbmZpZy5yZXNldCh0aGlzKTtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2hvdWxkUmVyZW5kZXIuaW5kZXhPZihjaGFuZ2VzW2ldKSA+IC0xKSB7XG4gIFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlcmVuZGVyKSB7XG4gIFx0XHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcblxuICBcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0XHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fVxuXG4gIFx0cmVzZXRIb29rLmZpcmUodGhpcywgZGF0YSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciByZXNldFBhcnRpYWwgPSBmdW5jdGlvbiAobmFtZSwgcGFydGlhbCkge1xuICBcdHZhciBwcm9taXNlLFxuICBcdCAgICBjb2xsZWN0aW9uID0gW107XG5cbiAgXHRmdW5jdGlvbiBjb2xsZWN0KHNvdXJjZSwgZGVzdCwgcmFjdGl2ZSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBhbmQgaXQgaGFzIGl0cyBvd24gcGFydGlhbCwgYmFpbFxuICBcdFx0aWYgKHJhY3RpdmUgJiYgcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSkgcmV0dXJuO1xuXG4gIFx0XHRzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHQvLyBxdWV1ZSB0byByZXJlbmRlciBpZiB0aGUgaXRlbSBpcyBhIHBhcnRpYWwgYW5kIHRoZSBjdXJyZW50IG5hbWUgbWF0Y2hlc1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBQQVJUSUFMICYmIGl0ZW0uZ2V0UGFydGlhbE5hbWUoKSA9PT0gbmFtZSkge1xuICBcdFx0XHRcdGRlc3QucHVzaChpdGVtKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIGl0IGhhcyBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRpZiAoaXRlbS5mcmFnbWVudCkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudC5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBoYXMgZnJhZ21lbnRzXG4gIFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uZnJhZ21lbnRzKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudHMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgaXRzZWxmIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGlzQXJyYXkoaXRlbS5pdGVtcykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgYSBjb21wb25lbnQsIHN0ZXAgaW4gYW5kIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gQ09NUE9ORU5UICYmIGl0ZW0uaW5zdGFuY2UpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaW5zdGFuY2UuZnJhZ21lbnQuaXRlbXMsIGRlc3QsIGl0ZW0uaW5zdGFuY2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgdGhlIGl0ZW0gaXMgYW4gZWxlbWVudCwgcHJvY2VzcyBpdHMgYXR0cmlidXRlcyB0b29cbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gRUxFTUVOVCkge1xuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uYXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5hdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Y29sbGVjdCh0aGlzLmZyYWdtZW50Lml0ZW1zLCBjb2xsZWN0aW9uKTtcbiAgXHR0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aXRlbS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgXHRcdGl0ZW0uc2V0VmFsdWUobmFtZSk7XG4gIFx0fSk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2VcbiAgLy8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuICAvLyBjb3VsZCBiZSBhY2hpZXZlZCB3aXRoIHVucmVuZGVyLXJlc2V0VGVtcGxhdGUtcmVuZGVyLiBBbHNvLCBpdCBzaG91bGRcbiAgLy8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXG4gIHZhciByZXNldFRlbXBsYXRlID0gUmFjdGl2ZSRyZXNldFRlbXBsYXRlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgXHR2YXIgdHJhbnNpdGlvbnNFbmFibGVkLCBjb21wb25lbnQ7XG5cbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZS5pbml0KG51bGwsIHRoaXMsIHsgdGVtcGxhdGU6IHRlbXBsYXRlIH0pO1xuXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblxuICBcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0cm9vdDogdGhpcyxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcbiAgfVxuXG4gIHZhciByZXZlcnNlID0gbWFrZUFycmF5TWV0aG9kKFwicmV2ZXJzZVwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfc2V0ID0gUmFjdGl2ZSRzZXQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbWFwLCBwcm9taXNlO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNldCBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0ZWxzZSB7XG4gIFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQocmFjdGl2ZSwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBzaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInNoaWZ0XCIpO1xuXG4gIHZhciBwcm90b3R5cGVfc29ydCA9IG1ha2VBcnJheU1ldGhvZChcInNvcnRcIik7XG5cbiAgdmFyIHNwbGljZSA9IG1ha2VBcnJheU1ldGhvZChcInNwbGljZVwiKTtcblxuICB2YXIgc3VidHJhY3QgPSBSYWN0aXZlJHN1YnRyYWN0O1xuICBmdW5jdGlvbiBSYWN0aXZlJHN1YnRyYWN0KGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kKTtcbiAgfVxuXG4gIC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG4gIC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duID0gUmFjdGl2ZSR0ZWFyZG93bjtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHR0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuXG4gIFx0UmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vay5maXJlKHRoaXMpO1xuXG4gIFx0dGhpcy5fYm91bmRGdW5jdGlvbnMuZm9yRWFjaChkZWxldGVGdW5jdGlvbkNvcHkpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGdW5jdGlvbkNvcHkoYm91bmQpIHtcbiAgXHRkZWxldGUgYm91bmQuZm5bYm91bmQucHJvcF07XG4gIH1cblxuICB2YXIgdG9nZ2xlID0gUmFjdGl2ZSR0b2dnbGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKGtleXBhdGgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGJhZEFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0dmFyIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHRoaXMsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9ICFfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiB0aGlzLnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgIXRoaXMuZ2V0KGtleXBhdGgpKTtcbiAgfVxuXG4gIHZhciB0b0hUTUwgPSBSYWN0aXZlJHRvSFRNTDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHRvSFRNTCgpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlciA9IFJhY3RpdmUkdW5yZW5kZXI7XG4gIHZhciB1bnJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVucmVuZGVyXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuICBcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcInJhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0XHRyZXR1cm4gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcbiAgXHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcbiAgXHRzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXG4gIFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG4gIFx0d2hpbGUgKHRoaXMuX2FuaW1hdGlvbnNbMF0pIHtcbiAgXHRcdHRoaXMuX2FuaW1hdGlvbnNbMF0uc3RvcCgpOyAvLyBpdCB3aWxsIHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgaW5kZXhcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuXG4gIFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcblxuICBcdHVucmVuZGVySG9vay5maXJlKHRoaXMpO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgdW5zaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInVuc2hpZnRcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSA9IFJhY3RpdmUkdXBkYXRlO1xuICB2YXIgdXBkYXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwidXBkYXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKSB8fCByb290S2V5cGF0aDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dXBkYXRlSG9vay5maXJlKHRoaXMsIGtleXBhdGgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZU1vZGVsID0gUmFjdGl2ZSR1cGRhdGVNb2RlbDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKGtleXBhdGgsIGNhc2NhZGUpIHtcbiAgXHR2YXIgdmFsdWVzLCBrZXksIGJpbmRpbmdzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcInN0cmluZ1wiICYmICFjYXNjYWRlKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleXBhdGhdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90d293YXlCaW5kaW5ncykge1xuICBcdFx0XHRpZiAoIWtleXBhdGggfHwgZ2V0S2V5cGF0aChrZXkpLmVxdWFsc09yU3RhcnRzV2l0aChrZXlwYXRoKSkge1xuICBcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoLmFwcGx5KGJpbmRpbmdzLCB0aGlzLl90d293YXlCaW5kaW5nc1trZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHZhbHVlcyA9IGNvbnNvbGlkYXRlKHRoaXMsIGJpbmRpbmdzKTtcbiAgXHRyZXR1cm4gdGhpcy5zZXQodmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnNvbGlkYXRlKHJhY3RpdmUsIGJpbmRpbmdzKSB7XG4gIFx0dmFyIHZhbHVlcyA9IHt9LFxuICBcdCAgICBjaGVja2JveEdyb3VwcyA9IFtdO1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICBcdFx0dmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdFx0aWYgKGIucmFkaW9OYW1lICYmICFiLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cbiAgXHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3RcbiAgXHRcdGlmIChiLmNoZWNrYm94TmFtZSkge1xuICBcdFx0XHRpZiAoIWNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdICYmICFiLmNoYW5nZWQoKSkge1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goYi5rZXlwYXRoKTtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSA9IGI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdG9sZFZhbHVlID0gYi5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRuZXdWYWx1ZSA9IGIuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKGFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0dmFsdWVzW2Iua2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG4gIFx0aWYgKGNoZWNrYm94R3JvdXBzLmxlbmd0aCkge1xuICBcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1trZXlwYXRoLnN0cl07IC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuICBcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblxuICBcdFx0XHRpZiAoIWFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IHtcbiAgXHRhZGQ6IHByb3RvdHlwZV9hZGQsXG4gIFx0YW5pbWF0ZTogcHJvdG90eXBlX2FuaW1hdGUsXG4gIFx0ZGV0YWNoOiBwcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IHByb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IHByb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZENvbnRhaW5lcjogZmluZENvbnRhaW5lcixcbiAgXHRmaW5kUGFyZW50OiBmaW5kUGFyZW50LFxuICBcdGZpcmU6IHByb3RvdHlwZV9maXJlLFxuICBcdGdldDogcHJvdG90eXBlX2dldCxcbiAgXHRpbnNlcnQ6IGluc2VydCxcbiAgXHRtZXJnZTogcHJvdG90eXBlX21lcmdlLFxuICBcdG9ic2VydmU6IG9ic2VydmUsXG4gIFx0b2JzZXJ2ZU9uY2U6IG9ic2VydmVPbmNlLFxuICBcdG9mZjogb2ZmLFxuICBcdG9uOiBvbixcbiAgXHRvbmNlOiBvbmNlLFxuICBcdHBvcDogcG9wLFxuICBcdHB1c2g6IHB1c2gsXG4gIFx0cmVuZGVyOiBwcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc2V0OiBwcm90b3R5cGVfcmVzZXQsXG4gIFx0cmVzZXRQYXJ0aWFsOiByZXNldFBhcnRpYWwsXG4gIFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcbiAgXHRyZXZlcnNlOiByZXZlcnNlLFxuICBcdHNldDogUmFjdGl2ZV9wcm90b3R5cGVfc2V0LFxuICBcdHNoaWZ0OiBzaGlmdCxcbiAgXHRzb3J0OiBwcm90b3R5cGVfc29ydCxcbiAgXHRzcGxpY2U6IHNwbGljZSxcbiAgXHRzdWJ0cmFjdDogc3VidHJhY3QsXG4gIFx0dGVhcmRvd246IFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHRvZ2dsZTogdG9nZ2xlLFxuICBcdHRvSFRNTDogdG9IVE1MLFxuICBcdHRvSHRtbDogdG9IVE1MLFxuICBcdHVucmVuZGVyOiBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1bnNoaWZ0OiB1bnNoaWZ0LFxuICBcdHVwZGF0ZTogUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlLFxuICBcdHVwZGF0ZU1vZGVsOiBwcm90b3R5cGVfdXBkYXRlTW9kZWxcbiAgfTtcblxuICB2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSkge1xuXG4gIFx0aWYgKGZvcmNlIHx8IG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkpIHtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdFx0ICAgIF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gXCJmdW5jdGlvblwiICYmIC9fc3VwZXIvLnRlc3QobWV0aG9kKTtcbiAgfVxuXG4gIHZhciB1bndyYXBFeHRlbmRlZCA9IHVud3JhcDtcblxuICBmdW5jdGlvbiB1bndyYXAoQ2hpbGQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIFx0d2hpbGUgKENoaWxkKSB7XG4gIFx0XHRhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKTtcbiAgXHRcdGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucyk7XG5cbiAgXHRcdGlmIChDaGlsZC5fUGFyZW50ICE9PSBfUmFjdGl2ZSkge1xuICBcdFx0XHRDaGlsZCA9IENoaWxkLl9QYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDaGlsZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdGFkZFJlZ2lzdHJ5KHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KHRhcmdldCwgb3B0aW9ucywgbmFtZSkge1xuICBcdHZhciByZWdpc3RyeSxcbiAgXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFtuYW1lXSk7XG5cbiAgXHRpZiAoIWtleXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCEocmVnaXN0cnkgPSBvcHRpb25zW25hbWVdKSkge1xuICBcdFx0cmVnaXN0cnkgPSBvcHRpb25zW25hbWVdID0ge307XG4gIFx0fVxuXG4gIFx0a2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuICEoa2V5IGluIHJlZ2lzdHJ5KTtcbiAgXHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiByZWdpc3RyeVtrZXldID0gdGFyZ2V0W25hbWVdW2tleV07XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRPYmplY3Qua2V5cyhDaGlsZC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCJjb21wdXRlZFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlW2tleV07XG5cbiAgXHRcdGlmICghKGtleSBpbiBvcHRpb25zKSkge1xuICBcdFx0XHRvcHRpb25zW2tleV0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBpdCBhIHdyYXBwZWQgZnVuY3Rpb24/XG4gIFx0XHRlbHNlIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9uc1trZXldLl9tZXRob2QpIHtcblxuICBcdFx0XHR2YXIgcmVzdWx0ID0gdW5kZWZpbmVkLFxuICBcdFx0XHQgICAgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG4gIFx0XHRcdHJlc3VsdCA9IHdyYXBNZXRob2Qob3B0aW9uc1trZXldLl9tZXRob2QsIHZhbHVlKTtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0b3B0aW9uc1trZXldID0gcmVzdWx0O1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIF9leHRlbmQgPSBfZXh0ZW5kX19leHRlbmQ7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZF9fZXh0ZW5kKCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRvcHRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBleHRlbmRPbmUodGhpcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBvcHRpb25zLnJlZHVjZShleHRlbmRPbmUsIHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE9uZShQYXJlbnQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgXHR2YXIgQ2hpbGQsIHByb3RvO1xuXG4gIFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLi4uXG4gIFx0Ly9cbiAgXHQvLyAgIHZhciBIdW1hbiA9IFJhY3RpdmUuZXh0ZW5kKC4uLiksIFNwaWRlciA9IFJhY3RpdmUuZXh0ZW5kKC4uLik7XG4gIFx0Ly8gICB2YXIgU3BpZGVybWFuID0gSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKTtcbiAgXHQvL1xuICBcdC8vIC4uLmluaGVyaXQgcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG4gIFx0aWYgKG9wdGlvbnMucHJvdG90eXBlIGluc3RhbmNlb2YgX1JhY3RpdmUpIHtcbiAgXHRcdG9wdGlvbnMgPSB1bndyYXBFeHRlbmRlZChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hpbGQpKSByZXR1cm4gbmV3IENoaWxkKG9wdGlvbnMpO1xuICBcdFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0cHJvdG8gPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICBcdC8vIFN0YXRpYyBwcm9wZXJ0aWVzXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhDaGlsZCwge1xuICBcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFx0XHRkZWZhdWx0czogeyB2YWx1ZTogcHJvdG8gfSxcblxuICBcdFx0Ly8gZXh0ZW5kYWJsZVxuICBcdFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kX19leHRlbmQsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSxcblxuICBcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICBcdFx0X1BhcmVudDogeyB2YWx1ZTogUGFyZW50IH1cbiAgXHR9KTtcblxuICBcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG4gIFx0Y29uZmlnX2NvbmZpZy5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRjdXN0b21fZGF0YS5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wdXRlZCkge1xuICBcdFx0cHJvdG8uY29tcHV0ZWQgPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUoUGFyZW50LnByb3RvdHlwZS5jb21wdXRlZCksIG9wdGlvbnMuY29tcHV0ZWQpO1xuICBcdH1cblxuICBcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gIFx0cmV0dXJuIENoaWxkO1xuICB9XG5cbiAgdmFyIGdldE5vZGVJbmZvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHR2YXIgaW5mbyA9IHt9LFxuICBcdCAgICBwcml2LFxuICBcdCAgICBpbmRpY2VzO1xuXG4gIFx0aWYgKCFub2RlIHx8ICEocHJpdiA9IG5vZGUuX3JhY3RpdmUpKSB7XG4gIFx0XHRyZXR1cm4gaW5mbztcbiAgXHR9XG5cbiAgXHRpbmZvLnJhY3RpdmUgPSBwcml2LnJvb3Q7XG4gIFx0aW5mby5rZXlwYXRoID0gcHJpdi5rZXlwYXRoLnN0cjtcbiAgXHRpbmZvLmluZGV4ID0ge307XG5cbiAgXHQvLyBmaW5kIGFsbCBpbmRleCByZWZlcmVuY2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKHByaXYucHJveHkucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmZvLmluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gaW5mbztcbiAgfTtcblxuICB2YXIgUmFjdGl2ZSwgcHJvcGVydGllcztcblxuICAvLyBNYWluIFJhY3RpdmUgcmVxdWlyZWQgb2JqZWN0XG4gIFJhY3RpdmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYWN0aXZlKSkgcmV0dXJuIG5ldyBSYWN0aXZlKG9wdGlvbnMpO1xuICBcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIHByb3BlcnRpZXMgPSB7XG5cbiAgXHQvLyBkZWJ1ZyBmbGFnXG4gIFx0REVCVUc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG4gIFx0REVCVUdfUFJPTUlTRVM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG5cbiAgXHQvLyBzdGF0aWMgbWV0aG9kczpcbiAgXHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmQgfSxcbiAgXHRnZXROb2RlSW5mbzogeyB2YWx1ZTogZ2V0Tm9kZUluZm8gfSxcbiAgXHRwYXJzZTogeyB2YWx1ZTogX3BhcnNlIH0sXG5cbiAgXHQvLyBOYW1lc3BhY2VkIGNvbnN0cnVjdG9yc1xuICBcdFByb21pc2U6IHsgdmFsdWU6IHV0aWxzX1Byb21pc2UgfSxcblxuICBcdC8vIHN1cHBvcnRcbiAgXHRzdmc6IHsgdmFsdWU6IHN2ZyB9LFxuICBcdG1hZ2ljOiB7IHZhbHVlOiBlbnZpcm9ubWVudF9fbWFnaWMgfSxcblxuICBcdC8vIHZlcnNpb25cbiAgXHRWRVJTSU9OOiB7IHZhbHVlOiBcIjAuNy4zXCIgfSxcblxuICBcdC8vIFBsdWdpbnNcbiAgXHRhZGFwdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0Y29tcG9uZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZGVjb3JhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZWFzaW5nOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2Vhc2luZyB9LFxuICBcdGV2ZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0aW50ZXJwb2xhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19pbnRlcnBvbGF0b3JzIH0sXG4gIFx0cGFydGlhbHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdHRyYW5zaXRpb25zOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfVxuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzKFJhY3RpdmUsIHByb3BlcnRpZXMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlID0gdXRpbHNfb2JqZWN0X19leHRlbmQocHJvdG90eXBlLCBjb25maWdfZGVmYXVsdHMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblxuICAvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgUmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXG4gIC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG4gIC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcbiAgLy8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuICAvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG4gIHZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcblxuICBpZiAodHlwZW9mIERhdGUubm93ICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTikge1xuICBcdHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIGF0dGVtcHRpbmcgdG8gdXNlIFJhY3RpdmUuanMgaW4gYW4gb2xkZXIgYnJvd3Nlci4gWW91J2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgJ2xlZ2FjeSBidWlsZHMnIGluIG9yZGVyIHRvIGNvbnRpbnVlIC0gc2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L2xlZ2FjeS1idWlsZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG5cbiAgdmFyIF9SYWN0aXZlID0gUmFjdGl2ZTtcblxuICByZXR1cm4gX1JhY3RpdmU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY3RpdmUuanMubWFwXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwickgxSlBHXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9yYWN0aXZlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHJhY3RpdmUgPSByZXF1aXJlKCdyYWN0aXZlJyk7XG52YXIgZmlyZWJhc2UgPSByZXF1aXJlKCdmaXJlYmFzZScpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBjb29raWUgPSByZXF1aXJlKCdqcy1jb29raWUnKTtcblxudmFyIGNvbmZpZyA9IHtcbiAgICBhcGlLZXk6IFwiQUl6YVN5Q002UUxsUmpRZmtSU2ZHX2xzaTN6TlMycUJHY2NZTGh3XCIsXG4gICAgYXV0aERvbWFpbjogXCJjaGF0YXBwLTUzMDg5LmZpcmViYXNlYXBwLmNvbVwiLFxuICAgIGRhdGFiYXNlVVJMOiBcImh0dHBzOi8vY2hhdGFwcC01MzA4OS5maXJlYmFzZWlvLmNvbVwiLFxuICAgIHN0b3JhZ2VCdWNrZXQ6IFwiY2hhdGFwcC01MzA4OS5hcHBzcG90LmNvbVwiLFxufTtcbmZpcmViYXNlLmluaXRpYWxpemVBcHAoY29uZmlnKTtcblxudmFyIGNoYXRSZWYgPSBmaXJlYmFzZS5kYXRhYmFzZSgpLnJlZigpO1xuXG5nbG9iYWwuZmIgPSBmaXJlYmFzZTtcbmdsb2JhbC5jUmVmID0gY2hhdFJlZjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSZWYocmVmbm8pIHtcbiAgICByZXR1cm4gZmlyZWJhc2UuZGF0YWJhc2UoKS5yZWYocmVmbm8pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0S2V5KG1lc3NhZ2UpIHtcbiAgICBjaGF0UmVmLmxpbWl0VG9MYXN0KDEpLm9uY2UoXG4gICAgICAgICdjaGlsZF9hZGRlZCcsIGZ1bmN0aW9uKHNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgbmV3UmVmID0gcGFyc2VJbnQoc25hcHNob3Qua2V5LCAxMCkgKyAxO1xuICAgICAgICAgICAgdmFyIHJlZiA9IGdlbmVyYXRlUmVmKG5ld1JlZik7XG4gICAgICAgICAgICBhZGRNZXNzYWdlKHJlZiwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5mdW5jdGlvbiBhZGRNZXNzYWdlKHJlZiwgbWVzc2FnZSkge1xuICAgIHJlZi50cmFuc2FjdGlvbihmdW5jdGlvbiAobWVzc2FnZVBvcykge1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlUG9zKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VQb3MpIHsgIC8vIG1lc3NhZ2UgZXhpc3RzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZmFpbCwgaW5jcmVtZW50aW5nIGluZGV4Jyk7XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXggPSBwYXJzZUludChtZXNzYWdlUG9zLmtleSwgMTApICsgMTtcbiAgICAgICAgICAgIHZhciBuZXdSZWYgPSBnZW5lcmF0ZVJlZihuZXdJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VzcycpO1xuICAgICAgICAgICAgcmVmLnNldChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5NZXNzYWdlKG1lc3NhZ2UsIHRpbWUsIHVzZXJuYW1lKSB7XG4gICByZXR1cm4ge1xuICAgICAgIG1lc3NhZ2UsIHRpbWUsIHVzZXJuYW1lXG4gICB9O1xufVxuXG52YXIgbXNnID0gZ2VuTWVzc2FnZSgndGVzdG1zZycsICcxMTExJywgJ2VzJyk7XG5nZXRMYXN0S2V5KG1zZyk7XG5nbG9iYWwubXNnID0gbXNnO1xuZ2xvYmFsLmFNID0gYWRkTWVzc2FnZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJySDFKUEdcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9mYWtlXzM1Yzc4MTkyLmpzXCIsXCIvXCIpIl19
